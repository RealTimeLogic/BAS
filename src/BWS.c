/*

                 Barracuda Web Server Amalgamated

This file is an amalgamation of many separate C source files from the
Barracuda Web Server (BWS) library. By combining all the individual C
code files into this single large file, the entire code can be
compiled as a single unit.

This file is easy to compile, but very difficult to read. Contact Real
Time Logic should you require the full (standard) source code.

The amalgamation includes the following components:

1: ZLIB (zlib License)
2: BWS-Amalgamated (GPLv2, or custom; See LICENSE file)

Ref: https://realtimelogic.com/products/barracuda-web-server/
*/


#ifdef _WIN32
#else /*  _WIN32 */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#endif /*  _WIN32 */
#ifndef NO_SHARKSSL
#include <SharkSSL.h>
#include <SharkSslASN1.h>
#endif
#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wchar-subscripts"
#if __clang__ != 1
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough="
#endif
#pragma GCC diagnostic ignored "-Wmisleading-indentation"
#endif
	/*
  ZLIB
  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
  claim that you wrote the original software. If you use this software
  in a product, an acknowledgment in the product documentation would be
  appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
  misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef NO_ZLIB 
#define BA_DEFLATE 1   /* compile deflate code */

#define _Z_UTIL_H 
#include <zlib.h>
#undef  _Z_UTIL_H

#include <TargConfig.h>
#include <string.h>
/* #define GUNZIP */
/* #define GZIP   */

typedef U32 u_nsigned; /* was unsigned */

static U8 *zeroBaMalloc(int size)
{
   U8 *p = baMalloc(size);
   if (p != NULL) memset(p, 0, size);
   return p;
}

/****************************************************************************
 zconf.h - configuration of the zlib compression library
****************************************************************************/

/* Maximum value for memLevel in deflateInit */
#ifndef MAX_MEM_LEVEL
#  define MAX_MEM_LEVEL 9
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/****************************************************************************
 zlib.h 
****************************************************************************/
#ifndef Z_BLOCK
#define Z_BLOCK   5
#endif
#ifndef Z_RLE
#define Z_RLE     3
#endif
#ifndef Z_FIXED
#define Z_FIXED   4
#endif
#ifndef Z_TEXT
#define Z_TEXT    1
#endif

/****************************************************************************
 zutil.h - internal interface and configuration of the compression library
****************************************************************************/
#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif

/* default memLevel */
#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif

/* The three kinds of block type */
#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2

/* The minimum and maximum match lengths */
#define MIN_MATCH  3
#define MAX_MATCH  258

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

/****************************************************************************
 inffast.h - header to use inffast.c
****************************************************************************/
void inflate_fast (z_streamp strm, u_nsigned start);

/****************************************************************************
 inftrees.h - header to use inftrees.c
****************************************************************************/
typedef struct {
   U8 op;           /* operation, extra bits, table bits */
   U8 bits;         /* bits in this part of the code */
   U16 val;         /* offset in table or code value */
} code;

#define ENOUGH 2048
#define MAXD 592

/* Type of code to build for inftable() */
typedef enum {
   CODES,
   LENS,
   DISTS
} codetype;

int inflate_table(codetype type, U16 *lens, u_nsigned codes, code **table,
                  u_nsigned *bits, U16 *work);

/****************************************************************************
 inflate.h
****************************************************************************/


/*
  Symbol collision on some devices.
*/

#undef HEAD
#undef FLAGS
#undef TIME
#undef OS
#undef EXLEN
#undef EXTRA
#undef NAME
#undef COMMENT
#undef HCRC
#undef DICTID
#undef DICT
#undef TYPE
#undef TYPEDO
#undef STORED
#undef COPY
#undef TABLE
#undef LENLENS
#undef CODELENS
#undef LEN
#undef LENEXT
#undef DIST
#undef DISTEXT
#undef MATCH
#undef LIT
#undef CHECK
#undef LENGTH
#undef DONE
#undef BAD
#undef MEM
#undef SYNC


/* Possible inflate modes between inflate() calls */
typedef enum {
   HEAD,       /* i: waiting for magic header */
   FLAGS,      /* i: waiting for method and flags (gzip) */
   TIME,       /* i: waiting for modification time (gzip) */
   OS,         /* i: waiting for extra flags and operating system (gzip) */
   EXLEN,      /* i: waiting for extra length (gzip) */
   EXTRA,      /* i: waiting for extra bytes (gzip) */
   NAME,       /* i: waiting for end of file name (gzip) */
   COMMENT,    /* i: waiting for end of comment (gzip) */
   HCRC,       /* i: waiting for header crc (gzip) */
   DICTID,     /* i: waiting for dictionary check value */
   DICT,       /* waiting for inflateSetDictionary() call */
   TYPE,       /* i: waiting for type bits, including last-flag bit */
   TYPEDO,     /* i: same, but skip check to exit inflate on new block */
   STORED,     /* i: waiting for stored size (length and complement) */
   COPY,       /* i/o: waiting for input or output to copy stored block */
   TABLE,      /* i: waiting for dynamic block table lengths */
   LENLENS,    /* i: waiting for code length code lengths */
   CODELENS,   /* i: waiting for length/lit and distance code lengths */
   LEN,        /* i: waiting for length/lit code */
   LENEXT,     /* i: waiting for length extra bits */
   DIST,       /* i: waiting for distance code */
   DISTEXT,    /* i: waiting for distance extra bits */
   MATCH,      /* o: waiting for output space to copy string */
   LIT,        /* o: waiting for output space to write literal */
   CHECK,      /* i: waiting for 32-bit check value */
   LENGTH,     /* i: waiting for 32-bit length (gzip) */
   DONE,       /* finished check, done -- remain here until reset */
   BAD,        /* got a data error -- remain here until reset */
   MEM,        /* got an inflate() memory error -- remain here until reset */
   SYNC        /* looking for synchronization bytes to restart inflate() */
} inflate_mode;

typedef struct gz_header_s {
   int     text;       /* true if compressed data believed to be text */
   U32     time;       /* modification time */
   int     xflags;     /* extra flags (not used when writing a gzip file) */
   int     os;         /* operating system */
   U8      *extra;     /* pointer to extra field or NULL if none */
   uInt    extra_len;  /* extra field length (valid if extra != NULL) */
   uInt    extra_max;  /* space at extra (only when reading header) */
   U8      *name;      /* pointer to zero-terminated file name or NULL */
   uInt    name_max;   /* space at name (only when reading header) */
   U8      *comment;   /* pointer to zero-terminated comment or NULL */
   uInt    comm_max;   /* space at comment (only when reading header) */
   int     hcrc;       /* true if there was or will be a header crc */
   int     done;       /* true when done reading gzip header (not used
                          when writing a gzip file) */
} gz_header;

typedef gz_header *gz_headerp;

/* state maintained between inflate() calls.  Approximately 7K bytes. */
struct inflate_state {
   inflate_mode mode;          /* current inflate mode */
   int last;                   /* true if processing last block */
   int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
   int havedict;               /* true if dictionary provided */
   int flags;                  /* gzip header method and flags (0 if zlib) */
   u_nsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
   U32 check;                  /* protected copy of check value */
   U32 total;                  /* protected copy of output count */
   gz_headerp head;            /* where to save gzip header information */
   /* sliding window */
   u_nsigned wbits;             /* log base 2 of requested window size */
   u_nsigned wsize;             /* window size or zero if not using window */
   u_nsigned whave;             /* valid bytes in the window */
   u_nsigned write;             /* window write index */
   U8 *window;                 /* allocated sliding window, if needed */
   /* bit accumulator */
   U32 hold;                   /* input bit accumulator */
   u_nsigned bits;              /* number of bits in "in" */
   /* for string and stored block copying */
   u_nsigned length;            /* literal or length of data to copy */
   u_nsigned offset;            /* distance back to copy string from */
   /* for table and code decoding */
   u_nsigned extra;             /* extra bits needed */
   /* fixed and dynamic code tables */
   code const *lencode;        /* starting table for length/literal codes */
   code const *distcode;       /* starting table for distance codes */
   u_nsigned lenbits;           /* index bits for lencode */
   u_nsigned distbits;          /* index bits for distcode */
   /* dynamic table building */
   u_nsigned ncode;             /* number of code length code lengths */
   u_nsigned nlen;              /* number of length code lengths */
   u_nsigned ndist;             /* number of distance code lengths */
   u_nsigned have;              /* number of code lengths in lens[] */
   code *next;                 /* next available space in codes[] */
   U16 lens[320];              /* temporary storage for code lengths */
   U16 work[288];              /* work area for code table building */
   code codes[ENOUGH];         /* space for code tables */
};

/****************************************************************************
 adler32.c - compute the Adler-32 checksum of a data stream
****************************************************************************/
#define BASE 65521UL    /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);
#define MOD(a)  a %= BASE
#define MOD4(a) a %= BASE

uLong adler32(uLong adler, const Bytef *buf, uInt len)
{
   U32 sum2;
   u_nsigned n;

   /* split Adler-32 into component sums */
   sum2 = (adler >> 16) & 0xffff;
   adler &= 0xffff;

   /* in case user likes doing a byte at a time, keep it fast */
   if (len == 1) {
      adler += buf[0];
      if (adler >= BASE)
         adler -= BASE;
      sum2 += adler;
      if (sum2 >= BASE)
         sum2 -= BASE;
      return adler | (sum2 << 16);
   }

   /* initial Adler-32 value (deferred check for len == 1 speed) */
   if (buf == NULL)
      return 1L;

   /* in case short lengths are provided, keep it somewhat fast */
   if (len < 16) {
      while (len--) {
         adler += *buf++;
         sum2 += adler;
      }
      if (adler >= BASE)
         adler -= BASE;
      MOD4(sum2);             /* only added so many BASE's */
      return adler | (sum2 << 16);
   }

   /* do length NMAX blocks -- requires just one modulo operation */
   while (len >= NMAX) {
      len -= NMAX;
      n = NMAX / 16;          /* NMAX is divisible by 16 */
      do {
         DO16(buf);          /* 16 sums unrolled */
         buf += 16;
      } while (--n);
      MOD(adler);
      MOD(sum2);
   }

   /* do remaining bytes (less than NMAX, still just one modulo) */
   if (len) {                  /* avoid modulos if none remaining */
      while (len >= 16) {
         len -= 16;
         DO16(buf);
         buf += 16;
      }
      while (len--) {
         adler += *buf++;
         sum2 += adler;
      }
      MOD(adler);
      MOD(sum2);
   }

   /* return recombined sums */
   return adler | (sum2 << 16);
}

/****************************************************************************
 crc32.c - compute the CRC-32 of a data stream
****************************************************************************/
/*
 * Table of CRC-32's of all single-byte values
 */
#define TBLS 1
static const U32 crc_table[TBLS][256] =
{
   {
      0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
      0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
      0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
      0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
      0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
      0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
      0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
      0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
      0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
      0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
      0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
      0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
      0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
      0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
      0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
      0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
      0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
      0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
      0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
      0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
      0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
      0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
      0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
      0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
      0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
      0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
      0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
      0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
      0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
      0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
      0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
      0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
      0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
      0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
      0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
      0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
      0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
      0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
      0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
      0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
      0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
      0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
      0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
      0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
      0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
      0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
      0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
      0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
      0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
      0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
      0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
      0x2d02ef8dUL
   }
};

#undef DO1
#undef DO8
#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1

/* ========================================================================= */
uLong crc32(uLong crc, const U8 *buf, uInt len)
{
   if (buf == NULL) return 0UL;

   crc = crc ^ 0xffffffffUL;
   while (len >= 8) {
      DO8;
      len -= 8;
   }
   if (len) do {
         DO1;
      } while (--len);
   return crc ^ 0xffffffffUL;
}

/****************************************************************************
 inflate.c - zlib interface to PzipInflate modules
****************************************************************************/
static void fixedtables (struct inflate_state *state);
static int updatewindow (z_streamp strm, u_nsigned out);



int inflateReset(z_streamp strm)
{
   struct inflate_state *state;

   if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
   state = (struct inflate_state*)strm->state;
   strm->total_in = strm->total_out = state->total = 0;
   strm->adler = 1;        /* to support ill-conceived Java test suite */
   state->mode = HEAD;
   state->last = 0;
   state->havedict = 0;
   state->dmax = 32768U;
   state->head = NULL;
   state->wsize = 0;
   state->whave = 0;
   state->write = 0;
   state->hold = 0;
   state->bits = 0;
   state->lencode = state->distcode = state->next = state->codes;
   return Z_OK;
}


int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
   struct inflate_state *state;

   if (version == NULL || version[0] != ZLIB_VERSION[0] ||
       stream_size != (int)(sizeof(z_stream)))
      return Z_VERSION_ERROR;
   if (strm == NULL) return Z_STREAM_ERROR;

   state = (struct inflate_state*) zeroBaMalloc(sizeof(struct inflate_state));
   if (state == NULL) return Z_MEM_ERROR;
   strm->state = (struct internal_state*)state;
   if (windowBits < 0) {
      state->wrap = 0;
      windowBits = -windowBits;
   }
   else {
      state->wrap = (windowBits >> 4) + 1;
#ifdef GUNZIP
      if (windowBits < 48) windowBits &= 15;
#endif
   }
   if (windowBits < 8 || windowBits > 15) {
      baFree(state);
      strm->state = NULL;
      return Z_STREAM_ERROR;
   }
   state->wbits = (u_nsigned)windowBits;
   state->window = NULL;
   return inflateReset(strm);
}

/*
  Return state with length and distance decoding tables and index sizes set to
  fixed code decoding.  Normally this returns fixed tables from inffixed.h.
  If BUILDFIXED is defined, then instead this routine builds the tables the
  first time it's called, and returns those tables the first time and
  thereafter.  This reduces the size of the code by about 2K bytes, in
  exchange for a little execution time.  However, BUILDFIXED should not be
  used for threaded applications, since the rewriting of the tables and virgin
  may not be thread-safe.
*/
static void fixedtables(struct inflate_state *state)
{
   static const code lenfix[512] = {
      {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
      {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
      {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
      {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
      {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
      {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
      {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
      {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
      {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
      {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
      {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
      {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
      {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
      {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
      {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
      {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
      {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
      {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
      {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
      {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
      {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
      {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
      {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
      {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
      {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
      {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
      {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
      {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
      {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
      {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
      {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
      {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
      {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
      {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
      {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
      {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
      {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
      {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
      {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
      {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
      {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
      {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
      {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
      {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
      {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
      {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
      {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
      {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
      {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
      {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
      {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
      {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
      {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
      {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
      {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
      {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
      {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
      {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
      {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
      {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
      {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
      {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
      {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
      {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
      {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
      {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
      {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
      {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
      {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
      {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
      {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
      {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
      {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
      {0,9,255}
   };

   static const code distfix[32] = {
      {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
      {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
      {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
      {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
      {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
      {22,5,193},{64,5,0}
   };

   state->lencode = lenfix;
   state->lenbits = 9;
   state->distcode = distfix;
   state->distbits = 5;
}

/*
  Update the window with the last wsize (normally 32K) bytes written before
  returning.  If window does not exist yet, create it.  This is only called
  when a window is already in use, or when output has been written during this
  inflate call, but the end of the deflate stream has not been reached yet.
  It is also called to create a window for dictionary data when a dictionary
  is loaded.

  Providing output buffers larger than 32K to inflate() should provide a speed
  advantage, since only the last 32K of output is copied to the sliding window
  upon return from inflate(), and since all distances after the first 32K of
  output will fall in the output data, making match copies simpler and faster.
  The advantage may be dependent on the size of the processor's data caches.
*/
static int updatewindow(z_streamp strm, u_nsigned out)
{
   struct inflate_state *state;
   u_nsigned copy, dist;

   state = (struct inflate_state *)strm->state;

   /* if it hasn't been done already, allocate space for the window */
   if (state->window == NULL) {
      state->window = (U8*)zeroBaMalloc(1U << state->wbits);
      if (state->window == NULL) return 1;
   }

   /* if window not in use yet, initialize */
   if (state->wsize == 0) {
      state->wsize = 1U << state->wbits;
      state->write = 0;
      state->whave = 0;
   }

   /* copy state->wsize or less output bytes into the circular window */
   copy = out - strm->avail_out;
   if (copy >= state->wsize) {
      memcpy(state->window, strm->next_out - state->wsize, state->wsize);
      state->write = 0;
      state->whave = state->wsize;
   }
   else {
      dist = state->wsize - state->write;
      if (dist > copy) dist = copy;
      memcpy(state->window + state->write, strm->next_out - copy, dist);
      copy -= dist;
      if (copy) {
         memcpy(state->window, strm->next_out - copy, copy);
         state->write = copy;
         state->whave = state->wsize;
      }
      else {
         state->write += dist;
         if (state->write == state->wsize) state->write = 0;
         if (state->whave < state->wsize) state->whave += dist;
      }
   }
   return 0;
}

/* Macros for inflate(): */

/* check function to use adler32() for zlib or crc32() for gzip */
#undef UPDATE
#ifdef GUNZIP
#  define UPDATE(check, buf, len)                                       \
   (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
#else
#  define UPDATE(check, buf, len) adler32(check, buf, len)
#endif

/* check macros for header crc */
#ifdef GUNZIP
#  define CRC2(check, word)                     \
   do {                                         \
      hbuf[0] = (U8)(word);                     \
      hbuf[1] = (U8)((word) >> 8);              \
      check = crc32(check, hbuf, 2);            \
   } while (0)

#  define CRC4(check, word)                     \
   do {                                         \
      hbuf[0] = (U8)(word);                     \
      hbuf[1] = (U8)((word) >> 8);              \
      hbuf[2] = (U8)((word) >> 16);             \
      hbuf[3] = (U8)((word) >> 24);             \
      check = crc32(check, hbuf, 4);            \
   } while (0)
#endif

/* Load registers with state in inflate() for speed */
#define LOAD()                                  \
   do {                                         \
      put = strm->next_out;                     \
      left = strm->avail_out;                   \
      next = strm->next_in;                     \
      have = strm->avail_in;                    \
      hold = state->hold;                       \
      bits = state->bits;                       \
   } while (0)

/* Restore state from registers in inflate() */
#define RESTORE()                               \
   do {                                         \
      strm->next_out = put;                     \
      strm->avail_out = left;                   \
      strm->next_in = next;                     \
      strm->avail_in = have;                    \
      state->hold = hold;                       \
      state->bits = bits;                       \
   } while (0)

/* Clear the input bit accumulator */
#define INITBITS()                              \
   do {                                         \
      hold = 0;                                 \
      bits = 0;                                 \
   } while (0)

/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */
#define PULLBYTE()                              \
   do {                                         \
      if (have == 0) goto inf_leave;            \
      have--;                                   \
      hold += (U32)(*next++) << bits;           \
      bits += 8;                                \
   } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */
#define NEEDBITS(n)                             \
   do {                                         \
      while (bits < (u_nsigned)(n))             \
         PULLBYTE();                            \
   } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n)                                 \
   ((u_nsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n)                             \
   do {                                         \
      hold >>= (n);                             \
      bits -= (U16)(n);                         \
   } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS()                              \
   do {                                         \
      hold >>= bits & 7;                        \
      bits -= bits & 7;                         \
   } while (0)

/* Reverse the bytes in a 32-bit value */
#define REVERSE(q)                                      \
   ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) +      \
    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))

int inflate(z_streamp strm, int flush)
{
   struct inflate_state *state;
   U8* next;                   /* next input */
   U8 *put;                    /* next output */
   u_nsigned have, left;        /* available input and output */
   U32 hold;                   /* bit buffer */
   u_nsigned bits;              /* bits in bit buffer */
   u_nsigned in, out;           /* save starting available input and output */
   u_nsigned copy;              /* number of stored or match bytes to copy */
   U8 *from;                   /* where to copy match bytes from */
   code t_his;                 /* current decoding table entry */
   code last;                  /* parent table entry */
   u_nsigned len;               /* length to copy for repeats, bits to drop */
   int ret;                    /* return code */
#ifdef GUNZIP
   U8 hbuf[4];                 /* buffer for gzip header crc calculation */
#endif
   static const U16 order[19] = /* permutation of code lengths */
      {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

   if (strm == NULL || strm->state == NULL || strm->next_out == NULL ||
       (strm->next_in == NULL && strm->avail_in != 0))
      return Z_STREAM_ERROR;

   state = (struct inflate_state *)strm->state;
   if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
   LOAD();
   in = have;
   out = left;
   ret = Z_OK;
   for (;;)
      switch (state->mode) {
         case HEAD:
            if (state->wrap == 0) {
               state->mode = TYPEDO;
               break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
               state->check = crc32(0L, NULL, 0);
               CRC2(state->check, hold);
               INITBITS();
               state->mode = FLAGS;
               break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != NULL)
               state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
#else
                if (
#endif
                   ((BITS(8) << 8) + (hold >> 8)) % 31) {
                   state->mode = BAD;
                   break;
                }
                if (BITS(4) != Z_DEFLATED) {
                   state->mode = BAD;
                   break;
                }
                DROPBITS(4);
                len = BITS(4) + 8;
                if (len > state->wbits) {
                   state->mode = BAD;
                   break;
                }
                state->dmax = 1U << len;
                strm->adler = state->check = adler32(0L, NULL, 0);
                state->mode = hold & 0x200 ? DICTID : TYPE;
                INITBITS();
                break;
#ifdef GUNZIP
               case FLAGS:
                NEEDBITS(16);
                state->flags = (int)(hold);
                if ((state->flags & 0xff) != Z_DEFLATED) {
                   state->mode = BAD;
                   break;
                }
                if (state->flags & 0xe000) {
                   state->mode = BAD;
                   break;
                }
                if (state->head != NULL)
                   state->head->text = (int)((hold >> 8) & 1);
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
                state->mode = TIME;
               case TIME:
                NEEDBITS(32);
                if (state->head != NULL)
                   state->head->time = hold;
                if (state->flags & 0x0200) CRC4(state->check, hold);
                INITBITS();
                state->mode = OS;
               case OS:
                NEEDBITS(16);
                if (state->head != NULL) {
                   state->head->xflags = (int)(hold & 0xff);
                   state->head->os = (int)(hold >> 8);
                }
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
                state->mode = EXLEN;
               case EXLEN:
                if (state->flags & 0x0400) {
                   NEEDBITS(16);
                   state->length = (u_nsigned)(hold);
                   if (state->head != NULL)
                      state->head->extra_len = (u_nsigned)hold;
                   if (state->flags & 0x0200) CRC2(state->check, hold);
                   INITBITS();
                }
                else if (state->head != NULL)
                   state->head->extra = NULL;
                state->mode = EXTRA;
               case EXTRA:
                if (state->flags & 0x0400) {
                   copy = state->length;
                   if (copy > have) copy = have;
                   if (copy) {
                      if (state->head != NULL &&
                          state->head->extra != NULL) {
                         len = state->head->extra_len - state->length;
                         memcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                      }
                      if (state->flags & 0x0200)
                         state->check = crc32(state->check, next, copy);
                      have -= copy;
                      next += copy;
                      state->length -= copy;
                   }
                   if (state->length) goto inf_leave;
                }
                state->length = 0;
                state->mode = NAME;
               case NAME:
                if (state->flags & 0x0800) {
                   if (have == 0) goto inf_leave;
                   copy = 0;
                   do {
                      len = (u_nsigned)(next[copy++]);
                      if (state->head != NULL &&
                          state->head->name != NULL &&
                          state->length < state->head->name_max)
                         state->head->name[state->length++] = len;
                   } while (len && copy < have);
                   if (state->flags & 0x0200)
                      state->check = crc32(state->check, next, copy);
                   have -= copy;
                   next += copy;
                   if (len) goto inf_leave;
                }
                else if (state->head != NULL)
                   state->head->name = NULL;
                state->length = 0;
                state->mode = COMMENT;
               case COMMENT:
                if (state->flags & 0x1000) {
                   if (have == 0) goto inf_leave;
                   copy = 0;
                   do {
                      len = (u_nsigned)(next[copy++]);
                      if (state->head != NULL &&
                          state->head->comment != NULL &&
                          state->length < state->head->comm_max)
                         state->head->comment[state->length++] = len;
                   } while (len && copy < have);
                   if (state->flags & 0x0200)
                      state->check = crc32(state->check, next, copy);
                   have -= copy;
                   next += copy;
                   if (len) goto inf_leave;
                }
                else if (state->head != NULL)
                   state->head->comment = NULL;
                state->mode = HCRC;
               case HCRC:
                if (state->flags & 0x0200) {
                   NEEDBITS(16);
                   if (hold != (state->check & 0xffff)) {
                      state->mode = BAD;
                      break;
                   }
                   INITBITS();
                }
                if (state->head != NULL) {
                   state->head->hcrc = (int)((state->flags >> 9) & 1);
                   state->head->done = 1;
                }
                strm->adler = state->check = crc32(0L, NULL, 0);
                state->mode = TYPE;
                break;
#endif
               case DICTID:
                NEEDBITS(32);
                strm->adler = state->check = REVERSE(hold);
                INITBITS();
                state->mode = DICT;
               /* FALLTHRU */
               case DICT:
                if (state->havedict == 0) {
                   RESTORE();
                   return Z_NEED_DICT;
                }
                strm->adler = state->check = adler32(0L, NULL, 0);
                state->mode = TYPE;
               /* FALLTHRU */
               case TYPE:
                if (flush == Z_BLOCK) goto inf_leave;
               /* FALLTHRU */
               case TYPEDO:
                if (state->last) {
                   BYTEBITS();
                   state->mode = CHECK;
                   break;
                }
                NEEDBITS(3);
                state->last = BITS(1);
                DROPBITS(1);
                switch (BITS(2)) {
                   case 0:                             /* stored block */
                      state->mode = STORED;
                      break;
                   case 1:                             /* fixed block */
                      fixedtables(state);
                      state->mode = LEN;              /* decode codes */
                      break;
                   case 2:                             /* dynamic block */
                      state->mode = TABLE;
                      break;
                   case 3:
                      state->mode = BAD;
                }
                DROPBITS(2);
                break;
               case STORED:
                BYTEBITS();                         /* go to byte boundary */
                NEEDBITS(32);
                if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                   state->mode = BAD;
                   break;
                }
                state->length = (u_nsigned)hold & 0xffff;
                INITBITS();
                state->mode = COPY;
               /* FALLTHRU */
               case COPY:
                copy = state->length;
                if (copy) {
                   if (copy > have) copy = have;
                   if (copy > left) copy = left;
                   if (copy == 0) goto inf_leave;
                   memcpy(put, next, copy);
                   have -= copy;
                   next += copy;
                   left -= copy;
                   put += copy;
                   state->length -= copy;
                   break;
                }
                state->mode = TYPE;
                break;
               case TABLE:
                NEEDBITS(14);
                state->nlen = BITS(5) + 257;
                DROPBITS(5);
                state->ndist = BITS(5) + 1;
                DROPBITS(5);
                state->ncode = BITS(4) + 4;
                DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
                if (state->nlen > 286 || state->ndist > 30) {
                   state->mode = BAD;
                   break;
                }
#endif
                state->have = 0;
                state->mode = LENLENS;
               case LENLENS:
                while (state->have < state->ncode) {
                   NEEDBITS(3);
                   state->lens[order[state->have++]] = (U16)BITS(3);
                   DROPBITS(3);
                }
                while (state->have < 19)
                   state->lens[order[state->have++]] = 0;
                state->next = state->codes;
                state->lencode = (code const *)(state->next);
                state->lenbits = 7;
                ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                    &(state->lenbits), state->work);
                if (ret) {
                   state->mode = BAD;
                   break;
                }
                state->have = 0;
                state->mode = CODELENS;
               case CODELENS:
                while (state->have < state->nlen + state->ndist) {
                   for (;;) {
                      t_his = state->lencode[BITS(state->lenbits)];
                      if ((u_nsigned)(t_his.bits) <= bits) break;
                      PULLBYTE();
                   }
                   if (t_his.val < 16) {
                      NEEDBITS(t_his.bits);
                      DROPBITS(t_his.bits);
                      state->lens[state->have++] = t_his.val;
                   }
                   else {
                      if (t_his.val == 16) {
                         NEEDBITS(t_his.bits + 2);
                         DROPBITS(t_his.bits);
                         if (state->have == 0) {
                            state->mode = BAD;
                            break;
                         }
                         len = state->lens[state->have - 1];
                         copy = 3 + BITS(2);
                         DROPBITS(2);
                      }
                      else if (t_his.val == 17) {
                         NEEDBITS(t_his.bits + 3);
                         DROPBITS(t_his.bits);
                         len = 0;
                         copy = 3 + BITS(3);
                         DROPBITS(3);
                      }
                      else {
                         NEEDBITS(t_his.bits + 7);
                         DROPBITS(t_his.bits);
                         len = 0;
                         copy = 11 + BITS(7);
                         DROPBITS(7);
                      }
                      if (state->have + copy > state->nlen + state->ndist) {
                         state->mode = BAD;
                         break;
                      }
                      while (copy--)
                         state->lens[state->have++] = (U16)len;
                   }
                }

                /* handle error breaks in while */
                if (state->mode == BAD) break;

                /* build code tables */
                state->next = state->codes;
                state->lencode = (code const *)(state->next);
                state->lenbits = 9;
                ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                    &(state->lenbits), state->work);
                if (ret) {
                   state->mode = BAD;
                   break;
                }
                state->distcode = (code const *)(state->next);
                state->distbits = 6;
                ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                                    &(state->next), &(state->distbits), state->work);
                if (ret) {
                   state->mode = BAD;
                   break;
                }
                state->mode = LEN;
               /* FALLTHRU */
               case LEN:
                if (have >= 6 && left >= 258) {
                   RESTORE();
                   inflate_fast(strm, out);
                   LOAD();
                   break;
                }
                for (;;) {
                   t_his = state->lencode[BITS(state->lenbits)];
                   if ((u_nsigned)(t_his.bits) <= bits) break;
                   PULLBYTE();
                }
                if (t_his.op && (t_his.op & 0xf0) == 0) {
                   last = t_his;
                   for (;;) {
                      t_his = state->lencode[last.val +
                                             (BITS(last.bits + last.op) >> last.bits)];
                      if ((u_nsigned)(last.bits + t_his.bits) <= bits) break;
                      PULLBYTE();
                   }
                   DROPBITS(last.bits);
                }
                DROPBITS(t_his.bits);
                state->length = (u_nsigned)t_his.val;
                if ((int)(t_his.op) == 0) {
                   state->mode = LIT;
                   break;
                }
                if (t_his.op & 32) {
                   state->mode = TYPE;
                   break;
                }
                if (t_his.op & 64) {
                   state->mode = BAD;
                   break;
                }
                state->extra = (u_nsigned)(t_his.op) & 15;
                state->mode = LENEXT;
               /* FALLTHRU */
               case LENEXT:
                if (state->extra) {
                   NEEDBITS(state->extra);
                   state->length += BITS(state->extra);
                   DROPBITS(state->extra);
                }
                state->mode = DIST;
               /* FALLTHRU */
               case DIST:
                for (;;) {
                   t_his = state->distcode[BITS(state->distbits)];
                   if ((u_nsigned)(t_his.bits) <= bits) break;
                   PULLBYTE();
                }
                if ((t_his.op & 0xf0) == 0) {
                   last = t_his;
                   for (;;) {
                      t_his = state->distcode[last.val +
                                              (BITS(last.bits + last.op) >> last.bits)];
                      if ((u_nsigned)(last.bits + t_his.bits) <= bits) break;
                      PULLBYTE();
                   }
                   DROPBITS(last.bits);
                }
                DROPBITS(t_his.bits);
                if (t_his.op & 64) {
                   state->mode = BAD;
                   break;
                }
                state->offset = (u_nsigned)t_his.val;
                state->extra = (u_nsigned)(t_his.op) & 15;
                state->mode = DISTEXT;
               /* FALLTHRU */
               case DISTEXT:
                if (state->extra) {
                   NEEDBITS(state->extra);
                   state->offset += BITS(state->extra);
                   DROPBITS(state->extra);
                }
#ifdef INFLATE_STRICT
                if (state->offset > state->dmax) {
                   state->mode = BAD;
                   break;
                }
#endif
                if (state->offset > state->whave + out - left) {
                   state->mode = BAD;
                   break;
                }
                state->mode = MATCH;
               /* FALLTHRU */
               case MATCH:
                if (left == 0) goto inf_leave;
                copy = out - left;
                if (state->offset > copy) {         /* copy from window */
                   copy = state->offset - copy;
                   if (copy > state->write) {
                      copy -= state->write;
                      from = state->window + (state->wsize - copy);
                   }
                   else
                      from = state->window + (state->write - copy);
                   if (copy > state->length) copy = state->length;
                }
                else {                              /* copy from output */
                   from = put - state->offset;
                   copy = state->length;
                }
                if (copy > left) copy = left;
                left -= copy;
                state->length -= copy;
                do {
                   *put++ = *from++;
                } while (--copy);
                if (state->length == 0) state->mode = LEN;
                break;
               case LIT:
                if (left == 0) goto inf_leave;
                *put++ = (U8)(state->length);
                left--;
                state->mode = LEN;
                break;
               case CHECK:
                if (state->wrap) {
                   NEEDBITS(32);
                   out -= left;
                   strm->total_out += out;
                   state->total += out;
                   if (out)
                      strm->adler = state->check =
                         UPDATE(state->check, put - out, out);
                   out = left;
                   if ((
#ifdef GUNZIP
                          state->flags ? hold :
#endif
                          REVERSE(hold)) != state->check) {
                      state->mode = BAD;
                      break;
                   }
                   INITBITS();
                }
#ifdef GUNZIP
                state->mode = LENGTH;
               case LENGTH:
                if (state->wrap && state->flags) {
                   NEEDBITS(32);
                   if (hold != (state->total & 0xffffffffUL)) {
                      state->mode = BAD;
                      break;
                   }
                   INITBITS();
                }
#endif
                state->mode = DONE;
               /* FALLTHRU */
               case DONE:
                ret = Z_STREAM_END;
                goto inf_leave;
               case BAD:
                ret = Z_DATA_ERROR;
                goto inf_leave;
               case MEM:
                return Z_MEM_ERROR;
               case SYNC:
               default:
                return Z_STREAM_ERROR;
                }

         /*
           Return from inflate(), updating the total counts and the check value.
           If there was no progress during the inflate() call, return a buffer
           error.  Call updatewindow() to create and/or update the window state.
           Note: a memory error from inflate() is non-recoverable.
         */
         inf_leave:
               RESTORE();
            if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
               if (updatewindow(strm, out)) {
                  state->mode = MEM;
                  return Z_MEM_ERROR;
               }
            in -= strm->avail_in;
            out -= strm->avail_out;
            strm->total_in += in;
            strm->total_out += out;
            state->total += out;
            if (state->wrap && out)
               strm->adler = state->check =
                  UPDATE(state->check, strm->next_out - out, out);
            strm->data_type = state->bits + (state->last ? 64 : 0) +
               (state->mode == TYPE ? 128 : 0);
            if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
               ret = Z_BUF_ERROR;
            return ret;
      }

   int inflateEnd(z_streamp strm)
   {
      struct inflate_state *state;
      if (strm == NULL || strm->state == NULL)
         return Z_STREAM_ERROR;
      state = (struct inflate_state *)strm->state;
      if (state->window != NULL) baFree(state->window);
      baFree(strm->state);
      strm->state = NULL;
      return Z_OK;
   }


/****************************************************************************
 inffast.c
****************************************************************************/
#ifdef POSTINC
#  define ZZ_OFF 0
#  define PUP(a) *(a)++
#else
#  define ZZ_OFF 1
#  define PUP(a) *++(a)
#endif

   void inflate_fast(z_streamp strm, u_nsigned start)
   {
      struct inflate_state *state;
      U8 *in;                 /* local strm->next_in */
      U8 *last;               /* while in < last, enough input available */
      U8 *out;                /* local strm->next_out */
      U8 *beg;                /* inflate()'s initial strm->next_out */
      U8 *end;                /* while out < end, enough space available */
#ifdef INFLATE_STRICT
      u_nsigned dmax;          /* maximum distance from zlib header */
#endif
      u_nsigned wsize;         /* window size or zero if not using window */
      u_nsigned whave;         /* valid bytes in the window */
      u_nsigned write;         /* window write index */
      U8 *window;             /* allocated sliding window, if wsize != 0 */
      U32 hold;               /* local strm->hold */
      u_nsigned bits;          /* local strm->bits */
      code const *lcode;      /* local strm->lencode */
      code const *dcode;      /* local strm->distcode */
      u_nsigned lmask;         /* mask for first level of length codes */
      u_nsigned dmask;         /* mask for first level of distance codes */
      code t_his;             /* retrieved table entry */
      u_nsigned op;            /* code bits, operation, extra bits, or */
      /* window position, window bytes to copy */
      u_nsigned len;           /* match length, unused bytes */
      u_nsigned dist;          /* match distance */
      U8 *from;               /* where to copy match from */

      /* copy state to local variables */
      state = (struct inflate_state *)strm->state;
      in = strm->next_in - ZZ_OFF;
      last = in + (strm->avail_in - 5);
      out = strm->next_out - ZZ_OFF;
      beg = out - (start - strm->avail_out);
      end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
      dmax = state->dmax;
#endif
      wsize = state->wsize;
      whave = state->whave;
      write = state->write;
      window = state->window;
      hold = state->hold;
      bits = state->bits;
      lcode = state->lencode;
      dcode = state->distcode;
      lmask = (1U << state->lenbits) - 1;
      dmask = (1U << state->distbits) - 1;

      /* decode literals and length/distances until end-of-block or not enough
         input data or output space */
      do {
         if (bits < 15) {
            hold += (U32)(PUP(in)) << bits;
            bits += 8;
            hold += (U32)(PUP(in)) << bits;
            bits += 8;
         }
         t_his = lcode[hold & lmask];
        dolen:
         op = (u_nsigned)(t_his.bits);
         hold >>= op;
         bits -= op;
         op = (u_nsigned)(t_his.op);
         if (op == 0) {                          /* literal */
            PUP(out) = (U8)(t_his.val);
         }
         else if (op & 16) {                     /* length base */
            len = (u_nsigned)(t_his.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
               if (bits < op) {
                  hold += (U32)(PUP(in)) << bits;
                  bits += 8;
               }
               len += (u_nsigned)hold & ((1U << op) - 1);
               hold >>= op;
               bits -= op;
            }
            if (bits < 15) {
               hold += (U32)(PUP(in)) << bits;
               bits += 8;
               hold += (U32)(PUP(in)) << bits;
               bits += 8;
            }
            t_his = dcode[hold & dmask];
           dodist:
            op = (u_nsigned)(t_his.bits);
            hold >>= op;
            bits -= op;
            op = (u_nsigned)(t_his.op);
            if (op & 16) {                      /* distance base */
               dist = (u_nsigned)(t_his.val);
               op &= 15;                       /* number of extra bits */
               if (bits < op) {
                  hold += (U32)(PUP(in)) << bits;
                  bits += 8;
                  if (bits < op) {
                     hold += (U32)(PUP(in)) << bits;
                     bits += 8;
                  }
               }
               dist += (u_nsigned)hold & ((1U << op) - 1);
#ifdef INFLATE_STRICT
               if (dist > dmax) {
                  state->mode = BAD;
                  break;
               }
#endif
               hold >>= op;
               bits -= op;
               op = (u_nsigned)(out - beg);     /* max distance in output */
               if (dist > op) {                /* see if copy from window */
                  op = dist - op;             /* distance back in window */
                  if (op > whave) {
                     state->mode = BAD;
                     break;
                  }
                  from = window - ZZ_OFF;
                  if (write == 0) {           /* very common case */
                     from += wsize - op;
                     if (op < len) {         /* some from window */
                        len -= op;
                        do {
                           PUP(out) = PUP(from);
                        } while (--op);
                        from = out - dist;  /* rest from output */
                     }
                  }
                  else if (write < op) {      /* wrap around window */
                     from += wsize + write - op;
                     op -= write;
                     if (op < len) {         /* some from end of window */
                        len -= op;
                        do {
                           PUP(out) = PUP(from);
                        } while (--op);
                        from = window - ZZ_OFF;
                        if (write < len) {  /* some from start of window */
                           op = write;
                           len -= op;
                           do {
                              PUP(out) = PUP(from);
                           } while (--op);
                           from = out - dist;      /* rest from output */
                        }
                     }
                  }
                  else {                      /* contiguous in window */
                     from += write - op;
                     if (op < len) {         /* some from window */
                        len -= op;
                        do {
                           PUP(out) = PUP(from);
                        } while (--op);
                        from = out - dist;  /* rest from output */
                     }
                  }
                  while (len > 2) {
                     PUP(out) = PUP(from);
                     PUP(out) = PUP(from);
                     PUP(out) = PUP(from);
                     len -= 3;
                  }
                  if (len) {
                     PUP(out) = PUP(from);
                     if (len > 1)
                        PUP(out) = PUP(from);
                  }
               }
               else {
                  from = out - dist;          /* copy direct from output */
                  do {                        /* minimum length is three */
                     PUP(out) = PUP(from);
                     PUP(out) = PUP(from);
                     PUP(out) = PUP(from);
                     len -= 3;
                  } while (len > 2);
                  if (len) {
                     PUP(out) = PUP(from);
                     if (len > 1)
                        PUP(out) = PUP(from);
                  }
               }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
               t_his = dcode[t_his.val + (hold & ((1U << op) - 1))];
               goto dodist;
            }
            else {
               state->mode = BAD;
               break;
            }
         }
         else if ((op & 64) == 0) {              /* 2nd level length code */
            t_his = lcode[t_his.val + (hold & ((1U << op) - 1))];
            goto dolen;
         }
         else if (op & 32) {                     /* end-of-block */
            state->mode = TYPE;
            break;
         }
         else {
            state->mode = BAD;
            break;
         }
      } while (in < last && out < end);

      /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
      len = bits >> 3;
      in -= len;
      bits -= len << 3;
      hold &= (1U << bits) - 1;

      /* update state and return */
      strm->next_in = in + ZZ_OFF;
      strm->next_out = out + ZZ_OFF;
      strm->avail_in = (u_nsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
      strm->avail_out = (u_nsigned)(out < end ?
                                    257 + (end - out) : 257 - (out - end));
      state->hold = hold;
      state->bits = bits;
      return;
   }


/****************************************************************************
 inftrees.c 
****************************************************************************/
#define ZLIBMAXBITS 15
   int inflate_table(codetype type, U16 *lens, u_nsigned codes, code **table, 
                     u_nsigned *bits, U16 *work)
   {
      u_nsigned len;               /* a code's length in bits */
      u_nsigned sym;               /* index of code symbols */
      u_nsigned min, max;          /* minimum and maximum code lengths */
      u_nsigned root;              /* number of index bits for root table */
      u_nsigned curr;              /* number of index bits for current table */
      u_nsigned drop;              /* code bits to drop for sub-table */
      int left;                   /* number of prefix codes available */
      u_nsigned used;              /* code entries in table used */
      u_nsigned huff;              /* Huffman code */
      u_nsigned incr;              /* for incrementing code, index */
      u_nsigned fill;              /* index for replicating entries */
      u_nsigned low;               /* low bits for current root entry */
      u_nsigned mask;              /* mask for low root bits */
      code t_his;                  /* table entry for duplication */
      code *next;                 /* next available space in table */
      const U16 *base;            /* base value table to use */
      const U16 *extra;           /* extra bits table to use */
      int end;                    /* use base and extra for symbol > end */
      U16 count[ZLIBMAXBITS+1];       /* number of codes of each length */
      U16 offs[ZLIBMAXBITS+1];        /* offsets in table for each length */
      static const U16 lbase[31] = { /* Length codes 257..285 base */
         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
      static const U16 lext[31] = { /* Length codes 257..285 extra */
         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
      static const U16 dbase[32] = { /* Distance codes 0..29 base */
         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
         8193, 12289, 16385, 24577, 0, 0};
      static const U16 dext[32] = { /* Distance codes 0..29 extra */
         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
         28, 28, 29, 29, 64, 64};

      /* accumulate lengths for codes (assumes lens[] all in 0..ZLIBMAXBITS) */
      for (len = 0; len <= ZLIBMAXBITS; len++)
         count[len] = 0;
      for (sym = 0; sym < codes; sym++)
         count[lens[sym]]++;

      /* bound code lengths, force root to be within code lengths */
      root = *bits;
      for (max = ZLIBMAXBITS; max >= 1; max--)
         if (count[max] != 0) break;
      if (root > max) root = max;
      if (max == 0) {                     /* no symbols to code at all */
         t_his.op = (U8)64;               /* invalid code marker */
         t_his.bits = (U8)1;
         t_his.val = (U16)0;
         *(*table)++ = t_his;             /* make a table to force an error */
         *(*table)++ = t_his;
         *bits = 1;
         return 0;     /* no symbols, but wait for decoding to report error */
      }
      for (min = 1; min <= ZLIBMAXBITS; min++)
         if (count[min] != 0) break;
      if (root < min) root = min;

      /* check for an over-subscribed or incomplete set of lengths */
      left = 1;
      for (len = 1; len <= ZLIBMAXBITS; len++) {
         left <<= 1;
         left -= count[len];
         if (left < 0) return -1;        /* over-subscribed */
      }
      if (left > 0 && (type == CODES || max != 1))
         return -1;                      /* incomplete set */

      /* generate offsets into symbol table for each length for sorting */
      offs[1] = 0;
      for (len = 1; len < ZLIBMAXBITS; len++)
         offs[len + 1] = offs[len] + count[len];

      /* sort symbols by length, by symbol order within each length */
      for (sym = 0; sym < codes; sym++)
         if (lens[sym] != 0) work[offs[lens[sym]]++] = (U16)sym;

      /* set up for code type */
      switch (type) {
         case CODES:
            base = extra = work;    /* dummy value--not used */
            end = 19;
            break;
         case LENS:
            base = lbase;
            base -= 257;
            extra = lext;
            extra -= 257;
            end = 256;
            break;
         default:            /* DISTS */
            base = dbase;
            extra = dext;
            end = -1;
      }

      /* initialize state for loop */
      huff = 0;                   /* starting code */
      sym = 0;                    /* starting code symbol */
      len = min;                  /* starting code length */
      next = *table;              /* current table to fill in */
      curr = root;                /* current table index bits */
      drop = 0;                   /* current bits to drop from code for index */
      low = (u_nsigned)(-1);       /* trigger new sub-table when len > root */
      used = 1U << root;          /* use root table entries */
      mask = used - 1;            /* mask for comparing low */

      /* check available table space */
      if (type == LENS && used >= ENOUGH - MAXD)
         return 1;

      /* process all codes and make table entries */
      for (;;) {
         /* create table entry */
         t_his.bits = (U8)(len - drop);
         if ((int)(work[sym]) < end) {
            t_his.op = (U8)0;
            t_his.val = work[sym];
         }
         else if ((int)(work[sym]) > end) {
            t_his.op = (U8)(extra[work[sym]]);
            t_his.val = base[work[sym]];
         }
         else {
            t_his.op = (U8)(32 + 64);         /* end of block */
            t_his.val = 0;
         }

         /* replicate for those indices with low len bits equal to huff */
         incr = 1U << (len - drop);
         fill = 1U << curr;
         min = fill;                 /* save offset to next table */
         do {
            fill -= incr;
            next[(huff >> drop) + fill] = t_his;
         } while (fill != 0);

         /* backwards increment the len-bit code huff */
         incr = 1U << (len - 1);
         while (huff & incr)
            incr >>= 1;
         if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
         }
         else
            huff = 0;

         /* go to next symbol, update count, len */
         sym++;
         if (--(count[len]) == 0) {
            if (len == max) break;
            len = lens[work[sym]];
         }

         /* create new sub-table if needed */
         if (len > root && (huff & mask) != low) {
            /* if first time, transition to sub-tables */
            if (drop == 0)
               drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
               left -= count[curr + drop];
               if (left <= 0) break;
               curr++;
               left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
            if (type == LENS && used >= ENOUGH - MAXD)
               return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (U8)curr;
            (*table)[low].bits = (U8)root;
            (*table)[low].val = (U16)(next - *table);
         }
      }

      /*
        Fill in rest of table for incomplete codes.  This loop is similar to the
        loop above in incrementing huff for table indices.  It is assumed that
        len is equal to curr + drop, so there is no loop needed to increment
        through high index bits.  When the current sub-table is filled, the loop
        drops back to the root table to fill in any remaining entries there.
      */
      t_his.op = (U8)64;                /* invalid code marker */
      t_his.bits = (U8)(len - drop);
      t_his.val = (U16)0;
      while (huff != 0) {
         /* when done with sub-table, drop back to root table */
         if (drop != 0 && (huff & mask) != low) {
            drop = 0;
            len = root;
            next = *table;
            t_his.bits = (U8)len;
         }

         /* put invalid code marker in table */
         next[huff >> drop] = t_his;

         /* backwards increment the len-bit code huff */
         incr = 1U << (len - 1);
         while (huff & incr)
            incr >>= 1;
         if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
         }
         else
            huff = 0;
      }

      /* set return parameters */
      *table += used;
      *bits = root;
      return 0;
   }

#if BA_DEFLATE
/****************************************************************************
 deflate.h 
****************************************************************************/
#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define INIT_STATE    42
#define EXTRA_STATE   69
#define NAME_STATE    73
#define COMMENT_STATE 91
#define HCRC_STATE   103
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
   typedef struct ct_data_s {
      union {
         U16  freq;       /* frequency count */
         U16  code;       /* bit string */
      } fc;
      union {
         U16  dad;        /* father node in Huffman tree */
         U16  len;        /* length of bit string */
      } dl;
   } FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

   typedef struct static_tree_desc_s  static_tree_desc;

   typedef struct tree_desc_s {
      ct_data *dyn_tree;           /* the dynamic tree */
      int     max_code;            /* largest code with non zero frequency */
      static_tree_desc *stat_desc; /* the corresponding static tree */
   } tree_desc;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */
   typedef U16 Pos;
   typedef Pos Posf;
   typedef u_nsigned IPos;

   typedef struct internal_state {
      z_streamp strm;      /* pointer back to this zlib stream */
      int   status;        /* as the name implies */
      U8   *pending_buf;  /* output still pending */
      U32   pending_buf_size; /* size of pending_buf */
      U8   *pending_out;  /* next pending byte to output to the stream */
      uInt   pending;      /* nb of bytes in the pending buffer */
      int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
      gz_headerp  gzhead;  /* gzip header information to write */
      uInt   gzindex;      /* where in extra, name, or comment */
      U8    method;        /* STORED (for zip only) or DEFLATED */
      int   last_flush;    /* value of flush param for previous deflate call */

      /* used by deflate.c: */

      uInt  w_size;        /* LZ77 window size (32K by default) */
      uInt  w_bits;        /* log2(w_size)  (8..16) */
      uInt  w_mask;        /* w_size - 1 */

      U8   *window;
      /* Sliding window. Input bytes are read into the second half of the window,
       * and move to the first half later to keep a dictionary of at least wSize
       * bytes. With this organization, matches are limited to a distance of
       * wSize-MAX_MATCH bytes, but this ensures that IO is always
       * performed with a length multiple of the block size. Also, it limits
       * the window size to 64K, which is quite useful on MSDOS.
       * To do: use the user input buffer as sliding window.
       */

      U32 window_size;
      /* Actual size of window: 2*wSize, except when the user input buffer
       * is directly used as sliding window.
       */

      Posf *prev;
      /* Link to older string with same hash index. To limit the size of this
       * array to 64K, this link is maintained only for the last 32K strings.
       * An index in this array is thus a window index modulo 32K.
       */

      Posf *head; /* Heads of the hash chains or NIL. */

      uInt  ins_h;          /* hash index of string to be inserted */
      uInt  hash_size;      /* number of elements in hash table */
      uInt  hash_bits;      /* log2(hash_size) */
      uInt  hash_mask;      /* hash_size-1 */

      uInt  hash_shift;
      /* Number of bits by which ins_h must be shifted at each input
       * step. It must be such that after MIN_MATCH steps, the oldest
       * byte no longer takes part in the hash key, that is:
       *   hash_shift * MIN_MATCH >= hash_bits
       */

      S32   block_start;
      /* Window position at the beginning of the current output block. Gets
       * negative when the window is moved backwards.
       */

      uInt match_length;           /* length of best match */
      IPos prev_match;             /* previous match */
      int match_available;         /* set if previous match exists */
      uInt strstart;               /* start of string to insert */
      uInt match_start;            /* start of matching string */
      uInt lookahead;              /* number of valid bytes ahead in window */

      uInt prev_length;
      /* Length of the best match at previous step. Matches not greater than this
       * are discarded. This is used in the lazy match evaluation.
       */

      uInt max_chain_length;
      /* To speed up deflation, hash chains are never searched beyond this
       * length.  A higher limit improves compression ratio but degrades the
       * speed.
       */

      uInt max_lazy_match;
      /* Attempt to find a better match only when the current match is strictly
       * smaller than this value. This mechanism is used only for compression
       * levels >= 4.
       */
#   define max_insert_length  max_lazy_match
      /* Insert new strings in the hash table only if the match length is not
       * greater than this length. This saves time but degrades compression.
       * max_insert_length is used only for compression levels <= 3.
       */

      int level;    /* compression level (1..9) */
      int strategy; /* favor or force Huffman coding*/

      uInt good_match;
      /* Use a faster search when the previous match is longer than this */

      int nice_match; /* Stop searching when current match exceeds this */

      /* used by trees.c: */
      /* Didn't use ct_data typedef below to supress compiler warning */
      struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
      struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
      struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

      struct tree_desc_s l_desc;               /* desc. for literal tree */
      struct tree_desc_s d_desc;               /* desc. for distance tree */
      struct tree_desc_s bl_desc;              /* desc. for bit length tree */

      U16 bl_count[MAX_BITS+1];
      /* number of codes at each bit length for an optimal tree */

      int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
      int heap_len;               /* number of elements in the heap */
      int heap_max;               /* element of largest frequency */
      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
       * The same heap array is used to build all trees.
       */

      U8  depth[2*L_CODES+1];
      /* Depth of each subtree used as tie breaker for trees of equal frequency
       */

      U8   *l_buf;          /* buffer for literals or lengths */

      uInt  lit_bufsize;
      /* Size of match buffer for literals/lengths.  There are 4 reasons for
       * limiting lit_bufsize to 64K:
       *   - frequencies can be kept in 16 bit counters
       *   - if compression is not successful for the first block, all input
       *     data is still in the window so we can still emit a stored block even
       *     when input comes from standard input.  (This can also be done for
       *     all blocks if lit_bufsize is not greater than 32K.)
       *   - if compression is not successful for a file smaller than 64K, we can
       *     even emit a stored file instead of a stored block (saving 5 bytes).
       *     This is applicable only for zip (not gzip or zlib).
       *   - creating new Huffman trees less frequently may not provide fast
       *     adaptation to changes in the input data statistics. (Take for
       *     example a binary file with poorly compressible code followed by
       *     a highly compressible string table.) Smaller buffer sizes give
       *     fast adaptation but have of course the overhead of transmitting
       *     trees more frequently.
       *   - I can't count above 4
       */

      uInt last_lit;      /* running index in l_buf */

      U16 *d_buf;
      /* Buffer for distances. To simplify the code, d_buf and l_buf have
       * the same number of elements. To use different lengths, an extra flag
       * array would be necessary.
       */

      U32 opt_len;        /* bit length of current block with optimal trees */
      U32 static_len;     /* bit length of current block with static trees */
      uInt matches;       /* number of string matches in current block */
      int last_eob_len;   /* bit length of EOB code for last block */

      U16 bi_buf;
      /* Output buffer. bits are inserted starting at the bottom (least
       * significant bits).
       */
      int bi_valid;
      /* Number of valid bits in bi_buf.  All bits above the last valid bit
       * are always zero.
       */

   } deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}


/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */
#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)

/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */
#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)

   void _tr_init         (deflate_state *s);
   void _tr_flush_block  (deflate_state *s, U8 *buf, U32 stored_len, int eof);
   void _tr_align        (deflate_state *s);
   void _tr_stored_block (deflate_state *s, U8 *buf, U32 stored_len, int eof);

   static void lm_init   (deflate_state *s);

/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */
#define d_code(dist)                                                    \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])

# define _tr_tally_lit(s, c, flush)                     \
   { U8 cc = (c);                                       \
      s->d_buf[s->last_lit] = 0;                        \
      s->l_buf[s->last_lit++] = cc;                     \
      s->dyn_ltree[cc].Freq++;                          \
      flush = (s->last_lit == s->lit_bufsize-1);        \
   }

/* cast in the following macro: U8, U16 */
# define _tr_tally_dist(s, distance, length, flush)             \
   { U8  len = (U8)(length);                                    \
      U16 dist = (U16)(distance);                               \
      s->d_buf[s->last_lit] = dist;                             \
      s->l_buf[s->last_lit++] = len;                            \
      dist--;                                                   \
      s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++;        \
      s->dyn_dtree[d_code(dist)].Freq++;                        \
      flush = (s->last_lit == s->lit_bufsize-1);                \
   }


/****************************************************************************
 trees.h/.c
****************************************************************************/
#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

   static const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
      = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

   static const int extra_dbits[D_CODES] /* extra bits for each distance code */
      = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

   static const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
      = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

   static const U8 bl_order[BL_CODES]
      = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(U8))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

#define DIST_CODE_LEN  512

   static const ct_data static_ltree[L_CODES+2] = {
      {{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
      {{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
      {{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
      {{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
      {{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
      {{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
      {{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
      {{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
      {{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
      {{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
      {{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
      {{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
      {{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
      {{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
      {{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
      {{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
      {{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
      {{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
      {{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
      {{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
      {{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
      {{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
      {{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
      {{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
      {{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
      {{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
      {{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
      {{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
      {{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
      {{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
      {{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
      {{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
      {{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
      {{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
      {{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
      {{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
      {{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
      {{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
      {{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
      {{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
      {{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
      {{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
      {{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
      {{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
      {{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
      {{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
      {{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
      {{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
      {{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
      {{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
      {{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
      {{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
      {{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
      {{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
      {{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
      {{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
      {{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
      {{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
   };

   static const ct_data static_dtree[D_CODES] = {
      {{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
      {{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
      {{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
      {{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
      {{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
      {{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
   };

   const U8 _dist_code[DIST_CODE_LEN] = {
      0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
      8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
      10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
      11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
      18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
      23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
      27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
      29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
   };

   const U8 _length_code[MAX_MATCH-MIN_MATCH+1]= {
      0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
      13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
      17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
      19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
      21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
      23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
      26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
   };

   static const int base_length[LENGTH_CODES] = {
      0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
      64, 80, 96, 112, 128, 160, 192, 224, 0
   };

   static const int base_dist[D_CODES] = {
      0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
      32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
      1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
   };

   struct static_tree_desc_s {
      const ct_data *static_tree;  /* static tree or NULL */
      const int *extra_bits;      /* extra bits for each code or NULL */
      int     extra_base;          /* base index for extra_bits */
      int     elems;               /* max number of elements in the tree */
      int     max_length;          /* max bit length for the codes */
   };

   static static_tree_desc  static_l_desc =
      {static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

   static static_tree_desc  static_d_desc =
      {static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

   static static_tree_desc  static_bl_desc =
      {(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

   static void init_block     (deflate_state *s);
   static void pqdownheap     (deflate_state *s, ct_data *tree, int k);
   static void gen_bitlen     (deflate_state *s, tree_desc *desc);
   static void gen_codes      (ct_data *tree, int max_code, U16 *bl_count);
   static void build_tree     (deflate_state *s, tree_desc *desc);
   static void scan_tree      (deflate_state *s, ct_data *tree, int max_code);
   static void send_tree      (deflate_state *s, ct_data *tree, int max_code);
   static int  build_bl_tree  (deflate_state *s);
   static void send_all_trees (deflate_state *s, int lcodes, int dcodes, int blcodes);
   static void compress_block (deflate_state *s, ct_data *ltree, ct_data *dtree);
   static void set_data_type  (deflate_state *s);
   static u_nsigned bi_reverse(u_nsigned value, int length);
   static void bi_windup      (deflate_state *s);
   static void bi_flush       (deflate_state *s);
   static void copy_block     (deflate_state *s, U8 *buf, u_nsigned len, int header);

/* Send a code of the given tree. c and tree must not have side effects */
#define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) {                       \
      put_byte(s, (U8)((w) & 0xff));            \
      put_byte(s, (U8)((U16)(w) >> 8));         \
   }

#define send_bits(s, value, length)                             \
   { int len = length;                                          \
      if (s->bi_valid > (int)Buf_size - len) {                  \
         int val = value;                                       \
         s->bi_buf |= (val << s->bi_valid);                     \
         put_short(s, s->bi_buf);                               \
         s->bi_buf = (U16)val >> (Buf_size - s->bi_valid);      \
         s->bi_valid += len - Buf_size;                         \
      } else {                                                  \
         s->bi_buf |= (value) << s->bi_valid;                   \
         s->bi_valid += len;                                    \
      }                                                         \
   }

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
   static void send_tree (deflate_state *s, ct_data *tree, int max_code)
   {
      int n;                     /* iterates over all tree elements */
      int prevlen = -1;          /* last emitted length */
      int curlen;                /* length of current code */
      int nextlen = tree[0].Len; /* length of next code */
      int count = 0;             /* repeat count of the current code */
      int max_count = 7;         /* max repeat count */
      int min_count = 4;         /* min repeat count */

      /* tree[max_code+1].Len = -1; */  /* guard already set */
      if (nextlen == 0) max_count = 138, min_count = 3;

      for (n = 0; n <= max_code; n++) {
         curlen = nextlen; nextlen = tree[n+1].Len;
         if (++count < max_count && curlen == nextlen) {
            continue;
         } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

         } else if (curlen != 0) {
            if (curlen != prevlen) {
               send_code(s, curlen, s->bl_tree); count--;
            }
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

         } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

         } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
         }
         count = 0; prevlen = curlen;
         if (nextlen == 0) {
            max_count = 138, min_count = 3;
         } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
         } else {
            max_count = 7, min_count = 4;
         }
      }
   }

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
   static void gen_bitlen(deflate_state *s, tree_desc *desc)
   {
      ct_data *tree        = desc->dyn_tree;
      int max_code         = desc->max_code;
      const ct_data *stree = desc->stat_desc->static_tree;
      const int *extra     = desc->stat_desc->extra_bits;
      int base             = desc->stat_desc->extra_base;
      int max_length       = desc->stat_desc->max_length;
      int h;              /* heap index */
      int n, m;           /* iterate over the tree elements */
      int bits;           /* bit length */
      int xbits;          /* extra bits */
      U16 f;              /* frequency */
      int overflow = 0;   /* number of elements with bit length too large */

      for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

      /* In a first pass, compute the optimal bit lengths (which may
       * overflow in the case of the bit length tree).
       */
      tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

      for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
         n = s->heap[h];
         bits = tree[tree[n].Dad].Len + 1;
         if (bits > max_length) bits = max_length, overflow++;
         tree[n].Len = (U16)bits;
         /* We overwrite tree[n].Dad which is no longer needed */

         if (n > max_code) continue; /* not a leaf node */

         s->bl_count[bits]++;
         xbits = 0;
         if (n >= base) xbits = extra[n-base];
         f = tree[n].Freq;
         s->opt_len += (U32)f * (bits + xbits);
         if (stree) s->static_len += (U32)f * (stree[n].Len + xbits);
      }
      if (overflow == 0) return;

      /* Find the first bit length which could increase: */
      do {
         bits = max_length-1;
         while (s->bl_count[bits] == 0) bits--;
         s->bl_count[bits]--;      /* move one leaf down the tree */
         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
         s->bl_count[max_length]--;
         /* The brother of the overflow item also moves one step up,
          * but this does not affect bl_count[max_length]
          */
         overflow -= 2;
      } while (overflow > 0);

      /* Now recompute all bit lengths, scanning in increasing frequency.
       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
       * lengths instead of fixing only the wrong ones. This idea is taken
       * from 'ar' written by Haruhiko Okumura.)
       */
      for (bits = max_length; bits != 0; bits--) {
         n = s->bl_count[bits];
         while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if ((u_nsigned) tree[m].Len != (u_nsigned) bits) {
               s->opt_len += ((S32)bits - (S32)tree[m].Len)
                  *(S32)tree[m].Freq;
               tree[m].Len = (U16)bits;
            }
            n--;
         }
      }
   }

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
   static void scan_tree (deflate_state *s, ct_data *tree, int max_code)
   {
      int n;                     /* iterates over all tree elements */
      int prevlen = -1;          /* last emitted length */
      int curlen;                /* length of current code */
      int nextlen = tree[0].Len; /* length of next code */
      int count = 0;             /* repeat count of the current code */
      int max_count = 7;         /* max repeat count */
      int min_count = 4;         /* min repeat count */

      if (nextlen == 0) max_count = 138, min_count = 3;
      tree[max_code+1].Len = (U16)0xffff; /* guard */

      for (n = 0; n <= max_code; n++) {
         curlen = nextlen; nextlen = tree[n+1].Len;
         if (++count < max_count && curlen == nextlen) {
            continue;
         } else if (count < min_count) {
            s->bl_tree[curlen].Freq += count;
         } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
         } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
         } else {
            s->bl_tree[REPZ_11_138].Freq++;
         }
         count = 0; prevlen = curlen;
         if (nextlen == 0) {
            max_count = 138, min_count = 3;
         } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
         } else {
            max_count = 7, min_count = 4;
         }
      }
   }

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
   void _tr_init(deflate_state *s)
   {
      s->l_desc.dyn_tree = s->dyn_ltree;
      s->l_desc.stat_desc = &static_l_desc;

      s->d_desc.dyn_tree = s->dyn_dtree;
      s->d_desc.stat_desc = &static_d_desc;

      s->bl_desc.dyn_tree = s->bl_tree;
      s->bl_desc.stat_desc = &static_bl_desc;

      s->bi_buf = 0;
      s->bi_valid = 0;
      s->last_eob_len = 8; /* enough lookahead for inflate */

      /* Initialize the first block of the first file: */
      init_block(s);
   }

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top)                          \
   {                                                    \
      top = s->heap[SMALLEST];                          \
      s->heap[SMALLEST] = s->heap[s->heap_len--];       \
      pqdownheap(s, tree, SMALLEST);                    \
   }

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth)                              \
   (tree[n].Freq < tree[m].Freq ||                              \
    (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
   static void pqdownheap(deflate_state *s, ct_data *tree, int k)
   {
      int v = s->heap[k];
      int j = k << 1;  /* left son of k */
      while (j <= s->heap_len) {
         /* Set j to the smallest of the two sons: */
         if (j < s->heap_len &&
             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
         }
         /* Exit if v is smaller than both sons */
         if (smaller(tree, v, s->heap[j], s->depth)) break;

         /* Exchange v with the smallest son */
         s->heap[k] = s->heap[j];  k = j;

         /* And continue down the tree, setting j to the left son of k */
         j <<= 1;
      }
      s->heap[k] = v;
   }

/* ===========================================================================
 * Initialize a new block.
 */
   static void init_block(deflate_state *s)
   {
      int n; /* iterates over tree elements */

      /* Initialize the trees. */
      for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
      for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
      for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

      s->dyn_ltree[END_BLOCK].Freq = 1;
      s->opt_len = s->static_len = 0L;
      s->last_lit = s->matches = 0;
   }

/* ===========================================================================
 * Send a stored block
 */
   void _tr_stored_block(deflate_state *s, U8 *buf, U32 stored_len, int eof)
   {
      send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
      copy_block(s, buf, (u_nsigned)stored_len, 1); /* with header */
   }

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
   static void bi_flush(deflate_state *s)
   {
      if (s->bi_valid == 16) {
         put_short(s, s->bi_buf);
         s->bi_buf = 0;
         s->bi_valid = 0;
      } else if (s->bi_valid >= 8) {
         put_byte(s, (U8)s->bi_buf);
         s->bi_buf >>= 8;
         s->bi_valid -= 8;
      }
   }

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
   static void bi_windup(deflate_state *s)
   {
      if (s->bi_valid > 8) {
         put_short(s, s->bi_buf);
      } else if (s->bi_valid > 0) {
         put_byte(s, (U8)s->bi_buf);
      }
      s->bi_buf = 0;
      s->bi_valid = 0;
   }

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
   static void gen_codes (ct_data *tree, int max_code, U16 *bl_count)
   {
      U16 next_code[MAX_BITS+1]; /* next code value for each bit length */
      U16 code = 0;              /* running code value */
      int bits;                  /* bit index */
      int n;                     /* code index */

      /* The distribution counts are first used to generate the code values
       * without bit reversal.
       */
      for (bits = 1; bits <= MAX_BITS; bits++) {
         next_code[bits] = code = (code + bl_count[bits-1]) << 1;
      }

      for (n = 0;  n <= max_code; n++) {
         int len = tree[n].Len;
         if (len == 0) continue;
         /* Now reverse the bits */
         tree[n].Code = (U16)bi_reverse(next_code[len]++, len); /* cast */
      }
   }

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
   static void send_all_trees(deflate_state *s, int lcodes, int dcodes, int blcodes)
   {
      int rank;                    /* index in bl_order */

      send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
      send_bits(s, dcodes-1,   5);
      send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
      for (rank = 0; rank < blcodes; rank++) {
         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
      }

      send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

      send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
   }

/* ===========================================================================
 * Set the data type to BINARY or TEXT, using a crude approximation:
 * set it to Z_TEXT if all symbols are either printable characters (33 to 255)
 * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
   static void set_data_type(deflate_state *s)
   {
      int n;

      for (n = 0; n < 9; n++)
         if (s->dyn_ltree[n].Freq != 0)
            break;
      if (n == 9)
         for (n = 14; n < 32; n++)
            if (s->dyn_ltree[n].Freq != 0)
               break;
      s->strm->data_type = (n == 32) ? Z_TEXT : Z_BINARY;
   }

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
   static u_nsigned bi_reverse(u_nsigned code, int len)
   {
      register u_nsigned res = 0;
      do {
         res |= code & 1;
         code >>= 1, res <<= 1;
      } while (--len > 0);
      return res >> 1;
   }

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
   static void build_tree(deflate_state *s, tree_desc *desc)
   {
      ct_data *tree         = desc->dyn_tree;
      const ct_data *stree  = desc->stat_desc->static_tree;
      int elems             = desc->stat_desc->elems;
      int n, m;          /* iterate over heap elements */
      int max_code = -1; /* largest code with non zero frequency */
      int node;          /* new node being created */

      /* Construct the initial heap, with least frequent element in
       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
       * heap[0] is not used.
       */
      s->heap_len = 0, s->heap_max = HEAP_SIZE;

      for (n = 0; n < elems; n++) {
         if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
         } else {
            tree[n].Len = 0;
         }
      }

      /* The pkzip format requires that at least one distance code exists,
       * and that at least one bit should be sent even if there is only one
       * possible code. So to avoid special checks later on we force at least
       * two codes of non zero frequency.
       */
      while (s->heap_len < 2) {
         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
         tree[node].Freq = 1;
         s->depth[node] = 0;
         s->opt_len--; if (stree) s->static_len -= stree[node].Len;
         /* node is 0 or 1 so it does not have extra bits */
      }
      desc->max_code = max_code;

      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
       * establish sub-heaps of increasing lengths:
       */
      for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

      /* Construct the Huffman tree by repeatedly combining the least two
       * frequent nodes.
       */
      node = elems;              /* next internal node of the tree */
      do {
         pqremove(s, tree, n);  /* n = node of least frequency */
         m = s->heap[SMALLEST]; /* m = node of next least frequency */

         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
         s->heap[--(s->heap_max)] = m;

         /* Create a new node father of n and m */
         tree[node].Freq = tree[n].Freq + tree[m].Freq;
         s->depth[node] = (U8)((s->depth[n] >= s->depth[m] ?
                                s->depth[n] : s->depth[m]) + 1);
         tree[n].Dad = tree[m].Dad = (U16)node;
         /* and insert the new node in the heap */
         s->heap[SMALLEST] = node++;
         pqdownheap(s, tree, SMALLEST);

      } while (s->heap_len >= 2);

      s->heap[--(s->heap_max)] = s->heap[SMALLEST];

      /* At this point, the fields freq and dad are set. We can now
       * generate the bit lengths.
       */
      gen_bitlen(s, (tree_desc *)desc);

      /* The field len is now set, we can generate the bit codes */
      gen_codes ((ct_data *)tree, max_code, s->bl_count);
   }

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
   static int build_bl_tree(deflate_state *s)
   {
      int max_blindex;  /* index of last bit length code of non zero freq */

      /* Determine the bit length frequencies for literal and distance trees */
      scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
      scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

      /* Build the bit length tree: */
      build_tree(s, (tree_desc *)(&(s->bl_desc)));
      /* opt_len now includes the length of the tree representations, except
       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
       */

      /* Determine the number of bit length codes to send. The pkzip format
       * requires that at least 4 bit length codes be sent. (appnote.txt says
       * 3 but the actual value used is 4.)
       */
      for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
      }
      /* Update opt_len to include the bit length tree and counts */
      s->opt_len += 3*(max_blindex+1) + 5+5+4;

      return max_blindex;
   }

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
   static void compress_block(deflate_state *s, ct_data *ltree, ct_data *dtree)
   {
      u_nsigned dist;      /* distance of matched string */
      int lc;              /* match length or unmatched char (if dist == 0) */
      u_nsigned lx = 0;    /* running index in l_buf */
      u_nsigned code;      /* the code to send */
      int extra;           /* number of extra bits to send */

      if (s->last_lit != 0) do {
            dist = s->d_buf[lx];
            lc = s->l_buf[lx++];
            if (dist == 0) {
               send_code(s, lc, ltree); /* send a literal byte */
            } else {
               /* Here, lc is the match length - MIN_MATCH */
               code = _length_code[lc];
               send_code(s, code+LITERALS+1, ltree); /* send the length code */
               extra = extra_lbits[code];
               if (extra != 0) {
                  lc -= base_length[code];
                  send_bits(s, lc, extra);       /* send the extra length bits */
               }
               dist--; /* dist is now the match distance - 1 */
               code = d_code(dist);

               send_code(s, code, dtree);       /* send the distance code */
               extra = extra_dbits[code];
               if (extra != 0) {
                  dist -= base_dist[code];
                  send_bits(s, dist, extra);   /* send the extra distance bits */
               }
            } /* literal or match pair ? */

         } while (lx < s->last_lit);

      send_code(s, END_BLOCK, ltree);
      s->last_eob_len = ltree[END_BLOCK].Len;
   }

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
   void _tr_flush_block(deflate_state *s, U8 *buf, U32 stored_len, int eof)
   {
      U32 opt_lenb, static_lenb; /* opt_len and static_len in bytes */
      int max_blindex = 0;  /* index of last bit length code of non zero freq */

      /* Build the Huffman trees unless a stored block is forced */
      if (s->level > 0) {

         /* Check if the file is binary or text */
         if (stored_len > 0 && s->strm->data_type == Z_UNKNOWN)
            set_data_type(s);

         /* Construct the literal and distance trees */
         build_tree(s, (tree_desc *)(&(s->l_desc)));

         build_tree(s, (tree_desc *)(&(s->d_desc)));

         /* At this point, opt_len and static_len are the total bit lengths of
          * the compressed block data, excluding the tree representations.
          */

         /* Build the bit length tree for the above two trees, and get the index
          * in bl_order of the last bit length code to send.
          */
         max_blindex = build_bl_tree(s);

         /* Determine the best encoding. Compute the block lengths in bytes. */
         opt_lenb = (s->opt_len+3+7)>>3;
         static_lenb = (s->static_len+3+7)>>3;

         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

      } else {
         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
      }

#ifdef FORCE_STORED
      if (buf != (char*)0) { /* force stored block */
#else
         if (stored_len+4 <= opt_lenb && buf != 0) {
            /* 4: two words for the lengths */
#endif
            /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
             * Otherwise we can't have processed more than WSIZE input bytes since
             * the last block flush, because compression would have been
             * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
             * transform a block into a stored block.
             */
            _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
         } else if (static_lenb >= 0) { /* force static trees */
#else
         } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
#endif
            send_bits(s, (STATIC_TREES<<1)+eof, 3);
            compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
         } else {
            send_bits(s, (DYN_TREES<<1)+eof, 3);
            send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                           max_blindex+1);
            compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
         }
         /* The above check is made mod 2^32, for files larger than 512 MB
          * and uLong implemented on 32 bits.
          */
         init_block(s);

         if (eof) {
            bi_windup(s);
         }
      }

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
      void _tr_align(deflate_state *s)
      {
         send_bits(s, STATIC_TREES<<1, 3);
         send_code(s, END_BLOCK, static_ltree);
         bi_flush(s);
         /* Of the 10 bits for the empty block, we have already sent
          * (10 - bi_valid) bits. The lookahead for the last real code (before
          * the EOB of the previous block) was thus at least one plus the length
          * of the EOB plus what we have just sent of the empty static block.
          */
         if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
            send_bits(s, STATIC_TREES<<1, 3);
            send_code(s, END_BLOCK, static_ltree);
            bi_flush(s);
         }
         s->last_eob_len = 7;
      }

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
      static void copy_block(deflate_state *s, U8 *buf, u_nsigned len, int header)
      {
         bi_windup(s);        /* align on byte boundary */
         s->last_eob_len = 8; /* enough lookahead for inflate */

         if (header) {
            put_short(s, (U16)len);
            put_short(s, (U16)~len);
         }
         while (len--) {
            put_byte(s, *buf++);
         }
      }

/****************************************************************************
 deflate.c 
****************************************************************************/
#  define def_check_match(s, start, match, length)

/* ===========================================================================
 *  Function prototypes.
 */
      typedef enum {
         need_more,      /* block not completed, need more input or more output */
         block_done,     /* block flush performed */
         finish_started, /* finish started, need only more output at next deflate */
         finish_done     /* finish done, accept no more input or output */
      } block_state;

      typedef block_state (*compress_func) (deflate_state *s, int flush);
/* Compression function. Returns the block state after the call. */

      static void fill_window    (deflate_state *s);
      static block_state deflate_stored (deflate_state *s, int flush);
      static block_state deflate_fast   (deflate_state *s, int flush);
      static block_state deflate_slow   (deflate_state *s, int flush);
      static void lm_init        (deflate_state *s);
      static void putShortMSB    (deflate_state *s, uInt b);
      static void flush_pending  (z_streamp strm);
      static int read_buf        (z_streamp strm, U8 *buf, u_nsigned size);

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
      typedef struct config_s {
         U16 good_length; /* reduce lazy search above this match length */
         U16 max_lazy;    /* do not perform lazy search above this match length */
         U16 nice_length; /* quit search above this match length */
         U16 max_chain;
         compress_func func;
      } config;

      static const config configuration_table[10] = {
/*      good lazy nice chain */
         /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
         /* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
         /* 2 */ {4,    5, 16,    8, deflate_fast},
         /* 3 */ {4,    6, 32,   32, deflate_fast},

         /* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
         /* 5 */ {8,   16, 32,   32, deflate_slow},
         /* 6 */ {8,   16, 128, 128, deflate_slow},
         /* 7 */ {8,   32, 128, 256, deflate_slow},
         /* 8 */ {32, 128, 258, 1024, deflate_slow},
         /* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#define INSERT_STRING(s, str, match_head)                               \
      (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]),      \
       match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h],     \
       s->head[s->ins_h] = (Pos)(str))

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s)                                                   \
      s->head[s->hash_size-1] = NIL;                                    \
      memset((U8 *)s->head, 0, (u_nsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
      int deflateInit_ (z_streamp strm, int level, const char *version, int stream_size)
      {
         return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                              Z_DEFAULT_STRATEGY, version, stream_size);
         /* To do: ignore strm->next_in if we use it as window */
      }

/* ========================================================================= */
      int deflateInit2_(z_streamp strm, int level, int method, int windowBits, 
                        int memLevel, int strategy, const char *version, int stream_size)
      {
         deflate_state *s;
         int wrap = 1;
         static const char my_version[] = ZLIB_VERSION;

         U16 *overlay;
         /* We overlay pending_buf and d_buf+l_buf. This works since the average
          * output size for (length,distance) codes is <= 24 bits.
          */

         if (version == NULL || version[0] != my_version[0] ||
             stream_size != sizeof(z_stream)) {
            return Z_VERSION_ERROR;
         }
         if (strm == NULL) return Z_STREAM_ERROR;

         if (level == Z_DEFAULT_COMPRESSION) level = 6;

         if (windowBits < 0) { /* suppress zlib wrapper */
            wrap = 0;
            windowBits = -windowBits;
         }
#ifdef GZIP
         else if (windowBits > 15) {
            wrap = 2;       /* write gzip wrapper instead */
            windowBits -= 16;
         }
#endif
         if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
             windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
             strategy < 0 || strategy > Z_FIXED) {
            return Z_STREAM_ERROR;
         }
         if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
         s = (deflate_state *)zeroBaMalloc(sizeof(deflate_state));
         if (s == NULL) return Z_MEM_ERROR;
         strm->state = (struct internal_state *)s;
         s->strm = strm;

         s->wrap = wrap;
         s->gzhead = NULL;
         s->w_bits = windowBits;
         s->w_size = 1 << s->w_bits;
         s->w_mask = s->w_size - 1;

         s->hash_bits = memLevel + 7;
         s->hash_size = 1 << s->hash_bits;
         s->hash_mask = s->hash_size - 1;
         s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

         s->window = (U8   *)  zeroBaMalloc(s->w_size * 2*sizeof(U8));
         s->prev   = (Posf *)  zeroBaMalloc(s->w_size * sizeof(Pos));
         s->head   = (Posf *)  zeroBaMalloc(s->hash_size * sizeof(Pos));

         s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

         overlay = (U16 *) zeroBaMalloc(s->lit_bufsize * (sizeof(U16)+2));
         s->pending_buf = (U8  *) overlay;
         s->pending_buf_size = (U32)s->lit_bufsize * (sizeof(U16)+2L);

         if (s->window == NULL || s->prev == NULL || s->head == NULL ||
             s->pending_buf == NULL) {
            s->status = FINISH_STATE;
            deflateEnd (strm);
            return Z_MEM_ERROR;
         }
         s->d_buf = overlay + s->lit_bufsize/sizeof(U16);
         s->l_buf = s->pending_buf + (1+sizeof(U16))*s->lit_bufsize;

         s->level = level;
         s->strategy = strategy;
         s->method = (U8)method;

         return deflateReset(strm);
      }

/* ========================================================================= */
      int deflateReset (z_streamp strm)
      {
         deflate_state *s;

         if (strm == NULL || strm->state == NULL) {
            return Z_STREAM_ERROR;
         }

         strm->total_in = strm->total_out = 0;
         /* strm->msg = NULL; use baFree if we ever allocate msg dynamically */
         strm->data_type = Z_UNKNOWN;

         s = (deflate_state *)strm->state;
         s->pending = 0;
         s->pending_out = s->pending_buf;

         if (s->wrap < 0) {
            s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
         }
         s->status = s->wrap ? INIT_STATE : BUSY_STATE;
         strm->adler =
#ifdef GZIP
            s->wrap == 2 ? crc32(0L, NULL, 0) :
#endif
            adler32(0L, NULL, 0);
         s->last_flush = Z_NO_FLUSH;

         _tr_init(s);
         lm_init(s);

         return Z_OK;
      }

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
      static void putShortMSB (deflate_state *s, uInt b)
      {
         put_byte(s, (U8)(b >> 8));
         put_byte(s, (U8)(b & 0xff));
      }

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
      static void flush_pending(z_streamp strm)
      {
         u_nsigned len = strm->state->pending;

         if (len > strm->avail_out) len = strm->avail_out;
         if (len == 0) return;

         memcpy(strm->next_out, strm->state->pending_out, len);
         strm->next_out  += len;
         strm->state->pending_out  += len;
         strm->total_out += len;
         strm->avail_out  -= len;
         strm->state->pending -= len;
         if (strm->state->pending == 0) {
            strm->state->pending_out = strm->state->pending_buf;
         }
      }

/* ========================================================================= */
      int deflate (z_streamp strm, int flush)
      {
         int old_flush; /* value of flush param for previous deflate call */
         deflate_state *s;

         if (strm == NULL || strm->state == NULL ||
             flush > Z_FINISH || flush < 0) {
            return Z_STREAM_ERROR;
         }
         s = strm->state;

         if (strm->next_out == NULL ||
             (strm->next_in == NULL && strm->avail_in != 0) ||
             (s->status == FINISH_STATE && flush != Z_FINISH)) {
            return Z_STREAM_ERROR;
         }
         if (strm->avail_out == 0) return Z_BUF_ERROR;

         s->strm = strm; /* just in case */
         old_flush = s->last_flush;
         s->last_flush = flush;

         /* Write the header */
         if (s->status == INIT_STATE) {
#ifdef GZIP
            if (s->wrap == 2) {
               strm->adler = crc32(0L, NULL, 0);
               put_byte(s, 31);
               put_byte(s, 139);
               put_byte(s, 8);
               if (s->gzhead == NULL) {
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, s->level == 9 ? 2 :
                           (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                            4 : 0));
                  put_byte(s, OS_CODE);
                  s->status = BUSY_STATE;
               }
               else {
                  put_byte(s, (s->gzhead->text ? 1 : 0) +
                           (s->gzhead->hcrc ? 2 : 0) +
                           (s->gzhead->extra == NULL ? 0 : 4) +
                           (s->gzhead->name == NULL ? 0 : 8) +
                           (s->gzhead->comment == NULL ? 0 : 16)
                     );
                  put_byte(s, (Byte)(s->gzhead->time & 0xff));
                  put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
                  put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
                  put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
                  put_byte(s, s->level == 9 ? 2 :
                           (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                            4 : 0));
                  put_byte(s, s->gzhead->os & 0xff);
                  if (s->gzhead->extra != NULL) {
                     put_byte(s, s->gzhead->extra_len & 0xff);
                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
                  }
                  if (s->gzhead->hcrc)
                     strm->adler = crc32(strm->adler, s->pending_buf,
                                         s->pending);
                  s->gzindex = 0;
                  s->status = EXTRA_STATE;
               }
            }
            else
#endif
            {
               uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
               uInt level_flags;

               if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
                  level_flags = 0;
               else if (s->level < 6)
                  level_flags = 1;
               else if (s->level == 6)
                  level_flags = 2;
               else
                  level_flags = 3;
               header |= (level_flags << 6);
               if (s->strstart != 0) header |= PRESET_DICT;
               header += 31 - (header % 31);

               s->status = BUSY_STATE;
               putShortMSB(s, header);

               /* Save the adler32 of the preset dictionary: */
               if (s->strstart != 0) {
                  putShortMSB(s, (uInt)(strm->adler >> 16));
                  putShortMSB(s, (uInt)(strm->adler & 0xffff));
               }
               strm->adler = adler32(0L, NULL, 0);
            }
         }
#ifdef GZIP
         if (s->status == EXTRA_STATE) {
            if (s->gzhead->extra != NULL) {
               uInt beg = s->pending;  /* start of bytes to update crc */

               while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
                  if (s->pending == s->pending_buf_size) {
                     if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                     flush_pending(strm);
                     beg = s->pending;
                     if (s->pending == s->pending_buf_size)
                        break;
                  }
                  put_byte(s, s->gzhead->extra[s->gzindex]);
                  s->gzindex++;
               }
               if (s->gzhead->hcrc && s->pending > beg)
                  strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                      s->pending - beg);
               if (s->gzindex == s->gzhead->extra_len) {
                  s->gzindex = 0;
                  s->status = NAME_STATE;
               }
            }
            else
               s->status = NAME_STATE;
         }
         if (s->status == NAME_STATE) {
            if (s->gzhead->name != NULL) {
               uInt beg = s->pending;  /* start of bytes to update crc */
               int val;

               do {
                  if (s->pending == s->pending_buf_size) {
                     if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                     flush_pending(strm);
                     beg = s->pending;
                     if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                     }
                  }
                  val = s->gzhead->name[s->gzindex++];
                  put_byte(s, val);
               } while (val != 0);
               if (s->gzhead->hcrc && s->pending > beg)
                  strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                      s->pending - beg);
               if (val == 0) {
                  s->gzindex = 0;
                  s->status = COMMENT_STATE;
               }
            }
            else
               s->status = COMMENT_STATE;
         }
         if (s->status == COMMENT_STATE) {
            if (s->gzhead->comment != NULL) {
               uInt beg = s->pending;  /* start of bytes to update crc */
               int val;

               do {
                  if (s->pending == s->pending_buf_size) {
                     if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                     flush_pending(strm);
                     beg = s->pending;
                     if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                     }
                  }
                  val = s->gzhead->comment[s->gzindex++];
                  put_byte(s, val);
               } while (val != 0);
               if (s->gzhead->hcrc && s->pending > beg)
                  strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                      s->pending - beg);
               if (val == 0)
                  s->status = HCRC_STATE;
            }
            else
               s->status = HCRC_STATE;
         }
         if (s->status == HCRC_STATE) {
            if (s->gzhead->hcrc) {
               if (s->pending + 2 > s->pending_buf_size)
                  flush_pending(strm);
               if (s->pending + 2 <= s->pending_buf_size) {
                  put_byte(s, (Byte)(strm->adler & 0xff));
                  put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
                  strm->adler = crc32(0L, NULL, 0);
                  s->status = BUSY_STATE;
               }
            }
            else
               s->status = BUSY_STATE;
         }
#endif

         /* Flush as much pending output as possible */
         if (s->pending != 0) {
            flush_pending(strm);
            if (strm->avail_out == 0) {
               /* Since avail_out is 0, deflate will be called again with
                * more output space, but possibly with both pending and
                * avail_in equal to zero. There won't be anything to do,
                * but this is not an error situation so make sure we
                * return OK instead of BUF_ERROR at next call of deflate:
                */
               s->last_flush = -1;
               return Z_OK;
            }

            /* Make sure there is something to do and avoid duplicate consecutive
             * flushes. For repeated and useless calls with Z_FINISH, we keep
             * returning Z_STREAM_END instead of Z_BUF_ERROR.
             */
         } else if (strm->avail_in == 0 && flush <= old_flush &&
                    flush != Z_FINISH) {
            return Z_BUF_ERROR;
         }

         /* User must not provide more input after the first FINISH: */
         if (s->status == FINISH_STATE && strm->avail_in != 0) {
            return Z_BUF_ERROR;
         }

         /* Start a new block or continue the current one.
          */
         if (strm->avail_in != 0 || s->lookahead != 0 ||
             (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
            block_state bstate;

            bstate = (*(configuration_table[s->level].func))(s, flush);

            if (bstate == finish_started || bstate == finish_done) {
               s->status = FINISH_STATE;
            }
            if (bstate == need_more || bstate == finish_started) {
               if (strm->avail_out == 0) {
                  s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
               }
               return Z_OK;
               /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                * of deflate should use the same flush parameter to make sure
                * that the flush is complete. So we don't have to output an
                * empty block here, this will be done at next call. This also
                * ensures that for a very small output buffer, we emit at most
                * one empty block.
                */
            }
            if (bstate == block_done) {
               if (flush == Z_PARTIAL_FLUSH) {
                  _tr_align(s);
               } else { /* FULL_FLUSH or SYNC_FLUSH */
                  _tr_stored_block(s, 0, 0L, 0);
                  /* For a full flush, this empty block will be recognized
                   * as a special marker by inflate_sync().
                   */
                  if (flush == Z_FULL_FLUSH) {
                     CLEAR_HASH(s);             /* forget history */
                  }
               }
               flush_pending(strm);
               if (strm->avail_out == 0) {
                  s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
                  return Z_OK;
               }
            }
         }

         if (flush != Z_FINISH) return Z_OK;
         if (s->wrap <= 0) return Z_STREAM_END;

         /* Write the trailer */
#ifdef GZIP
         if (s->wrap == 2) {
            put_byte(s, (Byte)(strm->adler & 0xff));
            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
            put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
            put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
            put_byte(s, (Byte)(strm->total_in & 0xff));
            put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
            put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
            put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
         }
         else
#endif
         {
            putShortMSB(s, (uInt)(strm->adler >> 16));
            putShortMSB(s, (uInt)(strm->adler & 0xffff));
         }
         flush_pending(strm);
         /* If avail_out is zero, the application will call deflate again
          * to flush the rest.
          */
         if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
         return s->pending != 0 ? Z_OK : Z_STREAM_END;
      }

/* ========================================================================= */
      int deflateEnd (z_streamp strm)
      {
         int status;

         if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;

         status = strm->state->status;
         if (status != INIT_STATE &&
             status != EXTRA_STATE &&
             status != NAME_STATE &&
             status != COMMENT_STATE &&
             status != HCRC_STATE &&
             status != BUSY_STATE &&
             status != FINISH_STATE) {
            return Z_STREAM_ERROR;
         }

         /* Deallocate in reverse order of allocations: */
#define TRY_FREE(s, p) {if (p) baFree(p);}
         TRY_FREE(strm, strm->state->pending_buf);
         TRY_FREE(strm, strm->state->head);
         TRY_FREE(strm, strm->state->prev);
         TRY_FREE(strm, strm->state->window);

         baFree(strm->state);
         strm->state = NULL;

         return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
      }

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
      static int read_buf(z_streamp strm, U8 *buf, u_nsigned size)
      {
         u_nsigned len = strm->avail_in;

         if (len > size) len = size;
         if (len == 0) return 0;

         strm->avail_in  -= len;

         if (strm->state->wrap == 1) {
            strm->adler = adler32(strm->adler, strm->next_in, len);
         }
#ifdef GZIP
         else if (strm->state->wrap == 2) {
            strm->adler = crc32(strm->adler, strm->next_in, len);
         }
#endif
         memcpy(buf, strm->next_in, len);
         strm->next_in  += len;
         strm->total_in += len;

         return (int)len;
      }

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
      static void lm_init (deflate_state *s)
      {
         s->window_size = (U32)2L*s->w_size;

         CLEAR_HASH(s);

         /* Set the default configuration parameters:
          */
         s->max_lazy_match   = configuration_table[s->level].max_lazy;
         s->good_match       = configuration_table[s->level].good_length;
         s->nice_match       = configuration_table[s->level].nice_length;
         s->max_chain_length = configuration_table[s->level].max_chain;

         s->strstart = 0;
         s->block_start = 0L;
         s->lookahead = 0;
         s->match_length = s->prev_length = MIN_MATCH-1;
         s->match_available = 0;
         s->ins_h = 0;
      }

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
      static uInt longest_match(deflate_state *s, IPos cur_match)
      {
         u_nsigned chain_length = s->max_chain_length;/* max hash chain length */
         register U8 *scan = s->window + s->strstart; /* current string */
         register U8 *match;                       /* matched string */
         register int len;                           /* length of current match */
         int best_len = s->prev_length;              /* best match length so far */
         int nice_match = s->nice_match;             /* stop if match long enough */
         IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
            s->strstart - (IPos)MAX_DIST(s) : NIL;
         /* Stop when cur_match becomes <= limit. To simplify the code,
          * we prevent matches with the string of window index 0.
          */
         Pos *prev = s->prev;
         uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
         /* Compare two bytes at a time. Note: this is not always beneficial.
          * Try with and without -DUNALIGNED_OK to check.
          */
         register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
         register ush scan_start = *(ushf*)scan;
         register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
         register U8 *strend = s->window + s->strstart + MAX_MATCH;
         register U8 scan_end1  = scan[best_len-1];
         register U8 scan_end   = scan[best_len];
#endif

         /* Do not waste too much time if we already have a good match: */
         if (s->prev_length >= s->good_match) {
            chain_length >>= 2;
         }
         /* Do not look for matches beyond the end of the input. This is necessary
          * to make deflate deterministic.
          */
         if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

         do {
            match = s->window + cur_match;

            /* Skip to next match if the match length cannot increase
             * or if the match length is less than 2.  Note that the checks below
             * for insufficient lookahead only occur occasionally for performance
             * reasons.  Therefore uninitialized memory will be accessed, and
             * conditional jumps will be made that depend on those values.
             * However the length of the match is limited to the lookahead, so
             * the output of deflate is not affected by the uninitialized values.
             */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
            /* This code assumes sizeof(U16) == 2. Do not use
             * UNALIGNED_OK if your compiler uses a different size.
             */
            if (*(U16*)(match+best_len-1) != scan_end ||
                *(U16*)match != scan_start) continue;

            /* It is not necessary to compare scan[2] and match[2] since they are
             * always equal when the other bytes match, given that the hash keys
             * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
             * strstart+3, +5, ... up to strstart+257. We check for insufficient
             * lookahead only every 4th comparison; the 128th check will be made
             * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
             * necessary to put more guard bytes at the end of the window, or
             * to check more often for insufficient lookahead.
             */
            scan++, match++;
            do {
            } while (*(U16*)(scan+=2) == *(U16*)(match+=2) &&
                     *(U16*)(scan+=2) == *(U16*)(match+=2) &&
                     *(U16*)(scan+=2) == *(U16*)(match+=2) &&
                     *(U16*)(scan+=2) == *(U16*)(match+=2) &&
                     scan < strend);
            /* The funny "do {}" generates better code on most compilers */

            /* Here, scan <= window+strstart+257 */
            if (*scan == *match) scan++;

            len = (MAX_MATCH - 1) - (int)(strend-scan);
            scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

            if (match[best_len]   != scan_end  ||
                match[best_len-1] != scan_end1 ||
                *match            != *scan     ||
                *++match          != scan[1])      continue;

            /* The check at best_len-1 can be removed because it will be made
             * again later. (This heuristic is not always a win.)
             * It is not necessary to compare scan[2] and match[2] since they
             * are always equal when the other bytes match, given that
             * the hash keys are equal and that HASH_BITS >= 8.
             */
            scan += 2, match++;

            /* We check for insufficient lookahead only every 8th comparison;
             * the 256th check will be made at strstart+258.
             */
            do {
            } while (*++scan == *++match && *++scan == *++match &&
                     *++scan == *++match && *++scan == *++match &&
                     *++scan == *++match && *++scan == *++match &&
                     *++scan == *++match && *++scan == *++match &&
                     scan < strend);

            len = MAX_MATCH - (int)(strend - scan);
            scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

            if (len > best_len) {
               s->match_start = cur_match;
               best_len = len;
               if (len >= nice_match) break;
#ifdef UNALIGNED_OK
               scan_end = *(U16*)(scan+best_len-1);
#else
               scan_end1  = scan[best_len-1];
               scan_end   = scan[best_len];
#endif
            }
         } while ((cur_match = prev[cur_match & wmask]) > limit
                  && --chain_length != 0);

         if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
         return s->lookahead;
      }

/* ---------------------------------------------------------------------------
 * Optimized version for level == 1 or strategy == Z_RLE only
 */
      static uInt longest_match_fast(deflate_state *s, IPos cur_match)
      {
         register U8 *scan = s->window + s->strstart; /* current string */
         register U8 *match;                       /* matched string */
         register int len;                           /* length of current match */
         register U8 *strend = s->window + s->strstart + MAX_MATCH;

         match = s->window + cur_match;

         /* Return failure if the match length is less than 2:
          */
         if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

         /* The check at best_len-1 can be removed because it will be made
          * again later. (This heuristic is not always a win.)
          * It is not necessary to compare scan[2] and match[2] since they
          * are always equal when the other bytes match, given that
          * the hash keys are equal and that HASH_BITS >= 8.
          */
         scan += 2, match += 2;

         /* We check for insufficient lookahead only every 8th comparison;
          * the 256th check will be made at strstart+258.
          */
         do {
         } while (*++scan == *++match && *++scan == *++match &&
                  *++scan == *++match && *++scan == *++match &&
                  *++scan == *++match && *++scan == *++match &&
                  *++scan == *++match && *++scan == *++match &&
                  scan < strend);

         len = MAX_MATCH - (int)(strend - scan);

         if (len < MIN_MATCH) return MIN_MATCH - 1;

         s->match_start = cur_match;
         return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
      }

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
      static void fill_window(deflate_state *s)
      {
         register u_nsigned n, m;
         register Posf *p;
         u_nsigned more;    /* Amount of free space at the end of the window. */
         uInt wsize = s->w_size;

         do {
            more = (u_nsigned)(s->window_size -(U32)s->lookahead -(U32)s->strstart);

            /* Deal with !@#$% 64K limit: */
            if (sizeof(int) <= 2) {
               if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                  more = wsize;

               } else if (more == (u_nsigned)(-1)) {
                  /* Very unlikely, but possible on 16 bit machine if
                   * strstart == 0 && lookahead == 1 (input done a byte at time)
                   */
                  more--;
               }
            }

            /* If the window is almost full and there is insufficient lookahead,
             * move the upper half to the lower one to make room in the upper half.
             */
            if (s->strstart >= wsize+MAX_DIST(s)) {

               memcpy(s->window, s->window+wsize, (u_nsigned)wsize);
               s->match_start -= wsize;
               s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
               s->block_start -= (S32) wsize;

               /* Slide the hash table (could be avoided with 32 bit values
                  at the expense of memory usage). We slide even when level == 0
                  to keep the hash table consistent if we switch back to level > 0
                  later. (Using level 0 permanently is not an optimal usage of
                  zlib, so we don't care about this pathological case.)
               */
               /* %%% avoid this when Z_RLE */
               n = s->hash_size;
               p = &s->head[n];
               do {
                  m = *--p;
                  *p = (Pos)(m >= wsize ? m-wsize : NIL);
               } while (--n);

               n = wsize;
               p = &s->prev[n];
               do {
                  m = *--p;
                  *p = (Pos)(m >= wsize ? m-wsize : NIL);
                  /* If n is not on any hash chain, prev[n] is garbage but
                   * its value will never be used.
                   */
               } while (--n);
               more += wsize;
            }
            if (s->strm->avail_in == 0) return;

            n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
            s->lookahead += n;

            /* Initialize the hash value now that we have some input: */
            if (s->lookahead >= MIN_MATCH) {
               s->ins_h = s->window[s->strstart];
               UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
               Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                  }
            /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
             * but this is not important since only literal bytes will be emitted.
             */

         } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
      }

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, eof) {                                      \
         _tr_flush_block(s, (s->block_start >= 0L ?                     \
                             (U8 *)&s->window[(u_nsigned)s->block_start] : \
                             (U8 *)NULL),                               \
                         (U32)((S32)s->strstart - s->block_start),      \
                         (eof));                                        \
         s->block_start = s->strstart;                                  \
         flush_pending(s->strm);                                        \
      }

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, eof) {                                           \
         FLUSH_BLOCK_ONLY(s, eof);                                      \
         if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
      }

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
      static block_state deflate_stored(deflate_state *s, int flush)
      {
         /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
          * to pending_buf_size, and each stored block has a 5 byte header:
          */
         U32 max_block_size = 0xffff;
         U32 max_start;

         if (max_block_size > s->pending_buf_size - 5) {
            max_block_size = s->pending_buf_size - 5;
         }

         /* Copy as much as possible from input to output: */
         for (;;) {
            /* Fill the window as much as possible: */
            if (s->lookahead <= 1) {

               fill_window(s);
               if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

               if (s->lookahead == 0) break; /* flush the current block */
            }

            s->strstart += s->lookahead;
            s->lookahead = 0;

            /* Emit a stored block if pending_buf will be full: */
            max_start = s->block_start + max_block_size;
            if (s->strstart == 0 || (U32)s->strstart >= max_start) {
               /* strstart == 0 is possible when wraparound on 16-bit machine */
               s->lookahead = (u_nsigned)(s->strstart - max_start);
               s->strstart = (u_nsigned)max_start;
               FLUSH_BLOCK(s, 0);
            }
            /* Flush if we may have to slide, otherwise block_start may become
             * negative and the data will be gone:
             */
            if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
               FLUSH_BLOCK(s, 0);
            }
         }
         FLUSH_BLOCK(s, flush == Z_FINISH);
         return flush == Z_FINISH ? finish_done : block_done;
      }

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
      static block_state deflate_fast(deflate_state *s, int flush)
      {
         IPos hash_head = NIL; /* head of the hash chain */
         int bflush;           /* set if current block must be flushed */

         for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the next match, plus MIN_MATCH bytes to insert the
             * string following the next match.
             */
            if (s->lookahead < MIN_LOOKAHEAD) {
               fill_window(s);
               if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                  return need_more;
               }
               if (s->lookahead == 0) break; /* flush the current block */
            }

            /* Insert the string window[strstart .. strstart+2] in the
             * dictionary, and set hash_head to the head of the hash chain:
             */
            if (s->lookahead >= MIN_MATCH) {
               INSERT_STRING(s, s->strstart, hash_head);
            }

            /* Find the longest match, discarding those <= prev_length.
             * At this point we have always match_length < MIN_MATCH
             */
            if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
               /* To simplify the code, we prevent matches with the string
                * of window index 0 (in particular we have to avoid a match
                * of the string with itself at the start of the input file).
                */
               if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
                  s->match_length = longest_match (s, hash_head);
               } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
                  s->match_length = longest_match_fast (s, hash_head);
               }
               /* longest_match() or longest_match_fast() sets match_start */
            }
            if (s->match_length >= MIN_MATCH) {
               def_check_match(s, s->strstart, s->match_start, s->match_length);

               _tr_tally_dist(s, s->strstart - s->match_start,
                              s->match_length - MIN_MATCH, bflush);

               s->lookahead -= s->match_length;

               /* Insert new strings in the hash table only if the match length
                * is not too large. This saves time but degrades compression.
                */
               if (s->match_length <= s->max_insert_length &&
                   s->lookahead >= MIN_MATCH) {
                  s->match_length--; /* string at strstart already in table */
                  do {
                     s->strstart++;
                     INSERT_STRING(s, s->strstart, hash_head);
                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                      * always MIN_MATCH bytes ahead.
                      */
                  } while (--s->match_length != 0);
                  s->strstart++;
               } else
               {
                  s->strstart += s->match_length;
                  s->match_length = 0;
                  s->ins_h = s->window[s->strstart];
                  UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                  Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                     /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                      * matter since it will be recomputed at next deflate call.
                      */
                     }
            } else {
               /* No match, output a literal byte */
               _tr_tally_lit (s, s->window[s->strstart], bflush);
               s->lookahead--;
               s->strstart++;
            }
            if (bflush) FLUSH_BLOCK(s, 0);
         }
         FLUSH_BLOCK(s, flush == Z_FINISH);
         return flush == Z_FINISH ? finish_done : block_done;
      }

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
      static block_state deflate_slow(deflate_state *s, int flush)
      {
         IPos hash_head = NIL;    /* head of hash chain */
         int bflush;              /* set if current block must be flushed */

         /* Process the input block. */
         for (;;) {
            /* Make sure that we always have enough lookahead, except
             * at the end of the input file. We need MAX_MATCH bytes
             * for the next match, plus MIN_MATCH bytes to insert the
             * string following the next match.
             */
            if (s->lookahead < MIN_LOOKAHEAD) {
               fill_window(s);
               if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                  return need_more;
               }
               if (s->lookahead == 0) break; /* flush the current block */
            }

            /* Insert the string window[strstart .. strstart+2] in the
             * dictionary, and set hash_head to the head of the hash chain:
             */
            if (s->lookahead >= MIN_MATCH) {
               INSERT_STRING(s, s->strstart, hash_head);
            }

            /* Find the longest match, discarding those <= prev_length.
             */
            s->prev_length = s->match_length, s->prev_match = s->match_start;
            s->match_length = MIN_MATCH-1;

            if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
                s->strstart - hash_head <= MAX_DIST(s)) {
               /* To simplify the code, we prevent matches with the string
                * of window index 0 (in particular we have to avoid a match
                * of the string with itself at the start of the input file).
                */
               if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
                  s->match_length = longest_match (s, hash_head);
               } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
                  s->match_length = longest_match_fast (s, hash_head);
               }
               /* longest_match() or longest_match_fast() sets match_start */

               if (s->match_length <= 5 && (s->strategy == Z_FILTERED
#if TOO_FAR <= 32767
                                            || (s->match_length == MIN_MATCH &&
                                                s->strstart - s->match_start > TOO_FAR)
#endif
                      )) {

                  /* If prev_match is also MIN_MATCH, match_start is garbage
                   * but we will ignore the current match anyway.
                   */
                  s->match_length = MIN_MATCH-1;
               }
            }
            /* If there was a match at the previous step and the current
             * match is not better, output the previous match:
             */
            if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
               uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
               /* Do not insert strings in hash table beyond this. */

               def_check_match(s, s->strstart-1, s->prev_match, s->prev_length);

               _tr_tally_dist(s, s->strstart -1 - s->prev_match,
                              s->prev_length - MIN_MATCH, bflush);

               /* Insert in hash table all strings up to the end of the match.
                * strstart-1 and strstart are already inserted. If there is not
                * enough lookahead, the last two strings are not inserted in
                * the hash table.
                */
               s->lookahead -= s->prev_length-1;
               s->prev_length -= 2;
               do {
                  if (++s->strstart <= max_insert) {
                     INSERT_STRING(s, s->strstart, hash_head);
                  }
               } while (--s->prev_length != 0);
               s->match_available = 0;
               s->match_length = MIN_MATCH-1;
               s->strstart++;

               if (bflush) FLUSH_BLOCK(s, 0);

            } else if (s->match_available) {
               /* If there was no match at the previous position, output a
                * single literal. If there was a match but the current match
                * is longer, truncate the previous match to a single literal.
                */
               _tr_tally_lit(s, s->window[s->strstart-1], bflush);
               if (bflush) {
                  FLUSH_BLOCK_ONLY(s, 0);
               }
               s->strstart++;
               s->lookahead--;
               if (s->strm->avail_out == 0) return need_more;
            } else {
               /* There is no previous match to compare with, wait for
                * the next step to decide.
                */
               s->match_available = 1;
               s->strstart++;
               s->lookahead--;
            }
         }
         if (s->match_available) {
            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
            s->match_available = 0;
         }
         FLUSH_BLOCK(s, flush == Z_FINISH);
         return flush == Z_FINISH ? finish_done : block_done;
      }

#endif /* BA_DEFLATE */

#endif /* NO_ZLIB */
	#include <WebSocketServer.h>
#include <NetIo.h>
#ifndef NO_SHARKSSL

#ifndef allocationdirection
#define allocationdirection

#include "SharkSSL_cfg.h"
#include "TargConfig.h"


#if   (defined(B_LITTLE_ENDIAN))
#if   (defined(B_BIG_ENDIAN))
#error B_LITTLE_ENDIAN and B_BIG_ENDIAN cannot be both #defined at the same widgetactive
#endif
#define setupcmdline(w) (*(U8*)((U8*)(&(w)) + 3))
#define exceptionupdates(w) (*(U8*)((U8*)(&(w)) + 2))
#define iisv4resource(w) (*(U8*)((U8*)(&(w)) + 1))
#define translationfault(w) (*(U8*)((U8*)(&(w)) + 0))

#elif (defined(B_BIG_ENDIAN))
#define setupcmdline(w) (*(U8*)((U8*)(&(w)) + 0))
#define exceptionupdates(w) (*(U8*)((U8*)(&(w)) + 1))
#define iisv4resource(w) (*(U8*)((U8*)(&(w)) + 2))
#define translationfault(w) (*(U8*)((U8*)(&(w)) + 3))

#else  
#define setupcmdline(w) ((U8)((w) >> 24))
#define exceptionupdates(w) ((U8)((w) >> 16))
#define iisv4resource(w) ((U8)((w) >> 8))
#define translationfault(w) ((U8)((w)))
#endif


#if   (__COLDFIRE__)  
static inline asm U32 __declspec(register_abi) blocktemplate (U32 d) { byterev.l d0 }
#define blockarray  blocktemplate

#elif (__ICCARM__ && __ARM_PROFILE_M__)   
#include <intrinsics.h>
#define blockarray  __REV
#define __sharkssl_packed      __packed  
   #if ((__CORE__==__ARM7M__) || (__CORE__==__ARM7EM__))  
   #ifndef SHARKSSL_AES_DISABLE_SBOX
   #define SHARKSSL_AES_DISABLE_SBOX 1
   #endif
   #endif

#elif (__CC_ARM && __TARGET_PROFILE_M)   
#define blockarray  __rev
#define __sharkssl_packed      __packed  
   #if ((__TARGET_ARCH_ARM == 0) && (__TARGET_ARCH_THUMB == 4))  
   #ifndef SHARKSSL_AES_DISABLE_SBOX
   #define SHARKSSL_AES_DISABLE_SBOX 1
   #endif
   #endif

#elif (__ICCRX__)  
static volatile inline U32 blocktemplate(U32 videoprobe) { asm ("\122\105\126\114\040\045\060\054\040\045\060" : "\053\162"(videoprobe)); return videoprobe; }
#define blockarray  blocktemplate

#elif (__GNUC__)  
#if !defined(_OSX_) && GCC_VERSION >= 402
#ifdef __bswap_32
#define blockarray  (U32)__bswap_32
#else
#include <byteswap.h>
#define blockarray  (U32)__builtin_bswap32
#endif
#endif
#endif


#ifndef __sharkssl_packed
#define __sharkssl_packed
#endif


#ifndef blockarray
#define blockarray(x) (((x) >> 24) | (((x) << 8) & 0x00FF0000) | (((x) >> 8) & 0x0000FF00) | ((x) << 24))
#endif


#if   (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define cleanupcount(w,a,i)  (w) = ((__sharkssl_packed U32*)(a))[(i) >> 2]
#elif (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define cleanupcount(w,a,i)  (w) = blockarray(((__sharkssl_packed U32*)(a))[(i) >> 2])
#else
#define cleanupcount(w,a,i)                 \
{                                         \
   (w) = ((U32)(a)[(i)])                  \
       | ((U32)(a)[(i) + 1] <<  8)        \
       | ((U32)(a)[(i) + 2] << 16)        \
       | ((U32)(a)[(i) + 3] << 24);       \
}
#endif


#if   (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define hsotgpdata(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = (w)
#elif (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define hsotgpdata(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = blockarray(w)
#else
#define hsotgpdata(w,a,i)                 \
{                                         \
   (a)[(i)]     = (U8)((w));              \
   (a)[(i) + 1] = (U8)((w) >>  8);        \
   (a)[(i) + 2] = (U8)((w) >> 16);        \
   (a)[(i) + 3] = (U8)((w) >> 24);        \
}
#endif


#if (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define read64uint32(w,a,i)  (w) = ((__sharkssl_packed U32*)(a))[(i) >> 2]
#elif (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define read64uint32(w,a,i)  (w) = blockarray(((__sharkssl_packed U32*)(a))[(i) >> 2])
#else
#define read64uint32(w,a,i)                 \
{                                         \
   (w) = ((U32)(a)[(i)] << 24)            \
       | ((U32)(a)[(i) + 1] << 16)        \
       | ((U32)(a)[(i) + 2] <<  8)        \
       | ((U32)(a)[(i) + 3]);             \
}
#endif


#if (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define inputlevel(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = (w)
#elif (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define inputlevel(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = blockarray(w)
#else
#define inputlevel(w,a,i)                 \
{                                         \
   (a)[(i)]     = (U8)((w) >> 24);        \
   (a)[(i) + 1] = (U8)((w) >> 16);        \
   (a)[(i) + 2] = (U8)((w) >>  8);        \
   (a)[(i) + 3] = (U8)((w));              \
}
#endif


#if (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define detectboard(w,a,i)  (w) = ((__sharkssl_packed U64*)(a))[(i) >> 3]
#elif (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define detectboard(w,a,i)  (w) = ((U64)(blockarray(((__sharkssl_packed U32*)(a))[(i) >> 2])) << 32) + \
                                 (blockarray(((__sharkssl_packed U32*)(a))[((i) >> 2) + 1]))
#else
#define detectboard(w,a,i)                 \
{                                         \
   (w) = ((U64)(a)[(i)]     << 56)        \
       | ((U64)(a)[(i) + 1] << 48)        \
       | ((U64)(a)[(i) + 2] << 40)        \
       | ((U64)(a)[(i) + 3] << 32)        \
       | ((U64)(a)[(i) + 4] << 24)        \
       | ((U64)(a)[(i) + 5] << 16)        \
       | ((U64)(a)[(i) + 6] <<  8)        \
       | ((U64)(a)[(i) + 7]);             \
}
#endif


#if (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define hwmoddisable(w,a,i)  ((__sharkssl_packed U64*)(a))[(i) >> 3] = (w)
#elif (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define hwmoddisable(w,a,i)  ((__sharkssl_packed U32*)(a))[((i) >> 2) + 1] = blockarray(*(__sharkssl_packed U32*)&(w));  \
                           ((__sharkssl_packed U32*)(a))[(i) >> 2] = blockarray(*(__sharkssl_packed U32*)((__sharkssl_packed U32*)&(w) + 1))
#else
#define hwmoddisable(w,a,i)                 \
{                                         \
   (a)[(i)]     = (U8)((w) >> 56);        \
   (a)[(i) + 1] = (U8)((w) >> 48);        \
   (a)[(i) + 2] = (U8)((w) >> 40);        \
   (a)[(i) + 3] = (U8)((w) >> 32);        \
   (a)[(i) + 4] = (U8)((w) >> 24);        \
   (a)[(i) + 5] = (U8)((w) >> 16);        \
   (a)[(i) + 6] = (U8)((w) >>  8);        \
   (a)[(i) + 7] = (U8)((w));              \
}
#endif



#if defined(__LP64__) && !defined(SHARKSSL_64BIT)
#define SHARKSSL_64BIT
#endif
#ifdef SHARKSSL_64BIT
#define UPTR U64
#define SHARKSSL_ALIGNMENT 4
#endif
#ifndef UPTR
#define UPTR                                       U32
#endif



#ifndef SHARKSSL_ALIGNMENT
#define SHARKSSL_ALIGNMENT                         4   
#endif
#define claimresource(s)                     (((s) + (SHARKSSL_ALIGNMENT - 1)) & ((U32)-SHARKSSL_ALIGNMENT))
#define regulatorconsumer(p)                (U8*)(((UPTR)((UPTR)(p) + SHARKSSL_ALIGNMENT - 1)) & ((UPTR)-SHARKSSL_ALIGNMENT))
#define pcmciaplatform(p)             (0 == ((unsigned int)(UPTR)(p) & (SHARKSSL_ALIGNMENT - 1)))
#if   (SHARKSSL_BIGINT_WORDSIZE > 32)
#error SHARKSSL_BIGINT_WORDSIZE must be 32, 16 or 8
#elif (SHARKSSL_BIGINT_WORDSIZE == 64)
#define computereturn             7  
#else
#define computereturn             ((U32)(SHARKSSL_BIGINT_WORDSIZE / 10))  
#endif

#if SHARKSSL_UNALIGNED_MALLOC
#define pcmciapdata(s)                   ((s) + SHARKSSL_ALIGNMENT)
#define selectaudio(p)                 regulatorconsumer(p)
#else
#define pcmciapdata(s)                   (s)
#define selectaudio(p)                 (U8*)(p)
#endif


#if   (SHARKSSL_BIGINT_WORDSIZE >= 32)
#define HEX4_TO_WORDSIZE(a,b,c,d) 0x##a##b##c##d
#define HEX2_TO_WORDSIZE(a,b)     0x##a##b
#elif (SHARKSSL_BIGINT_WORDSIZE == 16)
#define HEX4_TO_WORDSIZE(a,b,c,d) 0x##a##b, 0x##c##d
#define HEX2_TO_WORDSIZE(a,b)     0x##a##b
#elif (SHARKSSL_BIGINT_WORDSIZE == 8)
#define HEX4_TO_WORDSIZE(a,b,c,d) 0x##a, 0x##b, 0x##c, 0x##d
#define HEX2_TO_WORDSIZE(a,b)     0x##a, 0x##b
#endif

#if ((SHARKSSL_BIGINT_WORDSIZE == 8) || defined(B_BIG_ENDIAN))
#define memmove_endianess memmove

#else

void memmove_endianess(U8 *d, const U8 *s, U16 len);
#endif

#endif 

#ifndef hwmodlookup
#define hwmodlookup

#include "SharkSSL.h"
#include "SharkSslCrypto.h"



#define hsmmcplatform                           0x40  
#define sleepstore                          0x80  
#define cpucfgexits                           0x04  
#define signalpreserve                          0x04  
#define switcheractive                         0x08  
#define iommupdata                             0x10  
#define fixupdevices                           0x20  




typedef struct SharkSslCertEnum
{
   SharkSslCert cert;
   U16 certLen;
   U8  priv_notFirstCertFlag;
   U8  priv_chainLen;        
} SharkSslCertEnum;

#define registerautodeps(o, c) do {           \
   (o)->cert = c;                                         \
   (o)->certLen = SharkSslCert_len(c);                    \
   (o)->priv_notFirstCertFlag = (o)->priv_chainLen = 0;   \
} while (0)

#define updatesctlr(o) ((o)->cert)

#define SharkSslCertEnum_getCertLength(o) ((o)->certLen)

SharkSslCert removerecursive(SharkSslCertEnum *o);

 

#define mousethresh(e)              (U16)((e) & 0x00FF)
#define mcbspregister(e)              (U16)(((U16)(e) & 0x0F00) >> 8)
#define monadiccheck(e)            (U16)(((U16)(e) & 0xF000) >> 12)

#define rewindsingle                0x0
#define ts409partitions                 0x2
#define mutantchannel               0x6
#define cacherange                 0x8


#define SHARKSSL_KEYTYPE_RSA                       rewindsingle
#define SHARKSSL_KEYTYPE_EC                        ts409partitions

#define coupledexynos(e)               (mcbspregister(e) & cacherange)
#define allocatoralloc(e)             (mcbspregister(e) & mutantchannel)
#define machinekexec(e)          (allocatoralloc(e) == rewindsingle)
#define machinereboot(e)           (allocatoralloc(e) == ts409partitions)


#define specialmapping(e)  (e |= (U16)(rewindsingle + cacherange) << 8)
#define cryptoresources(e) (e |= (U16)(rewindsingle) << 8)
#define deltaticks(e)   (e |= (U16)(ts409partitions + cacherange) << 8)
#define hsspidevice(e)  (e |= (U16)(ts409partitions) << 8)
#define gpiolibbanka(e, l)           (e = (e & 0xFF00) | (l & 0xFF))



#define attachdevice(m)           (U16)((m) & 0x00FF)
#define supportedvector(m)          (m)
#define wakeupenable(m)              (U16)(((U16)(m) & 0xFF00) >> 8)
#define camerareset(m)             0

#define loaderbinfmt(m, e)           (machinereboot(e) ? attachdevice(m) : supportedvector(m))
#define targetoracle(m, e)              (machinereboot(e) ? wakeupenable(m) : camerareset(m))


#define nomsrnoirq(m, o)              (m = (((U16)o & 0xFF) << 8) | (m & 0xFF))
#define dcdc1consumers(m, l)              (m = (m & 0xFF00) | (l & 0xFF))



#if (SHARKSSL_ENABLE_CA_LIST  || SHARKSSL_ENABLE_CERTSTORE_API)
#define SHARKSSL_CA_LIST_NAME_SIZE                 8
#define SHARKSSL_CA_LIST_ELEMENT_SIZE              (SHARKSSL_CA_LIST_NAME_SIZE + 4)
#define SHARKSSL_CA_LIST_INDEX_TYPE                0x00

#if (SHARKSSL_ENABLE_CA_LIST && SHARKSSL_ENABLE_CERTSTORE_API)
#define SHARKSSL_CA_LIST_PTR_SIZE                  sizeof(U8*)
#define SHARKSSL_CA_LIST_PTR_TYPE                  0xAD
#define SHARKSSL_MAX_SNAME_LEN                     32

#if (SHARKSSL_MAX_SNAME_LEN < SHARKSSL_CA_LIST_NAME_SIZE)
#error SHARKS_MAX_SNAME_LEN must be >= SHARKSSL_CA_LIST_NAME_SIZE
#endif

typedef struct SharkSslCSCert
{
      DoubleLink super;
      U8 *ptr;  /* points to the byte sequence ASN.1 format of the cert */
      char name[SHARKSSL_MAX_SNAME_LEN + 1];  /* subject name of the CA */
} SharkSslCSCert;

#endif  
#endif  



#define entryearly            0x01
#define SHARKSSL_SIGNATUREALGORITHM_RSA_PKCS1      0x01
#define gpio1input            0x02
#define accessactive          0x03
#define SHARKSSL_SIGNATUREALGORITHM_RSA_PSS        0x08
#define SHARKSSL_OID_EC_PUBLIC_KEY                 0x0C  


#define processsdccr                0x00
#define skciphercreate                 SHARKSSL_HASHID_MD5
#define presentpages                SHARKSSL_HASHID_SHA1
#define registershashes              0x03
#define domainnumber              SHARKSSL_HASHID_SHA256
#define probewrite              SHARKSSL_HASHID_SHA384
#define batterythread              SHARKSSL_HASHID_SHA512
#define defaultspectre        0xEE  


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
typedef struct SharkSslCertKey
{
   U8 *mod, *exp;
   U16 modLen, expLen;
} SharkSslCertKey;


#if   SHARKSSL_USE_SHA_512
#define SHARKSSL_MAX_HASH_LEN  SHARKSSL_SHA512_HASH_LEN
#elif SHARKSSL_USE_SHA_384
#define SHARKSSL_MAX_HASH_LEN  SHARKSSL_SHA384_HASH_LEN
#else
#define SHARKSSL_MAX_HASH_LEN  SHARKSSL_SHA256_HASH_LEN
#endif

typedef struct SharkSslSignature  
{
   #if (SHARKSSL_MAX_HASH_LEN > (SHARKSSL_MD5_HASH_LEN + SHARKSSL_SHA1_HASH_LEN))
   U8 hash[SHARKSSL_MAX_HASH_LEN];
   #else
   U8 hash[SHARKSSL_MD5_HASH_LEN + SHARKSSL_SHA1_HASH_LEN];
   #endif
   U8 *signature;
   U16 signLen;
   U8  signatureAlgo;
   U8  hashAlgo;
} SharkSslSignature;


typedef struct SharkSslCertParam
{
   SharkSslCertInfo  certInfo;
   SharkSslCertKey   certKey;
   SharkSslSignature signature;
} SharkSslCertParam;


typedef struct SharkSslSignParam  
{
   SharkSslCertKey  *pCertKey;
   SharkSslSignature signature;
} SharkSslSignParam;


typedef struct SharkSslClonedCertInfo
{
   SharkSslCertInfo ci;
   #if SHARKSSL_ENABLE_SESSION_CACHE
   U16 refcnt;  /* counter of valid references */
   #endif
} SharkSslClonedCertInfo;
#endif  


#if SHARKSSL_ENABLE_DHE_RSA
typedef struct SharkSslDHParam
{
   U8 *p;     /* prime modulus     */
   U8 *g;     /* generator         */
   U8 *Y;     /* Ys/Yc             */
   U8 *r;     /* random secret     */
   U16 pLen;  /* len of p in bytes */
   U16 gLen;  /* len of g in bytes */
} SharkSslDHParam;
#endif


#if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
typedef struct SharkSslECDHParam
{
   U8 *XY;         /* X[,Y] coordinate[s] */
   U8 *k;          /* random secret       */
   U16 xLen;       /* len of X, Y, k      */
   U16 curveType;  /* curve ID            */
} SharkSslECDHParam;
#endif


#if SHARKSSL_ENABLE_ECDSA
typedef struct SharkSslECDSAParam
{
   U8 *R;          /* R coordinate   */
   U8 *S;          /* S coordinate   */
   U8 *key;        /* key (pub/pri)  */
   U8 *hash;       /* message hash   */
   U16 keyLen;     /* len of key,R,S */
   U16 hashLen;    /* len of hash    */
   U16 curveType;  /* curve ID       */
} SharkSslECDSAParam;
#endif


#if SHARKSSL_ENABLE_RSA
SHARKSSL_API int async3clksrc(const SharkSslCertKey *ck, U8 op, U8 *stackchecker);
int omap3430common(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe);
int writemessage(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe);
int clockaccess(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe);
int handleguest(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe);
#endif
#if SHARKSSL_ENABLE_DHE_RSA
int  SharkSslDHParam_DH(const SharkSslDHParam*, U8 op, U8*);
#if SHARKSSL_SSL_SERVER_CODE
void SharkSslDHParam_setParam(SharkSslDHParam *dh);
#endif
#endif  
#if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
int  SharkSslECDHParam_ECDH(const SharkSslECDHParam*, U8 op, U8*);
#endif
#if SHARKSSL_ENABLE_ECDSA
int SharkSslECDSAParam_ECDSA(const SharkSslECDSAParam*, U8 op);
U16 relocationchain(SharkSslCertKey *disableclock);
#endif

#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)

int  checkactions(SharkSslSignParam*);
int  systemcapabilities(const SharkSslSignParam*);

SHARKSSL_API int  spromregister(SharkSslCertParam*, const U8*, U32, U8*);
U8   SharkSslCertDN_equal(const SharkSslCertDN*, const SharkSslCertDN*);
SHARKSSL_API U16 interrupthandler(SharkSslCertKey*, SharkSslCert);
U16  SharkSslCert_vectSize_keyType(const SharkSslCert, U8*);
#if SHARKSSL_ENABLE_CLIENT_AUTH
U8   domainassociate(SharkSslCert, U8*, U16);
#endif
U8   fixupresources(SharkSslCert, U16, U8*);
U16  setupboard(SharkSslCert);
U8   realnummemory(SharkSslCon *o, SharkSslClonedCertInfo **outCertInfoPtr);
#if SHARKSSL_USE_ECC
U8   controllerregister(U16 delayusecs);
#endif
#endif


#endif 

#ifndef _shtype_t_h
#define _shtype_t_h

#include "SharkSSL.h"


#ifndef SHARKSSL_BIGINT_WORDSIZE
#error UNDEFINED SHARKSSL_BIGINT_WORDSIZE 
#endif

#ifndef SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K
#error UNDEFINED SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K
#endif

#ifndef SHARKSSL_BIGINT_MULT_LOOP_UNROLL
#error UNDEFINED SHARKSSL_BIGINT_MULT_LOOP_UNROLL
#endif

#define SHARKSSL_ECC_USE_NIST       (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1 || SHARKSSL_ECC_USE_SECP521R1)
#define SHARKSSL_ECC_USE_BRAINPOOL  (SHARKSSL_ECC_USE_BRAINPOOLP256R1 || SHARKSSL_ECC_USE_BRAINPOOLP384R1 || SHARKSSL_ECC_USE_BRAINPOOLP512R1)
#define SHARKSSL_ECC_USE_EDWARDS    (SHARKSSL_ECC_USE_CURVE25519 || SHARKSSL_ECC_USE_CURVE448)



#if   (SHARKSSL_BIGINT_WORDSIZE == 8)
typedef U8  shtype_tWord;
typedef S8  shtype_tWordS;
typedef U16 shtype_tDoubleWord;
typedef S16 shtype_tDoubleWordS;
#elif (SHARKSSL_BIGINT_WORDSIZE == 16)
typedef U16 shtype_tWord;
typedef S16 shtype_tWordS;
typedef U32 shtype_tDoubleWord;
typedef S32 shtype_tDoubleWordS;
#elif (SHARKSSL_BIGINT_WORDSIZE == 32)
typedef U32 shtype_tWord;
typedef S32 shtype_tWordS;
typedef U64 shtype_tDoubleWord;
typedef S64 shtype_tDoubleWordS;
#else
#error SHARKSSL_BIGINT_WORDSIZE should be 8, 16 or 32
#endif



#if _MSC_VER == 1200  
#define anatopdisconnect(a) (a >>= SHARKSSL_BIGINT_WORDSIZE);  
#elif (((shtype_tDoubleWordS)-1LL >> SHARKSSL_BIGINT_WORDSIZE) & (1LL << SHARKSSL_BIGINT_WORDSIZE))  
#define anatopdisconnect(a) (a >>= SHARKSSL_BIGINT_WORDSIZE);  
#else
#define anatopdisconnect(a) do {                                                                            \
   if (a < 0)                                                                                            \
   {                                                                                                     \
      a = ((shtype_tDoubleWord)-1LL ^ (shtype_tWord)-1L) | (a >> SHARKSSL_BIGINT_WORDSIZE);  \
   }                                                                                                     \
   else                                                                                                  \
   {                                                                                                     \
      a >>= SHARKSSL_BIGINT_WORDSIZE;                                                                    \
   }                                                                                                     \
} while (0)
#endif



typedef struct shtype_t
{
   shtype_tWord *mem, *beg;
   U16  len;
} shtype_t;


#define SHARKSSL__M (SHARKSSL_BIGINT_WORDSIZE / 8)


#ifdef __cplusplus
extern "\103" {
#endif


#if (SHARKSSL_ENABLE_RSA || (SHARKSSL_USE_ECC && (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)))
shtype_tWord remapcfgspace(const shtype_t *mod);

#if SHARKSSL_OPTIMIZED_BIGINT_ASM
extern
#endif
void writebytes(const shtype_t *o1, const shtype_t *o2,
                           shtype_t *deltadevices,   const shtype_t *mod,
                           shtype_tWord mu);
#endif

#define onenandpartitions(o,enablekernel,d) \
        traceaddress(o, (U16)((enablekernel)/SHARKSSL_BIGINT_WORDSIZE),(void*)(d))

#define consoledevice(o)     ((o)->beg)

#define publishdevices(o) ((o)->len)

#define pulsewidth(o)      (publishdevices(o) * SHARKSSL__M)

#define cachestride(o)           (!((o)->beg[(o)->len - 1] & 0x1))
        
void    deviceparse(const shtype_t *o);

void    blastscache(shtype_t *o);

void    traceaddress(shtype_t *o, U16 writepmresrn, void *alloccontroller);

void    unassignedvector(const shtype_t *src, shtype_t *pciercxcfg448);

shtype_tWord resolverelocs(shtype_t *o1, const shtype_t *o2);

shtype_tWord updatepmull(shtype_t *o1, const shtype_t *o2);

void    setupsdhci1(shtype_t *o1, const shtype_t *o2,
                              const shtype_t *mod);

void    keypaddevice(shtype_t *o1, const shtype_t *o2,
                              const shtype_t *mod);

U8      timerwrite(const shtype_t *o1, const shtype_t *o2);

void    hotplugpgtable(const shtype_t *o1, const shtype_t *o2, 
                            shtype_t *deltadevices);

void    envdatamcheck(shtype_t *injectexception, const shtype_t *mod, 
                               shtype_tWord *afterhandler);

int     suspendfinish(shtype_t *injectexception, const shtype_t *mod);

int     chunkmutex(const shtype_t *validconfig, shtype_t *exp,
                              const shtype_t *mod,  shtype_t *res,
                              U8 countersvalid);

void    ioswabwdefault(shtype_t *u, const shtype_t *mod,
                                  shtype_tWord *afterhandler);

void    backlightpdata(shtype_t *o);

#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
int     iommumapping(shtype_t *o, const shtype_t *mod);
#endif

#if SHARKSSL_ENABLE_ECDSA
U8      eventtimeout(shtype_t *o);
#endif

#if SHARKSSL_ECC_USE_EDWARDS
void    shtype_t_copyfull(const shtype_t *src, shtype_t *pciercxcfg448);
void    shtype_t_swapConditional(shtype_t *o1, shtype_t *o2, U32 swapFlag);
#endif

#if (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSAKEY_CREATE)
int     aemifdevice(shtype_t *o);
int     translateaddress(const shtype_t *o1, const shtype_t *o2,
                           shtype_t *deltadevices);
#endif

#ifdef __cplusplus
}
#endif


#endif 

#ifndef _SharkSslECC_h
#define _SharkSslECC_h


#include <SharkSslASN1.h>


#if SHARKSSL_USE_ECC
typedef struct  
{
   shtype_t x, y;
} SharkSslECPoint;


typedef struct SharkSslECCurve          
{
   #if SHARKSSL_ECC_USE_EDWARDS  /* virtual functions */
   int (*setPoint)(struct SharkSslECCurve*, SharkSslECPoint*);  
   int (*multiply)(struct SharkSslECCurve *, shtype_t *, SharkSslECPoint *);
   #endif
   shtype_t  prime;                /* prime */
   shtype_t  order;                /* order */
   SharkSslECPoint G;               /* base point */
   #if (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)
   shtype_t  a;              /* parameter a */
   #endif
   #if SHARKSSL_ECC_VERIFY_POINT
   shtype_t  b;              /* parameter b */
   #endif
   U16 bits;     /* the size of the prime in bits */
} SharkSslECCurve;

#define SharkSslECCurve_bits_Montgomery_flag  0x8000


#define SHARKSSL_SECP256R1_POINTLEN        32
#define SHARKSSL_SECP384R1_POINTLEN        48
#define SHARKSSL_SECP521R1_POINTLEN        66
#define SHARKSSL_BRAINPOOLP256R1_POINTLEN  32
#define SHARKSSL_BRAINPOOLP384R1_POINTLEN  48
#define SHARKSSL_BRAINPOOLP512R1_POINTLEN  64
#define SHARKSSL_CURVE25519_POINTLEN       32
#define SHARKSSL_CURVE448_POINTLEN         56

#ifdef __cplusplus
extern "\103" {
#endif


void    clearerrors(SharkSslECCurve *o, U16 rightsvalid);

int     SharkSslECCurve_setPoint_NB(SharkSslECCurve *o, SharkSslECPoint *p);
#if SHARKSSL_ECC_USE_EDWARDS
int     SharkSslECCurve_setPoint_ED(SharkSslECCurve *o, SharkSslECPoint *p);
#define initialdomain(o, p) (o)->setPoint(o, p)  
#else
#define initialdomain(o, p) SharkSslECCurve_setPoint_NB(o, p)
#endif

#if (!SHARKSSL_ECDSA_ONLY_VERIFY)
int     SharkSslECCurve_multiply_NB(SharkSslECCurve *o, shtype_t *k, 
                                   SharkSslECPoint *deltadevices);
#if SHARKSSL_ECC_USE_EDWARDS
int     SharkSslECCurve_multiply_ED(SharkSslECCurve *o, shtype_t *k, 
                                   SharkSslECPoint *deltadevices);
#define unregisterskciphers(o,k,r) (o)->multiply(o, k, r)  
#else
#define unregisterskciphers(o,k,r) SharkSslECCurve_multiply_NB(o,k,r)
#endif
#endif

#if SHARKSSL_ENABLE_ECDSA
int     directalloc(SharkSslECCurve *S, shtype_t *d, 
                                  SharkSslECCurve *T, shtype_t *e, 
                                  SharkSslECPoint *deltadevices);
#endif

#define receivebroadcast(o,w,a,b) \
        traceaddress(&((o)->x),(w),(a)); traceaddress(&((o)->y),(w),(b))

#define updatefrequency(o,t,a,b) \
        onenandpartitions(&((o)->x),(t),(a)); onenandpartitions(&((o)->y),(t),(b))

#define mipidplatform(s,d) \
        unassignedvector(&((s)->x), &((d)->x)); unassignedvector(&((s)->y), &((d)->y))

#ifdef __cplusplus
}
#endif

#endif  
#endif 


#ifndef _SharkSslCon_h
#define _SharkSslCon_h

#define SHARKSSL_LIB 1
#include "SharkSSL.h"


#if (SHARKSSL_TLS_1_3 && SHARKSSL_USE_ECC)  

#endif


#if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_SSL_CLIENT_CODE)

#define            SharkSsl_isServer(o) (o->role == SharkSsl_Server)
#define            SharkSsl_isClient(o) (o->role == SharkSsl_Client)

#elif SHARKSSL_SSL_SERVER_CODE

#define            SharkSsl_isServer(o) (1)
#define            SharkSsl_isClient(o) (0)

#elif SHARKSSL_SSL_CLIENT_CODE

#define            SharkSsl_isServer(o) (0)
#define            SharkSsl_isClient(o) (1)

#elif ((!SHARKSSL_ENABLE_RSA_API) && (!SHARKSSL_ENABLE_ECDSA_API) && (!SHARKSSL_ENABLE_PEM_API))

#error NEITHER SERVER NOR CLIENT CODE SELECTED
#endif

#define rangealigned   20
#define firstentry                21
#define controllegacy            22
#define polledbutton     23

#define switchessetup        0
#define pciercxcfg070         1
#define trampolinehandler         2
#define SHARKSSL_HANDSHAKETYPE_NEW_SESSION_TICKET   4
#define SHARKSSL_HANDSHAKETYPE_ENCRYPTED_EXTENSIONS 8
#define parsebootinfo          11
#define startflags  12
#define logicmembank  13
#define configcwfon    14
#define modifygraph   15
#define subtableheaders  16
#define switcherdevice             20
#define loongson3notifier             0xFF

#define ahashchild                0x01
#define systemtable                0x02
#define compatrestart              0x40

#define deviceunregister          0x00FF

#define cminstclear                0


#define firstversion                  0
#define protectionfault          1
#define switchertrace       2
#define pca953xpdata              3
#define mailboxentries               4
#define registerwatchdog               5
#define deviceprobe                6
#define recoverygpiod                 7
#define bootloaderentry                 8
#define callchainkernel                    9
#define registerpwrdms              10
#define pwrdmenable             10
#define edma0resources             11
#define logicpdtorpedo                          12
#define entrypaddr          13
#define restoremasks         13
#define moduleflags                     14
#define cpucfgsynthesize                    15
#define clkdmclear  16
#define queuelogical            17
#define pciercxcfg075 18
#define aa64isar1override               35
#define allocconsistent               41
#define doublefcvts           43
#define rm200hwint       45
#define shutdownnonboot      47
#define consumersupplies          49
#define reboothandler                    51
#define featurespresent           0xFF01


#define spannedpages                   23
#define ucb1400pdata                   23
#define restoretrace                   24
#define pciercxcfg034                   24
#define buildmemmap                   25
#define audiopdata                   25

#define samplingevent             26
#define gpio3config             26
#define entrytrampoline             27
#define negativeoffset             27
#define resumeprepare             28
#define sa1111disable             28

#define TLS_NAMEDCURVE_CURVE25519                  29
#define TLS_NAMEDGROUP_CURVE25519                  29
#define TLS_NAMEDCURVE_CURVE448                    30
#define TLS_NAMEDGROUP_CURVE448                    30


#define probesystem             0
#define crashsetup      1
#define checkheader      2



#define pchip1present             1
#define targetmemory1             2
#define mcbsp5hwmod                3



#if (!SHARKSSL_ENABLE_RSA)
#if SHARKSSL_ENABLE_DHE_RSA
#error SHARKSSL_ENABLE_RSA must be selected when SHARKSSL_ENABLE_DHE_RSA is enabled
#endif
#if SHARKSSL_ENABLE_ECDHE_RSA
#error SHARKSSL_ENABLE_RSA must be selected when SHARKSSL_ENABLE_ECDHE_RSA is enabled
#endif
#endif


#if SHARKSSL_USE_ECC
#if ((!SHARKSSL_ECC_USE_SECP256R1) && (!SHARKSSL_ECC_USE_SECP384R1) && (!SHARKSSL_ECC_USE_SECP521R1))
#error no elliptic nandflashpartition selected
#endif
#if (SHARKSSL_ECDSA_ONLY_VERIFY && (SHARKSSL_SSL_CLIENT_CODE || SHARKSSL_SSL_SERVER_CODE))
#error SHARKSSL_ECDSA_ONLY_VERIFY must be 0 when SSL/TLS is enabled
#endif
#else
#if SHARKSSL_ENABLE_ECDHE_RSA
#error SHARKSSL_USE_ECC must be selected when SHARKSSL_ENABLE_ECDHE_RSA is enabled
#endif
#if SHARKSSL_ENABLE_ECDHE_ECDSA
#error SHARKSSL_USE_ECC must be selected when SHARKSSL_ENABLE_ECDHE_ECDSA is enabled
#endif

#if (!SHARKSSL_ENABLE_RSA)
#if SHARKSSL_ENABLE_ECDHE_RSA
#error SHARKSSL_ENABLE_RSA must be selected when SHARKSSL_ENABLE_ECDHE_RSA is enabled
#endif
#endif  

#if SHARKSSL_ENABLE_ECDSA
#error SHARKSSL_USE_ECC must be selected when SHARKSSL_ENABLE_ECDSA is enabled
#else
#if SHARKSSL_ENABLE_ECDHE_ECDSA
#error SHARKSSL_ENABLE_ECDSA must be selected when SHARKSSL_ENABLE_ECDHE_ECDSA is enabled
#endif
#endif  
#endif  



#if SHARKSSL_ENABLE_AES_GCM

#if (SHARKSSL_USE_AES_128 && SHARKSSL_USE_SHA_256)
#if SHARKSSL_TLS_1_3
#define SHARKSSL_AES_128_GCM_SHA256  TLS_AES_128_GCM_SHA256
#endif  
#if SHARKSSL_TLS_1_2
#if SHARKSSL_ENABLE_DHE_RSA
#define branchenable   TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
#endif  
#if SHARKSSL_ENABLE_ECDHE_RSA
#define resumenonboot TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
#endif  
#if SHARKSSL_ENABLE_ECDHE_ECDSA
#define enablecharger TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
#endif  
#endif  
#endif  

#if (SHARKSSL_USE_AES_256 && SHARKSSL_USE_SHA_384)
#if SHARKSSL_TLS_1_3
#define SHARKSSL_AES_256_GCM_SHA384  TLS_AES_256_GCM_SHA384
#endif  
#if SHARKSSL_TLS_1_2
#if SHARKSSL_ENABLE_DHE_RSA
#define quirkslc90e66   TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
#endif  
#if SHARKSSL_ENABLE_ECDHE_RSA
#define mallocalign TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
#endif  
#if SHARKSSL_ENABLE_ECDHE_ECDSA
#define mitigationstate TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
#endif  
#endif  
#endif  

#endif  


#if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
#if SHARKSSL_TLS_1_3
#define SHARKSSL_CHACHA20_POLY1305_SHA256  TLS_CHACHA20_POLY1305_SHA256
#endif  
#if SHARKSSL_TLS_1_2
#if SHARKSSL_ENABLE_DHE_RSA
#define nvramgetenv         TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
#endif  
#if SHARKSSL_ENABLE_ECDHE_RSA
#define releasedpages       TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
#endif  
#if SHARKSSL_ENABLE_ECDHE_ECDSA
#define kernelrelocation     TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
#endif  
#endif  
#endif  


#define resourcebtuart                       SHARKSSL_MD5_HASH_LEN  
#define m62332senddata                      SHARKSSL_SHA1_HASH_LEN
#define loongson3cpucfg                    SHARKSSL_SHA256_HASH_LEN
#define gpiocfgdefault                    SHARKSSL_SHA384_HASH_LEN
#define iwmmxtcontext                    SHARKSSL_SHA512_HASH_LEN
#define stateoneshot                  SHARKSSL_POLY1305_HASH_LEN

#define SHARKSSL_FINISHED_MSG_LEN_TLS_1_2          12  

#define clkctrlmanaged                5    
#define traceentry             4 
#define SHARKSSL_MAX_SESSION_ID_LEN                32  
#define SHARKSSL_MAX_SESSION_TICKET_LEN            512 
#define SHARKSSL_SEQ_NUM_LEN                       8    
#define SHARKSSL_AES_GCM_EXPLICIT_IV_LEN           SHARKSSL_SEQ_NUM_LEN   
#define SHARKSSL_RANDOM_LEN                        32   
#define SHARKSSL_MASTER_SECRET_LEN                 48   
#define SHARKSSL_CERT_LENGTH_LEN                   3   

#if (SHARKSSL_AES_GCM_EXPLICIT_IV_LEN != SHARKSSL_SEQ_NUM_LEN)
#error SHARKSSL_AES_GCM_EXPLICIT_IV_LEN MUST BE = SHARKSSL_SEQ_NUM_LEN
#endif

#if   SHARKSSL_USE_SHA_512
#define SHARKSSL_MAX_DIGEST_LEN                    iwmmxtcontext
#define SHARKSSL_MAX_DIGEST_BLOCK_LEN              SHARKSSL_SHA512_BLOCK_LEN
#elif SHARKSSL_USE_SHA_384
#define SHARKSSL_MAX_DIGEST_LEN                    gpiocfgdefault
#define SHARKSSL_MAX_DIGEST_BLOCK_LEN              SHARKSSL_SHA384_BLOCK_LEN
#else
#define SHARKSSL_MAX_DIGEST_LEN                    loongson3cpucfg
#define SHARKSSL_MAX_DIGEST_BLOCK_LEN              SHARKSSL_SHA256_BLOCK_LEN
#endif  

#if SHARKSSL_TLS_1_3

#if SHARKSSL_USE_SHA_384
#define SHARKSSL_TLS_1_3_MAX_DIGEST_LENGTH         gpiocfgdefault
#else
#define SHARKSSL_TLS_1_3_MAX_DIGEST_LENGTH         loongson3cpucfg
#endif
#endif

#define SHARKSSL_MAX_DIGEST_PAD_LEN                48   
#define gpio2enable                       (16384 + 2048) 
#define prefetchwrite                   SHARKSSL_MAX_BLOCK_LEN

#define ckctlrecalc                16   
#if SHARKSSL_ENABLE_AES_GCM
#define systemcontroller                    SHARKSSL_SEQ_NUM_LEN
#else
#define systemcontroller                    0
#endif

#if   (SHARKSSL_USE_AES_256 || (SHARKSSL_USE_POLY1305 && SHARKSSL_USE_CHACHA20))
#define SHARKSSL_MAX_KEY_LEN                       32   
#elif (SHARKSSL_USE_AES_128)
#define SHARKSSL_MAX_KEY_LEN                       16   
#else
#error At least one cipher must be selected in SharkSSL_cfg.h
#endif

#if   (SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256)
#define SHARKSSL_MAX_BLOCK_LEN                     16   
#else
#define SHARKSSL_MAX_BLOCK_LEN                     0    
#endif



#define cachewback                    1024
#if (SHARKSSL_TLS_1_2 && SHARKSSL_ENABLE_AES_GCM)
#define gpio5config                 SHARKSSL_AES_GCM_EXPLICIT_IV_LEN  
#else
#define gpio5config                 0
#endif



#ifndef SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH        
#define SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH        0x10
#endif


#define SHARKSSL_HS_PARAM_OFFSET_1_3               0

#define SHARKSSL_HS_PARAM_OFFSET_1_2               claimresource(clkctrlmanaged + 1 + \
                                                                       clkctrlmanaged + \
                                                                       SHARKSSL_MAX_BLOCK_LEN + \
                                                                       SHARKSSL_FINISHED_MSG_LEN_TLS_1_2 + \
                                                                       SHARKSSL_MAX_DIGEST_LEN + \
                                                                       prefetchwrite)

#if SHARKSSL_TLS_1_2
#define SHARKSSL_HS_PARAM_OFFSET                   SHARKSSL_HS_PARAM_OFFSET_1_2
#else
#define SHARKSSL_HS_PARAM_OFFSET                   SHARKSSL_HS_PARAM_OFFSET_1_3
#endif


#define clockgettime32                0x00000001
#define audiosuspend                0x00000002
#define cachematch    0x00000004
#define shutdownlevel               0x00000008
#define SHARKSSL_FLAG_FRAGMENTED_HS_RECORD         0x00000010
#define firstcomponent                  0x00000020
#define switcherregister                  0x00000040
#define stealenabled               0x00000080
#define probedaddress          0x00000100
#define startqueue              0x00000200
#define unregistershash          0x00000400
#define nresetconsumers        0x00000800
#define accountsoftirq              0x00001000
#define serialreset            0x00002000
#define switcheractivation                   0x00004000
#define aarch32ptrace         0x00008000
#define registerbuses      0x00010000
#define skciphersetkey      0x00020000
#define platformdevice        0x00040000
#define createmappings     0x00080000
#define gpiolibmbank               0x00100000
#define devicedriver           0x00200000
#define uprobeabort                    0x00400000
#define symbolnodebug            0x00800000
#define ftracehandler               0x01000000
#define SHARKSSL_FLAG_CA_EXTENSION_REQUEST         0x02000000
#define SHARKSSL_FLAG_PARTIAL_HS_SEND              0x04000000


#define bcm1x80bcm1x55                     0x01
#define boardcompat                       0x02
#define SHARKSSL_OP_CONSTRUCTOR_FLAG               0x10
#define ptraceregsets                        0x20
#define populatebasepages                        0x40
#define chargerworker                     (bcm1x80bcm1x55 | boardcompat)
#define SHARKSSL_OP_CONSTRUCTOR                    (bcm1x80bcm1x55 | SHARKSSL_OP_CONSTRUCTOR_FLAG)



#define cleandcache                            0x0001
#define irqhandlerfixup                             0x0002
#define cpufreqcallback                            0x0004
#define percpudevid                            0x0008
#define SHARKSSL_CS_SHA256                         0x0010  
#define framekernel                           0x0020  
#define suspendenter                        0x0040  
#define SHARKSSL_CS_TLS13                          0x0080   
#define overcommitmemory                          0x0100
#define ioasicclocksource                         0x0200
#define keypadrelease                         0x0400
#define da9034backlight                        0x0800
#define recoverrange                           0x1000


typedef struct SharkSslBuf
{
   #if SHARKSSL_UNALIGNED_MALLOC
   U8  *mem;     /* where the allocated memory begins in this case */
   #endif
   U8  *buf;     /* where the allocated memory begins */
   U8  *data;    /* where the data begins */
   U16  size;    /* number of bytes in the buffer available to the user */
   U16  dataLen; /* length of the data to be processed */
   U16  temp;
} SharkSslBuf;

void    atomiccmpxchg(SharkSslBuf*, U16);
void    guestconfig5(SharkSslBuf*);
#if (!SHARKSSL_DISABLE_INBUF_EXPANSION)
U8     *othersegments(SharkSslBuf*, U16);
#endif
void    binaryheader(SharkSslBuf*);
#define microresources(o) (!((o)->buf))
#define func3fixup(o) \
   ((o)->buf + gpio5config)
#define serial2platform(o) \
   ((o)->data == func3fixup(o))
#define registerfixed(o) do {\
   (o)->data = func3fixup(o); \
   } while (0)
#if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
#define reportsyscall(pciercxcfg448, src) \
   memcpy((U8*)((pciercxcfg448)->buf), (U8*)((src)->buf), gpio5config)
#endif



typedef int (*SharkSslCon_cipherFunc)(SharkSslCon*, U8, U8*, U16);

typedef struct SharkSslCipherSuite
{
   SharkSslCon_cipherFunc cipherFunc;
   U16 id;
   U16 flags;
   U8  keyLen;
   U8  digestLen;
   U8  hashID;
} SharkSslCipherSuite;

#if SHARKSSL_TLS_1_2
U16 disableclean(SharkSslCipherSuite*);
#endif


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
typedef struct SharkSslCertParsed
{
   SharkSslCert cert;
   U16 msgLen;   /* certificate message length */
   U8  keyType;
   U8  keyOID;
   U8  signatureAlgo;
   U8  hashAlgo;
   #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
   const U8 *commonName;
   U8 *subjectAltNamesPtr;
   U16 subjectAltNamesLen; 
   U8  commonNameLen;      /** length in bytes of the field "commonName" */
   #endif
} SharkSslCertParsed;


typedef struct SharkSslCertList
{
   SingleLink link;
   SharkSslCertParsed certP;
} SharkSslCertList;
#endif  


typedef struct SharkSslHSParam
{
   union
   {
      #if SHARKSSL_TLS_1_2
      struct
      {
         U8 clientRandom[SHARKSSL_RANDOM_LEN];
         U8 serverRandom[SHARKSSL_RANDOM_LEN];
         U8 masterSecret[SHARKSSL_MASTER_SECRET_LEN];
         U8 sharedSecret[2 * (SHARKSSL_MAX_DIGEST_LEN +
            SHARKSSL_MAX_KEY_LEN +
            SHARKSSL_MAX_BLOCK_LEN) + SHARKSSL_MAX_DIGEST_LEN];
         #if SHARKSSL_USE_SHA_512
         SharkSslSha512Ctx sha512Ctx;
         #endif
         #if SHARKSSL_ENABLE_DHE_RSA
         SharkSslDHParam dhParam;
         #endif
      } tls12;
      #endif
      #if SHARKSSL_TLS_1_3
      struct
      {
         U8 HSSecret[SHARKSSL_TLS_1_3_MAX_DIGEST_LENGTH];
         U8 srvHSTraffic[SHARKSSL_TLS_1_3_MAX_DIGEST_LENGTH];
         U8 cliHSTraffic[SHARKSSL_TLS_1_3_MAX_DIGEST_LENGTH];
         #if SHARKSSL_USE_ECC
         #if SHARKSSL_ECC_USE_CURVE448
         U8 privKeyCURVE448[SHARKSSL_CURVE448_POINTLEN];
         #endif
         #if SHARKSSL_ECC_USE_CURVE25519
         U8 privKeyCURVE25519[SHARKSSL_CURVE25519_POINTLEN];
         #endif
         #if SHARKSSL_ECC_USE_SECP384R1
         U8 privKeySECP384R1[SHARKSSL_SECP384R1_POINTLEN];
         #endif
         #if SHARKSSL_ECC_USE_SECP256R1
         U8 privKeySECP256R1[SHARKSSL_SECP256R1_POINTLEN];
         #endif
         #endif  /* SHARKSSL_USE_ECC */
         #if SHARKSSL_ENABLE_CLIENT_AUTH
         U16 signatureScheme;
         #endif
      } tls13;
      #endif
   } prot;
   #if SHARKSSL_RANDOMIZE_EXTENSIONS
   #define SHARKSSL_MAX_EXTENSIONS 8  /* multiple of 4 to keep alignment */
   #if (SHARKSSL_BIGINT_WORDSIZE < 32)
   U16 extState;
   #else
   U32 extState; 
   #endif
   U8  extIndex[SHARKSSL_MAX_EXTENSIONS];
   #endif
   SharkSslSha256Ctx sha256Ctx;
   #if SHARKSSL_USE_SHA_384
   SharkSslSha384Ctx sha384Ctx;
   #endif
   #if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
   SharkSslCertParsed *certParsed;  /* the selected cert */
   SharkSslCertKey     certKey;     /* points to cert's key */
   SharkSslCertParam   certParam;   /* peer's cert */
   SharkSslSignParam   signParam;
   #endif
   #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
   SharkSslECDHParam   ecdhParam;
   #endif
   SharkSslCipherSuite *cipherSuite;
} SharkSslHSParam;


void    breakpointhandler(SharkSslHSParam*);
void    alignmentldmstm(SharkSslHSParam*);
void    ioremapresource(SharkSslHSParam*, U8*, U16);
int     wakeupvector(SharkSslHSParam*, U8*, U8);
#define hsParam(o) ((SharkSslHSParam*)(func3fixup(&o->outBuf) + SHARKSSL_HS_PARAM_OFFSET))


#if SHARKSSL_ENABLE_SESSION_CACHE
struct SharkSslSession
{
   SharkSslCipherSuite *cipherSuite;
   U32 firstAccess;
   U16 nUse;
   U8  major_minor, flags;
   SharkSslClonedCertInfo *clonedCertInfo;
   union
   {
      struct 
      {
         U32 latestAccess;
         U8  id[SHARKSSL_MAX_SESSION_ID_LEN];
         U8  masterSecret[SHARKSSL_MASTER_SECRET_LEN];
      } tls12;
      struct
      {
         U32 expiration, ticketAgeAdd;
         U8  PSK[SHARKSSL_MAX_DIGEST_LEN];
         U8 *ticket;
         U16 ticketLen, link;
      } tls13;
   } prot;
};

void SharkSslSession_copyClonedCertInfo(SharkSslSession*, SharkSslCon*);
#define SharkSslSession_isProtocol(o,prot)   ((o)->major_minor == (prot))
#define restarthandler(o,maj,min) ((o)->major_minor == (((maj & 0x0F) << 4) | (min & 0x0F)))
#define batterylevels(o)            (SHARKSSL_PROTOCOL_MAJOR((o)->major_minor))
#define hardirqsenabled(o)            (SHARKSSL_PROTOCOL_MINOR((o)->major_minor))
#define sha224final(o,maj,min) do {           \
   baAssert((maj <= 0x0F) && (min <= 0x0F));                \
   (o)->major_minor = (((maj & 0x0F) << 4) | (min & 0x0F)); \
   } while (0);



#define ecoffaouthdr             0x80


void    counter1clocksource(SharkSslSessionCache*, U16);
void    defaultsdhci0(SharkSslSessionCache*);
#define filtermatch(o)   ThreadMutex_set(&((o)->cacheMutex))
#define helperglobal(o) ThreadMutex_release(&((o)->cacheMutex))
SharkSslSession *sa1111device(SharkSslSessionCache*, SharkSslCon*, U8*, U16);
SharkSslSession *latchgpiochip(SharkSslSessionCache*, SharkSslCon*, U8*, U16);
#endif


struct SharkSslCon   
{
   #if SHARKSSL_MAX_BLOCK_LEN
   #if ((SHARKSSL_MAX_BLOCK_LEN < 16) && (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305))
   U8 rIV[16];
   #else
   U8 rIV[SHARKSSL_MAX_BLOCK_LEN];
   #endif
   #elif (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
   U8 rIV[16];
   #endif
   #if SHARKSSL_MAX_KEY_LEN
   U8 rKey[SHARKSSL_MAX_KEY_LEN];
   #endif

   #if SHARKSSL_MAX_BLOCK_LEN
   #if ((SHARKSSL_MAX_BLOCK_LEN < 16) && ((SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305) || SHARKSSL_ENABLE_AES_GCM))
   U8 wIV[16];
   #else
   U8 wIV[SHARKSSL_MAX_BLOCK_LEN];
   #endif
   #elif  ((SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305) || SHARKSSL_ENABLE_AES_GCM)
   U8 wIV[16];
   #endif
   #if SHARKSSL_MAX_KEY_LEN
   U8 wKey[SHARKSSL_MAX_KEY_LEN];
   #endif

   U8 rSeqNum[SHARKSSL_SEQ_NUM_LEN];
   #if (SHARKSSL_TLS_1_3 || (SHARKSSL_TLS_1_2 && (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)))
   U8 wSeqNum[SHARKSSL_SEQ_NUM_LEN];  /* not used by AES-GCM in TLS 1.2 */
   #endif

   #if SHARKSSL_TLS_1_3
   U8  masterSecret[SHARKSSL_MAX_DIGEST_LEN];
   #endif

   SharkSsl *sharkSsl;
   SharkSslCipherSuite *rCipherSuite, *wCipherSuite;
   #if SHARKSSL_ENABLE_SESSION_CACHE
   #if SHARKSSL_TLS_1_3
   U8  resumptionMasterSecret[SHARKSSL_MAX_DIGEST_LEN];
   #endif
   SharkSslSession *session;
   #endif

   void *rCtx, *wCtx;
   #if SHARKSSL_UNALIGNED_MALLOC
   SharkSslCon *mem;
   #endif

   #if SHARKSSL_ENABLE_ALPN_EXTENSION
   const char  *pALPN;
   const char  *rALPN;
   #if SHARKSSL_SSL_SERVER_CODE
   ALPNFunction fALPN;
   #endif
   #endif

   #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
   U8 clientVerifyData[SHARKSSL_FINISHED_MSG_LEN_TLS_1_2];
   U8 serverVerifyData[SHARKSSL_FINISHED_MSG_LEN_TLS_1_2];
   #endif

   #if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
   SharkSslClonedCertInfo *clonedCertInfo;
   #endif

   #if ((SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA) && (SHARKSSL_ENABLE_CA_LIST) && \
        ((SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_CLIENT_AUTH) || \
         (SHARKSSL_TLS_1_3 && SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CA_EXTENSION)))
   SharkSslCAList caListCertReq;
   #endif

   SharkSslBuf inBuf, outBuf;
   #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
   SharkSslBuf tmpBuf;
   #endif

   U32 flags;
   U16 padLen;
   U8 state;
   U8 reqMajor, reqMinor;
   U8 major, minor;
   U8 alertLevel, alertDescr;
   #if ((SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE) && SHARKSSL_ENABLE_SELECT_CIPHERSUITE)
   #if (SHARKSSL_SELECT_CIPHERSUITE_LIST_DEPTH > 0xFF)
   #error SHARKSSL_SELECT_CIPHERSUITE_LIST_DEPTH must be lower than 256
   #endif
   U8 cipherSelCtr;
   U8 cipherSelection[SHARKSSL_SELECT_CIPHERSUITE_LIST_DEPTH];
   #endif

   #if SHARKSSL_ERRORLINE_DEBUG
   int errLine;
   #endif
};


typedef enum
{
  tvp5146routes,
  rodatastart
} SharkSslCon_SendersRole;



#define SharkSsl_createCon2(o, sharkSslCon) do {\
   (o)->nCon++;\
   conditionvalid(sharkSslCon, o);\
} while (0)



void               conditionvalid(SharkSslCon *o, SharkSsl *resetcounters);
void               localenable(SharkSslCon *o);


SharkSslCon_RetVal savedconfig(SharkSslCon*, U8);
SharkSslCon_RetVal securememblock(SharkSslCon*, U8, U8);
SharkSslCon_RetVal configdword(SharkSslCon*, U8*, U16);
SharkSslCon_RetVal kexecprotect(SharkSslCon*, U8*, U16);
U8                *templateentry(SharkSslCon*, U8, U8*, U16);
#if SHARKSSL_TLS_1_3
int                SharkSslCon_calcMACAndEncryptHS(SharkSslCon*);
int                SharkSslCon_calcAppTrafficSecret(SharkSslCon*, U8*);
int                SharkSslCon_calcHandshakeTrafficSecret(SharkSslCon*);
#if SHARKSSL_ENABLE_SESSION_CACHE
int                SharkSslCon_calcResumptionSecret(SharkSslCon*, U8*);
int                SharkSslCon_calcTicketPSK(SharkSslCon*, U8*, U8*, U8);
int                SharkSslCon_calcEarlySecret(SharkSslCon*, U8*, U8);
#endif
#endif
#if SHARKSSL_TLS_1_2
int                allocalloc(SharkSslCon*, U8*, U16, U8*, U16, U8[32], U8[32]);
int                sanitisependbaser(SharkSslCon *o, SharkSslCon_SendersRole, U8*);
#endif
#if SHARKSSL_ENABLE_SELECT_CIPHERSUITE
int                sharkssl_protocol_ciphersuite(U8, U8);
#endif
int                printsilicon(SharkSslCon*, SharkSslCon_SendersRole, U8*);
int                SharkSslCon_calcMACAndEncrypt(SharkSslCon*);

#if SHARKSSL_TLS_1_3

#define            SharkSslCon_ccLen13(o) claimresource(clkctrlmanaged + ckctlrecalc + SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH + 1)
#endif
#if SHARKSSL_TLS_1_2
#define            SharkSslCon_ccLen12(o) claimresource(clkctrlmanaged + ckctlrecalc + systemcontroller)
#endif
#ifndef            SharkSslCon_ccLen13
#define            SharkSslCon_ccLen13(o) 0
#endif
#ifndef            SharkSslCon_ccLen12
#define            SharkSslCon_ccLen12(o) 0
#endif
#if (SharkSslCon_ccLen13(0) >= SharkSslCon_ccLen12(0))
#define r3000tlbchange(o) SharkSslCon_ccLen13(o)
#else
#define r3000tlbchange(o) SharkSslCon_ccLen12(o)
#endif

void               fpemureturn(SharkSslCon*);

#if SHARKSSL_ERRORLINE_DEBUG
#define            debugdestroy(o)      (o)->errLine
#define            resvdexits(o)      (debugdestroy(o) = (int)__LINE__)
#else
#define            debugdestroy(o)      0
#define            resvdexits(o)      
#endif

#if ((SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256) && SHARKSSL_ENABLE_AES_GCM)
int  offsetkernel(SharkSslCon*, U8, U8*, U16);
#endif
#if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
int updatecontext(SharkSslCon*, U8, U8*, U16);
#endif

#endif


#ifndef BA_LIB
#define BA_LIB
#endif



#if SHARKSSL_USE_ECC

#endif
#include <string.h>

#define SHARKSSL_DIM_ARR(a)  (sizeof(a)/sizeof(a[0]))

#define _SHARKSSLCON_HS_C_

#ifndef _SharkSslCipher_h
#define _SharkSslCipher_h


#ifdef _SHARKSSLCON_HS_C_

static const SharkSslCipherSuite genericsuspend[] =
{
   #if SHARKSSL_TLS_1_3
   #if SHARKSSL_AES_256_GCM_SHA384
   {
   offsetkernel,
   SHARKSSL_AES_256_GCM_SHA384,
   SHARKSSL_CS_TLS13 | irqhandlerfixup | cleandcache | cpufreqcallback | framekernel | ioasicclocksource,
   32, 
   16, 
   SHARKSSL_HASHID_SHA384
   },
   #endif
   #if SHARKSSL_AES_128_GCM_SHA256
   {
   offsetkernel,
   SHARKSSL_AES_128_GCM_SHA256,
   SHARKSSL_CS_TLS13 | irqhandlerfixup | cleandcache | cpufreqcallback | framekernel | SHARKSSL_CS_SHA256,
   16, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif
   #if SHARKSSL_CHACHA20_POLY1305_SHA256
   {
   updatecontext,
   SHARKSSL_CHACHA20_POLY1305_SHA256,
   SHARKSSL_CS_TLS13 | irqhandlerfixup | cleandcache | cpufreqcallback | suspendenter,
   32, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif
   #endif  

   #if SHARKSSL_TLS_1_2
   #if SHARKSSL_ENABLE_ECDHE_ECDSA
   
   #if kernelrelocation
   {
   updatecontext,
   kernelrelocation,
   overcommitmemory | irqhandlerfixup | cleandcache | cpufreqcallback | suspendenter,
   32, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif
   #if mitigationstate
   {
   offsetkernel,
   mitigationstate,
   overcommitmemory | irqhandlerfixup | cleandcache | cpufreqcallback | framekernel | ioasicclocksource,
   32, 
   16, 
   SHARKSSL_HASHID_SHA384
   },
   #endif
   #if enablecharger
   {
   offsetkernel,
   enablecharger,
   overcommitmemory | irqhandlerfixup | cleandcache | cpufreqcallback | framekernel,
   16, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif
   #endif  

   #if SHARKSSL_ENABLE_RSA
   
   #if releasedpages
   {
   updatecontext,
   releasedpages,
   overcommitmemory | irqhandlerfixup | cleandcache | percpudevid | suspendenter,
   32, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif
   #if mallocalign
   {
   offsetkernel,
   mallocalign,
   overcommitmemory | irqhandlerfixup | cleandcache | percpudevid | framekernel | ioasicclocksource,
   32, 
   16, 
   SHARKSSL_HASHID_SHA384
   },
   #endif
   #if resumenonboot
   {
   offsetkernel,
   resumenonboot,
   overcommitmemory | irqhandlerfixup | cleandcache | percpudevid | framekernel,
   16, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif

   
   #if nvramgetenv
   {
   updatecontext,
   nvramgetenv,
   overcommitmemory | cleandcache | percpudevid | suspendenter,
   32, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif
   #if quirkslc90e66
   {
   offsetkernel,
   quirkslc90e66,
   overcommitmemory | cleandcache | percpudevid | framekernel | ioasicclocksource,
   32, 
   16, 
   SHARKSSL_HASHID_SHA384
   },
   #endif
   #if branchenable
   {
   offsetkernel,
   branchenable,
   overcommitmemory | cleandcache | percpudevid | framekernel,
   16, 
   16, 
   SHARKSSL_HASHID_SHA256
   },
   #endif
   #endif  
   #endif  
};
#endif  

#endif
  
#undef  _SHARKSSLCON_HS_C_


#if SHARKSSL_ENABLE_SELECT_CIPHERSUITE
#if (SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE)
SHARKSSL_API U8 SharkSslCon_selectCiphersuite(SharkSslCon *o, U16 clockmodtable)
{
   baAssert(SHARKSSL_DIM_ARR(genericsuspend) < 0xFF);

   #if SHARKSSL_ENABLE_SESSION_CACHE
   
   if (!(o->session))
   #endif
   {
      if ((o) && ((o->state <= pciercxcfg070)
         #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
         || (o->flags & registerbuses)
         #endif
         ))
      {
         if (o->cipherSelCtr < SHARKSSL_SELECT_CIPHERSUITE_LIST_DEPTH)
         {
            
            int i;

            for (i = 0; (U16)i < SHARKSSL_DIM_ARR(genericsuspend); i++)
            {
               if (genericsuspend[i].id == clockmodtable)
               {
                  if (o->minor)  
                  {
                     baAssert((o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) || (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)));
                     if (!sharkssl_protocol_ciphersuite(o->minor, (U8)i))
                     {
                        SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                        return 0;  
                     }
                  }
                  
                  o->cipherSelection[o->cipherSelCtr++] = (U8)i;
                  return 1;  
               }
            }
         }
      }
   }

   return 0;
}


SHARKSSL_API U8 SharkSslCon_clearCiphersuiteSelection(SharkSslCon *o)
{
   if ((o) && ((o->state <= pciercxcfg070)
               #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
               || (o->flags & registerbuses)
               #endif
       ))
   {
      o->cipherSelCtr = 0;
      return 1;  
   }

   SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
   return 0;
}
#endif



int sharkssl_protocol_ciphersuite(U8 ejtagsetup, U8 fiqoutstart)
{
   baAssert(fiqoutstart < SHARKSSL_DIM_ARR(genericsuspend));
   return
      (
       #if SHARKSSL_PROTOCOL_TLS_1_2
       ((ejtagsetup == SHARKSSL_PROTOCOL_TLS_1_2) && (genericsuspend[fiqoutstart].flags & overcommitmemory))
       #if SHARKSSL_PROTOCOL_TLS_1_3
       ||
       #endif
       #endif
       #if SHARKSSL_PROTOCOL_TLS_1_3
       ((ejtagsetup == SHARKSSL_PROTOCOL_TLS_1_3) && (genericsuspend[fiqoutstart].flags & SHARKSSL_CS_TLS13))
       #endif
      );
}
#endif  


#if SHARKSSL_ENABLE_ALPN_EXTENSION
#if SHARKSSL_SSL_CLIENT_CODE
U8 SharkSslCon_setALPNProtocols(SharkSslCon *o, const char *iobanktiming)
{
   if (o && (o->state <= pciercxcfg070)
      #if SHARKSSL_SSL_SERVER_CODE
      && (SharkSsl_isClient(o->sharkSsl))
      #endif
      )
   {
      o->pALPN = iobanktiming;
      return 1;  
   }

   SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
   return 0;
}


const char *SharkSslCon_getALPNProtocol(SharkSslCon *o)
{
   return o->rALPN;
}
#endif


#if SHARKSSL_SSL_SERVER_CODE
U8 SharkSslCon_setALPNFunction(SharkSslCon *o, ALPNFunction func0fixup, void *writeabort)
{
   if (o && (o->state <= trampolinehandler)
      #if SHARKSSL_SSL_CLIENT_CODE
      && (SharkSsl_isServer(o->sharkSsl))
      #endif
      )
   {
      o->fALPN = func0fixup;
      o->pALPN = (const char*)writeabort;
      o->rALPN = NULL;
      return 1;  
   }

   SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
   return 0;
}
#endif
#endif  



int SharkSslCertParam_validateCertChain(SharkSslCertParam *certParam, SharkSslSignParam *tmpSignParam
   #if SHARKSSL_ENABLE_CA_LIST
   , U32 *driverchipcommon, SharkSslCAList displaysetup, U8 *afterhandler
   #endif
)
{
   #if SHARKSSL_ENABLE_CA_LIST
   U32 uart2hwmod;
   U8 *tp, gpio1config[SHARKSSL_CA_LIST_NAME_SIZE];
   #if SHARKSSL_ENABLE_CERTSTORE_API
   U8 *tb;
   U16 paramnamed;
   #endif
   U8  sha256export, i;
   #endif

   #if SHARKSSL_ENABLE_CA_LIST
   sha256export = 1;
   #endif
   while (certParam)
   {
      
      if (certParam->certInfo.parent != 0)
      {
         if (0 == SharkSslCertDN_equal(&(certParam->certInfo.issuer),
            &((SharkSslCertParam*)(certParam->certInfo.parent))->certInfo.subject))
         {
            
            if (certParam->certInfo.parent->parent)
            {
               certParam->certInfo.parent = certParam->certInfo.parent->parent;
               continue;
            }
            else
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return 1;  
            }
         }
         #if SHARKSSL_ENABLE_CA_LIST
      }

      
      if (displaysetup)
      {
         #if SHARKSSL_ENABLE_CERTSTORE_API
         baAssert(SHARKSSL_CA_LIST_PTR_SIZE == claimresource(SHARKSSL_CA_LIST_PTR_SIZE));
         paramnamed = SHARKSSL_CA_LIST_ELEMENT_SIZE;
         if (displaysetup[0] == SHARKSSL_CA_LIST_PTR_TYPE)
         {
            paramnamed = SHARKSSL_CA_LIST_NAME_SIZE + SHARKSSL_CA_LIST_PTR_SIZE;
         }
         else
         #endif
         if (displaysetup[0] != SHARKSSL_CA_LIST_INDEX_TYPE)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return -1;  
         }
         tp = (U8*)&(displaysetup[2]);
         uart2hwmod = (U16)(*tp++) << 8;
         uart2hwmod += *tp++;
         if (0 == uart2hwmod)  
         {
            break;
         }
         uart2hwmod--;
         #if SHARKSSL_ENABLE_CERTSTORE_API
         uart2hwmod *= paramnamed;
         #else
         uart2hwmod *= SHARKSSL_CA_LIST_ELEMENT_SIZE;
         #endif

         
         i = 0;
         if ((certParam->certInfo.issuer.commonName) && (certParam->certInfo.issuer.commonNameLen))
         {
            i = certParam->certInfo.issuer.commonNameLen;
            memcpy(gpio1config, certParam->certInfo.issuer.commonName, SHARKSSL_CA_LIST_NAME_SIZE);
         }
         else if ((certParam->certInfo.issuer.organization) && (certParam->certInfo.issuer.organizationLen))
         {
            i = certParam->certInfo.issuer.organizationLen;
            memcpy(gpio1config, certParam->certInfo.issuer.organization, SHARKSSL_CA_LIST_NAME_SIZE);
         }
         
         if (i >= SHARKSSL_CA_LIST_NAME_SIZE)
         {
            i = SHARKSSL_CA_LIST_NAME_SIZE;
         }
         if (i == 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return 1;  
         }

         memset(afterhandler, 0, sizeof(SharkSslCertParam));

         
         tp += uart2hwmod;
         while ((*tp != gpio1config[0]) && (uart2hwmod > 0))
         {
            #if SHARKSSL_ENABLE_CERTSTORE_API
            tp -= paramnamed;
            uart2hwmod -= paramnamed;
            #else
            tp -= SHARKSSL_CA_LIST_ELEMENT_SIZE;
            uart2hwmod -= SHARKSSL_CA_LIST_ELEMENT_SIZE;
            #endif
         }

         
         while (*tp == gpio1config[0])
         {
            if (0 == sharkssl_kmemcmp(tp, gpio1config, i))
            {
               #if SHARKSSL_ENABLE_CERTSTORE_API
               if (displaysetup[0] == SHARKSSL_CA_LIST_PTR_TYPE)
               {
                  tb = *(U8**)&tp[SHARKSSL_CA_LIST_NAME_SIZE];
               }
               else
               #endif
               {
                  uart2hwmod  = (U32)tp[SHARKSSL_CA_LIST_NAME_SIZE + 0] << 24;
                  uart2hwmod += (U32)tp[SHARKSSL_CA_LIST_NAME_SIZE + 1] << 16;
                  uart2hwmod += (U16)tp[SHARKSSL_CA_LIST_NAME_SIZE + 2] << 8;
                  uart2hwmod += tp[SHARKSSL_CA_LIST_NAME_SIZE + 3];
                  #if SHARKSSL_ENABLE_CERTSTORE_API
                  tb = (U8*)&(displaysetup[uart2hwmod]);
                  #endif
               }
               #if SHARKSSL_ENABLE_CERTSTORE_API
               if (!(spromregister((SharkSslCertParam*)afterhandler, tb, (U32)-5, NULL) < 0))
               #else
               if (!(spromregister((SharkSslCertParam*)afterhandler, (U8*)&(displaysetup[uart2hwmod]), (U32)-5, NULL) < 0))
               #endif
               {
                  if ((((SharkSslCertParam*)afterhandler)->certInfo.version < 2) || (((SharkSslCertParam*)afterhandler)->certInfo.CAflag))
                  {
                     if (SharkSslCertDN_equal(&(((SharkSslCertParam*)afterhandler)->certInfo.subject), &(certParam->certInfo.issuer)))
                     {
                        if (SharkSslCertDN_equal(&(certParam->certInfo.issuer), &(certParam->certInfo.subject)))
                        {
                           
                           if (0 == sharkssl_kmemcmp(((SharkSslCertParam*)afterhandler)->signature.signature,
                              certParam->signature.signature,
                              certParam->signature.signLen))
                           {
                              *driverchipcommon |= switcheractivation;
                              break;
                           }
                           
                        }
                        else
                        {
                           
                           if (0
                              #if SHARKSSL_ENABLE_RSA
                              || ((certParam->signature.signatureAlgo == entryearly) &&
                                 machinekexec(((SharkSslCertParam*)afterhandler)->certKey.expLen))
                              #endif
                              #if SHARKSSL_ENABLE_ECDSA
                              || ((certParam->signature.signatureAlgo == accessactive) &&
                                 machinereboot(((SharkSslCertParam*)afterhandler)->certKey.expLen))
                              #endif
                              )
                           {
                              certParam->certInfo.parent = (SharkSslCertInfo*)afterhandler;
                              sha256export = 0;
                              goto controlrestore;
                           }
                        }
                     }
                  }
               }
            }
            if (0 == uart2hwmod)
            {
               break;
            }
            #if SHARKSSL_ENABLE_CERTSTORE_API
            tp -= paramnamed;
            uart2hwmod -= paramnamed;
            #else
            tp -= SHARKSSL_CA_LIST_ELEMENT_SIZE;
            uart2hwmod -= SHARKSSL_CA_LIST_ELEMENT_SIZE;
            #endif
         }
      }

      
      if (certParam->certInfo.parent != 0)
      {
      controlrestore:
         #endif  
         
         if (((certParam->certInfo.parent)->version == 2) && !((certParam->certInfo.parent)->CAflag))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return 1;  
         }

         
         tmpSignParam->pCertKey = &(((SharkSslCertParam*)certParam->certInfo.parent)->certKey);
         
         memcpy(&(tmpSignParam->signature), &(certParam->signature), sizeof(SharkSslSignature));
         if (systemcapabilities(tmpSignParam) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return 1;  
         }

         #if SHARKSSL_ENABLE_CA_LIST
         if (0 == sha256export)  
         {
            *driverchipcommon |= switcheractivation;
            break;
         }
         #endif
      }

      certParam = (SharkSslCertParam*)certParam->certInfo.parent;
   }

   return 0;
}


#define SHARKSSL_WEIGHT                 U32          
#define trainingneeded   0x00800000L
#define smbuswrite        0x01000000L
#define lcd035q3dg01pdata              0x10000000L
#define clearevent       0x80000000L  
#define coverstate   0x00080000L  


#if SHARKSSL_TLS_1_2
#if SHARKSSL_SSL_SERVER_CODE
#if SHARKSSL_ENABLE_SNI
#include <SharkSslEx.h>
#endif
static int handleptrauth(SharkSslCon *o, SHARKSSL_WEIGHT *mfgpt0counter, U8 *registeredevent, U16 len)
{
   SHARKSSL_WEIGHT *p;
   SingleListEnumerator e;
   SingleLink *link;
   SharkSslHSParam *sharkSslHSParam;

#else
static int handleptrauth(SharkSslCon* o, U8* registeredevent, U16 len)
{
#endif

   U16 prminstwrite, paramnamed;

   baAssert(o);
   baAssert(registeredevent);
   #if SHARKSSL_SSL_SERVER_CODE
   sharkSslHSParam = hsParam(o);
   #endif
   #if SHARKSSL_USE_ECC
   baAssert(SHARKSSL_EC_CURVE_ID_SECP256R1 == spannedpages);
   baAssert(SHARKSSL_EC_CURVE_ID_SECP384R1 == restoretrace);
   baAssert(SHARKSSL_EC_CURVE_ID_SECP521R1 == buildmemmap);
   baAssert(SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1 == samplingevent);
   baAssert(SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1 == entrytrampoline);
   baAssert(SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1 == resumeprepare);
   baAssert(SHARKSSL_EC_CURVE_ID_CURVE25519 == TLS_NAMEDCURVE_CURVE25519);
   baAssert(SHARKSSL_EC_CURVE_ID_CURVE448 == TLS_NAMEDCURVE_CURVE448);
   #endif

   while (len >= 2)
   {
      prminstwrite  = (U16)(*registeredevent++) << 8;
      prminstwrite += *registeredevent++;
      len -= 2;

      if (len < 2)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return -1;
      }

      paramnamed  = (U16)(*registeredevent++) << 8;
      paramnamed += *registeredevent++;
      len -= 2;

      if (len < paramnamed)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return -1;
      }

      switch (prminstwrite)
      {
         #if SHARKSSL_ENABLE_ALPN_EXTENSION
         case clkdmclear:
            if (paramnamed)  
            {
               if (len < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               paramnamed = (U16)(*registeredevent++) << 8;
               paramnamed += *registeredevent++;
               len -= 2;
               if (paramnamed > len)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               #if SHARKSSL_SSL_CLIENT_CODE 
               #if SHARKSSL_SSL_SERVER_CODE
               if (SharkSsl_isClient(o->sharkSsl))
               #endif
               {
                  paramnamed = *registeredevent++;
                  len--;
                  if (paramnamed > len)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return -1;
                  }
                  len -= paramnamed;
                  
                  if (o->pALPN)
                  {
                     
                     U8 *afterhandler = (U8*)baMalloc(paramnamed + 1);
                     if (afterhandler)
                     {
                        memcpy(afterhandler, registeredevent, paramnamed);
                        *(afterhandler + paramnamed) = 0;
                        o->rALPN = strstr(o->pALPN, (const char *)afterhandler);
                        baFree(afterhandler);
                     }
                  }
               }
               #if SHARKSSL_SSL_SERVER_CODE 
               else
               #endif
               #endif
               #if SHARKSSL_SSL_SERVER_CODE
               {
                  if (o->fALPN)
                  {
                     o->rALPN = NULL;
                     while ((paramnamed > 0) && (paramnamed <= len) && (NULL == o->rALPN))
                     {
                        int ret;
                        U8* afterhandler;
                        prminstwrite = *registeredevent;  
                        
                        afterhandler = (U8*)baMalloc(prminstwrite + 1);
                        if (afterhandler)
                        {
                           memcpy(afterhandler, registeredevent + 1, prminstwrite);
                           *(afterhandler + prminstwrite) = 0;
                           ret = o->fALPN(o, (const char*)afterhandler, (void*)o->pALPN);
                           baFree(afterhandler);
                           
                           if (ret)
                           {
                              o->rALPN = (const char*)registeredevent;  
                           }
                        }
                        prminstwrite++;
                        registeredevent += prminstwrite;
                        paramnamed -= prminstwrite;
                        len -= prminstwrite;
                     }
                     if ((NULL == o->rALPN) && (0 == o->fALPN(o, NULL, (void*)o->pALPN)))
                     {
                        SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                        return -2;  
                     }
                  }
                  len -= paramnamed;
               }
               #endif
               registeredevent += paramnamed;
            }
            break;
         #endif

         case featurespresent:
            if (len < 1)
            {
               return -1;
            }
            paramnamed = *registeredevent++;
            len--;
            if (paramnamed > len)
            {
               return -1;
            }
            len -= paramnamed;
            if (!(o->flags & aarch32ptrace))
            {
               o->flags |= aarch32ptrace;
               if (paramnamed)
               {
                  
                  #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
                  goto hsudcresource;
                  #else
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
                  #endif
               }
            }
            else 
            {
               #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
               if (!(o->flags & platformdevice))
               {
                  hsudcresource:
                  if (paramnamed != SHARKSSL_FINISHED_MSG_LEN_TLS_1_2)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return -1;
                  }
               }
               if (sharkssl_kmemcmp(registeredevent, SharkSsl_isServer(o->sharkSsl) ? o->clientVerifyData : o->serverVerifyData, paramnamed))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               registeredevent += paramnamed;

               #else
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;  

               #endif
            }
            break;

         #if SHARKSSL_USE_ECC
         case edma0resources:
            if ((len < 1)
                #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
                || (o->minor == 0)
                #endif
               )
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            paramnamed = *registeredevent++;
            len--;
            if (paramnamed > len)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            len -= paramnamed;
            while ((paramnamed) && (*registeredevent++ != probesystem))
            {
               paramnamed--;
            }
            if (0 == paramnamed)  
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            paramnamed--;
            registeredevent += paramnamed;
            break;
         #endif  

         #if SHARKSSL_SSL_SERVER_CODE
         #if SHARKSSL_ENABLE_SNI
         case firstversion:
            if (paramnamed)   
            {
               if (len < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               paramnamed  = (U16)(*registeredevent++) << 8;
               paramnamed += *registeredevent++;
               len -= 2;
               if (paramnamed > len)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               len -= paramnamed;

               #if SHARKSSL_SSL_CLIENT_CODE
               
               if ((void*)0 == mfgpt0counter)
               {
                  registeredevent += paramnamed;
                  paramnamed = 0;
               }
               #endif
            }

            while (paramnamed)
            {
               if ((*registeredevent++) || (paramnamed < SHARKSSL_CERT_LENGTH_LEN))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;  
               }
               prminstwrite  = (U16)(*registeredevent++) << 8;
               prminstwrite += *registeredevent++;
               paramnamed -= SHARKSSL_CERT_LENGTH_LEN;
               if (prminstwrite > paramnamed)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               
               
               SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
               for (p = mfgpt0counter, link = SingleListEnumerator_getElement(&e);
                     link;
                     link = SingleListEnumerator_nextElement(&e), p++)
               {
                  if (*p) 
                  {
                     if (0 == sharkSubjectSubjectAltCmp((const char*)((SharkSslCertList*)link)->certP.commonName,
                                                        ((SharkSslCertList*)link)->certP.commonNameLen,
                                                        ((SharkSslCertList*)link)->certP.subjectAltNamesPtr,
                                                        ((SharkSslCertList*)link)->certP.subjectAltNamesLen,
                                                        (const char*)registeredevent, prminstwrite))
                     {
                        *(SHARKSSL_WEIGHT*)p |= clearevent;
                     }
                  }
               }

               registeredevent += prminstwrite;
               paramnamed -= prminstwrite;
            }
            break;
         #endif  

         #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         case registerpwrdms:
            if ((o->flags & startqueue)
                #if SHARKSSL_SSL_CLIENT_CODE  
                || (SharkSsl_isClient(o->sharkSsl))
                #endif
               )
            {
               goto swiotlbdetect;
            }
            if ((len < 2)
                #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
                || (o->minor == 0)
                #endif
               )
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            paramnamed  = (U16)(*registeredevent++) << 8;
            paramnamed += *registeredevent++;
            len -= 2;
            if (paramnamed > len)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            len -= paramnamed;
            sharkSslHSParam->ecdhParam.xLen = 0;
            while (paramnamed)
            {
               U8 savedsigmask;

               if (paramnamed < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               
               prminstwrite  = (U16)(*registeredevent++) << 8;
               prminstwrite += *registeredevent++;
               paramnamed -= 2;

               
               savedsigmask = controllerregister(prminstwrite);
               if (savedsigmask)
               {
                  
                  if (0 == sharkSslHSParam->ecdhParam.xLen)
                  {
                     sharkSslHSParam->ecdhParam.xLen = savedsigmask;
                     
                     sharkSslHSParam->ecdhParam.curveType = prminstwrite;
                  }

                  
                  SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
                  for (p = mfgpt0counter, link = SingleListEnumerator_getElement(&e);
                       link;
                       link = SingleListEnumerator_nextElement(&e), p++)
                  {
                     if ( (*p)
                          && (((SharkSslCertList*)link)->certP.keyType == compatrestart)  
                          && (((SharkSslCertList*)link)->certP.keyOID == prminstwrite))
                     {
                        *(SHARKSSL_WEIGHT*)p |= trainingneeded;
                     }
                  }
               }
            }
            break;
         #endif  

         case entrypaddr:
            #if SHARKSSL_SSL_CLIENT_CODE  
            if (SharkSsl_isClient(o->sharkSsl))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            #endif
            if (o->minor >= 3)  
            {
               if (len < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               paramnamed  = (U16)(*registeredevent++) << 8;
               paramnamed += *registeredevent++;
               len -= 2;
               if ((paramnamed > len) || (paramnamed & 0x1))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               len -= paramnamed;
               prminstwrite = 0;  
               while (paramnamed)
               {
                  
                  SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
                  for (p = mfgpt0counter, link = SingleListEnumerator_getElement(&e);
                       link;
                       link = SingleListEnumerator_nextElement(&e), p++)
                  {
                     if ((*p) && (!(*p & smbuswrite)))
                     {
                        if ((((SharkSslCertList*)link)->certP.hashAlgo == registeredevent[0]) &&
                            (((SharkSslCertList*)link)->certP.signatureAlgo == registeredevent[1]))
                        {
                           *(SHARKSSL_WEIGHT*)p |= smbuswrite;
                        }
                     }
                  }

                  
                  if (prminstwrite < 2)
                  {
                     if ((registeredevent[0] == presentpages) || (registeredevent[0] == domainnumber)
                         #if SHARKSSL_USE_SHA_384
                         || (registeredevent[0] == probewrite)
                         #endif
                         #if SHARKSSL_USE_SHA_512
                         || (registeredevent[0] == batterythread)
                         #endif
                        )
                     {
                        #if SHARKSSL_ENABLE_RSA
                        if ((0 == sharkSslHSParam->signParam.signature.signatureAlgo) && (registeredevent[1] == entryearly))
                        {
                           sharkSslHSParam->signParam.signature.signatureAlgo = registeredevent[0];
                           prminstwrite++;
                        }
                        #endif
                        #if SHARKSSL_ENABLE_ECDSA
                        if ((0 == sharkSslHSParam->signParam.signature.hashAlgo) && (registeredevent[1] == accessactive))
                        {
                           sharkSslHSParam->signParam.signature.hashAlgo = registeredevent[0];
                           prminstwrite++;
                        }
                        #endif
                     }
                  }
                  registeredevent += 2;
                  paramnamed -= 2;
               }
               break;
            }
            
         #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
            swiotlbdetect:
         #endif
         #endif  

         default:  
            if (len < paramnamed)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            len -= paramnamed;
            registeredevent += paramnamed;
            break;
      }
   }
   return 0;
}
#endif  


#if SHARKSSL_TLS_1_3
#if SHARKSSL_SSL_CLIENT_CODE

static int dfbmcs320device(SharkSslCon* o, U8* registeredevent, U16 len)
{
   U16 prminstwrite, paramnamed;

   baAssert(o);
   baAssert(registeredevent);

   while (len >= 2)
   {
      prminstwrite = (U16)(*registeredevent++) << 8;
      prminstwrite += *registeredevent++;
      len -= 2;

      if (len < 2)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return -1;
      }

      paramnamed = (U16)(*registeredevent++) << 8;
      paramnamed += *registeredevent++;
      len -= 2;

      if (len < paramnamed)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return -1;
      }

      if (prminstwrite == doublefcvts)
      {
         #if (SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_3) != SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_2))
         #error INTERNAL ERROR SHARKSSL_PROTOCOL_MAJOR TLS 1.3 <> TLS 1.2
         #endif
         if ((paramnamed != 2) || (*registeredevent++ != SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_3)))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return -1;  
         }
         if ((*registeredevent != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) && (*registeredevent != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return -1;  
         }
         return (int)*registeredevent;
      }
      else  
      {
         len -= paramnamed;
         registeredevent += paramnamed;
      }
   }
   return 0;  
}
#endif  

   
 static int registerclass(SharkSslCon *o, U8 *registeredevent, U16 len)
{
   U16 prminstwrite, paramnamed, kLen;

   baAssert(o);
   baAssert(registeredevent);
   #if SHARKSSL_USE_ECC
   baAssert(SHARKSSL_EC_CURVE_ID_SECP256R1 == ucb1400pdata);
   baAssert(SHARKSSL_EC_CURVE_ID_SECP384R1 == pciercxcfg034);
   baAssert(SHARKSSL_EC_CURVE_ID_SECP521R1 == audiopdata);
   baAssert(SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1 == gpio3config);
   baAssert(SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1 == negativeoffset);
   baAssert(SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1 == sa1111disable);
   baAssert(SHARKSSL_EC_CURVE_ID_CURVE25519 == TLS_NAMEDCURVE_CURVE25519);
   baAssert(SHARKSSL_EC_CURVE_ID_CURVE448 == TLS_NAMEDCURVE_CURVE448);
   #endif

   while (len >= 2)
   {
      prminstwrite = (U16)(*registeredevent++) << 8;
      prminstwrite += *registeredevent++;
      len -= 2;

      if (len < 2)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return -1;
      }

      paramnamed = (U16)(*registeredevent++) << 8;
      paramnamed += *registeredevent++;
      len -= 2;

      if (len < paramnamed)
      {
         return -1;
      }

      switch (prminstwrite)
      {
         #if SHARKSSL_ENABLE_ALPN_EXTENSION
         case clkdmclear:
            if (paramnamed)
            {
               if (len < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               paramnamed = (U16)(*registeredevent++) << 8;
               paramnamed += *registeredevent++;
               len -= 2;
               if (paramnamed > len)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               paramnamed = *registeredevent++;
               len--;
               if (paramnamed > len)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               len -= paramnamed;
               
               if (o->pALPN)
               {
                  
                  U8* afterhandler = (U8*)baMalloc(paramnamed + 1);
                  if (afterhandler)
                  {
                     memcpy(afterhandler, registeredevent, paramnamed);
                     *(afterhandler + paramnamed) = 0;
                     o->rALPN = strstr(o->pALPN, (const char*)afterhandler);
                     baFree(afterhandler);
                  }
               }
               registeredevent += paramnamed;
            }
            break;
         #endif

         case reboothandler:
            if (len < 5)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            prminstwrite = (U16)(*registeredevent++) << 8;
            prminstwrite += (*registeredevent++);
            len -= 2;
            hsParam(o)->ecdhParam.curveType = prminstwrite;  
            
            kLen = controllerregister(prminstwrite);
            
            paramnamed = (U16)(*registeredevent++) << 8;
            paramnamed += (*registeredevent++);
            len -= 2;
            if ((0 == kLen) || (len < paramnamed))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            #if SHARKSSL_ECC_USE_EDWARDS
            if ((prminstwrite == TLS_NAMEDGROUP_CURVE25519) || (prminstwrite == TLS_NAMEDGROUP_CURVE448))
            {
               if (paramnamed != kLen)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
            }
            else
            #endif
            {
               #if (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1)
               if (*registeredevent++ != SHARKSSL_EC_POINT_UNCOMPRESSED)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               paramnamed--;
               len--;
               if (paramnamed != (U16)(kLen << 1))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               #else
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
               #endif
            }
            hsParam(o)->ecdhParam.xLen = kLen;
            hsParam(o)->ecdhParam.XY = registeredevent;      
            switch (prminstwrite)
            {
               #if SHARKSSL_ECC_USE_SECP384R1
               case pciercxcfg034:
                  hsParam(o)->ecdhParam.k = hsParam(o)->prot.tls13.privKeySECP384R1;
                  break;
               #endif

               #if SHARKSSL_ECC_USE_SECP256R1
               case ucb1400pdata:
                  hsParam(o)->ecdhParam.k = hsParam(o)->prot.tls13.privKeySECP256R1;
                  break;
               #endif

               #if SHARKSSL_ECC_USE_CURVE25519
               case TLS_NAMEDGROUP_CURVE25519:
                  hsParam(o)->ecdhParam.k = hsParam(o)->prot.tls13.privKeyCURVE25519;
                  break;
               #endif

               #if SHARKSSL_ECC_USE_CURVE448
               case TLS_NAMEDGROUP_CURVE448:
                  hsParam(o)->ecdhParam.k = hsParam(o)->prot.tls13.privKeyCURVE448;
                  break;
               #endif

               default:
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
            }
            len -= paramnamed;
            registeredevent += paramnamed;
            
            SharkSslECDHParam_ECDH(&(hsParam(o)->ecdhParam), switcheractive, hsParam(o)->ecdhParam.k);
            break;

         case allocconsistent:
            #if SHARKSSL_SSL_SERVER_CODE
            if (SharkSsl_isServer(o->sharkSsl))
            {
               
               if (len < paramnamed)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               len -= paramnamed;
               registeredevent += paramnamed;
            }
            else
            #endif
            {
               if (len < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               paramnamed = (U16)(*registeredevent++) << 8;  
               paramnamed += (*registeredevent++);
               len -= 2;
               if (paramnamed != 0)  
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return -1;
               }
               o->flags |= startqueue;
            }
            break;

         
         default:  
            
            if (len < paramnamed)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return -1;
            }
            len -= paramnamed;
            registeredevent += paramnamed;
            break;
      }
   }

   return 0;
}
#endif  


int SharkSslHSParam_setSignatureHashAlgoFromSignatureScheme(SharkSslHSParam *s, U16 ahashreqsize)
{
   switch (ahashreqsize)  
   {
      #if (SHARKSSL_ENABLE_ECDSA || (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSA_PKCS1)) && (SHARKSSL_USE_SHA_256 || SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
      #if SHARKSSL_ENABLE_ECDSA
      #if SHARKSSL_USE_SHA_256
      case 0x0403:
      #endif
      #if SHARKSSL_USE_SHA_384
      case 0x0503:
      #endif
      #if SHARKSSL_USE_SHA_512
      case 0x0603:
      #endif
      #endif
      #if SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSA_PKCS1
      #if SHARKSSL_USE_SHA_256
      case 0x0401:
      #endif
      #if SHARKSSL_USE_SHA_384
      case 0x0501:
      #endif
      #if SHARKSSL_USE_SHA_512
      case 0x0601:
      #endif
      #endif
         s->signParam.signature.hashAlgo = (ahashreqsize >> 8);
         s->signParam.signature.signatureAlgo = (ahashreqsize & 0xFF);
         break;
      #endif

      #if SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSASSA_PSS && (SHARKSSL_USE_SHA_256 || SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
      #if SHARKSSL_USE_SHA_256
      case 0x0804:
      #endif
      #if SHARKSSL_USE_SHA_384
      case 0x0805:
      #endif
      #if SHARKSSL_USE_SHA_512
      case 0x0806:
      #endif
         s->signParam.signature.hashAlgo = (ahashreqsize & 0xFF);
         s->signParam.signature.signatureAlgo = (ahashreqsize >> 8);
         break;
      #endif

      default:
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return -1;  
   }

   return 0;
}


#if SHARKSSL_SSL_SERVER_CODE  

static int SharkSslHSParam_setCert(SharkSslHSParam *s, SharkSslCertParsed **certPtr, U16 cipherSuiteFlags)
{
   baAssert(s);
   baAssert(certPtr);
   #if SHARKSSL_TLS_1_3
   if (cipherSuiteFlags & SHARKSSL_CS_TLS13)
   {
      return -1;  
   }
   #endif
   switch (cipherSuiteFlags & (cleandcache | irqhandlerfixup | cpufreqcallback | percpudevid))
   {
      #if SHARKSSL_ENABLE_RSA
      case percpudevid:  
      #if SHARKSSL_ENABLE_DHE_RSA
      case cleandcache | percpudevid:  
      #endif
      #if SHARKSSL_ENABLE_ECDHE_RSA
      case cleandcache | irqhandlerfixup | percpudevid:  
      #endif
         if (certPtr[0])  
         {
            s->certParsed = certPtr[0];
            return 0;
         }
         break;
      #endif  

      #if SHARKSSL_ENABLE_ECDHE_ECDSA
      case cleandcache | irqhandlerfixup | cpufreqcallback:  
         if (certPtr[2])  
         {
            s->certParsed = certPtr[2];
            return 0;
         }
         #if SHARKSSL_ENABLE_RSA
         else if (certPtr[1])  
         {
            s->certParsed = certPtr[1];
            return 0;
         }
         #endif
         break;
      #endif

      default:
         
         break;
   }

   return -1;
}
#endif  


SharkSslCon_RetVal configdword(SharkSslCon *o,
                                                U8  *registeredevent,
                                                U16  atagsprocfs)
{
   #if SHARKSSL_TLS_1_2
   #if SHARKSSL_SSL_SERVER_CODE
   static const U8 registeraudio[] =
   {
      (U8)(featurespresent >> 8),
      (U8)(featurespresent & 0xFF),
      0x00, 0x01, 0x00
   };
   #endif
   #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
   static const U8 resetsources[] =  
   {
      0x00, edma0resources,
      0x00, 0x02, 0x01, probesystem
   };
   #endif
   #endif  
   
   #if SHARKSSL_TLS_1_3
   static const U8 cvServerCtxZero[34] = { '\124','\114','\123','\040','\061','\056','\063','\054','\040','\163','\145','\162','\166','\145','\162','\040',
                                           '\103','\145','\162','\164','\151','\146','\151','\143','\141','\164','\145','\126','\145','\162','\151','\146','\171', 0x00 };
   #if SHARKSSL_SSL_CLIENT_CODE
   SharkSslECDHParam configvdcdc2;
   #endif
   #endif  

   U32  now_ccLen, crLen;
   U8  *tp, *sp, *tb, *afterhandler;
   SharkSslHSParam *sharkSslHSParam;
   #if ((SHARKSSL_SSL_CLIENT_CODE || SHARKSSL_SSL_SERVER_CODE) && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
   SharkSslCertParam *certParam;
   #if (SHARKSSL_SSL_SERVER_CODE || SHARKSSL_ENABLE_CLIENT_AUTH)
   SingleListEnumerator e;
   SingleLink *link;
   #endif
   #endif
   U16  hsDataLen, paramnamed, hsLen, i;
   U8   setupinterface, ics;

   tb = (U8*)0;
   suspendlocal:
   if ((0 == registeredevent) || (*registeredevent != o->state))
   {
      #if SHARKSSL_SSL_CLIENT_CODE
      if (o->flags & probedaddress)
      {
         SharkSslCipherSuite *clockmodtable;

         baAssert(SharkSsl_isClient(o->sharkSsl));
         o->flags &= ~probedaddress;

         baAssert(microresources(&o->outBuf));
         atomiccmpxchg(&o->outBuf, o->sharkSsl->outBufSize);
         if (microresources(&o->outBuf))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return SharkSslCon_AllocationError;
         }
         sharkSslHSParam = hsParam(o);
         breakpointhandler(sharkSslHSParam);

         baAssert(microresources(&o->inBuf));
         atomiccmpxchg(&o->inBuf, o->sharkSsl->inBufStartSize);
         if (microresources(&o->inBuf))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return SharkSslCon_AllocationError;
         }

         
         o->major = SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_2);

         
         tp = sp = templateentry(o, controllegacy, o->inBuf.data, 0);
         *tp++ = pciercxcfg070;
         *tp++ = 0x00;
         *tp++ = 0x00;
         *tp++ = 0x00;
         *tp++ = o->reqMajor = o->major;
         
         *tp++ = o->reqMinor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);

         
         #if SHARKSSL_TLS_1_2
         now_ccLen = (U32)baGetUnixTime();
         inputlevel(now_ccLen, tp, 0);
         tp += 4;
         
         if (sharkssl_rng(tp, (SHARKSSL_RANDOM_LEN - 4)) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            resvdexits(o);
            return SharkSslCon_Error;
         }
         tp += (SHARKSSL_RANDOM_LEN - 4);
         
         memcpy(sharkSslHSParam->prot.tls12.clientRandom, tp - SHARKSSL_RANDOM_LEN, SHARKSSL_RANDOM_LEN);
         #else
         if (sharkssl_rng(tp, SHARKSSL_RANDOM_LEN) < 0)
         {
            resvdexits(o);
            return SharkSslCon_Error;
         }
         tp += SHARKSSL_RANDOM_LEN;
         #endif

         #if (SHARKSSL_TLS_1_2 && SHARKSSL_ENABLE_SESSION_CACHE)
         if ((o->session) 
             #if SHARKSSL_TLS_1_3
             && (SharkSslSession_isProtocol(o->session, SHARKSSL_PROTOCOL_TLS_1_2))
             #endif
             )
         {
            *tp++ = SHARKSSL_MAX_SESSION_ID_LEN;
            memcpy(tp, o->session->prot.tls12.id, SHARKSSL_MAX_SESSION_ID_LEN);
            tp += SHARKSSL_MAX_SESSION_ID_LEN;
         }
         else
         #endif
         {
            #if 1
            *tp++ = 0;  
            #else
            *tp++ = SHARKSSL_MAX_SESSION_ID_LEN;
            if (sharkssl_rng(tp, SHARKSSL_MAX_SESSION_ID_LEN) < 0)
            {
               resvdexits(o);
               return SharkSslCon_Error;
            }
            
            tp += SHARKSSL_MAX_SESSION_ID_LEN;
            #endif
         }

         
         #if SHARKSSL_ENABLE_SELECT_CIPHERSUITE
         if (o->cipherSelCtr)
         {
            #if SHARKSSL_ENABLE_SESSION_CACHE
            baAssert(!(o->session));
            #endif
            paramnamed = (U16)((U16)o->cipherSelCtr << 1);
            *tp++ = (U8)(paramnamed >> 8);
            *tp++ = (U8)(paramnamed & 0xFF);
            paramnamed = 0;
            #if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
            hsLen = 0;
            #endif
            while (paramnamed < o->cipherSelCtr)
            {
               clockmodtable = (SharkSslCipherSuite*)&genericsuspend[o->cipherSelection[paramnamed++]];
               now_ccLen = clockmodtable->id;
               *tp++ = (U8)(now_ccLen >> 8);
               *tp++ = (U8)(now_ccLen & 0xFF);

               #if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
               
               if (o->minor == 0)
               {
                  hsLen |= clockmodtable->flags & (overcommitmemory | SHARKSSL_CS_TLS13);
               }
               #endif
            }
            #if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
            switch (hsLen)
            {
            case overcommitmemory:
               
               o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);
               break;

            case SHARKSSL_CS_TLS13:
               
               o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3);
               break;

            default:
               
               break;
            }
            #endif
         }
         else
         #endif
         {
            paramnamed = (U16)((U16)SHARKSSL_DIM_ARR(genericsuspend) << 1);
            baAssert(paramnamed);
            #if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
            
            if (o->minor) 
            {
               tb = tp++;
               tp++;
            }
            else
            #endif
            {
               *tp++ = (U8)(paramnamed >> 8);
               *tp++ = (U8)(paramnamed & 0xFF);
            }
            paramnamed >>= 1;
            clockmodtable = (SharkSslCipherSuite*)&genericsuspend[0];
            #if SHARKSSL_ENABLE_SESSION_CACHE
            crLen = 0;  
            if (o->session)
            {
               baAssert((o->minor == 0) || (o->minor == hardirqsenabled(o->session)));
               
               crLen = o->session->cipherSuite->id;
               *tp++ = (U8)(crLen >> 8);
               *tp++ = (U8)(crLen & 0xFF);
            }
            #endif
            while (paramnamed)
            {
               paramnamed--;
               now_ccLen = clockmodtable->id;
               #if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
               if ( (o->minor == 0) 
                    || 
                    ((o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) && (clockmodtable->flags & overcommitmemory)) 
                    ||
                    ((o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) && (clockmodtable->flags & SHARKSSL_CS_TLS13)) )
               #endif
               {
                  #if SHARKSSL_ENABLE_SESSION_CACHE
                  
                  if ((!(o->session)) || (now_ccLen != crLen))
                  #endif
                  {
                     *tp++ = (U8)(now_ccLen >> 8);
                     *tp++ = (U8)(now_ccLen & 0xFF);
                  }
               }
               clockmodtable++;
            }
            #if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
            if (o->minor)
            {
               paramnamed = (U16)(tp - tb - 2);
               *tb++ = (U8)(paramnamed >> 8);
               *tb   = (U8)(paramnamed & 0xFF);
            }
            #endif
         }

         
         *tp++ = 1; 
         *tp++ = cminstclear;

         
         afterhandler = tp++;
         tp++;

         #if SHARKSSL_RANDOMIZE_EXTENSIONS
         
         baAssert(sizeof(U32) & 0x4);
         baAssert(0 == (sizeof(U32) & 0x3));
         sharkssl_rng((U8 *)&sharkSslHSParam->extState, sizeof(U32) & 0x4);
         for (ics = 0; ics < SHARKSSL_MAX_EXTENSIONS; ics++)
         {
            sharkSslHSParam->extIndex[ics] = ics + 1;
         }
         
         for (ics = 0; ics < SHARKSSL_MAX_EXTENSIONS; ics++)
         {
            for (setupinterface = 0; setupinterface < 37; setupinterface++)
            {
               U8 t;
               #if (SHARKSSL_BIGINT_WORDSIZE < 32)
               
               sharkSslHSParam->extState ^= sharkSslHSParam->extState << 7;
               sharkSslHSParam->extState ^= sharkSslHSParam->extState >> 9;
               sharkSslHSParam->extState ^= sharkSslHSParam->extState << 8;
               #else
               
               sharkSslHSParam->extState ^= sharkSslHSParam->extState << 13;
               sharkSslHSParam->extState ^= sharkSslHSParam->extState >> 17;
               sharkSslHSParam->extState ^= sharkSslHSParam->extState << 5;
               #endif

               t = (U8)sharkSslHSParam->extState;
               if ((t < SHARKSSL_MAX_EXTENSIONS) && (t != ics))
               {
                  
                  sharkSslHSParam->extIndex[ics] += sharkSslHSParam->extIndex[t];
                  sharkSslHSParam->extIndex[t]    = sharkSslHSParam->extIndex[ics] - sharkSslHSParam->extIndex[t];
                  sharkSslHSParam->extIndex[ics] -= sharkSslHSParam->extIndex[t];
               }
            }
         }
         for (ics = 0; ics < SHARKSSL_MAX_EXTENSIONS; ics++)
         #endif
         {
            #if SHARKSSL_RANDOMIZE_EXTENSIONS
            switch (sharkSslHSParam->extIndex[ics])
            {
               case 8:
            #endif
                  
                  #if SHARKSSL_ENABLE_SNI
                  if ((o->padLen) && (o->rCtx))
                  {
                     *tp++ = (U8)(firstversion >> 8);
                     *tp++ = (U8)(firstversion & 0xFF);
                     paramnamed = (U8)(o->padLen) + 5;
                     *tp++ = (U8)(paramnamed >> 8);
                     *tp++ = (U8)(paramnamed & 0xFF);
                     paramnamed -= 2;
                     *tp++ = (U8)(paramnamed >> 8);
                     *tp++ = (U8)(paramnamed & 0xFF);
                     *tp++ = 0x00;  
                     paramnamed -= 3;
                     *tp++ = (U8)(paramnamed >> 8);
                     *tp++ = (U8)(paramnamed & 0xFF);
                     memcpy(tp, o->rCtx, paramnamed);
                     tp += paramnamed;

                     o->rCtx = NULL;
                     o->padLen = 0;
                  }
                  #endif
               #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               case 7:
               #endif
                  
                  #if SHARKSSL_ENABLE_ALPN_EXTENSION
                  if (o->pALPN)
                  {
                     *tp++ = (U8)(clkdmclear >> 8);
                     *tp++ = (U8)(clkdmclear & 0xFF);
                     paramnamed = (U16)(3 + (U16)strlen(o->pALPN));
                     *tp++ = (U8)(paramnamed >> 8);
                     *tp++ = (U8)(paramnamed & 0xFF);
                     paramnamed -= 2;
                     *tp++ = (U8)(paramnamed >> 8);
                     *tp++ = (U8)(paramnamed & 0xFF);
                     tb = (U8*)o->pALPN;
                     for (;;)
                     {
                        paramnamed = 0;
                        tp++;  
                        while ((*tb != '\054') && (*tb != 0))
                        {
                           paramnamed++;
                           *tp++ = *tb++;
                        }
                        *(tp - paramnamed - 1) = (U8)paramnamed;  
                        if (0 == *tb)
                        {
                           break;
                        }
                        tb++;
                     }
                  }
                  #endif
               #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               case 6:
               #endif
                  
                  #if SHARKSSL_TLS_1_3
                  #if SHARKSSL_TLS_1_2
                  
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
                  #endif
                  {
                     *tp++ = (U8)(doublefcvts >> 8);
                     *tp++ = (U8)(doublefcvts & 0xFF);
                     *tp++ = 0x00;
                     tb = tp++;
                     tp++;  
                     *tp++ = SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_3);
                     *tp++ = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3);
                     #if SHARKSSL_TLS_1_2
                     
                     if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
                     {
                        *tp++ = SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_2);
                        *tp++ = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);
                     }
                     #endif
                     
                     paramnamed = (U16)(tp - tb);
                     *tb++ = (U8)--paramnamed;
                     *tb   = (U8)--paramnamed;
                  }
                  #endif
               #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               case 5:
               #endif
                  
                  #if SHARKSSL_TLS_1_2
                  baAssert(restoremasks == entrypaddr);
                  #endif
                  *tp++ = (U8)(restoremasks >> 8);
                  *tp++ = (U8)(restoremasks & 0xFF);
                  tb = tp;  
                  tp += 4;
                  #if SHARKSSL_ENABLE_ECDSA
                  #if (SHARKSSL_ECC_USE_SECP521R1 && SHARKSSL_USE_SHA_512)
                  *tp++ = batterythread;
                  *tp++ = accessactive;
                  #endif
                  #if (SHARKSSL_ECC_USE_SECP384R1 && SHARKSSL_USE_SHA_384)
                  *tp++ = probewrite;
                  *tp++ = accessactive;
                  #endif
                  #if (SHARKSSL_ECC_USE_SECP256R1 && SHARKSSL_USE_SHA_256)
                  *tp++ = domainnumber;
                  *tp++ = accessactive;
                  #endif
                  #if SHARKSSL_TLS_1_2
                  #if SHARKSSL_TLS_1_3
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
                  #endif
                  {
                     *tp++ = presentpages;
                     *tp++ = accessactive;
                  }
                  #endif
                  #endif  
                  #if SHARKSSL_ENABLE_RSA
                  #if SHARKSSL_ENABLE_RSA_PKCS1
                  #if SHARKSSL_USE_SHA_512
                  *tp++ = batterythread;
                  *tp++ = entryearly;
                  #endif
                  #if SHARKSSL_USE_SHA_384
                  *tp++ = probewrite;
                  *tp++ = entryearly;
                  #endif
                  #if SHARKSSL_USE_SHA_256
                  *tp++ = domainnumber;
                  *tp++ = entryearly;
                  #endif
                  #if (SHARKSSL_TLS_1_2 && (SHARKSSL_USE_SHA1 || SHARKSSL_USE_MD5))
                  #if SHARKSSL_TLS_1_3
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
                  #endif
                  {
                     
                     #if SHARKSSL_USE_SHA1
                     *tp++ = presentpages;
                     *tp++ = entryearly;
                     #endif
                     #if SHARKSSL_USE_MD5
                     *tp++ = skciphercreate;
                     *tp++ = entryearly;
                     #endif
                  }
                  #endif
                  #endif  
                  #if (SHARKSSL_TLS_1_3 && SHARKSSL_ENABLE_RSASSA_PSS)
                  #if SHARKSSL_TLS_1_2
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
                  #endif
                  {
                     #if SHARKSSL_USE_SHA_512
                     *tp++ = SHARKSSL_SIGNATUREALGORITHM_RSA_PSS;
                     *tp++ = batterythread;
                     #endif
                     #if SHARKSSL_USE_SHA_384
                     *tp++ = SHARKSSL_SIGNATUREALGORITHM_RSA_PSS;
                     *tp++ = probewrite;
                     #endif
                     #if SHARKSSL_USE_SHA_256
                     *tp++ = SHARKSSL_SIGNATUREALGORITHM_RSA_PSS;
                     *tp++ = domainnumber;
                     #endif
                  }
                  #endif  
                  #endif  
                  
                  paramnamed = (U16)(tp - tb - 2);
                  *tb++ = (U8)(paramnamed >> 8);
                  *tb++ = (U8)(paramnamed & 0xFF);
                  paramnamed -= 2;
                  *tb++ = (U8)(paramnamed >> 8);
                  *tb   = (U8)(paramnamed & 0xFF);
               #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               case 4:
               #endif
                  
                  #if (SHARKSSL_USE_ECC && (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1 || SHARKSSL_ECC_USE_SECP521R1))
                  #if SHARKSSL_TLS_1_2
                  baAssert(pwrdmenable == registerpwrdms);
                  #endif
                  {
                     static const U8 tcpudpmagic[] =
                     {
                        #if SHARKSSL_ECC_USE_SECP521R1
                        0x00, buildmemmap,
                        #endif
                        #if SHARKSSL_ECC_USE_BRAINPOOLP512R1  
                        0x00, resumeprepare,  
                        #endif
                        #if (SHARKSSL_TLS_1_3 && SHARKSSL_ECC_USE_CURVE448)
                        0x00, TLS_NAMEDCURVE_CURVE448,
                        #endif
                        #if SHARKSSL_ECC_USE_SECP384R1
                        0x00, restoretrace,
                        #endif
                        #if SHARKSSL_ECC_USE_BRAINPOOLP384R1
                        0x00, entrytrampoline,  
                        #endif
                        #if (SHARKSSL_TLS_1_3 && SHARKSSL_ECC_USE_CURVE25519)
                        0x00, TLS_NAMEDCURVE_CURVE25519,
                        #endif
                        #if SHARKSSL_ECC_USE_SECP256R1
                        0x00, spannedpages,
                        #endif
                        #if SHARKSSL_ECC_USE_BRAINPOOLP256R1
                        0x00, samplingevent,  
                        #endif
                     };

                  
                  *tp++ = (U8)(pwrdmenable >> 8);
                  *tp++ = (U8)(pwrdmenable & 0xFF);
                  paramnamed = 2 + SHARKSSL_DIM_ARR(tcpudpmagic);
                  *tp++ = (U8)(paramnamed >> 8);
                  *tp++ = (U8)(paramnamed & 0xFF);
                  paramnamed -= 2;
                  *tp++ = (U8)(paramnamed >> 8);
                  *tp++ = (U8)(paramnamed & 0xFF);
                  memcpy(tp, tcpudpmagic, SHARKSSL_DIM_ARR(tcpudpmagic));
                  tp += SHARKSSL_DIM_ARR(tcpudpmagic);
                  #if SHARKSSL_TLS_1_2
                  #if SHARKSSL_TLS_1_3
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
                  #endif
                  {
                     memcpy(tp, resetsources, SHARKSSL_DIM_ARR(resetsources));
                     tp += SHARKSSL_DIM_ARR(resetsources);
                  }
                  #endif
                  }
                  #endif
               #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               case 3:
               #endif
                  
                  #if (SHARKSSL_TLS_1_3 && SHARKSSL_ENABLE_SESSION_CACHE)
                  #if SHARKSSL_TLS_1_2
                  
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
                  #endif
                  {
                     *tp++ = (U8)(rm200hwint >> 8);
                     *tp++ = (U8)(rm200hwint & 0xFF);
                     *tp++ = 0x00;
                     *tp++ = 0x02;  
                     *tp++ = 0x01;  
                     *tp++ = 0x01;  
                  }
                  #endif  
               #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               case 2:
               #endif
                  
                  #if (SHARKSSL_TLS_1_3 && SHARKSSL_ENABLE_CA_LIST && SHARKSSL_ENABLE_CA_EXTENSION)
                  #if SHARKSSL_TLS_1_2
                  
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
                  #endif
                  {
                     if (o->caListCertReq)
                     {
                        SharkSslCert pCert;
                        U8 *cp;

                        baAssert(o->flags & SHARKSSL_FLAG_CA_EXTENSION_REQUEST);
                        #if SHARKSSL_ENABLE_CERTSTORE_API
                        baAssert(SHARKSSL_CA_LIST_PTR_SIZE == claimresource(SHARKSSL_CA_LIST_PTR_SIZE));
                        #endif
                        if ((o->caListCertReq[0] != SHARKSSL_CA_LIST_INDEX_TYPE)
                              #if SHARKSSL_ENABLE_CERTSTORE_API
                              && (o->caListCertReq[0] != SHARKSSL_CA_LIST_PTR_TYPE)
                              #endif
                           )
                        {
                           SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                           return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
                        }
                        now_ccLen = ((U16)(o->caListCertReq[2]) << 8) + o->caListCertReq[3];
                        if (now_ccLen)  
                        {
                           *tp++ = (U8)(shutdownnonboot >> 8);
                           *tp++ = (U8)(shutdownnonboot & 0xFF);
                           tb = tp;
                           tp += 4;
                           cp = (U8*)&(o->caListCertReq[4]);
                           while (now_ccLen--)
                           {
                              int ret;
                              U16 installidmap;
                              #if SHARKSSL_ENABLE_CERTSTORE_API
                              if (o->caListCertReq[0] == SHARKSSL_CA_LIST_PTR_TYPE)
                              {
                                 pCert = *(SharkSslCert*)&cp[SHARKSSL_CA_LIST_NAME_SIZE];
                                 cp += SHARKSSL_CA_LIST_NAME_SIZE + SHARKSSL_CA_LIST_PTR_SIZE;  
                              }
                              else
                              #endif
                              {
                                 crLen  = (U32)cp[SHARKSSL_CA_LIST_NAME_SIZE+0] << 24;
                                 crLen += (U32)cp[SHARKSSL_CA_LIST_NAME_SIZE+1] << 16;
                                 crLen += (U16)cp[SHARKSSL_CA_LIST_NAME_SIZE+2] << 8;
                                 crLen +=      cp[SHARKSSL_CA_LIST_NAME_SIZE+3];
                                 pCert  = (SharkSslCert)&(o->caListCertReq[crLen]);
                                 cp    += SHARKSSL_CA_LIST_ELEMENT_SIZE;  
                              }
                              
                              ret = spromregister(0, (U8*)pCert, (U32)-2, (U8*)&installidmap);
                              if (ret > 0)
                              {
                                 pCert += (U32)ret;
                                 *tp++ = (U8)(installidmap >> 8);
                                 *tp++ = (U8)(installidmap & 0xFF);
                                 memcpy(tp, pCert, installidmap);
                                 tp += installidmap;
                              }
                           }
                           
                           paramnamed = (U16)(tp - tb - 2);
                           *tb++ = (U8)(paramnamed >> 8);
                           *tb++ = (U8)(paramnamed & 0xFF);
                           paramnamed -= 2;
                           *tb++ = (U8)(paramnamed >> 8);
                           *tb   = (U8)(paramnamed & 0xFF);
                        }
                     }
                  }
                  #endif  
               #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               case 1:
               #endif
                  
                  #if (SHARKSSL_TLS_1_3 && SHARKSSL_USE_ECC)
                  #if SHARKSSL_TLS_1_2
                  
                  if (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
                  #endif
                  {
                     *tp++ = (U8)(reboothandler >> 8);
                     *tp++ = (U8)(reboothandler & 0xFF);
                     tb = tp;
                     tp += 4;
                     configvdcdc2.XY = NULL;
                     
                     #if SHARKSSL_ECC_USE_CURVE448
                     configvdcdc2.k = hsParam(o)->prot.tls13.privKeyCURVE448;
                     i = configvdcdc2.xLen = SHARKSSL_CURVE448_POINTLEN;
                     configvdcdc2.curveType = TLS_NAMEDCURVE_CURVE448;
                     *tp++ = (U8)(configvdcdc2.curveType >> 8);
                     *tp++ = (U8)(configvdcdc2.curveType & 0xFF);
                     *tp++ = (U8)(i >> 8);
                     *tp++ = (U8)(i & 0xFF);
                     
                     SharkSslECDHParam_ECDH(&configvdcdc2, signalpreserve, tp);
                     tp += i;
                     #endif
                     #if SHARKSSL_ECC_USE_SECP384R1
                     configvdcdc2.k = hsParam(o)->prot.tls13.privKeySECP384R1;
                     i = configvdcdc2.xLen = SHARKSSL_SECP384R1_POINTLEN;
                     configvdcdc2.curveType = restoretrace;
                     *tp++ = (U8)(configvdcdc2.curveType >> 8);
                     *tp++ = (U8)(configvdcdc2.curveType & 0xFF);
                     i <<= 1; i++;
                     *tp++ = (U8)(i >> 8);
                     *tp++ = (U8)(i & 0xFF);
                     *tp++ = SHARKSSL_EC_POINT_UNCOMPRESSED;
                     i--;
                     
                     SharkSslECDHParam_ECDH(&configvdcdc2, signalpreserve, tp);
                     tp += i;
                     #endif
                     #if SHARKSSL_ECC_USE_CURVE25519
                     configvdcdc2.k = hsParam(o)->prot.tls13.privKeyCURVE25519;
                     i = configvdcdc2.xLen = SHARKSSL_CURVE25519_POINTLEN;
                     configvdcdc2.curveType = TLS_NAMEDCURVE_CURVE25519;
                     *tp++ = (U8)(configvdcdc2.curveType >> 8);
                     *tp++ = (U8)(configvdcdc2.curveType & 0xFF);
                     *tp++ = (U8)(i >> 8);
                     *tp++ = (U8)(i & 0xFF);
                     
                     SharkSslECDHParam_ECDH(&configvdcdc2, signalpreserve, tp);
                     tp += i;
                     #endif
                     #if SHARKSSL_ECC_USE_SECP256R1
                     configvdcdc2.k = hsParam(o)->prot.tls13.privKeySECP256R1;
                     i = configvdcdc2.xLen = SHARKSSL_SECP256R1_POINTLEN;
                     configvdcdc2.curveType = spannedpages;
                     *tp++ = (U8)(configvdcdc2.curveType >> 8);
                     *tp++ = (U8)(configvdcdc2.curveType & 0xFF);
                     i <<= 1; i++;
                     *tp++ = (U8)(i >> 8);
                     *tp++ = (U8)(i & 0xFF);
                     *tp++ = SHARKSSL_EC_POINT_UNCOMPRESSED;
                     i--;
                     
                     SharkSslECDHParam_ECDH(&configvdcdc2, signalpreserve, tp);
                     tp += i;
                     #endif
                     
                     paramnamed = (U16)(tp - tb - 2);
                     *tb++ = (U8)(paramnamed >> 8);
                     *tb++ = (U8)(paramnamed & 0xFF);
                     paramnamed -= 2;
                     *tb++ = (U8)(paramnamed >> 8);
                     *tb   = (U8)(paramnamed & 0xFF);
                  }
                  #endif  
            #if SHARKSSL_RANDOMIZE_EXTENSIONS
                  break;

               default:
                  break;
            }
            #endif
         }

         
         #if (SHARKSSL_TLS_1_3 && SHARKSSL_ENABLE_SESSION_CACHE)
         tb = (U8*)0;
         if ((o->session)
             #if SHARKSSL_TLS_1_2
             && (SharkSslSession_isProtocol(o->session, SHARKSSL_PROTOCOL_TLS_1_3))
             #endif
            )
         {
            now_ccLen = (U32)baGetUnixTime();
            if (now_ccLen < o->session->prot.tls13.expiration)
            {
               #if 0
               *tp++ = (U8)(rm200hwint >> 8);
               *tp++ = (U8)(rm200hwint & 0xFF);
               *tp++ = 0x00;
               *tp++ = 0x02;  
               *tp++ = 0x01;  
               *tp++ = 0x01;  
               
               #endif
               *tp++ = (U8)(allocconsistent >> 8);
               *tp++ = (U8)(allocconsistent & 0xFF);
               tb = tp++;
               tp++;  
               paramnamed = 6 + o->session->prot.tls13.ticketLen;  
               *tp++ = (U8)(paramnamed >> 8);
               *tp++ = (U8)(paramnamed & 0xFF);
               paramnamed -= 6;
               *tp++ = (U8)(paramnamed >> 8);
               *tp++ = (U8)(paramnamed & 0xFF);
               memcpy(tp, o->session->prot.tls13.ticket, paramnamed);
               tp += paramnamed;
               now_ccLen -= o->session->firstAccess;
               now_ccLen *= 1000;  
               now_ccLen += o->session->prot.tls13.ticketAgeAdd;
               *tp++ = (U8)(now_ccLen >> 24);
               *tp++ = (U8)(now_ccLen >> 16);
               *tp++ = (U8)(now_ccLen >> 8);
               *tp++ = (U8)(now_ccLen & 0xFF);
               i = sharkssl_getHashLen(o->session->cipherSuite->hashID) + 1;  
               *tp++ = (U8)(i >> 8);
               *tp++ = (U8)(i & 0xFF);
               baAssert(i <= 0x100);
               *tp++ = (U8)--i;  
               tp += i;  
               
               paramnamed = (U16)(tp - tb - 2);
               *tb++ = (U8)(paramnamed >> 8);
               *tb   = (U8)(paramnamed & 0xFF);
               tb = tp - i;  
            }
            else
            {
               o->session = 0;
            }
         }
         #endif  

         
         paramnamed = (U16)(tp - afterhandler - 2);
         *afterhandler++ = (U8)(paramnamed >> 8);
         *afterhandler   = (U8)(paramnamed & 0xFF);
         
         hsLen = (U16)(tp - sp);
         *(sp - 2) = (U8)(hsLen >> 8);
         *(sp - 1) = (U8)(hsLen & 0xFF);
         
         paramnamed = (U16)(hsLen - traceentry);
         *(sp + 2) = (U8)(paramnamed >> 8);
         *(sp + 3) = (U8)(paramnamed & 0xFF);

         #if (SHARKSSL_TLS_1_3 && SHARKSSL_ENABLE_SESSION_CACHE)
         
         if (tb)
         {
            baAssert(o->session);
            ics = o->session->cipherSuite->hashID;
            paramnamed = sharkssl_getHashLen(ics);
            
            sharkssl_hash(tb, sp, (U16)(tb - sp - 3), ics);
            
            SharkSslCon_calcEarlySecret(o, o->session->prot.tls13.PSK, ics);
            
            if (sharkssl_HMAC(ics, tb, paramnamed, sharkSslHSParam->prot.tls13.HSSecret, paramnamed, tb) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
            }
         }
         #endif  

         ioremapresource(sharkSslHSParam, sp, hsLen);
         o->inBuf.temp = (U16)(hsLen + clkctrlmanaged);
         o->state = trampolinehandler;
         return SharkSslCon_Handshake;
      }

      
      if ( (SharkSsl_isClient(o->sharkSsl)) 
           &&
           (
              0
              #if (SHARKSSL_TLS_1_2 && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
              ||
              (
              #if SHARKSSL_TLS_1_3
              (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) &&
              #endif
              ((o->state == configcwfon) && (registeredevent) &&
               (*registeredevent == logicmembank))
              )
              #endif
              #if SHARKSSL_TLS_1_3
              ||
              (
              #if SHARKSSL_TLS_1_2
              (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) &&
              #endif
              (((o->state == logicmembank) && (registeredevent) &&
                 (*registeredevent == parsebootinfo))
              ||
              ((o->state == loongson3notifier) && (*registeredevent == SHARKSSL_HANDSHAKETYPE_NEW_SESSION_TICKET)))
              )
              #endif
           ) )
      {
         o->state = *registeredevent;
      }
      else
      #endif   
      #if SHARKSSL_SSL_SERVER_CODE
      if ((o->state == loongson3notifier)
          && (*registeredevent == pciercxcfg070)
          #if SHARKSSL_SSL_CLIENT_CODE
          && (SharkSsl_isServer(o->sharkSsl))
          #endif
         )
      {
         
         baAssert(!(o->flags & audiosuspend));
         #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
         if (o->flags & skciphersetkey)
         {
            o->flags &= ~skciphersetkey;
         }
         else
         #endif
         {
            return securememblock(o, SHARKSSL_ALERT_LEVEL_WARNING, SHARKSSL_ALERT_NO_RENEGOTIATION);
         }
         #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
         o->flags |= platformdevice;
         o->flags &= ~(startqueue | switcheractivation);
         o->state = pciercxcfg070;
         #endif
      }
      else
      #endif  
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         regionfixed:
         return savedconfig(o, SHARKSSL_ALERT_ILLEGAL_PARAMETER);
      }
   }

   registeredevent++;
   atagsprocfs--;

   if (atagsprocfs < 3)
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      goto regionfixed;
   }

   
   if (*registeredevent++)
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      goto regionfixed;
   }

   hsDataLen  = (U16)(*registeredevent++) << 8;
   hsDataLen += (*registeredevent++);
   atagsprocfs -= 3;

   if (atagsprocfs < hsDataLen)
   {
      if ((o->state != pciercxcfg070) && (o->state != trampolinehandler) && 
          (o->state != switcherdevice) && (o->state != loongson3notifier))
      {
         
         o->flags |= SHARKSSL_FLAG_FRAGMENTED_HS_RECORD;
         registeredevent -= 4;  
         if (o->inBuf.data != registeredevent)
         {
            
            o->inBuf.dataLen -= (U16)(registeredevent - o->inBuf.data);
            o->inBuf.data = registeredevent;
         }
         return SharkSslCon_Handshake;
      }
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      goto regionfixed;
   }

   atagsprocfs -= hsDataLen;
   tp = registeredevent - traceentry;
   hsLen = hsDataLen + traceentry;

   baAssert(!microresources(&o->outBuf));
   #if (SHARKSSL_TLS_1_2 && SHARKSSL_ENABLE_SECURE_RENEGOTIATION)
   if (
      #if SHARKSSL_TLS_1_3
      (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) &&
      #endif
      (o->flags & shutdownlevel)
      )
   {
      baAssert(o->flags & platformdevice);
      o->flags &= ~shutdownlevel;
      reportsyscall(&o->tmpBuf, &o->outBuf);
      guestconfig5(&o->outBuf);  
      o->outBuf = o->tmpBuf;
      memset(&o->tmpBuf, 0, sizeof(SharkSslBuf));  
   }
   #endif

   #if SHARKSSL_TLS_1_3
   if (
      #if SHARKSSL_TLS_1_2
      (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) &&
      #endif
      (o->state == SHARKSSL_HANDSHAKETYPE_NEW_SESSION_TICKET)
      )
   {
      sharkSslHSParam = NULL;
      afterhandler = NULL;
   }
   else
   #endif
   {
      sharkSslHSParam = hsParam(o);
      afterhandler = (U8*)(sharkSslHSParam + 1);
   }

   #if (SHARKSSL_TLS_1_2 && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
   if (
      #if SHARKSSL_TLS_1_3
      (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) &&
      #endif
      ((pciercxcfg070 != o->state) &&
       (switcherdevice     != o->state))
      )
   {
      baAssert(0 == monadiccheck(sharkSslHSParam->certParam.certKey.expLen));
      #if SHARKSSL_ENABLE_RSA
      #if (!SHARKSSL_USE_ECC)
      baAssert(machinekexec(sharkSslHSParam->certParam.certKey.expLen));
      #else
      if (machinekexec(sharkSslHSParam->certParam.certKey.expLen))
      #endif
      {
         afterhandler += supportedvector(sharkSslHSParam->certParam.certKey.modLen);
         afterhandler += claimresource(mousethresh(sharkSslHSParam->certParam.certKey.expLen));
      }
      #if SHARKSSL_USE_ECC
      else
      #endif
      #endif  
      #if SHARKSSL_USE_ECC
      if (machinereboot(sharkSslHSParam->certParam.certKey.expLen))
      {
         afterhandler += (U16)(attachdevice(sharkSslHSParam->certParam.certKey.modLen)) * 2;
      }
      #endif
      #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
      if ((sharkSslHSParam->cipherSuite) && (sharkSslHSParam->cipherSuite->flags & cleandcache))
      #endif
      {
         #if SHARKSSL_ENABLE_DHE_RSA
         if (sharkSslHSParam->cipherSuite->flags & percpudevid)
         {
            afterhandler += sharkSslHSParam->prot.tls12.dhParam.pLen;  
            #if SHARKSSL_SSL_CLIENT_CODE
            if (SharkSsl_isClient(o->sharkSsl))
            {
               afterhandler += sharkSslHSParam->prot.tls12.dhParam.pLen;    
               afterhandler += sharkSslHSParam->prot.tls12.dhParam.gLen;    
            }
            #endif  
         }
         #endif  

         #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
         {
            afterhandler += sharkSslHSParam->ecdhParam.xLen;  
            #if SHARKSSL_SSL_CLIENT_CODE
            if (SharkSsl_isClient(o->sharkSsl))
            {
               afterhandler += sharkSslHSParam->ecdhParam.xLen;  
            }
            #endif  
            #if (SHARKSSL_ECC_USE_SECP521R1 && (SHARKSSL_ALIGNMENT >= 4))
            afterhandler = (U8*)regulatorconsumer(afterhandler);
            #endif
         }
         #endif
      }
   }
   #endif

   
   baAssert(pcmciaplatform(afterhandler));

   switch (o->state)
   {
      #if SHARKSSL_TLS_1_2
      #if SHARKSSL_SSL_SERVER_CODE
      case pciercxcfg070:
         baAssert(SharkSsl_isServer(o->sharkSsl));
         baAssert(serial2platform(&o->inBuf));
         baAssert(pcmciaplatform(func3fixup(&o->inBuf)));
         baAssert(pcmciaplatform(func3fixup(&o->outBuf)));

         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         o->reqMajor = *registeredevent++;
         o->reqMinor = *registeredevent++;
         hsDataLen -= 2;

         if (o->reqMajor != 3)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_hs_alert_handshake_failure;
         }
         o->major = 3;

         if (o->reqMinor >= 3)
         {
            o->minor = 3;  
         }
         else
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            
            _sharkssl_hs_alert_handshake_failure:
            return savedconfig(o, SHARKSSL_ALERT_HANDSHAKE_FAILURE);
         }

         breakpointhandler(sharkSslHSParam);
         ioremapresource(sharkSslHSParam, tp, hsLen);

         
         memset(afterhandler, 0, (4 * (sizeof(SharkSslCertParsed**) + sizeof(SHARKSSL_WEIGHT))));
         afterhandler += (4 * (sizeof(SharkSslCertParsed**) + sizeof(SHARKSSL_WEIGHT)));

         SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
         for (tp = afterhandler, link = SingleListEnumerator_getElement(&e);
              link;
              link = SingleListEnumerator_nextElement(&e), tp += sizeof(SHARKSSL_WEIGHT))
         {
            *(SHARKSSL_WEIGHT*)tp = 0;

            
            #if SHARKSSL_ENABLE_RSA
            if (((SharkSslCertList*)link)->certP.keyType == ahashchild)
            {
               
               *(SHARKSSL_WEIGHT*)tp = trainingneeded + ahashchild;
            }
            #if SHARKSSL_USE_ECC
            else
            #endif
            #endif
            #if SHARKSSL_USE_ECC
            if (((SharkSslCertList*)link)->certP.keyType == compatrestart)
            {
               
               *(SHARKSSL_WEIGHT*)tp = compatrestart +
                                       (((SharkSslCertList*)link)->certP.keyOID) +
                                       (U16)(((SharkSslCertList*)link)->certP.signatureAlgo);
            }
            #endif

            
            {
               if (((SharkSslCertList*)link)->certP.hashAlgo <= presentpages)
               {
                  *(SHARKSSL_WEIGHT*)tp |= smbuswrite;
               }
            }
         }
         baAssert(tp != afterhandler);  
         *(SHARKSSL_WEIGHT*)tp = (SHARKSSL_WEIGHT)-1;  

         baAssert(!(o->flags & startqueue));
         if (hsDataLen < (1 + SHARKSSL_RANDOM_LEN))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         memcpy(sharkSslHSParam->prot.tls12.clientRandom, registeredevent, SHARKSSL_RANDOM_LEN);  
         registeredevent += SHARKSSL_RANDOM_LEN;
         setupinterface = *registeredevent++;
         hsDataLen -= (1 + SHARKSSL_RANDOM_LEN);

         if (setupinterface > 0)
         {
            if ((hsDataLen < setupinterface) || (setupinterface > SHARKSSL_MAX_SESSION_ID_LEN))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }

            #if SHARKSSL_ENABLE_SESSION_CACHE
            #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
            if (o->flags & platformdevice)
            {
               
               if (o->session)
               {
                  SharkSslSession_release(o->session, o->sharkSsl);
               }
               o->session = (SharkSslSession*)0;
            }
            else
            #endif
            {
               o->session = latchgpiochip(&o->sharkSsl->sessionCache, o, registeredevent, setupinterface);
               if (o->session)
               {
                  o->flags |= startqueue;
               }
            }
            #endif

            registeredevent += setupinterface;
            hsDataLen -= setupinterface;
         }

         
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         tb = registeredevent;  
         paramnamed  = (U16)(*registeredevent++) << 8;
         paramnamed += *registeredevent++;
         hsDataLen -= 2;

         if ((paramnamed == 0) || (paramnamed & 0x01) || (hsDataLen < paramnamed))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         registeredevent    += paramnamed;
         hsDataLen -= paramnamed;

         
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         setupinterface = *registeredevent++;
         hsDataLen--;

         if ((hsDataLen < setupinterface) || (setupinterface == 0))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         
         do
         {
            paramnamed = *registeredevent++;  
            hsDataLen--;
            setupinterface--;
         } while ((setupinterface) && (paramnamed != cminstclear));

         if (paramnamed != cminstclear)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_hs_alert_handshake_failure;
         }

         registeredevent += setupinterface;
         hsDataLen -= setupinterface;

         if (hsDataLen)
         {  
            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed  = (U16)(*registeredevent++) << 8;
            paramnamed += *registeredevent++;
            hsDataLen -= 2;

            if (hsDataLen < paramnamed)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }

            
            i = (U16)handleptrauth(o, (SHARKSSL_WEIGHT*)afterhandler, registeredevent, paramnamed);
            if (i != 0)
            {
               #if SHARKSSL_ENABLE_ALPN_EXTENSION
               if ((U16)-2 == i)  
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return savedconfig(o, SHARKSSL_ALERT_NO_APPLICATION_PROTOCOL);
               }
               #endif
               goto _sharkssl_hs_alert_handshake_failure;
            }
            hsDataLen -= paramnamed;
         }

         #if SHARKSSL_ENABLE_SNI
         
         i = 0;
         tp = afterhandler;
         while (*(SHARKSSL_WEIGHT*)tp != (SHARKSSL_WEIGHT)-1)
         {
            if (*(SHARKSSL_WEIGHT*)tp & clearevent)
            {
               i++;
               break;
            }
            tp += sizeof(SHARKSSL_WEIGHT);
         }
         #endif

         
         tp = afterhandler;
         while (*(SHARKSSL_WEIGHT*)tp != (SHARKSSL_WEIGHT)-1)
         {
            if ( ( (*(SHARKSSL_WEIGHT*)tp)
                     && 
                     (
                     (!(*(SHARKSSL_WEIGHT*)tp & trainingneeded))
                     || ((o->minor >= 3) && (!(*(SHARKSSL_WEIGHT*)tp & smbuswrite)))
                     )
                  )
               #if SHARKSSL_ENABLE_SNI
               ||
                  ((i > 0) && (!(*(SHARKSSL_WEIGHT*)tp & clearevent)))
               #endif
               )

            {
               *(SHARKSSL_WEIGHT*)tp = 0;
            }
            tp += sizeof(SHARKSSL_WEIGHT);
         }

         
         tp = afterhandler;
         afterhandler -= (4 * (sizeof(SharkSslCertParsed**) + sizeof(SHARKSSL_WEIGHT)));

         SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
         for (link = SingleListEnumerator_getElement(&e);
               link;
               link = SingleListEnumerator_nextElement(&e), tp += sizeof(SHARKSSL_WEIGHT))
         {
            #if SHARKSSL_ENABLE_RSA
            if (((SharkSslCertList*)link)->certP.keyType == ahashchild)
            {
               
               if (((SharkSslCertList*)link)->certP.signatureAlgo == entryearly)
               {
                  if ((*(SHARKSSL_WEIGHT*)tp) && (*(SHARKSSL_WEIGHT*)tp > *(SHARKSSL_WEIGHT*)(afterhandler + 4 * sizeof(SharkSslCertParsed**))))
                  {
                     *(SHARKSSL_WEIGHT*)(afterhandler + 4 * sizeof(SharkSslCertParsed**)) = *(SHARKSSL_WEIGHT*)tp;
                     *(SharkSslCertParsed**)afterhandler = &(((SharkSslCertList*)link)->certP);
                  }
               }
            }
            #if (SHARKSSL_USE_ECC || SHARKSSL_ENABLE_ECDSA)
            else
            #endif
            #endif
            #if (SHARKSSL_USE_ECC || SHARKSSL_ENABLE_ECDSA)
            if (((SharkSslCertList*)link)->certP.keyType == compatrestart)
            {
               
               if (((SharkSslCertList*)link)->certP.signatureAlgo == accessactive)
               {
                  if ((*(SHARKSSL_WEIGHT*)tp) && (*(SHARKSSL_WEIGHT*)tp > *(SHARKSSL_WEIGHT*)(afterhandler + 4 * sizeof(SharkSslCertParsed**) + 2 * sizeof(SHARKSSL_WEIGHT))))
                  {
                     *(SHARKSSL_WEIGHT*)(afterhandler + 4 * sizeof(SharkSslCertParsed**) + 2 * sizeof(SHARKSSL_WEIGHT)) = *(SHARKSSL_WEIGHT*)tp;
                     *(SharkSslCertParsed**)(afterhandler + 2 * sizeof(SharkSslCertParsed**)) = &(((SharkSslCertList*)link)->certP);
                  }
               }
               #if SHARKSSL_ENABLE_RSA
               
               else if (((SharkSslCertList *)link)->certP.signatureAlgo == entryearly)
               {
                  if ((*(SHARKSSL_WEIGHT*)tp) && (*(SHARKSSL_WEIGHT*)tp > *(SHARKSSL_WEIGHT*)(afterhandler + 4 * sizeof(SharkSslCertParsed**) + 1 * sizeof(SHARKSSL_WEIGHT))))
                  {
                     *(SHARKSSL_WEIGHT*)(afterhandler + 4 * sizeof(SharkSslCertParsed**) + 1 * sizeof(SHARKSSL_WEIGHT)) = *(SHARKSSL_WEIGHT*)tp;
                     *(SharkSslCertParsed**)(afterhandler + 1 * sizeof(SharkSslCertParsed**)) = &(((SharkSslCertList*)link)->certP);
                  }
               }
               #endif
            }
            #endif
         }
         baAssert(*(SHARKSSL_WEIGHT*)tp == (SHARKSSL_WEIGHT)-1);  

         
         baAssert(!(sharkSslHSParam->cipherSuite));
         baAssert(SHARKSSL_DIM_ARR(genericsuspend) < 0xFF);
         ics = 0xFF;
         crLen = 0;  
         #define crLen_FLAG_stream_cipher_found    0x01
         #define crLen_FLAG_RSA_ciphersuite_found  0x02
         #define crLen_FLAG_stream_RSA_found       0x04

         paramnamed  = (U16)(*tb++) >> 8;
         paramnamed += *tb++;
         while (paramnamed)
         {
            i  = (U16)(*tb++) << 8;
            i +=  *tb++;
            paramnamed -= 2;

            #if SHARKSSL_ENABLE_SESSION_CACHE
            if (o->flags & startqueue)
            {
               baAssert(o->session);
               
               if ((o->session->cipherSuite) && (i == o->session->cipherSuite->id))
               {
                  sharkSslHSParam->cipherSuite = o->session->cipherSuite;
                  break;
               }
            }
            else
            #endif
            {
               if (deviceunregister == i)
               {
                  #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
                  if (o->flags & platformdevice)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto _sharkssl_hs_alert_handshake_failure;
                  }
                  #endif
                  o->flags |= aarch32ptrace;
               }
               #if SHARKSSL_ENABLE_SELECT_CIPHERSUITE
               else if (o->cipherSelCtr)
               {
                  
                  for (now_ccLen = 0; now_ccLen < o->cipherSelCtr; now_ccLen++)
                  {
                     setupinterface = o->cipherSelection[now_ccLen];
                     if ( (i == genericsuspend[setupinterface].id)
                     #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
                           && ((sharkSslHSParam->ecdhParam.xLen) || (!(genericsuspend[setupinterface].flags & irqhandlerfixup)))
                     #endif
                        )
                     {
                        if ((now_ccLen < ics) && (0 == SharkSslHSParam_setCert(sharkSslHSParam, (SharkSslCertParsed**)afterhandler, genericsuspend[setupinterface].flags)))
                        {
                           
                           ics = (U8)now_ccLen;
                        }
                     }
                  }
               }
               #endif
               else
               {
                  for (now_ccLen = 0; now_ccLen < SHARKSSL_DIM_ARR(genericsuspend); now_ccLen++)
                  {
                     if ( (i == genericsuspend[now_ccLen].id)
                     #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
                           && ((sharkSslHSParam->ecdhParam.xLen) || (!(genericsuspend[now_ccLen].flags & irqhandlerfixup)))
                     #endif
                        )
                     {
                        
                        #if SHARKSSL_ENABLE_RSA
                        if ((o->flags & uprobeabort) && (genericsuspend[now_ccLen].flags & percpudevid))
                        {
                           if ((!(crLen & crLen_FLAG_RSA_ciphersuite_found)) || ((U8)now_ccLen < ics))
                           {
                              if (0 == SharkSslHSParam_setCert(sharkSslHSParam, (SharkSslCertParsed**)afterhandler, genericsuspend[now_ccLen].flags))
                              {
                                 crLen |= crLen_FLAG_RSA_ciphersuite_found;
                                 ics = (U8)now_ccLen;
                              }
                           }
                        }
                        else
                        #endif
                        {
                           if ((now_ccLen < ics)
                                 #if SHARKSSL_ENABLE_RSA
                                 && (!(crLen & crLen_FLAG_RSA_ciphersuite_found))
                                 #endif
                                 && (0 == SharkSslHSParam_setCert(sharkSslHSParam, (SharkSslCertParsed**)afterhandler, genericsuspend[now_ccLen].flags))
                              )
                           {
                              ics = (U8)now_ccLen;
                           }
                        }
                     }
                  }  
               }
            }
         }
         #undef crLen_FLAG_stream_cipher_found
         #undef crLen_FLAG_RSA_ciphersuite_found
         #undef crLen_FLAG_stream_RSA_found

         if (!(sharkSslHSParam->cipherSuite))  
         {
            if (ics == 0xFF)  
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto _sharkssl_hs_alert_handshake_failure;
            }
            #if SHARKSSL_ENABLE_SELECT_CIPHERSUITE
            if (o->cipherSelCtr)
            {
               sharkSslHSParam->cipherSuite = (SharkSslCipherSuite*)&genericsuspend[o->cipherSelection[ics]];
            }
            else
            #endif
            {
               sharkSslHSParam->cipherSuite = (SharkSslCipherSuite*)&genericsuspend[ics];
            }
         }

         
         if (hsDataLen > 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return savedconfig(o, SHARKSSL_ALERT_DECODE_ERROR);
         }

         o->inBuf.temp = 0;

         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (!(o->flags & startqueue))
         {
            o->session = sa1111device(&o->sharkSsl->sessionCache, o, 0, 0);
         }
         #endif

         
         crLen = paramnamed = 0;  
         if (o->flags & aarch32ptrace)
         {
            #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
            if (o->flags & platformdevice)
            {
               crLen = 1 + 2 * SHARKSSL_FINISHED_MSG_LEN_TLS_1_2;
               
               paramnamed += 2 + 2 + (U16)crLen; 
            }
            else
            #endif
            {
               paramnamed += SHARKSSL_DIM_ARR(registeraudio);
            }
         }
         #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
         {
            paramnamed += SHARKSSL_DIM_ARR(resetsources);
         }
         #endif
         #if SHARKSSL_ENABLE_ALPN_EXTENSION
         if (o->rALPN)
         {
            paramnamed += *o->rALPN + 7;
            memcpy(afterhandler, o->rALPN, *o->rALPN + 1);
         }
         #endif
         sp = o->inBuf.data + clkctrlmanaged;
         tp = sp + traceentry;
         *tp++ = o->major;
         *tp++ = o->minor;

         now_ccLen = (U32)baGetUnixTime();
         *tp++ = (U8)(now_ccLen >> 24);
         *tp++ = (U8)(now_ccLen >> 16);
         *tp++ = (U8)(now_ccLen >> 8);
         *tp++ = (U8)(now_ccLen & 0xFF);

         
         if (sharkssl_rng(tp, (SHARKSSL_RANDOM_LEN - 4)) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            resvdexits(o);
            return SharkSslCon_Error;
         }
         tp += (SHARKSSL_RANDOM_LEN - 4);

         
         memcpy(sharkSslHSParam->prot.tls12.serverRandom, tp - SHARKSSL_RANDOM_LEN, SHARKSSL_RANDOM_LEN);

         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (o->session)  
         {
            *tp++ = SHARKSSL_MAX_SESSION_ID_LEN;
            memcpy(tp, o->session->prot.tls12.id, SHARKSSL_MAX_SESSION_ID_LEN);
            tp += SHARKSSL_MAX_SESSION_ID_LEN;
         }
         else
         #endif
         {
            *tp++ = 0;
         }

         *tp++ = (U8)(sharkSslHSParam->cipherSuite->id >> 8);
         *tp++ = (U8)(sharkSslHSParam->cipherSuite->id & 0xFF);
         *tp++ = 0; 

         
         if (paramnamed)
         {
            *tp++ = (paramnamed >> 8);
            *tp++ = (paramnamed & 0xFF);
            if (o->flags & aarch32ptrace)
            {
               #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
               if (o->flags & platformdevice)
               {
                  *tp++ = (featurespresent >> 8);
                  *tp++ = (featurespresent & 0xFF);
                  *tp++ = 0x00;
                  *tp++ = crLen & 0xFF;
                  *tp++ = (--crLen) & 0xFF;
                  baAssert((crLen & 1) == 0);
                  crLen >>= 1;
                  memcpy(tp, o->clientVerifyData, crLen);
                  tp+= crLen;
                  memcpy(tp, o->serverVerifyData, crLen);
                  tp+= crLen;
               }
               else
               #endif
               {
                  memcpy(tp, registeraudio, SHARKSSL_DIM_ARR(registeraudio));
                  tp += SHARKSSL_DIM_ARR(registeraudio);
               }
            }
            #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
            if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
            {
               memcpy(tp, resetsources, SHARKSSL_DIM_ARR(resetsources));
               tp += SHARKSSL_DIM_ARR(resetsources);
            }
            #endif
            #if SHARKSSL_ENABLE_ALPN_EXTENSION
            if (o->rALPN)
            {
               *tp++ = (U8)(clkdmclear >> 8);
               *tp++ = (U8)(clkdmclear & 0xFF);
               *tp++ = 0x00;
               *tp++ = *afterhandler + 3;  
               *tp++ = 0x00;
               *tp++ = *afterhandler + 1;  
               memcpy(tp, afterhandler, *afterhandler + 1);
               tp += *afterhandler + 1;
            }
            #endif
         }
         i = (U16)(tp - sp) - traceentry;
         sp[0] = trampolinehandler;
         sp[1] = 0;
         sp[2] = (U8)(i >> 8);
         sp[3] = (U8)(i & 0xFF);
         

         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (o->flags & startqueue)
         {
            
            memcpy(sharkSslHSParam->prot.tls12.masterSecret, o->session->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN);
            
            paramnamed = disableclean(sharkSslHSParam->cipherSuite);
            if (allocalloc(o, sharkSslHSParam->prot.tls12.sharedSecret, paramnamed,
                                            sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN,
                                            sharkSslHSParam->prot.tls12.serverRandom,
                                            sharkSslHSParam->prot.tls12.clientRandom) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }

            
            i += traceentry;
            tp = templateentry(o, controllegacy, sp - clkctrlmanaged, i);
            ioremapresource(sharkSslHSParam, tp, i);
            tp += i;

            #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
            baAssert(!(o->flags & platformdevice));
            #endif

            if (sanitisependbaser(o, rodatastart, tp))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }

            o->state = switcherdevice;
         }
         else  
         #endif
         {
            baAssert(sharkSslHSParam->certParsed);
            
            i = sharkSslHSParam->certParsed->msgLen;
            *tp++ = parsebootinfo;
            *tp++ = 0x00;
            *tp++ = (i >> 8);
            *tp++ = (i & 0xFF);
            if (fixupresources(sharkSslHSParam->certParsed->cert, i, tp))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }
            tp += i;
            

            
            if (0 == interrupthandler(&(sharkSslHSParam->certKey), sharkSslHSParam->certParsed->cert))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return SharkSslCon_CertificateError;
            }

            #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
            if (sharkSslHSParam->cipherSuite->flags & cleandcache)
            {
               
               tb = tp;
               tp += traceentry;  
               #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
               if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
               {
                  baAssert(sharkSslHSParam->ecdhParam.curveType);
                  baAssert(sharkSslHSParam->ecdhParam.xLen);
                  sharkSslHSParam->ecdhParam.k = afterhandler;
                  afterhandler += sharkSslHSParam->ecdhParam.xLen;
                  #if (SHARKSSL_ECC_USE_SECP521R1 && (SHARKSSL_ALIGNMENT >= 4))
                  afterhandler = (U8*)regulatorconsumer(afterhandler);
                  #endif
                  *tp++ = mcbsp5hwmod;
                  *tp++ = (sharkSslHSParam->ecdhParam.curveType >> 8);
                  *tp++ = (sharkSslHSParam->ecdhParam.curveType & 0xFF);
                  #if SHARKSSL_ECC_USE_EDWARDS
                  if ((sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE25519) || 
                      (sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE448))
                  {
                     paramnamed = sharkSslHSParam->ecdhParam.xLen;
                     *tp++ = (U8)(paramnamed);
                     i = 4;  
                  }
                  else
                  #endif
                  {
                     paramnamed = (U16)(sharkSslHSParam->ecdhParam.xLen << 1);
                     baAssert(paramnamed < 0x00FF);
                     *tp++ = (U8)(paramnamed + 1);
                     *tp++ = SHARKSSL_EC_POINT_UNCOMPRESSED;
                     i = 5;  
                  }
                  
                  if ((int)SharkSslCon_AllocationError ==
                      SharkSslECDHParam_ECDH(&(sharkSslHSParam->ecdhParam), signalpreserve, tp))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return SharkSslCon_AllocationError;
                  }
               }
               else
               #endif
               {
                  #if SHARKSSL_ENABLE_DHE_RSA
                  U8 *g;

                  
                  SharkSslDHParam_setParam(&(sharkSslHSParam->prot.tls12.dhParam));
                  
                  baAssert(pcmciaplatform(afterhandler));
                  sharkSslHSParam->prot.tls12.dhParam.r = afterhandler;
                  paramnamed = sharkSslHSParam->prot.tls12.dhParam.pLen;
                  afterhandler += paramnamed;
                  i = 6;  
                  *tp++ = (U8)(paramnamed >> 8);
                  *tp++ = (U8)(paramnamed & 0xFF);
                  memcpy(tp, sharkSslHSParam->prot.tls12.dhParam.p, paramnamed);
                  tp += paramnamed;
                  i  += paramnamed;
                  g = sharkSslHSParam->prot.tls12.dhParam.g;
                  crLen = sharkSslHSParam->prot.tls12.dhParam.gLen;
                  while ((0 == *g) && (crLen > 1))
                  {
                     g++;
                     crLen--;
                  }
                  *tp++ = (U8)(crLen >> 8);
                  *tp++ = (U8)(crLen & 0xFF);
                  memcpy(tp, g, crLen);
                  tp += (U16)crLen;
                  i  += (U16)crLen;
                  *tp++ = (U8)(paramnamed >> 8);
                  *tp++ = (U8)(paramnamed & 0xFF);
                  
                  if ((int)SharkSslCon_AllocationError ==
                      SharkSslDHParam_DH(&(sharkSslHSParam->prot.tls12.dhParam), cpucfgexits, tp))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return SharkSslCon_AllocationError;
                  }
                  #else
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
                  #endif
               }
               tp += paramnamed;
               i  += paramnamed;
               
               baAssert(pcmciaplatform(afterhandler));
               memcpy(afterhandler, sharkSslHSParam->prot.tls12.clientRandom, SHARKSSL_RANDOM_LEN);
               memcpy(afterhandler + SHARKSSL_RANDOM_LEN, sharkSslHSParam->prot.tls12.serverRandom, SHARKSSL_RANDOM_LEN);
               memcpy(afterhandler + (2 * SHARKSSL_RANDOM_LEN), (tp - i), i);
               i += (2 * SHARKSSL_RANDOM_LEN);

               sharkSslHSParam->signParam.pCertKey = &(sharkSslHSParam->certKey);  

               
               #if SHARKSSL_ENABLE_RSA
               if (machinekexec(sharkSslHSParam->signParam.pCertKey->expLen))
               {
                  sharkSslHSParam->signParam.signature.hashAlgo = sharkSslHSParam->signParam.signature.signatureAlgo;
                  sharkSslHSParam->signParam.signature.signatureAlgo = entryearly;
               }
               #endif
               #if SHARKSSL_ENABLE_ECDSA
               if (machinereboot(sharkSslHSParam->signParam.pCertKey->expLen))
               {
                  sharkSslHSParam->signParam.signature.signatureAlgo = accessactive;
               }
               #endif
               if (!(sharkSslHSParam->signParam.signature.hashAlgo))
               {
                  sharkSslHSParam->signParam.signature.hashAlgo = presentpages;
               }

               
               if (sharkssl_hash(sharkSslHSParam->signParam.signature.hash, afterhandler, i, sharkSslHSParam->signParam.signature.hashAlgo))
               {
                  return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
               }

               *tp++ = sharkSslHSParam->signParam.signature.hashAlgo;
               *tp++ = sharkSslHSParam->signParam.signature.signatureAlgo;

               sharkSslHSParam->signParam.signature.signature = tp + 2;  
               if (checkactions(&(sharkSslHSParam->signParam)) < 0)
               {
                  return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
               }
               *tp++ = (sharkSslHSParam->signParam.signature.signLen >> 8);
               *tp++ = (sharkSslHSParam->signParam.signature.signLen & 0xFF);
               tp += sharkSslHSParam->signParam.signature.signLen;

               i = (U16)(tp - tb) - traceentry;
               tb[0] = startflags;
               tb[1]= 0;
               tb[2] = (U8)(i >> 8);
               tb[3] = (U8)(i & 0xFF);
               
            }
            #endif

            #if (SHARKSSL_ENABLE_CLIENT_AUTH && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
            if (o->flags & unregistershash)
            {
               static const U8 serialwakeup[] =
               {
                  #if SHARKSSL_ENABLE_ECDSA
                  #if SHARKSSL_USE_SHA_512
                  batterythread, accessactive,
                  #endif
                  #if SHARKSSL_USE_SHA_384
                  probewrite, accessactive,
                  #endif
                  domainnumber, accessactive,
                  presentpages,   accessactive,
                  #endif  
                  #if SHARKSSL_ENABLE_RSA
                  #if SHARKSSL_USE_SHA_512
                  batterythread, entryearly,
                  #endif
                  #if SHARKSSL_USE_SHA_384
                  probewrite, entryearly,
                  #endif
                  domainnumber, entryearly,
                  #if SHARKSSL_USE_SHA1
                  presentpages,   entryearly,
                  #endif
                  #if SHARKSSL_USE_MD5
                  skciphercreate,    entryearly  
                  #endif
                  #endif  
               };

               
               tb = tp;
               tp += traceentry;  
               ics = 0;
               #if SHARKSSL_ENABLE_RSA
               tp[++ics] = ahashchild;
               #endif
               #if SHARKSSL_ENABLE_ECDSA
               {
                  tp[++ics] = compatrestart;
               }
               #endif
               *tp++ = ics;  
               tp += ics;

               
               *tp++ = (U8)(SHARKSSL_DIM_ARR(serialwakeup) >> 8);
               *tp++ = (U8)(SHARKSSL_DIM_ARR(serialwakeup) & 0xFF);
               memcpy(tp, serialwakeup, SHARKSSL_DIM_ARR(serialwakeup));
               tp += SHARKSSL_DIM_ARR(serialwakeup);
               

               #if SHARKSSL_ENABLE_CA_LIST
               if (o->caListCertReq)
               {
                  SharkSslCert pCert;
                  U8 *cp;

                  #if SHARKSSL_ENABLE_CERTSTORE_API
                  baAssert(SHARKSSL_CA_LIST_PTR_SIZE == claimresource(SHARKSSL_CA_LIST_PTR_SIZE));
                  #endif
                  if ((o->caListCertReq[0] != SHARKSSL_CA_LIST_INDEX_TYPE)
                        #if SHARKSSL_ENABLE_CERTSTORE_API
                        && (o->caListCertReq[0] != SHARKSSL_CA_LIST_PTR_TYPE)
                        #endif
                     )
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
                  }
                  now_ccLen = ((U16)(o->caListCertReq[2]) << 8) + o->caListCertReq[3];
                  if (0 == now_ccLen)  
                  {
                     goto _sharkssl_empty_CA_DN;
                  }
                  paramnamed = 2;  
                  cp = (U8*)&(o->caListCertReq[4]);
                  while (now_ccLen--)
                  {
                     int ret;
                     U16 installidmap;
                     #if SHARKSSL_ENABLE_CERTSTORE_API
                     if (o->caListCertReq[0] == SHARKSSL_CA_LIST_PTR_TYPE)
                     {
                        pCert = *(SharkSslCert*)&cp[SHARKSSL_CA_LIST_NAME_SIZE];
                        cp += SHARKSSL_CA_LIST_NAME_SIZE + SHARKSSL_CA_LIST_PTR_SIZE;  
                     }
                     else
                     #endif
                     {
                        crLen  = (U32)cp[SHARKSSL_CA_LIST_NAME_SIZE+0] << 24;
                        crLen += (U32)cp[SHARKSSL_CA_LIST_NAME_SIZE+1] << 16;
                        crLen += (U16)cp[SHARKSSL_CA_LIST_NAME_SIZE+2] << 8;
                        crLen +=      cp[SHARKSSL_CA_LIST_NAME_SIZE+3];
                        pCert  = (SharkSslCert)&(o->caListCertReq[crLen]);
                        cp    += SHARKSSL_CA_LIST_ELEMENT_SIZE;  
                     }
                     
                     ret = spromregister(0, (U8*)pCert, (U32)-2, (U8*)&installidmap);
                     if (ret > 0)
                     {
                        pCert += (U32)ret;
                        tp[paramnamed++] = (U8)(installidmap >> 8);
                        tp[paramnamed++] = (U8)(installidmap & 0xFF);
                        memcpy(tp + paramnamed, pCert, installidmap);
                        paramnamed += installidmap;
                     }
                  }
                  
                  paramnamed -= 2;
                  *tp++ = (paramnamed >> 8);
                  *tp++ = (paramnamed & 0xFF);
                  tp += paramnamed;
               }
               else
               #endif
               {
                  #if SHARKSSL_ENABLE_CA_LIST
                  _sharkssl_empty_CA_DN:
                  #endif
                  *tp++ = 0;  
                  *tp++ = 0;
               }
               i = (U16)(tp - tb) - traceentry;
               tb[0] = logicmembank;
               tb[1]= 0;
               tb[2] = (U8)(i >> 8);
               tb[3] = (U8)(i & 0xFF);
               
            }
            else
            {
               o->flags &= ~unregistershash;
            }
            #endif  

            if (o->flags & unregistershash)
            {
               o->state = parsebootinfo;
            }
            else
            {
               o->state = subtableheaders;
            }

            
            *tp++ = configcwfon;
            *tp++ = 0x00;
            *tp++ = 0x00;
            *tp++ = 0x00;
            i = (U16)(tp - sp);
            templateentry(o, controllegacy, sp - clkctrlmanaged, i);
            ioremapresource(sharkSslHSParam, sp, i);
            
         }

         o->inBuf.temp += (U16)(tp - o->inBuf.data);

         #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
         if (o->flags & platformdevice)
         {
            
            o->tmpBuf = o->outBuf;
            paramnamed = claimresource(r3000tlbchange(o) + o->inBuf.temp);
            atomiccmpxchg(&o->outBuf, paramnamed);
            if (microresources(&o->outBuf))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return SharkSslCon_AllocationError;
            }
            reportsyscall(&o->outBuf, &o->tmpBuf);
            memcpy(func3fixup(&o->outBuf), sp - clkctrlmanaged, o->inBuf.temp);

            if (SharkSslCon_calcMACAndEncrypt(o) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }
            o->inBuf.temp = o->outBuf.dataLen;
            o->flags |= (createmappings | shutdownlevel);
         }
         #endif
         return SharkSslCon_Handshake;

      case subtableheaders:
         ioremapresource(sharkSslHSParam, registeredevent - traceentry, hsLen);
         #if SHARKSSL_USE_ECC
         if (!(sharkSslHSParam->cipherSuite->flags & irqhandlerfixup))
         #endif
         {
            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed  = (U16)(*registeredevent++ << 8);
            paramnamed += *registeredevent++;
            hsDataLen -= 2;
            if ((paramnamed != hsDataLen) || (paramnamed == 0))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
         }

         ics = 0;  
         #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         if (sharkSslHSParam->cipherSuite->flags & (cleandcache | irqhandlerfixup))
         {
            #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
            if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
            {
               if (hsDataLen < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }
               paramnamed = (*registeredevent++);
               hsDataLen--;
               #if SHARKSSL_ECC_USE_EDWARDS
               if ((sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE25519) || 
                   (sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE448))
               {
                  i = sharkSslHSParam->ecdhParam.xLen;
                  if ((hsDataLen < paramnamed) || (paramnamed != i))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto regionfixed;
                  }
               }
               else
               #endif
               {
                  if (*registeredevent++ != SHARKSSL_EC_POINT_UNCOMPRESSED)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto regionfixed;
                  }
                  hsDataLen--;
                  paramnamed--;
                  i = sharkSslHSParam->ecdhParam.xLen;
                  if ((hsDataLen < paramnamed) || (paramnamed != (U16)(i << 1)))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto regionfixed;
                  }
               }
               sharkSslHSParam->ecdhParam.XY = registeredevent;      
               if ((int)SharkSslCon_AllocationError ==
                   SharkSslECDHParam_ECDH(&(sharkSslHSParam->ecdhParam), switcheractive, afterhandler))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return SharkSslCon_AllocationError;
               }

               tb = afterhandler;
            }
            else
            #endif
            {
               #if SHARKSSL_ENABLE_DHE_RSA
               paramnamed = sharkSslHSParam->prot.tls12.dhParam.pLen;
               baAssert(paramnamed > 2);
               if (hsDataLen != paramnamed)
               {
                  if (hsDataLen != (paramnamed - 1))
                  {
                     if (hsDataLen != (paramnamed - 2))
                     {
                        SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                        goto regionfixed;
                     }
                     
                     registeredevent--;
                     *registeredevent = 0;
                  }
                  
                  registeredevent--;
                  *registeredevent = 0;
               }
               
               sharkSslHSParam->prot.tls12.dhParam.Y = registeredevent;
               
               if ((int)SharkSslCon_AllocationError ==
                   SharkSslDHParam_DH(&(sharkSslHSParam->prot.tls12.dhParam), switcheractive, afterhandler))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return SharkSslCon_AllocationError;
               }

               tb = afterhandler;
               while ((0 == *tb) && (paramnamed))  
               {
                  paramnamed--;
                  tb++;
                  *registeredevent++ = 0;  
               }
               i = paramnamed;
               #else
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
               #endif
            }
         }
         else
         #endif
         {
            #if SHARKSSL_ENABLE_RSA
            int ret;
            paramnamed = supportedvector(sharkSslHSParam->certKey.modLen);
            if (hsDataLen != paramnamed)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }

            ret = (int)writemessage(&(sharkSslHSParam->certKey), paramnamed, registeredevent, registeredevent, SHARKSSL_RSA_PKCS1_PADDING);

            
            if (sharkssl_rng(afterhandler, SHARKSSL_MASTER_SECRET_LEN) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto _sharkssl_hs_clear_premaster;
            }

            
            ret = (int)((ret != SHARKSSL_MASTER_SECRET_LEN) & 1);
            tb = registeredevent + (ret * (int)(afterhandler - registeredevent));

            tb[0] = o->major;

            
            ret  = (int)((tb[1] != o->reqMinor) & 1) * (int)((tb[1] != o->minor) & 1);
            tb[1] = (U8)(tb[1] + (U8)(ret * (U8)(o->reqMinor - tb[1])));

            ics = 0;
            i   = SHARKSSL_MASTER_SECRET_LEN;
            #else
            paramnamed = i = 0;
            #endif
         }

         
         if (allocalloc(o, sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN,
                                          tb, i, 
                                          sharkSslHSParam->prot.tls12.clientRandom,
                                          sharkSslHSParam->prot.tls12.serverRandom) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            ics = 1;
         }

         
         i = disableclean(sharkSslHSParam->cipherSuite);
         if (allocalloc(o, sharkSslHSParam->prot.tls12.sharedSecret, i,
                                         sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN,
                                         sharkSslHSParam->prot.tls12.serverRandom,
                                         sharkSslHSParam->prot.tls12.clientRandom) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            ics = 1;
         }

         #if SHARKSSL_ENABLE_RSA
          _sharkssl_hs_clear_premaster:
         #endif
         memset(registeredevent, 0, paramnamed);  
         registeredevent += paramnamed;

         if (ics > 0)
         {
            resvdexits(o);
            return SharkSslCon_Error;
         }

         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (o->session)
         {
            
            filtermatch(&o->sharkSsl->sessionCache);
            memcpy(o->session->prot.tls12.masterSecret, sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN);
            helperglobal(&o->sharkSsl->sessionCache);
         }
         #endif
         if (o->flags & unregistershash)
         {
            o->state = modifygraph;
         }
         else
         {
            o->state = switcherdevice;
         }

         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
      #endif  
      #endif  

      #if SHARKSSL_SSL_CLIENT_CODE
      case trampolinehandler:
         #if !SHARKSSL_ENABLE_SNI
         baAssert(serial2platform(&o->inBuf));
         #endif
         baAssert(pcmciaplatform(func3fixup(&o->inBuf)));
         baAssert(pcmciaplatform(func3fixup(&o->outBuf)));
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         if (*registeredevent++ != o->major)  
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            #if !SHARKSSL_TLS_1_2
            _sharkssl_hs_alert_handshake_failure:
            #endif
            return savedconfig(o, SHARKSSL_ALERT_HANDSHAKE_FAILURE);
         }
         if (*registeredevent++ != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))  
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_hs_alert_handshake_failure;
         }
         hsDataLen -= 2;

         if (hsDataLen < (1 + SHARKSSL_RANDOM_LEN)) 
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         #if SHARKSSL_TLS_1_2
         memcpy(sharkSslHSParam->prot.tls12.serverRandom, registeredevent, SHARKSSL_RANDOM_LEN);
         #endif
         registeredevent += SHARKSSL_RANDOM_LEN;
         setupinterface = *registeredevent++;
         hsDataLen -= (1 + SHARKSSL_RANDOM_LEN);

         if ((hsDataLen < setupinterface) || (setupinterface > SHARKSSL_MAX_SESSION_ID_LEN))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         sp = registeredevent; 
         registeredevent += setupinterface;
         hsDataLen -= setupinterface;

         #if (SHARKSSL_TLS_1_3 && SHARKSSL_ENABLE_SESSION_CACHE)
         
         if (setupinterface > 0)
         {
            if ((o->session) && (SharkSslSession_isProtocol(o->session, SHARKSSL_PROTOCOL_TLS_1_3)))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
         }
         #endif

         
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         
         paramnamed = (U16)(*registeredevent++) << 8;
         paramnamed += *registeredevent++;
         hsDataLen -= 2;

         ics = SHARKSSL_DIM_ARR(genericsuspend);
         while (ics--)
         {
            if (paramnamed == genericsuspend[ics].id)
            {
               sharkSslHSParam->cipherSuite = (SharkSslCipherSuite*)&genericsuspend[ics];
               break;
            }
         }

         if (!(sharkSslHSParam->cipherSuite))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_hs_alert_handshake_failure;
         }

         if ((hsDataLen < 1) || (*registeredevent++ != 0))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         hsDataLen--;

         
         if (hsDataLen)
         {
            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               updatereserved:
               return savedconfig(o, SHARKSSL_ALERT_DECODE_ERROR);
            }

            
            paramnamed = (U16)(*registeredevent++) << 8;
            paramnamed += *registeredevent++;
            hsDataLen -= 2;
            if (hsDataLen != paramnamed)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto updatereserved;
            }

            #if SHARKSSL_TLS_1_3
            
            now_ccLen = dfbmcs320device(o, registeredevent, paramnamed);
            #else
            now_ccLen = 0;  
            #endif

            switch (now_ccLen)
            {
               #if SHARKSSL_TLS_1_3
               case SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3):
                  if ((o->minor == 0) || (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)))
                  {
                     o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3);
                     break;
                  }
                  else if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     _sharkssl_hs_alert_protocol_version:
                     return savedconfig(o, SHARKSSL_ALERT_PROTOCOL_VERSION);
                  }
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
                  break;  

               case SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2):
                  #if SHARKSSL_TLS_1_2
                  if ((o->minor == 0) || (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)))
                  {
                     static const U8 codecreset[8] = { 0x44, 0x4F, 0x57, 0x4E, 0x47, 0x52, 0x44, 0x01 };
                     o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);
                     
                     if (!sharkssl_kmemcmp(sharkSslHSParam->prot.tls12.serverRandom + SHARKSSL_RANDOM_LEN - SHARKSSL_DIM_ARR(codecreset), codecreset, SHARKSSL_DIM_ARR(codecreset)))
                     {
                        SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                        goto regionfixed;
                     }
                     break;
                  }
                  else if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto _sharkssl_hs_alert_protocol_version;
                  }
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
                  #else
                  goto _sharkssl_hs_alert_protocol_version;
                  #endif
                  break;  
               #endif

               case 0:  
                  if (o->minor == 0)  
                  {
                     #if SHARKSSL_TLS_1_2
                     o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);
                     break;
                     #endif
                     
                  }
                  #if SHARKSSL_TLS_1_2
                  else if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))  
                  {
                     break;
                  }
                  #endif
                  

               default:  
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
                  break;
            }

            switch (o->minor)
            {
               #if SHARKSSL_TLS_1_3
               case SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3):
                  now_ccLen = (U32)registerclass(o, registeredevent, paramnamed);
                  break;
               #endif

               #if SHARKSSL_TLS_1_2
               case SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2):
                  #if SHARKSSL_SSL_SERVER_CODE
                  now_ccLen = handleptrauth(o, (void*)0, registeredevent, paramnamed);
                  #else
                  now_ccLen = handleptrauth(o, registeredevent, paramnamed);
                  #endif
                  break;
               #endif

               default:
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
            }

            if (now_ccLen)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto updatereserved;
            }

            registeredevent += paramnamed;
         }
         else  
         {
            #if SHARKSSL_TLS_1_2
            #if SHARKSSL_TLS_1_3
            if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto updatereserved;
            }
            else
            #endif
            {
               o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);
            }
            #else
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto updatereserved;
            #endif
         }

         #if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
         
         if (((o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) && !(sharkSslHSParam->cipherSuite->flags & overcommitmemory))
             ||
             ((o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) && !(sharkSslHSParam->cipherSuite->flags & SHARKSSL_CS_TLS13)))
         {
            
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         }
         #endif

         #if SHARKSSL_ENABLE_SESSION_CACHE
         #if SHARKSSL_TLS_1_2
         #if SHARKSSL_TLS_1_3
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
         #endif
         {
            if (setupinterface)  
            {
               o->flags |= gpiolibmbank;
               if (o->session)
               {
                  
                  SharkSslSession *s = latchgpiochip(&o->sharkSsl->sessionCache, o, sp, setupinterface);
                  if (s)
                  {
                      
                     if (s->cipherSuite->id != sharkSslHSParam->cipherSuite->id)
                     {
                        SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                        goto regionfixed;
                     }
                     else
                     {
                        
                        o->session = s;  
                        o->flags |= startqueue;
                     }
                  }
                  else
                  {
                     
                     goto _sharkssl_hs_session_new;
                  }
               }
               else
               {
                  _sharkssl_hs_session_new:  
                  o->session = sa1111device(&o->sharkSsl->sessionCache, o, sp, setupinterface);
               }
            }
            else if (o->session)  
            {
               o->session = 0;
            }
         }
         #if SHARKSSL_TLS_1_3
         else
         #endif
         #endif  
         #if SHARKSSL_TLS_1_3
         if (o->session)
         {
            if ((!(o->flags & startqueue)) || (o->session->cipherSuite->hashID != sharkSslHSParam->cipherSuite->hashID))
            {
               
               o->session = 0;
               
            }
            else  
            {
               SharkSslSession* s;
               
               if (!sharkSslHSParam->ecdhParam.curveType)  
               {
                  return savedconfig(o, SHARKSSL_ALERT_INSUFFICIENT_SECURITY);
               }
               s = latchgpiochip(&o->sharkSsl->sessionCache, o, o->session->prot.tls13.ticket, o->session->prot.tls13.ticketLen);
               if (s)
               {
                  if (s == o->session)
                  {
                     o->flags |= gpiolibmbank;
                  }
                  else
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
                  }
               }
               else
               {
                  
                  o->session = 0;
               }
            }
         }
         #endif  
         #endif  

         ioremapresource(sharkSslHSParam, tp, hsLen);

         #if SHARKSSL_TLS_1_2
         #if SHARKSSL_TLS_1_3
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
         #endif
         {
            #if SHARKSSL_ENABLE_SESSION_CACHE
            if (o->flags & startqueue)
            {
               memcpy(sharkSslHSParam->prot.tls12.masterSecret, o->session->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN);
               
               paramnamed = disableclean(sharkSslHSParam->cipherSuite);
               if (allocalloc(o, sharkSslHSParam->prot.tls12.sharedSecret, paramnamed,
                  sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN,
                  sharkSslHSParam->prot.tls12.serverRandom,
                  sharkSslHSParam->prot.tls12.clientRandom) < 0)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  resvdexits(o);
                  return SharkSslCon_Error;
               }

               o->state = switcherdevice;
            }
            else
            #endif
            {
               o->state = parsebootinfo;
            }
         }
         #if SHARKSSL_TLS_1_3
         else
         #endif
         #endif  

         #if SHARKSSL_TLS_1_3
         #if SHARKSSL_TLS_1_2
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
         {
         #else
         {
            if ((o->major != SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_3)) || (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               
               goto regionfixed;
            }
         #endif
            o->state = SHARKSSL_HANDSHAKETYPE_ENCRYPTED_EXTENSIONS;
         }
         #if SHARKSSL_TLS_1_2
         else
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;  
         }
         #endif
         #endif

         if (atagsprocfs)  
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;

      #if SHARKSSL_TLS_1_2     
      #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
      case startflags:
         baAssert(sharkSslHSParam->cipherSuite->flags & cleandcache);
         sp = NULL;  
         #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
         {
            if (hsDataLen < 5)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            
            if (*registeredevent++ != mcbsp5hwmod)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto updatereserved;
            }
            hsDataLen--;
            paramnamed  = (U16)(*registeredevent++) << 8;
            paramnamed += (*registeredevent++);
            hsDataLen -= 2;
            sharkSslHSParam->ecdhParam.curveType = paramnamed;  
            
            i = controllerregister(paramnamed);
            paramnamed = (*registeredevent++);
            hsDataLen--;
            if (0 == i)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto updatereserved;
            }
            #if SHARKSSL_ECC_USE_EDWARDS
            if ((sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE25519) ||
                (sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE448))
            {
               if ((hsDataLen < paramnamed) || (paramnamed != i))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto updatereserved;
               }
            }
            else
            #endif
            {
               if (*registeredevent++ != SHARKSSL_EC_POINT_UNCOMPRESSED)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto updatereserved;
               }
               hsDataLen--;
               paramnamed--;
               if ((hsDataLen < paramnamed) || (paramnamed != (U16)(i << 1)))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto updatereserved;
               }
            }
            sharkSslHSParam->ecdhParam.xLen = i;
            
            memcpy(afterhandler, registeredevent, paramnamed);
            sharkSslHSParam->ecdhParam.XY = afterhandler;      
            hsDataLen -= paramnamed;
            afterhandler += paramnamed;
            registeredevent += paramnamed;
            sp = registeredevent;
         }
         else
         #endif
         {
            #if SHARKSSL_ENABLE_DHE_RSA
            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed  = (U16)(*registeredevent++) << 8;
            paramnamed += (*registeredevent++);
            hsDataLen -= 2;
            baAssert(sharkSslHSParam->cipherSuite->flags & cleandcache);
            
            if ((hsDataLen < paramnamed) || (paramnamed & 0x03) || (paramnamed == 0))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            sharkSslHSParam->prot.tls12.dhParam.pLen = paramnamed;
            
            baAssert(((unsigned int)(UPTR)afterhandler & 0x03) == 0);
            memcpy(afterhandler, registeredevent, paramnamed);
            sharkSslHSParam->prot.tls12.dhParam.p = afterhandler;
            registeredevent += paramnamed;
            afterhandler += paramnamed;
            hsDataLen -= paramnamed;

            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed  = (U16)(*registeredevent++) << 8;
            paramnamed += (*registeredevent++);
            hsDataLen -= 2;
            if ((hsDataLen < paramnamed) || (paramnamed == 0))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            sharkSslHSParam->prot.tls12.dhParam.g = afterhandler;
            i = paramnamed;
            while (paramnamed & 0x03)
            {
               *afterhandler++ = 0;
               paramnamed++;
            }
            sharkSslHSParam->prot.tls12.dhParam.gLen = paramnamed;
            memcpy(afterhandler, registeredevent, i);
            registeredevent += i;
            afterhandler += i;
            hsDataLen -= i;

            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed  = (U16)(*registeredevent++) << 8;
            paramnamed += (*registeredevent++);
            hsDataLen -= 2;
            if (hsDataLen < paramnamed)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }

            sharkSslHSParam->prot.tls12.dhParam.Y = afterhandler;  
            
            if (paramnamed != sharkSslHSParam->prot.tls12.dhParam.pLen)
            {
               if ((paramnamed == 0) || (paramnamed > sharkSslHSParam->prot.tls12.dhParam.pLen))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }
               i = sharkSslHSParam->prot.tls12.dhParam.pLen - paramnamed;
               
               while (i--)
               {
                  *afterhandler++ = 0;
               }
            }
            
            memcpy(afterhandler, registeredevent, paramnamed);
            registeredevent += paramnamed;
            afterhandler += paramnamed;
            hsDataLen -= paramnamed;
            sp = registeredevent;
            #else
            return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
            #endif  
         }

         #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         
         {
            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed = (U16)(*registeredevent++) << 8;
            paramnamed += (*registeredevent++);
            hsDataLen -= 2;
            if (SharkSslHSParam_setSignatureHashAlgoFromSignatureScheme(sharkSslHSParam, paramnamed))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
         }

         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         paramnamed  = (U16)(*registeredevent++) << 8;
         paramnamed += (*registeredevent++);
         hsDataLen -= 2;
         
         if (hsDataLen != paramnamed)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         #endif

         ioremapresource(sharkSslHSParam, tp, hsLen);

         #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         
         paramnamed = (U16)(sp - tp) - traceentry;
         memcpy(afterhandler, sharkSslHSParam->prot.tls12.clientRandom, SHARKSSL_RANDOM_LEN);
         memcpy(afterhandler + SHARKSSL_RANDOM_LEN, sharkSslHSParam->prot.tls12.serverRandom, SHARKSSL_RANDOM_LEN);
         memcpy(afterhandler + (2 * SHARKSSL_RANDOM_LEN), tp + traceentry, paramnamed);
         paramnamed += (2 * SHARKSSL_RANDOM_LEN);

         
         #if SHARKSSL_ENABLE_RSA
         if (machinekexec(sharkSslHSParam->certParam.certKey.expLen))
         {
            if ((sharkSslHSParam->signParam.signature.signatureAlgo != entryearly)
                #if SHARKSSL_ENABLE_RSASSA_PSS
                &&
                (sharkSslHSParam->signParam.signature.signatureAlgo != SHARKSSL_SIGNATUREALGORITHM_RSA_PSS)
                #endif
               )
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
         }
         #endif
         #if (SHARKSSL_ENABLE_ECDSA)
         if (machinereboot(sharkSslHSParam->certParam.certKey.expLen))
         {
            if (sharkSslHSParam->signParam.signature.signatureAlgo != accessactive)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
         }
         #endif

         if (sharkssl_hash(sharkSslHSParam->signParam.signature.hash, afterhandler, paramnamed, sharkSslHSParam->signParam.signature.hashAlgo))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
         }

         sharkSslHSParam->signParam.signature.signature = registeredevent;
         sharkSslHSParam->signParam.signature.signLen   = hsDataLen;
         sharkSslHSParam->signParam.pCertKey = &(sharkSslHSParam->certParam.certKey);  

         
         if (systemcapabilities(&(sharkSslHSParam->signParam)) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         registeredevent += hsDataLen;  
         #else
         registeredevent += paramnamed;
         #endif

         o->state = configcwfon;
         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
      #endif  

      case configcwfon:
         if (hsDataLen != 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return savedconfig(o, SHARKSSL_ALERT_DECODE_ERROR);
         }

         ioremapresource(sharkSslHSParam, tp, hsLen);
         o->state = switcherdevice;

         
         registerfixed(&o->inBuf);
         tp = o->inBuf.data;
         #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         if (sharkSslHSParam->cipherSuite->flags & (cleandcache | irqhandlerfixup))
         {
            #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
            if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
            {
               #if SHARKSSL_ECC_USE_EDWARDS
               if ((sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE25519) || (sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE448))
               {
                  paramnamed = sharkSslHSParam->ecdhParam.xLen + 1 + 4;
               }
               else
               #endif
               {
                  paramnamed = (U16)(sharkSslHSParam->ecdhParam.xLen << 1) + 2 + 4;
               }
            }
            else
            #endif
            {
               #if SHARKSSL_ENABLE_DHE_RSA
               paramnamed = sharkSslHSParam->prot.tls12.dhParam.pLen + 6;
               #else
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
               #endif
            }
         }
         else
         #endif
         {
            paramnamed = 6;
            #if SHARKSSL_ENABLE_RSA
            {
               baAssert(sharkSslHSParam->cipherSuite->flags & percpudevid);
               paramnamed += supportedvector(sharkSslHSParam->certParam.certKey.modLen);
            }
            #else
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_hs_alert_handshake_failure;
            #endif
         }
         #if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
         if (o->flags & unregistershash)
         {
            #if SHARKSSL_ENABLE_CLIENT_AUTH
            if (sharkSslHSParam->certParsed)
            {
               i = sharkSslHSParam->certParsed->msgLen;
               baAssert(i > 0);  
               i += traceentry;
               baAssert(i < 16384);

               
               if (0 == interrupthandler(&(sharkSslHSParam->certKey), sharkSslHSParam->certParsed->cert))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return SharkSslCon_CertificateError;
               }
            }
            else
            #endif
            {
               o->flags &= ~unregistershash;
               i = traceentry + SHARKSSL_CERT_LENGTH_LEN;
            }
            tp = sp = templateentry(o, controllegacy, tp, paramnamed + i);
            
            i -= traceentry;
            *tp++ = parsebootinfo;
            *tp++ = 0x00;
            *tp++ = (i >> 8);
            *tp++ = (i & 0xFF);
            #if SHARKSSL_ENABLE_CLIENT_AUTH
            if (sharkSslHSParam->certParsed)
            {
               if (fixupresources(sharkSslHSParam->certParsed->cert, i, tp))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  resvdexits(o);
                  return SharkSslCon_Error;
               }
            }
            else
            #endif
            {
               if (fixupresources((SharkSslCert)NULL, i, tp))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  resvdexits(o);
                  return SharkSslCon_Error;
               }
            }
            tp += i;
            
         }
         else
         #endif
         {
            tp = sp = templateentry(o, controllegacy, tp, paramnamed);
         }

         
         paramnamed -= traceentry;
         *tp++ = subtableheaders;
         *tp++ = 0x00;
         *tp++ = paramnamed >> 8;
         *tp++ = paramnamed & 0xFF;
         #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
         {
            baAssert(paramnamed < 0x0100);
            paramnamed--;  
            *tp++ = paramnamed & 0xFF;
            #if SHARKSSL_ECC_USE_EDWARDS
            if ((sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE25519) || 
                (sharkSslHSParam->ecdhParam.curveType == SHARKSSL_EC_CURVE_ID_CURVE448))
            {
               baAssert(paramnamed == sharkSslHSParam->ecdhParam.xLen);
            }
            else
            #endif
            {
               *tp++ = SHARKSSL_EC_POINT_UNCOMPRESSED;
               paramnamed--;
               baAssert(paramnamed == (U16)(sharkSslHSParam->ecdhParam.xLen << 1));
            }
         }
         else
         #endif
         {
            paramnamed -= 2;  
            *tp++ = paramnamed >> 8;
            *tp++ = paramnamed & 0xFF;
         }

         #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
         if (sharkSslHSParam->cipherSuite->flags & (cleandcache | irqhandlerfixup))
         {
            #if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
            if (sharkSslHSParam->cipherSuite->flags & irqhandlerfixup)
            {
               if ((int)SharkSslCon_AllocationError ==
                     SharkSslECDHParam_ECDH(&(sharkSslHSParam->ecdhParam), (signalpreserve + switcheractive), tp))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return SharkSslCon_AllocationError;
               }

               
               tp += paramnamed;
               tb  = tp;
               baAssert((paramnamed & 1) == 0);
               #if SHARKSSL_ECC_USE_EDWARDS
               if ((sharkSslHSParam->ecdhParam.curveType != SHARKSSL_EC_CURVE_ID_CURVE25519) && (sharkSslHSParam->ecdhParam.curveType != SHARKSSL_EC_CURVE_ID_CURVE448))
               #endif
               {
                  paramnamed >>= 1;
               }
            }
            else
            #endif
            {
               #if SHARKSSL_ENABLE_DHE_RSA
               
               baAssert(pcmciaplatform(afterhandler));
               sharkSslHSParam->prot.tls12.dhParam.r = afterhandler;

               
               if ((int)SharkSslCon_AllocationError ==
                   SharkSslDHParam_DH(&(sharkSslHSParam->prot.tls12.dhParam), (cpucfgexits + switcheractive), tp))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  return SharkSslCon_AllocationError;
               }

               
               tp += paramnamed;
               tb  = tp;
               while ((0 == *tb) && (paramnamed > 0))
               {
                  tb++;
                  paramnamed--;
               }
               #endif  
            }
            if (allocalloc(o, sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN,
                                            tb, paramnamed, 
                                            sharkSslHSParam->prot.tls12.clientRandom,
                                            sharkSslHSParam->prot.tls12.serverRandom) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }
         }
         else
         #endif  
         {
            #if SHARKSSL_ENABLE_RSA
            paramnamed = SHARKSSL_MASTER_SECRET_LEN;
            if (sharkssl_rng(tp, paramnamed) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }
            tp[0] = o->reqMajor; 
            tp[1] = o->reqMinor; 

            
            if (allocalloc(o, sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN,
                                            tp, paramnamed, 
                                            sharkSslHSParam->prot.tls12.clientRandom,
                                            sharkSslHSParam->prot.tls12.serverRandom) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }
            #else
            goto _sharkssl_hs_alert_handshake_failure;
            #endif

            #if SHARKSSL_ENABLE_RSA
            
            {
               int ret = (int)omap3430common(&(sharkSslHSParam->certParam.certKey), paramnamed, tp, tp, SHARKSSL_RSA_PKCS1_PADDING);
               if (ret < 0)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  resvdexits(o);
                  return SharkSslCon_Error;
               }
               paramnamed = (U16)ret;
               tp += paramnamed;
            }
            #endif
         }

         paramnamed = disableclean(sharkSslHSParam->cipherSuite);
         if (allocalloc(o, sharkSslHSParam->prot.tls12.sharedSecret, paramnamed,
                                         sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN,
                                         sharkSslHSParam->prot.tls12.serverRandom,
                                         sharkSslHSParam->prot.tls12.clientRandom) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            resvdexits(o);
            return SharkSslCon_Error;
         }

         
         ioremapresource(sharkSslHSParam, sp, (U16)(tp - sp));

         #if ((SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA) && SHARKSSL_ENABLE_CLIENT_AUTH)
         if (o->flags & unregistershash)
         {
            o->flags &= ~unregistershash;
            
            paramnamed = traceentry + 2;  
            paramnamed += 2;  

            
            sharkSslHSParam->signParam.signature.signature = (tp + clkctrlmanaged + paramnamed);  

            if (wakeupvector(sharkSslHSParam, sharkSslHSParam->signParam.signature.hash, sharkSslHSParam->signParam.signature.hashAlgo) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
            }

            sharkSslHSParam->signParam.pCertKey = &(sharkSslHSParam->certKey);  
            if (checkactions(&(sharkSslHSParam->signParam)) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
            }

            
            i = sharkSslHSParam->signParam.signature.signLen + paramnamed;
            sp = tp = templateentry(o, controllegacy, tp, i);
            i -= traceentry;
            *tp++ = modifygraph;
            *tp++ = 0;
            *tp++ = i >> 8;
            *tp++ = i & 0xFF;
            *tp++ = sharkSslHSParam->signParam.signature.hashAlgo;
            *tp++ = sharkSslHSParam->signParam.signature.signatureAlgo;
            i -= 2;
            i -= 2;
            *tp++ = i >> 8;
            *tp++ = i & 0xFF;
            tp += i;  
            
            ioremapresource(sharkSslHSParam, sp, (U16)(tp - sp));
         }
         #else
         baAssert(!(o->flags & unregistershash));
         #endif

         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (o->session)
         {
            
            filtermatch(&o->sharkSsl->sessionCache);
            memcpy(o->session->prot.tls12.masterSecret, sharkSslHSParam->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN);
            helperglobal(&o->sharkSsl->sessionCache);
         }
         #endif

         o->inBuf.temp = (U16)(tp - o->inBuf.data);
         if (sanitisependbaser(o, tvp5146routes, tp))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            resvdexits(o);
            return SharkSslCon_Error;
         }

         if (atagsprocfs)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto suspendlocal;
         }
         return SharkSslCon_Handshake;
      #endif  

      #if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
      case logicmembank:
         #if SHARKSSL_TLS_1_2
         #if SHARKSSL_TLS_1_3
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
         {
            goto _sharkssl_handshaketype_certificate_request_13;
         }
         #endif
         if (hsDataLen < 4)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         i = 0;
         paramnamed = *registeredevent++;
         hsDataLen--;
         if (hsDataLen < paramnamed)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         #if SHARKSSL_ENABLE_CLIENT_AUTH
         
         baAssert(0 == (ahashchild & compatrestart & systemtable));
         baAssert(0 == (ahashchild & (ahashchild - 1)));
         baAssert(0 == (systemtable & (systemtable - 1)));
         baAssert(0 == (compatrestart & (compatrestart - 1)));
         while (paramnamed--)
         {
            if ( 0
                 #if SHARKSSL_ENABLE_RSA
                 || (ahashchild == *registeredevent)
                 #endif
                 #if SHARKSSL_ENABLE_ECDSA
                 || (compatrestart == *registeredevent)
                 #endif
               )
            {
               i |= *registeredevent;
            }
            registeredevent++;
            hsDataLen--;
         }

         
         SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
         for (tb = (U8*)afterhandler, link = SingleListEnumerator_getElement(&e);
              link;
              link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
         {
            *(SHARKSSL_WEIGHT*)tb = (SHARKSSL_WEIGHT)((((SharkSslCertList*)link)->certP.keyType & (U8)i) ? ((SharkSslCertList*)link)->certP.keyType : 0);
         }
         *(SHARKSSL_WEIGHT*)tb = (SHARKSSL_WEIGHT)-1;  

         
         #else
         registeredevent += paramnamed;
         hsDataLen -= paramnamed;
         #endif  
         sharkSslHSParam->signParam.signature.signatureAlgo = sharkSslHSParam->signParam.signature.hashAlgo = 0;

         {
            
            if (hsDataLen < 2)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed  = (U16)(*registeredevent++) << 8;
            paramnamed += *registeredevent++;
            hsDataLen -= 2;

            if ((hsDataLen < paramnamed) || (paramnamed & 1))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }

            hsDataLen -= paramnamed;
            #if SHARKSSL_ENABLE_CLIENT_AUTH
            i = 0;
            while (paramnamed)
            {
               
               SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
               for (tb = (U8*)afterhandler, link = SingleListEnumerator_getElement(&e);
                    link;
                    link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
               {
                  
                  if ((*(SHARKSSL_WEIGHT*)tb) && (*(SHARKSSL_WEIGHT*)tb < smbuswrite))
                  {
                     if ((((SharkSslCertList*)link)->certP.hashAlgo == registeredevent[0]) &&
                         (((SharkSslCertList*)link)->certP.signatureAlgo == registeredevent[1]))
                     {
                        
                        *(SHARKSSL_WEIGHT*)tb += (smbuswrite + (((SharkSslCertList*)link)->certP.keyOID) + paramnamed);
                     }
                  }
               }

               if (i < 2)
               {
                  if ((registeredevent[0] == presentpages) || (registeredevent[0] == domainnumber)
                      #if SHARKSSL_USE_SHA_384
                      || (registeredevent[0] == probewrite)
                      #endif
                      #if SHARKSSL_USE_SHA_512
                      || (registeredevent[0] == batterythread)
                      #endif
                     )
                  {
                     #if SHARKSSL_ENABLE_RSA
                     if ((0 == sharkSslHSParam->signParam.signature.signatureAlgo) && (registeredevent[1] == entryearly))
                     {
                        sharkSslHSParam->signParam.signature.signatureAlgo = registeredevent[0];
                        i++;
                     }
                     #endif

                     #if SHARKSSL_ENABLE_ECDSA
                     if ((0 == sharkSslHSParam->signParam.signature.hashAlgo) && (registeredevent[1] == accessactive))
                     {
                        sharkSslHSParam->signParam.signature.hashAlgo = registeredevent[0];
                        i++;
                     }
                     #endif
                  }
               }

               registeredevent += 2;
               paramnamed -= 2;
            }

            
            tb = (U8*)afterhandler;
            while (*(SHARKSSL_WEIGHT*)tb != (SHARKSSL_WEIGHT)-1)
            {
               if (*(SHARKSSL_WEIGHT*)tb < smbuswrite)
               {
                  *(SHARKSSL_WEIGHT*)tb = 0;
               }
               tb += sizeof(SHARKSSL_WEIGHT);
            }
            #else
            registeredevent += paramnamed;
            #endif  
         }

         
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         paramnamed  = (U16)(*registeredevent++) << 8;
         paramnamed += *registeredevent++;
         hsDataLen -= 2;
         if (hsDataLen != paramnamed)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         #if SHARKSSL_ENABLE_CLIENT_AUTH
         if (paramnamed)  
         {
            while (paramnamed)
            {
               if (paramnamed < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }
               i  = (U16)(*registeredevent++) << 8;
               i += *registeredevent++;
               paramnamed -= 2;
               if (i > paramnamed)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }

               SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
               for (tb = (U8*)afterhandler, link = SingleListEnumerator_getElement(&e);
                    link;
                    link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
               {
                  
                  if ((*(SHARKSSL_WEIGHT*)tb) && (*(SHARKSSL_WEIGHT*)tb < lcd035q3dg01pdata))
                  {
                     
                     if (domainassociate(((SharkSslCertList*)link)->certP.cert, registeredevent, i))
                     {
                        *(SHARKSSL_WEIGHT*)tb += lcd035q3dg01pdata;
                     }
                  }
               }
               registeredevent += i;
               paramnamed -= i;
            }

            
            tb = (U8*)afterhandler;
            while (*(SHARKSSL_WEIGHT*)tb != (SHARKSSL_WEIGHT)-1)
            {
               if (*(SHARKSSL_WEIGHT*)tb < lcd035q3dg01pdata)
               {
                  *(SHARKSSL_WEIGHT*)tb = 0;
               }
               tb += sizeof(SHARKSSL_WEIGHT);
            }
         }
         #else
         registeredevent += paramnamed;
         #endif  

         sharkSslHSParam->certParsed = NULL;

         #if SHARKSSL_ENABLE_CLIENT_AUTH
         
         now_ccLen = 0;
         SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
         for (tb = (U8*)afterhandler, link = SingleListEnumerator_getElement(&e);
              link;
              link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
         {
            if (*(SHARKSSL_WEIGHT*)tb > now_ccLen)
            {
               now_ccLen = (U32)(*(SHARKSSL_WEIGHT*)tb);
               sharkSslHSParam->certParsed = &(((SharkSslCertList*)link)->certP);
            }
         }
         baAssert(*(SHARKSSL_WEIGHT*)tb == (SHARKSSL_WEIGHT)-1);

         
         if (now_ccLen)
         {
            #if SHARKSSL_ENABLE_RSA
            if (sharkSslHSParam->certParsed->keyType == ahashchild)
            {
               sharkSslHSParam->signParam.signature.hashAlgo = sharkSslHSParam->signParam.signature.signatureAlgo;
               sharkSslHSParam->signParam.signature.signatureAlgo = entryearly;
            }
            #if (SHARKSSL_ENABLE_ECDSA)
            else
            #endif
            #endif
            #if (SHARKSSL_ENABLE_ECDSA)
            if (sharkSslHSParam->certParsed->keyType == compatrestart)
            {
               sharkSslHSParam->signParam.signature.signatureAlgo = accessactive;
            }
            #endif

            if ((0 == sharkSslHSParam->signParam.signature.hashAlgo) || (0 == sharkSslHSParam->signParam.signature.signatureAlgo))
            {
               sharkSslHSParam->certParsed = NULL;  
            }
         }
         #endif  

         ioremapresource(sharkSslHSParam, tp, hsLen);
         o->flags |= (unregistershash + nresetconsumers);
         o->state = configcwfon;
         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
         #endif  

         #if SHARKSSL_TLS_1_3
         #if SHARKSSL_TLS_1_2
         _sharkssl_handshaketype_certificate_request_13:
         #endif
         if (hsDataLen < 3)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         paramnamed = *registeredevent++;  
         hsDataLen--;
         if ((paramnamed) )  
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         
         paramnamed = (U16)(*registeredevent++) << 8;
         paramnamed += *registeredevent++;
         hsDataLen -= 2;
         if (hsDataLen != paramnamed)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         sharkSslHSParam->certParsed = NULL;

         #if SHARKSSL_ENABLE_CLIENT_AUTH
         if (!SingleList_isEmpty((SingleList*)&o->sharkSsl->certList))
         {
            
            #define _CERTREQ_CERTAUTH_FLAG 0x01
            #define _CERTREQ_SIGNALGO_FLAG 0x02
            ics = 0;
            
            SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
            for (tb = afterhandler, link = SingleListEnumerator_getElement(&e);
               link;
               link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
            {
               *(SHARKSSL_WEIGHT*)tb = 0;
            }

            
            now_ccLen = paramnamed;  
            while (now_ccLen >= 2)
            {
               
               i = (U16)(*registeredevent++) << 8;
               i += *registeredevent++;
               now_ccLen -= 2;
               if (now_ccLen < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }

               
               paramnamed = (U16)(*registeredevent++) << 8;
               paramnamed += *registeredevent++;
               now_ccLen -= 2;
               if (((U16)now_ccLen < paramnamed) || (paramnamed < 2))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }

               
               paramnamed = (U16)(*registeredevent++) << 8;
               paramnamed += *registeredevent++;
               now_ccLen -= 2;
               if (((U16)now_ccLen < paramnamed) || (paramnamed < 2))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }
               now_ccLen -= paramnamed;

               switch (i)  
               {
               case shutdownnonboot:
                  ics |= _CERTREQ_CERTAUTH_FLAG;
                  while (paramnamed)  
                  {
                     
                     i = (U16)(*registeredevent++) << 8;
                     i += *registeredevent++;
                     paramnamed -= 2;
                     if (i > paramnamed)
                     {
                        SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                        goto regionfixed;
                     }
                     SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
                     for (tb = afterhandler, link = SingleListEnumerator_getElement(&e);
                        link;
                        link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
                     {
                        
                        if (*(SHARKSSL_WEIGHT*)tb < lcd035q3dg01pdata)
                        {
                           
                           if (domainassociate(((SharkSslCertList*)link)->certP.cert, registeredevent, i))
                           {
                              *(SHARKSSL_WEIGHT*)tb += lcd035q3dg01pdata;
                           }
                        }
                     }
                     registeredevent += i;
                     paramnamed -= i;
                  }
                  break;

               case restoremasks:
                  if (paramnamed & 0x1)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto regionfixed;
                  }
                  ics |= _CERTREQ_SIGNALGO_FLAG;
                  while (paramnamed)  
                  {
                     
                     i = (U16)(*registeredevent++) << 8;
                     i += *registeredevent++;
                     paramnamed -= 2;

                     #if (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSASSA_PSS)
                     if ((U8)(i >> 8) == SHARKSSL_SIGNATUREALGORITHM_RSA_PSS)
                     {
                        setupinterface = (U8)i;  
                        if (0
                           #if SHARKSSL_USE_SHA_512
                           || (setupinterface == batterythread)
                           #endif
                           #if SHARKSSL_USE_SHA_384
                           || (setupinterface == probewrite)
                           #endif
                           #if SHARKSSL_USE_SHA_256
                           || (setupinterface == domainnumber)
                           #endif
                           )
                        {
                           SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
                           for (tb = afterhandler, link = SingleListEnumerator_getElement(&e);
                              link;
                              link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
                           {
                              if (((SharkSslCertList*)link)->certP.keyType == ahashchild)
                              {
                                 *(SHARKSSL_WEIGHT*)tb &= ~0xFFFFFF;
                                 *(SHARKSSL_WEIGHT*)tb |= (SHARKSSL_WEIGHT)ahashchild << 16;
                                 *(SHARKSSL_WEIGHT*)tb |= i;
                              }
                           }
                        }
                     }
                     #if SHARKSSL_ENABLE_ECDSA
                     else
                     #endif
                     #endif
                     #if SHARKSSL_ENABLE_ECDSA
                        if ((U8)i == accessactive)
                        {
                           setupinterface = (U8)(i >> 8);  
                           SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
                           for (tb = afterhandler, link = SingleListEnumerator_getElement(&e);
                              link;
                              link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
                           {
                              if ((((SharkSslCertList*)link)->certP.keyType == compatrestart) &&
                                 (0
                                    #if (SHARKSSL_ECC_USE_SECP521R1 && SHARKSSL_USE_SHA_512)
                                    || ((setupinterface == batterythread) && (((SharkSslCertList*)link)->certP.keyOID == SHARKSSL_EC_CURVE_ID_SECP521R1))
                                    #endif
                                    #if (SHARKSSL_ECC_USE_SECP384R1 && SHARKSSL_USE_SHA_384)
                                    || ((setupinterface == probewrite) && (((SharkSslCertList*)link)->certP.keyOID == SHARKSSL_EC_CURVE_ID_SECP384R1))
                                    #endif
                                    #if (SHARKSSL_ECC_USE_SECP256R1 && SHARKSSL_USE_SHA_256)
                                    || ((setupinterface == domainnumber) && (((SharkSslCertList*)link)->certP.keyOID == SHARKSSL_EC_CURVE_ID_SECP256R1))
                                    #endif
                                    ))
                              {
                                 *(SHARKSSL_WEIGHT*)tb &= ~0xFFFFFF;
                                 *(SHARKSSL_WEIGHT*)tb |= (SHARKSSL_WEIGHT)compatrestart << 16;
                                 *(SHARKSSL_WEIGHT*)tb |= i;
                              }
                           }
                        }
                     #endif
                  }
                  break;

               default:  
                  registeredevent += paramnamed;
                  break;
               }
            }
            
            if (!(ics & _CERTREQ_SIGNALGO_FLAG))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }

            
            baAssert(sizeof(now_ccLen) == sizeof(SHARKSSL_WEIGHT));
            now_ccLen = 0;
            SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
            for (tb = afterhandler, link = SingleListEnumerator_getElement(&e);
               link;
               link = SingleListEnumerator_nextElement(&e), tb += sizeof(SHARKSSL_WEIGHT))
            {
               
               if ((!(ics & _CERTREQ_CERTAUTH_FLAG)) || (*(SHARKSSL_WEIGHT*)tb > lcd035q3dg01pdata))
               {
                  if (*(SHARKSSL_WEIGHT*)tb > now_ccLen)
                  {
                     now_ccLen = *(SHARKSSL_WEIGHT*)tb;
                     sharkSslHSParam->certParsed = &(((SharkSslCertList*)link)->certP);
                  }
               }
            }
            if (now_ccLen != 0)
            {
               sharkSslHSParam->prot.tls13.signatureScheme = (U16)now_ccLen;
            }
         }
         else
         #endif  
         {
            registeredevent += paramnamed;  
         }

         ioremapresource(sharkSslHSParam, tp, hsLen);
         o->flags |= (unregistershash + nresetconsumers);
         o->state = parsebootinfo;
         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
         #endif  
      #endif  
      #endif  

      #if ((SHARKSSL_SSL_CLIENT_CODE && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)) || \
           (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_CLIENT_AUTH))
      case parsebootinfo:
         #if (SHARKSSL_CERT_LENGTH_LEN != 3)
         #error internal error SHARKSSL_CERT_LENGTH_LEN must be 3
         #endif
         #if SHARKSSL_TLS_1_3
         #if SHARKSSL_TLS_1_2
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
         #endif
         {
            if (hsDataLen < 1)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            paramnamed = *registeredevent++;
            hsDataLen--;
            if (paramnamed)
            {
               if (hsDataLen < paramnamed)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }
               
               registeredevent += paramnamed;
               hsDataLen -= paramnamed;
            }
         }
         #endif

         if (hsDataLen < SHARKSSL_CERT_LENGTH_LEN)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         crLen = (U32)(*registeredevent++) << 16;
         crLen += (U16)(*registeredevent++) << 8;
         crLen += *registeredevent++;
         hsDataLen -= SHARKSSL_CERT_LENGTH_LEN;

         if (crLen == 0)
         {
            #if SHARKSSL_SSL_SERVER_CODE
            
            if (SharkSsl_isServer(o->sharkSsl))
            {
               o->flags &= ~unregistershash;
               o->flags |=  serialreset;
            }
            else
            #endif
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_BAD_CERTIFICATE);
            }
         }
         else if (hsDataLen < SHARKSSL_CERT_LENGTH_LEN)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         
         ioremapresource(sharkSslHSParam, tp, hsLen);

         ics = 0; 
         certParam = &(sharkSslHSParam->certParam);
         while (crLen > 0)
         {
            
            now_ccLen = (U32)(*registeredevent++) << 16;
            now_ccLen += (U16)(*registeredevent++) << 8;
            now_ccLen += *registeredevent++;
            hsDataLen -= SHARKSSL_CERT_LENGTH_LEN;

            if (hsDataLen < now_ccLen)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }

            
            if (spromregister(certParam, registeredevent, now_ccLen, 0) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_UNSUPPORTED_CERTIFICATE);
            }

            if (0 == ics)
            {
               ics++;
               
               #if SHARKSSL_USE_ECC
               if (machinereboot(certParam->certKey.expLen))
               {
                  baAssert(0 == mousethresh(certParam->certKey.expLen));
                  baAssert(sharkSslHSParam->cipherSuite);
                  i = (U16)(attachdevice(certParam->certKey.modLen)) * 2;
                  memcpy(afterhandler, certParam->certKey.mod, i);
                  certParam->certKey.mod = afterhandler;
                  afterhandler += i;
               }
               #if SHARKSSL_ENABLE_RSA
               else
               #endif
               #endif
               #if SHARKSSL_ENABLE_RSA
               {
                  baAssert(machinekexec(certParam->certKey.expLen));
                  memcpy(afterhandler, certParam->certKey.mod, supportedvector(certParam->certKey.modLen));
                  certParam->certKey.mod = afterhandler;
                  afterhandler += supportedvector(certParam->certKey.modLen);
                  memcpy(afterhandler, certParam->certKey.exp, mousethresh(certParam->certKey.expLen));
                  certParam->certKey.exp = afterhandler;
                  afterhandler += claimresource(mousethresh(certParam->certKey.expLen));
               }
               #endif
            }

            hsDataLen -= (U16)now_ccLen;
            registeredevent += (U16)now_ccLen;
            crLen -= (now_ccLen + SHARKSSL_CERT_LENGTH_LEN);

            #if SHARKSSL_TLS_1_3
            #if SHARKSSL_TLS_1_2
            if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
            #endif
            {
               
               if (crLen < 2)
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  goto regionfixed;
               }
               paramnamed = (U16)(*registeredevent++) << 8;
               paramnamed += *registeredevent++;
               crLen -= 2;
               hsDataLen -= 2;
               if (paramnamed)  
               {
                  baAssert(hsDataLen >= crLen);
                  if (crLen < paramnamed)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto regionfixed;
                  }
                  crLen -= paramnamed;
                  registeredevent += paramnamed;
                  hsDataLen -= paramnamed;
               }
            }
            #endif

            if (crLen) 
            {
               certParam->certInfo.parent = (SharkSslCertInfo*)afterhandler;
               certParam = (SharkSslCertParam*)afterhandler;
               memset(certParam, 0, sizeof(SharkSslCertParam));
               afterhandler += claimresource(sizeof(SharkSslCertParam));
            }
         }

         #if SHARKSSL_SSL_SERVER_CODE
         if (!(o->flags & serialreset))  
         #endif
         {
            #if (SHARKSSL_ENABLE_CA_EXTENSION && SHARKSSL_ENABLE_CA_LIST)
            SharkSslCAList displaysetup;

            if ((o->flags & SHARKSSL_FLAG_CA_EXTENSION_REQUEST) && (SharkSsl_isClient(o->sharkSsl)) && (o->caListCertReq))
            {
               displaysetup = o->caListCertReq;
            }
            else
            {
               displaysetup = o->sharkSsl->caList;
            }
            #endif
            if (SharkSslCertParam_validateCertChain(&(sharkSslHSParam->certParam), &(sharkSslHSParam->signParam)
               #if SHARKSSL_ENABLE_CA_LIST
               , &o->flags
               #if SHARKSSL_ENABLE_CA_EXTENSION
               , displaysetup
               #else
               , o->sharkSsl->caList
               #endif
               , afterhandler
               #endif
            ))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_BAD_CERTIFICATE);
            }
         }

         baAssert((SharkSslClonedCertInfo*)0 == o->clonedCertInfo);
         if (realnummemory(o, &o->clonedCertInfo))
         {
            SHARKDBG_PRINTF(("\157\050\045\060\070\130\051\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\050\045\060\070\130\051\055\076\162\145\146\143\156\164\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)o, (U32)o->clonedCertInfo, o->clonedCertInfo->refcnt, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\103\157\156\137\160\162\157\143\145\163\163\110\141\156\144\163\150\141\153\145"));
            #if SHARKSSL_ENABLE_SESSION_CACHE
            if (o->session)
            {
               
               filtermatch(&o->sharkSsl->sessionCache);
               SharkSslSession_copyClonedCertInfo(o->session, o);
               helperglobal(&o->sharkSsl->sessionCache);
            }
            #endif  
         }

         #if SHARKSSL_SSL_CLIENT_CODE
         if (SharkSsl_isClient(o->sharkSsl))
         {
            #if SHARKSSL_TLS_1_3
            #if SHARKSSL_TLS_1_2
            if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
            #endif
            {
               o->state = modifygraph;
            }
            #if SHARKSSL_TLS_1_2
            else
            #endif
            #endif
            #if SHARKSSL_TLS_1_2
            {
               #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
               if (sharkSslHSParam->cipherSuite->flags & cleandcache)
               {
                  o->state = startflags;
               }
               else
                  #endif
               {
                  o->state = configcwfon;
               }
            }
            #endif
         }
         #if SHARKSSL_SSL_SERVER_CODE
         else
         #endif
         #endif
         #if SHARKSSL_SSL_SERVER_CODE
         {
            o->state = subtableheaders;
         }
         #endif

         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
         #endif  

      case switcherdevice:
         i = 0;  
         #if SHARKSSL_TLS_1_2
         #if SHARKSSL_TLS_1_3
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
         #endif
         {
            if (!(o->flags & cachematch))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return savedconfig(o, SHARKSSL_ALERT_UNEXPECTED_MESSAGE);
            }
            o->flags &= ~cachematch;
            paramnamed = SHARKSSL_FINISHED_MSG_LEN_TLS_1_2;
         }
         #if SHARKSSL_TLS_1_3
         else
         #endif
         #endif
         #if SHARKSSL_TLS_1_3
         {
            paramnamed = i = sharkssl_getHashLen(o->rCipherSuite->hashID);
            baAssert(o->wCipherSuite == o->rCipherSuite);
         }
         #endif

         if ((atagsprocfs) || (hsDataLen != paramnamed))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         
         registerfixed(&o->outBuf);

         
         if (printsilicon(o, SharkSsl_isClient(o->sharkSsl) ? rodatastart : tvp5146routes, afterhandler) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            resvdexits(o);
            return SharkSslCon_Error;
         }
         if (sharkssl_kmemcmp(registeredevent, afterhandler, paramnamed))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         o->state = loongson3notifier;
         o->inBuf.temp = 0;

         #if SHARKSSL_TLS_1_2
         #if SHARKSSL_TLS_1_3
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
         #endif
         {
            #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
            memcpy(SharkSsl_isServer(o->sharkSsl) ? o->clientVerifyData : o->serverVerifyData, registeredevent, paramnamed);
            #if (SHARKSSL_ENABLE_ALPN_EXTENSION) && (SHARKSSL_SSL_CLIENT_CODE)
            #if SHARKSSL_SSL_SERVER_CODE
            if (SharkSsl_isClient(o->sharkSsl))
            #endif
            {
               o->pALPN = NULL;  
            }
            #endif
            #endif

            #if SHARKSSL_ENABLE_AES_GCM
            
            o->flags |= devicedriver;
            #endif

            
            o->flags &= ~unregistershash;

            if (((SharkSsl_isServer(o->sharkSsl)) && (!(o->flags & startqueue)))
               ||
               ((SharkSsl_isClient(o->sharkSsl)) && ((o->flags & startqueue))))
            {
               ioremapresource(sharkSslHSParam, registeredevent - traceentry, hsDataLen + traceentry);
               if (sanitisependbaser(o, SharkSsl_isServer(o->sharkSsl) ? rodatastart : tvp5146routes, (U8*)0))
               {
                  SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                  resvdexits(o);
                  return SharkSslCon_Error;
               }
            }

            #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
            o->flags &= ~platformdevice;
            #endif
         }
         #if SHARKSSL_TLS_1_3
         else
         #endif
         #endif  

         #if SHARKSSL_TLS_1_3
         {
            ioremapresource(sharkSslHSParam, registeredevent - traceentry, hsDataLen + traceentry);
            
            wakeupvector(sharkSslHSParam, afterhandler, o->rCipherSuite->hashID);
            
            registerfixed(&o->inBuf);
            tb = o->inBuf.data;
            
            if (o->flags & cachematch)
            {
               tb = templateentry(o, rangealigned, tb, 1);
               *tb++ = 1;
               o->inBuf.data = tb;  
            }
            
            if (o->flags & unregistershash)
            {
               sp = tb + clkctrlmanaged;
               tp = sp + traceentry;
               *tp++ = 0;  
               paramnamed = 1;  
               #if SHARKSSL_ENABLE_CLIENT_AUTH
               if (sharkSslHSParam->certParsed)
               {
                  SharkSslCert kernelvaddr;
                  SharkSslCertEnum cEnum;
                  U8* sdhciplatdata;

                  registerautodeps(&cEnum, sharkSslHSParam->certParsed->cert);
                  kernelvaddr = updatesctlr(&cEnum);
                  
                  if (!interrupthandler(&(sharkSslHSParam->certKey), kernelvaddr))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return SharkSslCon_CertificateError;
                  }

                  
                  tp += SHARKSSL_CERT_LENGTH_LEN;
                  sdhciplatdata = tp;

                  while (kernelvaddr != NULL)
                  {
                     crLen = SharkSslCertEnum_getCertLength(&cEnum);
                     *tp++ = 0x00;
                     *tp++ = (U8)(crLen >> 8);
                     *tp++ = (U8)(crLen & 0xFF);
                     
                     memcpy(tp, kernelvaddr, crLen);
                     tp += crLen;
                     
                     *tp++ = 0x00;   
                     *tp++ = 0x00;
                     
                     kernelvaddr = removerecursive(&cEnum);
                  }

                  crLen = (U16)(tp - sdhciplatdata);  
                  *--sdhciplatdata = (U8)(crLen & 0xFF);
                  *--sdhciplatdata = (U8)(crLen >> 8);
                  *--sdhciplatdata = 0x00;

                  paramnamed += (U16)crLen + SHARKSSL_CERT_LENGTH_LEN;  
               }
               else
               #endif
               {
                  o->flags &= ~unregistershash;
                  *tp++ = 0x00;
                  *tp++ = 0x00;
                  *tp++ = 0x00;
                  paramnamed += 3;
               }
               *sp++ = parsebootinfo;
               *sp++ = 0;
               *sp++ = (U8)(paramnamed >> 8);
               *sp++ = (U8)(paramnamed & 0xFF);
               ioremapresource(sharkSslHSParam, sp - traceentry, paramnamed + traceentry);
               #if SHARKSSL_ENABLE_CLIENT_AUTH
               
               if (o->flags & unregistershash)
               {
                  o->flags &= ~unregistershash;
                  afterhandler += i;  
                  
                  if (wakeupvector(sharkSslHSParam, afterhandler + SHARKSSL_DIM_ARR(cvServerCtxZero) + 64, o->wCipherSuite->hashID) < 0)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     _sharkssl_hs_alert_internal_error:
                     return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
                  }
                  memset(afterhandler, 0x20, 64);
                  memcpy(afterhandler + 64, cvServerCtxZero, SHARKSSL_DIM_ARR(cvServerCtxZero));
                  memcpy(afterhandler + 64 + 9, "\143\154\151\145\156\164", 6);  
                  if (SharkSslHSParam_setSignatureHashAlgoFromSignatureScheme(sharkSslHSParam, sharkSslHSParam->prot.tls13.signatureScheme))
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     goto _sharkssl_hs_alert_internal_error;
                  }
                  sharkssl_hash(sharkSslHSParam->signParam.signature.hash, afterhandler, SHARKSSL_DIM_ARR(cvServerCtxZero) + 64 + i, sharkSslHSParam->signParam.signature.hashAlgo);
                  
                  sharkSslHSParam->signParam.pCertKey = &(sharkSslHSParam->certKey);

                  
                  sharkSslHSParam->signParam.signature.signature = tp + traceentry + 4;
                  if (checkactions(&(sharkSslHSParam->signParam)) < 0)
                  {
                     SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
                  }
                  crLen = sharkSslHSParam->signParam.signature.signLen + 4;
                  *tp++ = modifygraph;
                  *tp++ = 0x00;
                  *tp++ = (U8)(crLen >> 8);
                  *tp++ = (U8)(crLen & 0xFF);
                  crLen -= 4;
                  *tp++ = (U8)(sharkSslHSParam->prot.tls13.signatureScheme >> 8);
                  *tp++ = (U8)(sharkSslHSParam->prot.tls13.signatureScheme & 0xFF);
                  *tp++ = (U8)(crLen >> 8);
                  *tp++ = (U8)(crLen & 0xFF);
                  tp += crLen;
                  crLen += 8;
                  ioremapresource(sharkSslHSParam, tp - crLen, (U16)crLen);
                  afterhandler -= i;  
               }
               #endif
            }
            else
            {
               tp = tb + clkctrlmanaged;
            }
            
            paramnamed = i;
            #if SHARKSSL_ENABLE_SESSION_CACHE
            crLen = paramnamed;
            sp = tp;
            #endif
            * tp++ = switcherdevice;
            *tp++ = 0x00;
            *tp++ = 0x00;
            *tp++ = (U8)paramnamed;
            if (printsilicon(o, tvp5146routes, tp) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }
            paramnamed += (U16)(tp - tb);
            o->inBuf.temp += paramnamed;
            paramnamed -= clkctrlmanaged;
            templateentry(o, controllegacy, tb, paramnamed);
            #if SHARKSSL_ENABLE_SESSION_CACHE
            crLen += (U16)(tp - sp);
            memcpy(afterhandler + i, sp, crLen);
            #endif
            
            if (SharkSslCon_calcMACAndEncryptHS(o) < 0)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               resvdexits(o);
               return SharkSslCon_Error;
            }
            if (o->flags & cachematch)
            {
               
               registerfixed(&o->inBuf);
               o->inBuf.temp += clkctrlmanaged + 1;
            }
            SharkSslCon_calcAppTrafficSecret(o, afterhandler);  
            #if SHARKSSL_ENABLE_SESSION_CACHE
            ioremapresource(sharkSslHSParam, afterhandler + i, (U16)crLen);
            
            wakeupvector(sharkSslHSParam, afterhandler, o->rCipherSuite->hashID);
            SharkSslCon_calcResumptionSecret(o, afterhandler);
            #endif
         }
         #endif  

         alignmentldmstm(sharkSslHSParam);
         return SharkSslCon_Handshake;

      case modifygraph:
         #if (SHARKSSL_TLS_1_3 && SHARKSSL_SSL_CLIENT_CODE)
         #if (SHARKSSL_TLS_1_2 && SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_CLIENT_AUTH)
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
         {
            goto _sharkssl_handshaketype_certificate_verify_12;
         }
         #endif
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         paramnamed = (U16)(*registeredevent++) << 8;
         paramnamed += *registeredevent++;
         hsDataLen -= 2;

         if (SharkSslHSParam_setSignatureHashAlgoFromSignatureScheme(sharkSslHSParam, paramnamed))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;  
         }
         paramnamed = (*registeredevent++ << 8);
         paramnamed += *registeredevent++;
         hsDataLen -= 2;
         if (paramnamed != hsDataLen)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         #if SHARKSSL_ENABLE_RSA
         #if (!SHARKSSL_ENABLE_ECDSA)
         baAssert(machinekexec(sharkSslHSParam->certParam.certKey.expLen));
         #else
         if (machinekexec(sharkSslHSParam->certParam.certKey.expLen))
         #endif
         {
            afterhandler += supportedvector(sharkSslHSParam->certParam.certKey.modLen);
            afterhandler += claimresource(mousethresh(sharkSslHSParam->certParam.certKey.expLen));
         }
         #if SHARKSSL_ENABLE_ECDSA
         else
         #endif
         #endif  
         #if SHARKSSL_ENABLE_ECDSA
         {
            if (machinereboot(sharkSslHSParam->certParam.certKey.expLen))
            {
               afterhandler += (U16)(attachdevice(sharkSslHSParam->certParam.certKey.modLen)) * 2;
            }
         }
         #endif

         if (wakeupvector(sharkSslHSParam, afterhandler + SHARKSSL_DIM_ARR(cvServerCtxZero) + 64, o->rCipherSuite->hashID) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
         }
         ioremapresource(sharkSslHSParam, tp, hsLen);

         
         memset(afterhandler, 0x20, 64);
         memcpy(afterhandler + 64, cvServerCtxZero, SHARKSSL_DIM_ARR(cvServerCtxZero));
         sharkssl_hash(sharkSslHSParam->signParam.signature.hash, afterhandler, SHARKSSL_DIM_ARR(cvServerCtxZero) + 64 + sharkssl_getHashLen(o->rCipherSuite->hashID), sharkSslHSParam->signParam.signature.hashAlgo);

         sharkSslHSParam->signParam.signature.signature = registeredevent;
         sharkSslHSParam->signParam.signature.signLen = hsDataLen;
         
         sharkSslHSParam->signParam.pCertKey = &(sharkSslHSParam->certParam.certKey);
         if (systemcapabilities(&(sharkSslHSParam->signParam)) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            
            return savedconfig(o, SHARKSSL_ALERT_DECRYPT_ERROR);
         }
         registeredevent += hsDataLen;
         o->state = switcherdevice;
         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
         #endif  
   
         #if (SHARKSSL_TLS_1_2 && SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_CLIENT_AUTH)
         #if (SHARKSSL_TLS_1_3 && SHARKSSL_SSL_CLIENT_CODE)
         _sharkssl_handshaketype_certificate_verify_12:
         #endif
         tp = registeredevent - traceentry;
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         {
            if ( (hsDataLen < 2)
                  ||
                  ((*registeredevent != presentpages) && (*registeredevent != domainnumber)
                  #if SHARKSSL_USE_SHA_384
                  && (*registeredevent != probewrite)
                  #endif
                  #if SHARKSSL_USE_SHA_512
                  && (*registeredevent != batterythread)
                  #endif
                  ) )
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            sharkSslHSParam->signParam.signature.hashAlgo = *registeredevent++;

            if (1
                #if SHARKSSL_ENABLE_RSA
                && (*registeredevent != entryearly)
                #endif
                #if SHARKSSL_ENABLE_ECDSA
                && (*registeredevent != accessactive)
                #endif
                )
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto regionfixed;
            }
            sharkSslHSParam->signParam.signature.signatureAlgo = *registeredevent++;
            hsDataLen -= 2;
         }

         paramnamed  = (*registeredevent++ << 8);
         paramnamed += *registeredevent++;
         hsDataLen -= 2;
         if (paramnamed != hsDataLen)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }

         if (wakeupvector(sharkSslHSParam, sharkSslHSParam->signParam.signature.hash, sharkSslHSParam->signParam.signature.hashAlgo) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
         }
         ioremapresource(sharkSslHSParam, tp, hsLen);

         sharkSslHSParam->signParam.signature.signature = registeredevent;
         sharkSslHSParam->signParam.signature.signLen = hsDataLen;
         sharkSslHSParam->signParam.pCertKey = &(sharkSslHSParam->certParam.certKey);  
         if (systemcapabilities(&(sharkSslHSParam->signParam)) < 0)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         registeredevent += hsDataLen;
         o->state = switcherdevice;
         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
         #endif  

      #if SHARKSSL_TLS_1_3
      #if SHARKSSL_SSL_CLIENT_CODE
      case SHARKSSL_HANDSHAKETYPE_ENCRYPTED_EXTENSIONS:
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         paramnamed = (U16)(*registeredevent++) << 8;
         paramnamed += *registeredevent++;
         hsDataLen -= 2;
         if (hsDataLen != paramnamed)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto updatereserved;
         }

         if ((paramnamed) && (registerclass(o, registeredevent, paramnamed)))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         registeredevent += paramnamed;
         ioremapresource(sharkSslHSParam, tp, hsLen);
         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (o->flags & startqueue)
         {
            o->state = switcherdevice;
         }
         else
         #endif
         {
            o->state = logicmembank;
         }
         if (atagsprocfs)
         {
            goto suspendlocal;
         }
         return SharkSslCon_Handshake;

      case SHARKSSL_HANDSHAKETYPE_NEW_SESSION_TICKET:
         
         o->flags |= devicedriver;  
         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (hsDataLen < 9)  
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         read64uint32(now_ccLen, registeredevent, 0);  
         read64uint32(crLen, registeredevent, 4);  
         registeredevent += 8;
         setupinterface = *registeredevent++;  
         hsDataLen -= 9;
         if ((hsDataLen < setupinterface) || (now_ccLen > 0x00093A80L ))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         tp = registeredevent;  
         registeredevent += setupinterface;
         hsDataLen -= setupinterface;
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         paramnamed = (U16)(*registeredevent++) << 8;
         paramnamed += (*registeredevent++);
         hsDataLen -= 2;
         if (hsDataLen < paramnamed)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         sp = registeredevent;  
         registeredevent += paramnamed;
         hsDataLen -= paramnamed;
         if (hsDataLen < 2)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         
         i = (U16)(*registeredevent++) << 8;
         i += (*registeredevent++);
         hsDataLen -= 2;
         if (hsDataLen != i)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto regionfixed;
         }
         
         if (!(o->session))
         {
            o->flags |= gpiolibmbank;
            o->session = sa1111device(&o->sharkSsl->sessionCache, o, sp, paramnamed);
            if (o->session)
            {
               
               filtermatch(&o->sharkSsl->sessionCache);
               o->session->prot.tls13.expiration += now_ccLen;
               o->session->prot.tls13.ticketAgeAdd = crLen;
               SharkSslCon_calcTicketPSK(o, (U8*)&o->session->prot.tls13.PSK, tp, setupinterface);
               
               SharkSslSession_copyClonedCertInfo(o->session, o);
               helperglobal(&o->sharkSsl->sessionCache);
            }
         }
         
         #endif
         o->state = loongson3notifier;
         o->inBuf.temp = 0;
         return SharkSslCon_Handshake;
      #endif    
      #endif  

      default:
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return savedconfig(o, SHARKSSL_ALERT_UNEXPECTED_MESSAGE);
   }
}
#endif


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include "BaMimeTypes.h"
#include "BaServerLib.h"

typedef struct
{
   const char* ext;
   const char* val;
} HttpMimeType;

static const char htmlMmimeT[]={"\164\145\170\164\057\150\164\155\154\073\040\143\150\141\162\163\145\164\075\165\164\146\055\070"};


static const HttpMimeType mimeTypes[] = {
   {"\063\144\155",         "\170\055\167\157\162\154\144\057\170\055\063\144\155\146"},
   {"\063\144\155\146",        "\170\055\167\157\162\154\144\057\170\055\063\144\155\146"},
   {"\141\141\142",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\141\165\164\150\157\162\167\141\162\145\055\142\151\156"},
   {"\141\141\155",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\141\165\164\150\157\162\167\141\162\145\055\155\141\160"},
   {"\141\141\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\141\165\164\150\157\162\167\141\162\145\055\163\145\147"},
   {"\141\142\143",         "\164\145\170\164\057\166\156\144\056\141\142\143"},
   {"\141\146\154",         "\166\151\144\145\157\057\141\156\151\155\141\146\154\145\170"},
   {"\141\151",          "\141\160\160\154\151\143\141\164\151\157\156\057\160\157\163\164\163\143\162\151\160\164"},
   {"\141\151\146",         "\141\165\144\151\157\057\170\055\141\151\146\146"},
   {"\141\151\146\143",        "\141\165\144\151\157\057\170\055\141\151\146\146"},
   {"\141\151\146\146",        "\141\165\144\151\157\057\170\055\141\151\146\146"},
   {"\141\151\155",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\141\151\155"},
   {"\141\151\160",         "\164\145\170\164\057\170\055\141\165\144\151\157\163\157\146\164\055\151\156\164\162\141"},
   {"\141\156\151",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\156\141\166\151\055\141\156\151\155\141\164\151\157\156"},
   {"\141\157\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\156\157\153\151\141\055\071\060\060\060\055\143\157\155\155\165\156\151\143\141\164\157\162\055\141\144\144\055\157\156\055\163\157\146\164\167\141\162\145"},
   {"\141\160\160\154\151\143\141\164\151\157\156","\141\160\160\154\151\143\141\164\151\157\156\057\170\055\155\163\055\141\160\160\154\151\143\141\164\151\157\156"},
   {"\141\160\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\151\155\145"},
   {"\141\162\164",         "\151\155\141\147\145\057\170\055\152\147"},
   {"\141\163\146",         "\166\151\144\145\157\057\170\055\155\163\055\141\163\146"},
   {"\141\163\155",         "\164\145\170\164\057\170\055\141\163\155"},
   {"\141\163\160",         "\164\145\170\164\057\141\163\160"},
   {"\141\163\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\155\160\154\141\171\145\162\062"},
   {"\141\165",          "\141\165\144\151\157\057\142\141\163\151\143"},
   {"\141\166\151",         "\166\151\144\145\157\057\170\055\155\163\166\151\144\145\157"},
   {"\142\143\160\151\157",       "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\142\143\160\151\157"},
   {"\142\155",          "\151\155\141\147\145\057\142\155\160"},
   {"\142\155\160",         "\151\155\141\147\145\057\142\155\160"},
   {"\142\157\157",         "\141\160\160\154\151\143\141\164\151\157\156\057\142\157\157\153"},
   {"\142\157\157\153",        "\141\160\160\154\151\143\141\164\151\157\156\057\142\157\157\153"},
   {"\142\157\172",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\142\172\151\160\062"},
   {"\142\163\150",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\142\163\150"},
   {"\142\172",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\142\172\151\160"},
   {"\142\172\062",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\142\172\151\160\062"},
   {"\143",           "\164\145\170\164\057\160\154\141\151\156"},
   {"\143",           "\164\145\170\164\057\170\055\143"},
   {"\143\053\053",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\143\141\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\155\163\055\160\153\151\056\163\145\143\143\141\164"},
   {"\143\143",          "\164\145\170\164\057\160\154\141\151\156"},
   {"\143\143",          "\164\145\170\164\057\170\055\143"},
   {"\143\143\141\144",        "\141\160\160\154\151\143\141\164\151\157\156\057\143\154\141\162\151\163\143\141\144"},
   {"\143\143\157",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\157\143\157\141"},
   {"\143\144\146",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\156\145\164\143\144\146"},
   {"\143\145\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\170\065\060\071\055\143\141\055\143\145\162\164"},
   {"\143\150\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\150\141\164"},
   {"\143\150\141\164",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\150\141\164"},
   {"\143\154\141\163\163",       "\141\160\160\154\151\143\141\164\151\157\156\057\152\141\166\141"},
   {"\143\157\156\146",        "\164\145\170\164\057\160\154\141\151\156"},
   {"\143\160\151\157",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\160\151\157"},
   {"\143\160\160",         "\164\145\170\164\057\170\055\143"},
   {"\143\160\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\160\164"},
   {"\143\162\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\160\153\151\170\055\143\162\154"},
   {"\143\162\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\170\065\060\071\055\165\163\145\162\055\143\145\162\164"},
   {"\143\163\150",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\163\150"},
   {"\143\163\150",         "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\143\163\150"},
   {"\143\163\163",         "\164\145\170\164\057\143\163\163"},
   {"\143\170\170",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\144\143\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\144\151\162\145\143\164\157\162"},
   {"\144\145\145\160\166",       "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\144\145\145\160\166"},
   {"\144\145\146",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\144\145\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\170\065\060\071\055\143\141\055\143\145\162\164"},
   {"\144\151\146",         "\166\151\144\145\157\057\170\055\144\166"},
   {"\144\151\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\144\151\162\145\143\164\157\162"},
   {"\144\154",          "\166\151\144\145\157\057\144\154"},
   {"\144\154",          "\166\151\144\145\157\057\170\055\144\154"},
   {"\144\157\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\167\157\162\144"},
   {"\144\157\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\167\157\162\144"},
   {"\144\160",          "\141\160\160\154\151\143\141\164\151\157\156\057\143\157\155\155\157\156\147\162\157\165\156\144"},
   {"\144\162\167",         "\141\160\160\154\151\143\141\164\151\157\156\057\144\162\141\146\164\151\156\147"},
   {"\144\166",          "\166\151\144\145\157\057\170\055\144\166"},
   {"\144\166\151",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\144\166\151"},
   {"\144\167\146",         "\155\157\144\145\154\057\166\156\144\056\144\167\146"},
   {"\144\167\147",         "\141\160\160\154\151\143\141\164\151\157\156\057\141\143\141\144"},
   {"\144\167\147",         "\151\155\141\147\145\057\170\055\144\167\147"},
   {"\144\170\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\144\151\162\145\143\164\157\162"},
   {"\145\154",          "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\145\154\151\163\160"},
   {"\145\154\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\145\154\143"},
   {"\145\156\166",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\145\156\166\157\171"},
   {"\145\160\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\160\157\163\164\163\143\162\151\160\164"},
   {"\145\163",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\145\163\162\145\150\142\145\162"},
   {"\145\164\170",         "\164\145\170\164\057\170\055\163\145\164\145\170\164"},
   {"\145\166\171",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\145\156\166\157\171"},
   {"\146",           "\164\145\170\164\057\170\055\146\157\162\164\162\141\156"},
   {"\146\067\067",         "\164\145\170\164\057\170\055\146\157\162\164\162\141\156"},
   {"\146\071\060",         "\164\145\170\164\057\170\055\146\157\162\164\162\141\156"},
   {"\146\144\146",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\146\144\146"},
   {"\146\151\146",         "\151\155\141\147\145\057\146\151\146"},
   {"\146\154\151",         "\166\151\144\145\157\057\170\055\146\154\151"},
   {"\146\154\157",         "\151\155\141\147\145\057\146\154\157\162\151\141\156"},
   {"\146\154\170",         "\164\145\170\164\057\166\156\144\056\146\155\151\056\146\154\145\170\163\164\157\162"},
   {"\146\155\146",         "\166\151\144\145\157\057\170\055\141\164\157\155\151\143\063\144\055\146\145\141\164\165\162\145"},
   {"\146\157\162",         "\164\145\170\164\057\170\055\146\157\162\164\162\141\156"},
   {"\146\160\170",         "\151\155\141\147\145\057\166\156\144\056\156\145\164\055\146\160\170"},
   {"\146\162\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\146\162\145\145\154\157\141\144\145\162"},
   {"\146\165\156\153",        "\141\165\144\151\157\057\155\141\153\145"},
   {"\147",           "\164\145\170\164\057\160\154\141\151\156"},
   {"\147\063",          "\151\155\141\147\145\057\147\063\146\141\170"},
   {"\147\151\146",         "\151\155\141\147\145\057\147\151\146"},
   {"\147\154",          "\166\151\144\145\157\057\170\055\147\154"},
   {"\147\163\144",         "\141\165\144\151\157\057\170\055\147\163\155"},
   {"\147\163\155",         "\141\165\144\151\157\057\170\055\147\163\155"},
   {"\147\163\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\147\163\160"},
   {"\147\163\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\147\163\163"},
   {"\147\164\141\162",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\147\164\141\162"},
   {"\147\172",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\147\172\151\160"},
   {"\147\172\151\160",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\147\172\151\160"},
   {"\150",           "\164\145\170\164\057\160\154\141\151\156"},
   {"\150",           "\164\145\170\164\057\170\055\150"},
   {"\150\144\146",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\150\144\146"},
   {"\150\145\154\160",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\150\145\154\160\146\151\154\145"},
   {"\150\147\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\150\160\055\110\120\107\114"},
   {"\150\150",          "\164\145\170\164\057\160\154\141\151\156"},
   {"\150\154\142",         "\164\145\170\164\057\170\055\163\143\162\151\160\164"},
   {"\150\154\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\151\156\150\145\154\160"},
   {"\150\160\147",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\150\160\055\110\120\107\114"},
   {"\150\160\147\154",        "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\150\160\055\110\120\107\114"},
   {"\150\161\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\142\151\156\150\145\170"},
   {"\150\164\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\150\164\141"},
   {"\150\164\143",         "\164\145\170\164\057\170\055\143\157\155\160\157\156\145\156\164"},
   {"\150\164\155",         htmlMmimeT},
   {"\150\164\155\154",        htmlMmimeT},
   {"\150\164\155\154\163",       htmlMmimeT},
   {"\150\164\164",         "\164\145\170\164\057\167\145\142\166\151\145\167\150\164\155\154"},
   {"\151\143\145",         "\170\055\143\157\156\146\145\162\145\156\143\145\057\170\055\143\157\157\154\164\141\154\153"},
   {"\151\143\157",         "\151\155\141\147\145\057\170\055\151\143\157\156"},
   {"\151\144\143",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\151\145\146",         "\151\155\141\147\145\057\151\145\146"},
   {"\151\145\146\163",        "\151\155\141\147\145\057\151\145\146"},
   {"\151\147\145\163",        "\141\160\160\154\151\143\141\164\151\157\156\057\151\147\145\163"},
   {"\151\147\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\151\147\145\163"},
   {"\151\155\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\151\155\141"},
   {"\151\155\141\160",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\150\164\164\160\144\055\151\155\141\160"},
   {"\151\156\146",         "\141\160\160\154\151\143\141\164\151\157\156\057\151\156\146"},
   {"\151\156\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\151\156\164\145\162\156\145\164\164\055\163\151\147\156\165\160"},
   {"\151\160",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\151\160\062"},
   {"\151\163\165",         "\166\151\144\145\157\057\170\055\151\163\166\151\144\145\157"},
   {"\151\164",          "\141\165\144\151\157\057\151\164"},
   {"\151\166",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\151\156\166\145\156\164\157\162"},
   {"\151\166\162",         "\151\055\167\157\162\154\144\057\151\055\166\162\155\154"},
   {"\151\166\171",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\154\151\166\145\163\143\162\145\145\156"},
   {"\152\141\155",         "\141\165\144\151\157\057\170\055\152\141\155"},
   {"\152\141\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\152\141\166\141"},
   {"\152\141\166\141",        "\164\145\170\164\057\170\055\152\141\166\141\055\163\157\165\162\143\145"},
   {"\152\143\155",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\152\141\166\141\055\143\157\155\155\145\162\143\145"},
   {"\152\146\151\146",        "\151\155\141\147\145\057\152\160\145\147"},
   {"\152\156\154\160",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\152\141\166\141\055\152\156\154\160\055\146\151\154\145"},
   {"\152\160\145",         "\151\155\141\147\145\057\152\160\145\147"},
   {"\152\160\145\147",        "\151\155\141\147\145\057\152\160\145\147"},
   {"\152\160\147",         "\151\155\141\147\145\057\152\160\145\147"},
   {"\152\160\163",         "\151\155\141\147\145\057\170\055\152\160\163"},
   {"\152\163",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\152\141\166\141\163\143\162\151\160\164"},
   {"\152\165\164",         "\151\155\141\147\145\057\152\165\164\166\151\163\151\157\156"},
   {"\153\141\162",         "\141\165\144\151\157\057\155\151\144\151"},
   {"\153\163\150",         "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\153\163\150"},
   {"\154\141",          "\141\165\144\151\157\057\170\055\156\163\160\141\165\144\151\157"},
   {"\154\141\155",         "\141\165\144\151\157\057\170\055\154\151\166\145\141\165\144\151\157"},
   {"\154\141\164\145\170",       "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\154\141\164\145\170"},
   {"\154\150\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\154\150\141"},
   {"\154\151\163\164",        "\164\145\170\164\057\160\154\141\151\156"},
   {"\154\155\141",         "\141\165\144\151\157\057\170\055\156\163\160\141\165\144\151\157"},
   {"\154\157\147",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\154\163\164",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\154\163\170",         "\164\145\170\164\057\170\055\154\141\055\141\163\146"},
   {"\154\164\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\154\141\164\145\170"},
   {"\154\172\150",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\154\172\150"},
   {"\154\172\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\154\172\170"},
   {"\155",           "\164\145\170\164\057\160\154\141\151\156"},
   {"\155",           "\164\145\170\164\057\170\055\155"},
   {"\155\061\166",         "\166\151\144\145\157\057\155\160\145\147"},
   {"\155\062\141",         "\141\165\144\151\157\057\155\160\145\147"},
   {"\155\062\166",         "\166\151\144\145\157\057\155\160\145\147"},
   {"\155\063\165",         "\141\165\144\151\157\057\170\055\155\160\145\161\165\162\154"},
   {"\155\141\156",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\162\157\146\146\055\155\141\156"},
   {"\155\141\156\151\146\145\163\164",   "\141\160\160\154\151\143\141\164\151\157\156\057\155\141\156\151\146\145\163\164"},
   {"\155\141\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\156\141\166\151\155\141\160"},
   {"\155\141\162",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\155\142\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\142\145\144\154\145\164"},
   {"\155\143\044",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\155\141\147\151\143\055\143\141\160\055\160\141\143\153\141\147\145\055\061\056\060"},
   {"\155\143\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\155\141\164\150\143\141\144"},
   {"\155\143\146",         "\151\155\141\147\145\057\166\141\163\141"},
   {"\155\143\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\156\145\164\155\143"},
   {"\155\145",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\162\157\146\146\055\155\145"},
   {"\155\150\164",         "\155\145\163\163\141\147\145\057\162\146\143\070\062\062"},
   {"\155\150\164\155\154",       "\155\145\163\163\141\147\145\057\162\146\143\070\062\062"},
   {"\155\151\144",         "\141\165\144\151\157\057\155\151\144\151"},
   {"\155\151\144\151",        "\141\165\144\151\157\057\155\151\144\151"},
   {"\155\151\155\145",        "\155\145\163\163\141\147\145\057\162\146\143\070\062\062"},
   {"\155\152\146",         "\141\165\144\151\157\057\170\055\166\156\144\056\101\165\144\151\157\105\170\160\154\157\163\151\157\156\056\115\152\165\151\143\145\115\145\144\151\141\106\151\154\145"},
   {"\155\152\160\147",        "\166\151\144\145\157\057\170\055\155\157\164\151\157\156\055\152\160\145\147"},
   {"\155\153\166",         "\166\151\144\145\157\057\170\055\155\141\164\162\157\163\153\141"},
   {"\155\155",          "\141\160\160\154\151\143\141\164\151\157\156\057\142\141\163\145\066\064"},
   {"\155\155\145",         "\141\160\160\154\151\143\141\164\151\157\156\057\142\141\163\145\066\064"},
   {"\155\157\144",         "\141\165\144\151\157\057\170\055\155\157\144"},
   {"\155\157\157\166",        "\166\151\144\145\157\057\161\165\151\143\153\164\151\155\145"},
   {"\155\157\166",         "\166\151\144\145\157\057\161\165\151\143\153\164\151\155\145"},
   {"\155\157\166\151\145",       "\166\151\144\145\157\057\170\055\163\147\151\055\155\157\166\151\145"},
   {"\155\160\062",         "\141\165\144\151\157\057\155\160\145\147"},
   {"\155\160\063",         "\141\165\144\151\157\057\155\160\145\147\063"},
   {"\155\160\064",         "\166\151\144\145\157\057\155\160\064"},
   {"\155\160\141",         "\141\165\144\151\157\057\155\160\145\147"},
   {"\155\160\141",         "\166\151\144\145\157\057\155\160\145\147"},
   {"\155\160\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\160\162\157\152\145\143\164"},
   {"\155\160\145",         "\166\151\144\145\157\057\155\160\145\147"},
   {"\155\160\145\147",        "\166\151\144\145\157\057\155\160\145\147"},
   {"\155\160\147",         "\166\151\144\145\157\057\155\160\145\147"},
   {"\155\160\147\141",        "\141\165\144\151\157\057\155\160\145\147"},
   {"\155\160\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\155\163\055\160\162\157\152\145\143\164"},
   {"\155\160\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\160\162\157\152\145\143\164"},
   {"\155\160\166",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\160\162\157\152\145\143\164"},
   {"\155\160\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\160\162\157\152\145\143\164"},
   {"\155\162\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\141\162\143"},
   {"\155\163",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\162\157\146\146\055\155\163"},
   {"\155\166",          "\166\151\144\145\157\057\170\055\163\147\151\055\155\157\166\151\145"},
   {"\155\171",          "\141\165\144\151\157\057\155\141\153\145"},
   {"\155\172\172",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\166\156\144\056\101\165\144\151\157\105\170\160\154\157\163\151\157\156\056\155\172\172"},
   {"\156\141\160",         "\151\155\141\147\145\057\156\141\160\154\160\163"},
   {"\156\141\160\154\160\163",      "\151\155\141\147\145\057\156\141\160\154\160\163"},
   {"\156\143",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\156\145\164\143\144\146"},
   {"\156\143\155",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\156\157\153\151\141\056\143\157\156\146\151\147\165\162\141\164\151\157\156\055\155\145\163\163\141\147\145"},
   {"\156\151\146",         "\151\155\141\147\145\057\170\055\156\151\146\146"},
   {"\156\151\146\146",        "\151\155\141\147\145\057\170\055\156\151\146\146"},
   {"\156\151\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\155\151\170\055\164\162\141\156\163\146\145\162"},
   {"\156\163\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\157\156\146\145\162\145\156\143\145"},
   {"\156\166\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\156\141\166\151\144\157\143"},
   {"\157\144\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\157\144\141"},
   {"\157\147\147",         "\166\151\144\145\157\057\157\147\147"},
   {"\157\147\155",         "\166\151\144\145\157\057\157\147\147"},
   {"\157\155\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\157\155\143"},
   {"\157\155\143\144",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\157\155\143\144\141\164\141\155\141\153\145\162"},
   {"\157\155\143\162",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\157\155\143\162\145\147\145\162\141\164\157\162"},
   {"\160",           "\164\145\170\164\057\170\055\160\141\163\143\141\154"},
   {"\160\141\163",         "\164\145\170\164\057\160\141\163\143\141\154"},
   {"\160\142\155",         "\151\155\141\147\145\057\170\055\160\157\162\164\141\142\154\145\055\142\151\164\155\141\160"},
   {"\160\143\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\160\143\154"},
   {"\160\143\164",         "\151\155\141\147\145\057\170\055\160\151\143\164"},
   {"\160\143\170",         "\151\155\141\147\145\057\170\055\160\143\170"},
   {"\160\144\142",         "\143\150\145\155\151\143\141\154\057\170\055\160\144\142"},
   {"\160\144\146",         "\141\160\160\154\151\143\141\164\151\157\156\057\160\144\146"},
   {"\160\146\165\156\153",       "\141\165\144\151\157\057\155\141\153\145"},
   {"\160\147\155",         "\151\155\141\147\145\057\170\055\160\157\162\164\141\142\154\145\055\147\162\141\171\155\141\160"},
   {"\160\151\143",         "\151\155\141\147\145\057\160\151\143\164"},
   {"\160\151\143\164",        "\151\155\141\147\145\057\160\151\143\164"},
   {"\160\153\147",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\156\145\167\164\157\156\055\143\157\155\160\141\164\151\142\154\145\055\160\153\147"},
   {"\160\153\157",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\155\163\055\160\153\151\056\160\153\157"},
   {"\160\154\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\120\151\130\103\114\163\143\162\151\160\164"},
   {"\160\155\064",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\160\141\147\145\155\141\153\145\162"},
   {"\160\155\065",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\160\141\147\145\155\141\153\145\162"},
   {"\160\156\147",         "\151\155\141\147\145\057\160\156\147"},
   {"\160\156\155",         "\151\155\141\147\145\057\170\055\160\157\162\164\141\142\154\145\055\141\156\171\155\141\160"},
   {"\160\157\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\160\157\167\145\162\160\157\151\156\164"},
   {"\160\157\166",         "\155\157\144\145\154\057\170\055\160\157\166"},
   {"\160\160\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\155\163\055\160\157\167\145\162\160\157\151\156\164"},
   {"\160\160\155",         "\151\155\141\147\145\057\170\055\160\157\162\164\141\142\154\145\055\160\151\170\155\141\160"},
   {"\160\160\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\160\157\167\145\162\160\157\151\156\164"},
   {"\160\160\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\160\157\167\145\162\160\157\151\156\164"},
   {"\160\160\172",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\160\157\167\145\162\160\157\151\156\164"},
   {"\160\162\145",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\146\162\145\145\154\141\156\143\145"},
   {"\160\162\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\160\162\157\137\145\156\147"},
   {"\160\163",          "\141\160\160\154\151\143\141\164\151\157\156\057\160\157\163\164\163\143\162\151\160\164"},
   {"\160\166\165",         "\160\141\154\145\157\166\165\057\170\055\160\166"},
   {"\160\167\172",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\155\163\055\160\157\167\145\162\160\157\151\156\164"},
   {"\160\171",          "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\160\150\171\164\157\156"},
   {"\160\171\143",         "\141\160\160\154\151\143\141\151\164\157\156\057\170\055\142\171\164\145\143\157\144\145\056\160\171\164\150\157\156"},
   {"\161\143\160",         "\141\165\144\151\157\057\166\156\144\056\161\143\145\154\160"},
   {"\161\144\063",         "\170\055\167\157\162\154\144\057\170\055\063\144\155\146"},
   {"\161\144\063\144",        "\170\055\167\157\162\154\144\057\170\055\063\144\155\146"},
   {"\161\151\146",         "\151\155\141\147\145\057\170\055\161\165\151\143\153\164\151\155\145"},
   {"\161\164",          "\166\151\144\145\157\057\161\165\151\143\153\164\151\155\145"},
   {"\161\164\143",         "\166\151\144\145\157\057\170\055\161\164\143"},
   {"\161\164\151",         "\151\155\141\147\145\057\170\055\161\165\151\143\153\164\151\155\145"},
   {"\161\164\151\146",        "\151\155\141\147\145\057\170\055\161\165\151\143\153\164\151\155\145"},
   {"\162\141",          "\141\165\144\151\157\057\170\055\162\145\141\154\141\165\144\151\157"},
   {"\162\141\155",         "\141\165\144\151\157\057\170\055\160\156\055\162\145\141\154\141\165\144\151\157"},
   {"\162\141\163",         "\151\155\141\147\145\057\170\055\143\155\165\055\162\141\163\164\145\162"},
   {"\162\141\163\164",        "\151\155\141\147\145\057\143\155\165\055\162\141\163\164\145\162"},
   {"\162\145\170\170",        "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\162\145\170\170"},
   {"\162\146",          "\151\155\141\147\145\057\166\156\144\056\162\156\055\162\145\141\154\146\154\141\163\150"},
   {"\162\147\142",         "\151\155\141\147\145\057\170\055\162\147\142"},
   {"\162\155",          "\141\165\144\151\157\057\170\055\160\156\055\162\145\141\154\141\165\144\151\157"},
   {"\162\155\151",         "\141\165\144\151\157\057\155\151\144"},
   {"\162\155\155",         "\141\165\144\151\157\057\170\055\160\156\055\162\145\141\154\141\165\144\151\157"},
   {"\162\156\147",         "\141\160\160\154\151\143\141\164\151\157\156\057\162\151\156\147\151\156\147\055\164\157\156\145\163"},
   {"\162\156\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\162\156\055\162\145\141\154\160\154\141\171\145\162"},
   {"\162\157\146\146",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\162\157\146\146"},
   {"\162\160",          "\151\155\141\147\145\057\166\156\144\056\162\156\055\162\145\141\154\160\151\170"},
   {"\162\160\155",         "\141\165\144\151\157\057\170\055\160\156\055\162\145\141\154\141\165\144\151\157\055\160\154\165\147\151\156"},
   {"\162\164",          "\164\145\170\164\057\162\151\143\150\164\145\170\164"},
   {"\162\164\146",         "\164\145\170\164\057\162\151\143\150\164\145\170\164"},
   {"\162\164\170",         "\164\145\170\164\057\162\151\143\150\164\145\170\164"},
   {"\162\166",          "\166\151\144\145\157\057\166\156\144\056\162\156\055\162\145\141\154\166\151\144\145\157"},
   {"\163",           "\164\145\170\164\057\170\055\141\163\155"},
   {"\163\063\155",         "\141\165\144\151\157\057\163\063\155"},
   {"\163\142\153",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\142\157\157\153"},
   {"\163\144\155\154",        "\164\145\170\164\057\160\154\141\151\156"},
   {"\163\144\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\144\160"},
   {"\163\144\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\163\157\165\156\144\145\162"},
   {"\163\145\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\145\141"},
   {"\163\145\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\163\145\164"},
   {"\163\147\155",         "\164\145\170\164\057\170\055\163\147\155\154"},
   {"\163\147\155\154",        "\164\145\170\164\057\170\055\163\147\155\154"},
   {"\163\150",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\150"},
   {"\163\150\141\162",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\150\141\162"},
   {"\163\150\164\155\154",       htmlMmimeT},
   {"\163\151\144",         "\141\165\144\151\157\057\170\055\160\163\151\144"},
   {"\163\151\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\164\165\146\146\151\164"},
   {"\163\153\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\153\157\141\156"},
   {"\163\153\155",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\153\157\141\156"},
   {"\163\153\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\153\157\141\156"},
   {"\163\153\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\153\157\141\156"},
   {"\163\154",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\145\145\154\157\147\157"},
   {"\163\155\151",         "\141\160\160\154\151\143\141\164\151\157\156\057\163\155\151\154"},
   {"\163\155\151\154",        "\141\160\160\154\151\143\141\164\151\157\156\057\163\155\151\154"},
   {"\163\156\144",         "\141\165\144\151\157\057\142\141\163\151\143"},
   {"\163\157\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\163\157\154\151\144\163"},
   {"\163\160\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\146\165\164\165\162\145\163\160\154\141\163\150"},
   {"\163\160\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\160\162\151\164\145"},
   {"\163\160\162\151\164\145",      "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\160\162\151\164\145"},
   {"\163\162\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\141\151\163\055\163\157\165\162\143\145"},
   {"\163\163\151",         "\164\145\170\164\057\170\055\163\145\162\166\145\162\055\160\141\162\163\145\144\055\150\164\155\154"},
   {"\163\163\155",         "\141\160\160\154\151\143\141\164\151\157\156\057\163\164\162\145\141\155\151\156\147\155\145\144\151\141"},
   {"\163\163\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\155\163\055\160\153\151\056\143\145\162\164\163\164\157\162\145"},
   {"\163\164\145\160",        "\141\160\160\154\151\143\141\164\151\157\156\057\163\164\145\160"},
   {"\163\164\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\163\164\145\160"},
   {"\163\166\064\143\160\151\157",     "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\166\064\143\160\151\157"},
   {"\163\166\064\143\162\143",      "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\166\064\143\162\143"},
   {"\163\166\147",         "\151\155\141\147\145\057\163\166\147\053\170\155\154"},
   {"\163\166\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\157\162\154\144"},
   {"\163\167\146",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\150\157\143\153\167\141\166\145\055\146\154\141\163\150"},
   {"\164",           "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\162\157\146\146"},
   {"\164\141\154\153",        "\164\145\170\164\057\170\055\163\160\145\145\143\150"},
   {"\164\141\162",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\141\162"},
   {"\164\142\153",         "\141\160\160\154\151\143\141\164\151\157\156\057\164\157\157\154\142\157\157\153"},
   {"\164\143\154",         "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\164\143\154"},
   {"\164\143\163\150",        "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\164\143\163\150"},
   {"\164\145\170",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\145\170"},
   {"\164\145\170\151",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\145\170\151\156\146\157"},
   {"\164\145\170\151\156\146\157",     "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\145\170\151\156\146\157"},
   {"\164\145\170\164",        "\141\160\160\154\151\143\141\164\151\157\156\057\160\154\141\151\156"},
   {"\164\145\170\164",        "\164\145\170\164\057\160\154\141\151\156"},
   {"\164\147\172",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\157\155\160\162\145\163\163\145\144"},
   {"\164\151\146",         "\151\155\141\147\145\057\170\055\164\151\146\146"},
   {"\164\151\146\146",        "\151\155\141\147\145\057\170\055\164\151\146\146"},
   {"\164\162",          "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\164\162\157\146\146"},
   {"\164\163\151",         "\141\165\144\151\157\057\164\163\160\055\141\165\144\151\157"},
   {"\164\163\160",         "\141\165\144\151\157\057\164\163\160\154\141\171\145\162"},
   {"\164\163\166",         "\164\145\170\164\057\164\141\142\055\163\145\160\141\162\141\164\145\144\055\166\141\154\165\145\163"},
   {"\164\165\162\142\157\164",      "\151\155\141\147\145\057\146\154\157\162\151\141\156"},
   {"\164\170\164",         "\164\145\170\164\057\160\154\141\151\156"},
   {"\165\151\154",         "\164\145\170\164\057\170\055\165\151\154"},
   {"\165\156\151",         "\164\145\170\164\057\165\162\151\055\154\151\163\164"},
   {"\165\156\151\163",        "\164\145\170\164\057\165\162\151\055\154\151\163\164"},
   {"\165\156\166",         "\141\160\160\154\151\143\141\164\151\157\156\057\151\055\144\145\141\163"},
   {"\165\162\151",         "\164\145\170\164\057\165\162\151\055\154\151\163\164"},
   {"\165\162\151\163",        "\164\145\170\164\057\165\162\151\055\154\151\163\164"},
   {"\165\163\164\141\162",       "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\165\163\164\141\162"},
   {"\165\163\164\141\162",       "\155\165\154\164\151\160\141\162\164\057\170\055\165\163\164\141\162"},
   {"\165\165",          "\164\145\170\164\057\170\055\165\165\145\156\143\157\144\145"},
   {"\165\165\145",         "\164\145\170\164\057\170\055\165\165\145\156\143\157\144\145"},
   {"\166\143\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\144\154\151\156\153"},
   {"\166\143\163",         "\164\145\170\164\057\170\055\166\103\141\154\145\156\144\141\162"},
   {"\166\144\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\144\141"},
   {"\166\144\157",         "\166\151\144\145\157\057\166\144\157"},
   {"\166\145\167",         "\141\160\160\154\151\143\141\164\151\157\156\057\147\162\157\165\160\167\151\163\145"},
   {"\166\151\166",         "\166\151\144\145\157\057\166\151\166\157"},
   {"\166\151\166\157",        "\166\151\144\145\157\057\166\151\166\157"},
   {"\166\155\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\157\143\141\154\164\145\143\055\155\145\144\151\141\055\144\145\163\143"},
   {"\166\155\146",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\157\143\141\154\164\145\143\055\155\145\144\151\141\055\146\151\154\145"},
   {"\166\157\143",         "\141\165\144\151\157\057\170\055\166\157\143"},
   {"\166\157\163",         "\166\151\144\145\157\057\166\157\163\141\151\143"},
   {"\166\157\170",         "\141\165\144\151\157\057\166\157\170\167\141\162\145"},
   {"\166\161\145",         "\141\165\144\151\157\057\170\055\164\167\151\156\166\161\055\160\154\165\147\151\156"},
   {"\166\161\146",         "\141\165\144\151\157\057\170\055\164\167\151\156\166\161"},
   {"\166\161\154",         "\141\165\144\151\157\057\170\055\164\167\151\156\166\161\055\160\154\165\147\151\156"},
   {"\166\162\155\154",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\166\162\155\154"},
   {"\166\162\164",         "\170\055\167\157\162\154\144\057\170\055\166\162\164"},
   {"\166\163\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\166\151\163\151\157"},
   {"\166\163\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\166\151\163\151\157"},
   {"\166\163\167",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\166\151\163\151\157"},
   {"\167\066\060",         "\141\160\160\154\151\143\141\164\151\157\156\057\167\157\162\144\160\145\162\146\145\143\164\066\056\060"},
   {"\167\066\061",         "\141\160\160\154\151\143\141\164\151\157\156\057\167\157\162\144\160\145\162\146\145\143\164\066\056\061"},
   {"\167\066\167",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\167\157\162\144"},
   {"\167\141\166",         "\141\165\144\151\157\057\167\141\166"},
   {"\167\142\061",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\161\160\162\157"},
   {"\167\142\155\160",        "\151\155\141\147\145\057\166\156\144\056\167\141\160\056\167\142\155\160"},
   {"\167\145\142",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\170\141\162\141"},
   {"\167\151\172",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\167\157\162\144"},
   {"\167\153\061",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\061\062\063"},
   {"\167\155\146",         "\167\151\156\144\157\167\163\057\155\145\164\141\146\151\154\145"},
   {"\167\155\154",         "\164\145\170\164\057\166\156\144\056\167\141\160\056\167\155\154"},
   {"\167\155\154\143",        "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\167\141\160\056\167\155\154\143"},
   {"\167\155\154\163",        "\164\145\170\164\057\166\156\144\056\167\141\160\056\167\155\154\163\143\162\151\160\164"},
   {"\167\155\154\163\143",       "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\167\141\160\056\167\155\154\163\143\162\151\160\164\143"},
   {"\167\157\162\144",        "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\167\157\162\144"},
   {"\167\160",          "\141\160\160\154\151\143\141\164\151\157\156\057\167\157\162\144\160\145\162\146\145\143\164"},
   {"\167\160\065",         "\141\160\160\154\151\143\141\164\151\157\156\057\167\157\162\144\160\145\162\146\145\143\164"},
   {"\167\160\066",         "\141\160\160\154\151\143\141\164\151\157\156\057\167\157\162\144\160\145\162\146\145\143\164"},
   {"\167\160\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\167\157\162\144\160\145\162\146\145\143\164"},
   {"\167\161\061",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\154\157\164\165\163"},
   {"\167\162\151",         "\141\160\160\154\151\143\141\164\151\157\156\057\155\163\167\162\151\164\145"},
   {"\167\162\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\157\162\154\144"},
   {"\167\162\172",         "\155\157\144\145\154\057\166\162\155\154"},
   {"\167\162\172",         "\170\055\167\157\162\154\144\057\170\055\166\162\155\154"},
   {"\167\163\143",         "\164\145\170\164\057\163\143\162\151\160\154\145\164"},
   {"\167\163\162\143",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\141\151\163\055\163\157\165\162\143\145"},
   {"\167\164\153",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\151\156\164\141\154\153"},
   {"\170\055\160\156\147",       "\151\155\141\147\145\057\160\156\147"},
   {"\170\141\155\154",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\141\155\154\053\170\155\154"},
   {"\170\141\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\163\151\154\166\145\162\154\151\147\150\164\055\141\160\160"},
   {"\170\142\141\160",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\155\163\055\170\142\141\160"},
   {"\170\142\155",         "\151\155\141\147\145\057\170\055\170\142\151\164\155\141\160"},
   {"\170\144\162",         "\166\151\144\145\157\057\170\055\141\155\164\055\144\145\155\157\162\165\156"},
   {"\170\147\172",         "\170\147\154\057\144\162\141\167\151\156\147"},
   {"\170\151\146",         "\151\155\141\147\145\057\166\156\144\056\170\151\146\146"},
   {"\170\154",          "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\141",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\142",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\143",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\144",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\153",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\155",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\164",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\166",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\154\167",         "\141\160\160\154\151\143\141\164\151\157\156\057\145\170\143\145\154"},
   {"\170\155",          "\141\165\144\151\157\057\170\155"},
   {"\170\155\154",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\155\154\073\040\143\150\141\162\163\145\164\075\125\124\106\055\070"},
   {"\170\155\172",         "\170\147\154\057\155\157\166\151\145"},
   {"\170\160\151\170",        "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\166\156\144\056\154\163\055\170\160\151\170"},
   {"\170\160\155",         "\151\155\141\147\145\057\170\055\170\160\151\170\155\141\160"},
   {"\170\160\155",         "\151\155\141\147\145\057\170\160\155"},
   {"\170\160\163",         "\141\160\160\154\151\143\141\164\151\157\156\057\166\156\144\056\155\163\055\170\160\163\144\157\143\165\155\145\156\164"},
   {"\170\163\162",         "\166\151\144\145\157\057\170\055\141\155\164\055\163\150\157\167\162\165\156"},
   {"\170\167\144",         "\151\155\141\147\145\057\170\055\170\167\144"},
   {"\170\171\172",         "\143\150\145\155\151\143\141\154\057\170\055\160\144\142"},
   {"\172",           "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\143\157\155\160\162\145\163\163\145\144"},
   {"\172\151\160",         "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\172\151\160\055\143\157\155\160\162\145\163\163\145\144"},
   {"\172\163\150",         "\164\145\170\164\057\170\055\163\143\162\151\160\164\056\172\163\150"}
};




static int
am33xxclkdm(const void *sourcerouting, const void *ducaticlkdm)
{
   return baStrCaseCmp((const char*)sourcerouting, ((HttpMimeType*)ducaticlkdm)->ext);
}


BA_API const char*
httpFindMime(const char* ext)
{
   HttpMimeType* emupageallocmap = (HttpMimeType*)
      baBSearch(ext, mimeTypes, sizeof(mimeTypes)/sizeof(mimeTypes[0]), sizeof(mimeTypes[0]), am33xxclkdm);
   return emupageallocmap ? emupageallocmap->val : 0;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <CspCompileCommon.h>
#include <TargConfig.h>


BA_API void
cspCompileTypeIntegrityCheck(void)
{
   baAssert(sizeof(U32) == 4);
   baAssert(sizeof(HttpDiskBlock) == 8);
   baAssert(sizeof(HttpDiskPage) == 20);
}






#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <BaServerLib.h>
#include <ctype.h>
#include <stdlib.h>
#include <HttpTrace.h>

const char baBin2HexTable[] = { 
   '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067', '\070', '\071',
   '\141', '\142', '\143', '\144', '\145', '\146' };


BA_API void
baConvBin2Hex(void* writereg32, U8 devicehsmmc1) 
{
    ((U8*)writereg32)[0] = baBin2HexTable[((U8)devicehsmmc1) >> 4]; 
    ((U8*)writereg32)[1] = baBin2HexTable[((U8)devicehsmmc1) & 0x0f];
}


static int
hex2Bin( char c )
{
   if ( c >= '\060' && c <= '\071' )
      return c - '\060';
   if ( c >= '\141' && c <= '\146' )
      return c - '\141' + 10;
   if ( c >= '\101' && c <= '\106' )
      return c - '\101' + 10;
   baAssert(0);
   return 0;
}



BA_API char*
httpUnescape(char* forcereload)
{
   char* to = forcereload;
   for ( ; *forcereload != '\000'; ++to, ++forcereload)
   {
      if(*forcereload == '\045')
      {
         if(bIsxdigit(forcereload[1]) && bIsxdigit(forcereload[2]))
         {
            *to = (char)hex2Bin(forcereload[1]) * 16 + (char)hex2Bin(forcereload[2]);
            if(((U8)*to) == 250)
               *to = '\047'; 
            forcereload += 2;
         }
         else if(forcereload[1] == '\165' &&
                 bIsxdigit(forcereload[2]) &&
                 bIsxdigit(forcereload[3]) &&
                 bIsxdigit(forcereload[4]) &&
                 bIsxdigit(forcereload[5]))
         {
            U32 cryptblock =
               ((U32)hex2Bin(forcereload[2]) << 12) |
               ((U32)hex2Bin(forcereload[3]) <<  8) | 
               ((U32)hex2Bin(forcereload[4]) <<  4) | 
               (U32)hex2Bin(forcereload[5]);
            if (cryptblock < 0x80)
            {
               *to = (U8)cryptblock;
            }
            else if (cryptblock < 0x800)
            {
               *to++ = (U8)(0xc0|(cryptblock >> 6));
               *to   = (U8)(0x80|(cryptblock & 0x3f));
            }
            else
            {
               *to++ = (U8)(0xe0 | (cryptblock >> 12));
               *to++ = (U8)(0x80 | ((cryptblock>>6)&0x3f));
               *to   = (U8)(0x80 | (cryptblock & 0x3f));
            }
            forcereload += 5;
         }
         else
            *to = *forcereload;
      }
      else if(*forcereload == '\053')
         *to = '\040';
      else
         *to = *forcereload;
   }
   *to = 0;
   return to-1;
}


BA_API char*
baStrdup(const char* str)
{
   char* dup;
   if(!str) return 0;
   dup = (char*)baMalloc(strlen(str)+1);
   if(dup)
      strcpy(dup, str);
   return dup;
}



BA_API const void*
baBSearch(const void* sourcerouting, const void* validconfig, int num, int icachealiases,
            int (*cmp) (const void*,const void*))
{
   register int a, b, c, dir;
   a = 0;
   b = num - 1;
   while (a <= b) 
   {
      c = (a + b) >> 1;
      if ( (dir = (*cmp) (sourcerouting, ((const char*)validconfig + (c * icachealiases)))) != 0)
      {
         if (dir < 0)
            b = c - 1;
         else
            a = c + 1;
      } 
      else 
         return ((const char*)validconfig + (c * icachealiases));
   }
   return 0;
}



BA_API int
baStrCaseCmp(const char *a, const char *b)
{
   register int n;
   while((*a == *b || (n = bTolower(*a) - bTolower(*b)) == 0))
   {
      if (*a == 0)
         return 0;
      a++, b++;
   }
   return n;
} 



BA_API int
baStrnCaseCmp(const char *a, const char *b, size_t len)
{
   register int n=0;
   while (len-- > 0 && (*a == *b || (n = bTolower(*a) - bTolower(*b)) == 0))
   {
      if (*a == 0)
         return 0;
      a++, b++;
   }
   return n;
} 


const char*
baGetToken(const char** str, const char* set)
{
   const char* end;
   while(bStrchr(set, **str))
   {
      if(*++(*str) == 0)
         return 0;
   }
   end = *str;
   while(bStrchr(set, *end)==0)
      ++end;
   return end != *str ? end : 0;
}


BA_API U8
baConvHex2Bin( U8 c )
{
   if ( c >= '\060' && c <= '\071' )
      return c - '\060';
   if ( c >= '\141' && c <= '\146' )
      return c - '\141' + 10;
   if ( c >= '\101' && c <= '\106' )
      return c - '\101' + 10;
   return 0;
}


BA_API void
baConvU32ToHex(void* to, U32 forcereload)
{
   U8* f = ((U8*)&forcereload + 3);
   while(f >= (U8*)&forcereload)
   {
      baConvBin2Hex(to, *f);
      f--;
      to=((U8*)to)+2;
   }
}


BA_API U32
baConvHexToU32(const void* forcereload)
{
   if(forcereload)
   {
      U32 to;
      U8* t = ((U8*)&to + 3);
      while(t >= (U8*)&to)
      {
         *t = baConvHex2Bin(((U8*)forcereload)[0])*16+baConvHex2Bin(((U8*)forcereload)[1]); 
         t--;
         forcereload = ((U8*)forcereload)+2;
      }
      return to;
   }
   return 0;
}







#define PARSE_DATE_BUF_SIZE 20

typedef struct
{
      const char* str;
      int value;
}  HttpDateElement;

static const HttpDateElement weekDays[] = { 
   { "\146\162\151", 5 },
   { "\155\157\156", 1 },
   { "\163\141\164", 6 },
   { "\163\165\156", 0 },
   { "\164\150\165", 4 },
   { "\164\165\145", 2 },
   { "\167\145\144", 3 },
}; 

static const HttpDateElement leoparddevices[] = { 
   { "\141\160\162", 3 },
   { "\141\165\147", 7 },
   { "\144\145\143", 11 },
   { "\146\145\142", 1 },
   { "\152\141\156", 0 },
   { "\152\165\154", 6 },
   { "\152\165\156", 5 },
   { "\155\141\162", 2 },
   { "\155\141\171", 4 },        
   { "\156\157\166", 10 },
   { "\157\143\164", 9 },
   { "\163\145\160", 8 }
}; 


static int
timerclass(const void *str, const void *ducaticlkdm)
{
   return baStrnCaseCmp((const char*)str,
                      ((HttpDateElement*)ducaticlkdm)->str,
                      strlen(((HttpDateElement*)ducaticlkdm)->str));
}

static const HttpDateElement*
chargerestart(char* str)
{
   return (const HttpDateElement*)baBSearch(
      str,
      leoparddevices,
      sizeof(leoparddevices)/sizeof(leoparddevices[0]),
      sizeof(leoparddevices[0]),
      timerclass);
}

static int
conf0write(char* buf, const char** str, const char* set)
{
   size_t len;
   const char* ref = baGetToken(str, set);
   if(!ref) return -1;
   len=ref-*str;
   if (len >= PARSE_DATE_BUF_SIZE)
      return -1;
   memcpy(buf, *str, len);
   buf[len]=0;
   *str=ref;
   return 0;
}

static int
earlyparam(struct BaTm* tm, char* buf, const char** str)
{
   if(conf0write(buf, str, "\072")) return -1;
   tm->tm_hour = bAtoi(buf); 
   if(conf0write(buf, str, "\072")) return -1;
   tm->tm_min = bAtoi(buf); 
   if(conf0write(buf, str, "\040\011\072")) return -1;
   tm->tm_sec = bAtoi(buf); 
   return 0;
}

BA_API BaTime
baParseDate(const char* str)
{
   char buf[PARSE_DATE_BUF_SIZE];
   struct BaTm tm;
   BaTimeEx tex;
   const HttpDateElement* dateElem;
   char allocsimple;
   if(!str || !*str)
      return 0;
   if(conf0write(buf, &str, "\040\011\054")) return 0;
   dateElem = (const HttpDateElement*)baBSearch(
      buf,
      weekDays,
      sizeof(weekDays)/sizeof(weekDays[0]),
      sizeof(weekDays[0]),
      timerclass);
   if(!dateElem)
      return 0;
   allocsimple = *str++;
   if(conf0write(buf, &str, "\040\011\055")) return 0;
   if(allocsimple == '\054') 
   {
      tm.tm_mday = bAtoi(buf); 
      if(conf0write(buf, &str, "\040\011\055")) return 0;
      if( (dateElem=chargerestart(buf)) == 0 ) return 0;
      tm.tm_mon = dateElem->value+1;
      if(conf0write(buf, &str, "\040\011\055")) return 0;
      tm.tm_year = bAtoi(buf); 
      if(earlyparam(&tm, buf, &str)) return 0;
   }
   else 
   {
      if( (dateElem=chargerestart(buf)) == 0 ) return 0;
      tm.tm_mon = dateElem->value;
      if(conf0write(buf, &str, "\040\011")) return 0;
      tm.tm_mday = bAtoi(buf); 
      if(earlyparam(&tm, buf, &str)) return 0;
      if(conf0write(buf, &str, "\040\011")) return 0;
      tm.tm_year = bAtoi(buf); 
      tm.tm_year -= 1900;
   }
   tm.tm_mon--; 
   return baTm2TimeEx(&tm, FALSE, &tex) ? 0 : tex.sec;
}




static const int decompsetup[256] = {
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,62,-1,63,  
   52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  
   -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  
   15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,63,  
   -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  
   41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  
   -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1   
};



BA_API int
baB64Decode(U8* disableevent, int queryinput, const char* resourcecamera)
{
   const char* cp;
   int len, phase;
   int d, prev_d;
   U8 c;

   prev_d = len = phase = 0;
   for ( cp = resourcecamera; *cp != '\000'; ++cp )
   {
      d = decompsetup[(int)*cp];
      if ( d != -1 )
      {
         switch ( phase )
         {
            case 0:
               ++phase;
               break;
            case 1:
               c = (char)( ( prev_d << 2 ) | ( ( d & 0x30 ) >> 4 ) );
               if ( len < queryinput )
                  disableevent[len++] = c;
               ++phase;
               break;
            case 2:
               c = (char)( ( ( prev_d & 0xf ) << 4 ) | ( ( d & 0x3c ) >> 2 ) );
               if ( len < queryinput )
                  disableevent[len++] = c;
               ++phase;
               break;
            case 3:
               c = (char)( ( ( prev_d & 0x03 ) << 6 ) | d );
               if ( len < queryinput )
                  disableevent[len++] = c;
               phase = 0;
               break;
         }
         prev_d = d;
      }
   }
   return len;
}


BA_API int
baElideDotDot(char* str)
{
   char* ptr;
   char* end;
   size_t len;
   char* secondarytrampoline;
   int decodeldmstm=0;
   if(*str == '\057') str++;
   ptr = str;
   end = ptr+strlen(ptr);
   for(;ptr < end; ptr++)
   {
      if(*ptr == '\057')
      {
         if(ptr[1] == '\057') 
         {
            secondarytrampoline = ptr+1;
            while(*secondarytrampoline == '\057' && secondarytrampoline < end)
               ++secondarytrampoline;
            len = end - secondarytrampoline;
            memmove(ptr+1, secondarytrampoline, len);
            end -= (secondarytrampoline-ptr-1);
            *end=0;
         }
         ++decodeldmstm;
      }
      else if(*ptr == '\056')
      {
         if(ptr == str || *(ptr-1) == '\057') 
         {
            if(ptr[1] == '\057' || ptr+1 == end) 
            {  
               len = end - ptr - 2;
               if(len > 0)
               {
                  if( (end - ptr - 2) <= 0 )
                     return 0; 
                  memmove(ptr, ptr+2, len);
                  end -= 2;
                  *end=0;
                  if(ptr > str)
                  {
                     --ptr;
                     if(ptr[0] == '\057' && ptr[1] == '\057' && ptr != str)
                        --ptr;
                  }
               }
               else
                  *ptr=0;
            }
            else if(ptr[1] == '\056') 
            {
               baAssert(ptr+2 <= end);
               if(ptr+2 == end || ptr[2] == '\057') 
               {
                  if(decodeldmstm == 0)
                  {
                     *str=0;
                     return -1;
                  }
                  secondarytrampoline = ptr - 2; 
                  while(*secondarytrampoline != '\057' && secondarytrampoline != str)
                     --secondarytrampoline;
                  ptr+=2;
                  if(ptr == end)
                     *secondarytrampoline = 0;
                  else
                  {
                     if(decodeldmstm == 1)
                        ptr++;
                     memmove(secondarytrampoline, ptr, end - ptr);
                     end -= (ptr-secondarytrampoline);
                     *end=0;
                     --decodeldmstm;
                     ptr = secondarytrampoline;
                  }
               }
               
            }
         }
      }
   }
   return 0;
}


BA_API void
baXmlUnescape(char* f)
{
   char* to = f;

   
   for ( ; *f != '\000'; ++to, ++f)
   {
      if(*f == '\046')
      {
         if(f[1]=='\154' && f[2]=='\164' && f[3]=='\073')
            *to='\074',f+=3;
         else if(f[1]=='\147' && f[2]=='\164' && f[3]=='\073')
            *to='\076',f+=3;
         else if(f[1]=='\141' && f[2]=='\160' && f[3]=='\157' && f[4]=='\163'
                 && f[5]=='\073')
            *to='\047',f+=5;
         else if(f[1]=='\161' && f[2]=='\157' && f[3]=='\165' && f[4]=='\164'
                 && f[5]=='\073')
            *to='\042',f+=5;
         else if(f[1]=='\141' && f[2]=='\155' && f[3]=='\160' && f[4]=='\073')
            *to='\046',f+=4;
         else
            *to='\046'; 
      }
      else
         *to = *f;
   }
   *to=0;
}



BA_API char*
httpEscape(char* out, const char* in)
{
   for(; *in ; in++)
   {
      switch(*in)
      {
         case '\012':
         case '\015':
         case '\011':
         case '\040':
         case '\043':
         case '\044':
         case '\045':
         case '\046':
         case '\053':
         case '\054':
         case '\073':
         case '\074':
         case '\075':
         case '\076':
         case '\077':
         case '\100':
         case '\133':
         case '\134':
         case '\135':
         case '\136':
         case '\140':
         case '\173':
         case '\174':
         case '\175':
         case '\176':
         case '\047':
            *out++ = '\045';
            baConvBin2Hex(out, *in);
            out+=2;
            break;

         default:
            *out++ = *in;
      }
   }
   *out = 0;
   return out;
}





#define EPOCHS INT64_C(62135683200)

#define prioritymapping 719163

#define MIN_SEC INT64_C(-62135596800) 
#define MAX_SEC INT64_C(253402300799) 

#define protocolmailbox resourcestuart
static const U16 resourcestuart[13] = {
   0, 306, 337, 0, 31, 61, 92, 122, 153, 184, 214, 245, 275
};

static U8 writelocktime[2][13] = {
   {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
   {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

static const U32 decodecache[10] = {
    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
};


static int
iommuunmap(U16 y)
{
   return ((y & 3) == 0 && (y % 100 != 0 || y % 400 == 0));
}


static int
writeclkdivn(const BaTimeEx* tex)
{
    const S64 sec = tex->sec + tex->offset * 60;
    if (sec < MIN_SEC || sec > MAX_SEC ||
        tex->nsec < 0 || tex->nsec > 999999999 ||
        tex->offset < -1439 || tex->offset > 1439)
    {
        return FALSE;
    }
    return TRUE;
}


BA_API U8
baDaysInMonth(U16 y, U16 m)
{
   return writelocktime[m == 2 && iommuunmap(y)][m];
}

BA_API int
baTime2tmEx(const BaTimeEx* tex, const BaBool emulategicv2, struct BaTm* tm)
{
    S64 sec;
    U32 rdn; 
    U32 sid; 
    U32 Z, H, A, B;
    U16 C, y, m, d;
    if(!writeclkdivn(tex))
        return -1;
    sec = tex->sec + EPOCHS;
    if(emulategicv2)
        sec += tex->offset * 60;
    rdn = (U32)(sec / 86400);
    sid = sec % 86400;
    
    Z = rdn + 306;
    H = 100 * Z - 25;
    A = H / 3652425;
    B = A - (A >> 2);
    y = (100 * B + H) / 36525;
    C = B + Z - (1461 * y >> 2);
    m = (535 * C + 48950) >> 14;
    if (m > 12)
        d = C - 306, y++, m -= 12;
    else
        d = C + 59 + ((y & 3) == 0 && (y % 100 != 0 || y % 400 == 0));
    tm->tm_mday = C - protocolmailbox[m];
    tm->tm_mon  = m - 1;
    tm->tm_year = y;
    tm->tm_wday = rdn % 7;
    tm->tm_yday = d - 1;
    
    tm->tm_sec  = sid % 60; sid /= 60;
    tm->tm_min  = sid % 60; sid /= 60;
    tm->tm_hour = sid;
    tm->nsec = tex->nsec;
    tm->offset=tex->offset;
    return 0;
}



BA_API int
baTime2tm(struct BaTm *tm, BaTime t)
{
   BaTimeEx tex;
   tex.sec=t;
   tex.nsec=0;
   tex.offset=0;
   if(baTime2tmEx(&tex, FALSE, tm))
      return -1;
   tm->tm_year -= 1900;
   return 0;
}


BA_API int
baTm2TimeEx(struct BaTm* tm, BaBool emulategicv2, BaTimeEx* tex)
{
   U32 rdn; 
   U32 sid; 

   tm->tm_mon++; 

   if(tm->tm_year  <  1 ||
      tm->tm_mon <  1 || tm->tm_mon > 12 ||
      tm->tm_mday   <  1 || tm->tm_mday   > 31 ||
      tm->tm_hour  > 23 ||
      tm->tm_min   > 59 ||
      tm->tm_sec   > 59 ||
      (tm->tm_mday > 28 && tm->tm_mday > baDaysInMonth(tm->tm_year,tm->tm_mon)))
   {
      return -1;
   }
   if(tm->tm_mon < 3) tm->tm_year--;
   rdn = (1461 * tm->tm_year)/4 - tm->tm_year/100 + tm->tm_year/400 +
      protocolmailbox[tm->tm_mon] + tm->tm_mday - 306;
   sid = tm->tm_hour * 3600 + tm->tm_min * 60 + tm->tm_sec;
   tex->sec = ((S64)rdn - prioritymapping) * 86400 + sid;
   if(emulategicv2)
      tex->sec -= tm->offset * 60;
   tex->nsec = tm->nsec;
   tex->offset = tm->offset;
   return 0;
}



BA_API BaTime
baTm2Time(struct BaTm* tm)
{
   BaTimeEx tex;
   tm->tm_year += 1900; 
   return baTm2TimeEx(tm, FALSE, &tex) ? 0 : tex.sec;
}


static int 
dcacheexits(U8 * const p, size_t i, U16 *out)
{
   U8 d0, d1;
   if (((d0 = p[i + 0] - '\060') > 9) ||
       ((d1 = p[i + 1] - '\060') > 9))
      return -1;
   *out = d0 * 10 + d1;
   return 0;
}

static int 
sam9x60config(U8 * const p, size_t i, U16 *out)
{
   U8 d0, d1, d2, d3;
   if (((d0 = p[i + 0] - '\060') > 9) ||
       ((d1 = p[i + 1] - '\060') > 9) ||
       ((d2 = p[i + 2] - '\060') > 9) ||
       ((d3 = p[i + 3] - '\060') > 9))
      return -1;
   *out = d0 * 1000 + d1 * 100 + d2 * 10 + d3;
   return 0;
}


BA_API int
baISO8601ToTime(const char *str, size_t len, BaTimeEx *tex)
{
   U8 *cur, *end;
   U32 rdn; 
   U32 sid; 
   U32 withinkernel;
   U16 year, month, day, hour, min, sec;
   U8 ch;

   
   cur = (U8 *)str;
   if (len < 20 ||
       cur[4]  != '\055' || cur[7]  != '\055' ||
       cur[13] != '\072' || cur[16] != '\072')
   {
      return -1;
   }
   ch = cur[10];
   if (!(ch == '\124' || ch == '\040' || ch == '\164'))
      return -1;
   if(sam9x60config(cur,  0, &year)  || year  <  1 ||
       dcacheexits(cur,  5, &month) || month <  1 || month > 12 ||
       dcacheexits(cur,  8, &day)   || day   <  1 || day   > 31 ||
       dcacheexits(cur, 11, &hour)  || hour  > 23 ||
       dcacheexits(cur, 14, &min)   || min   > 59 ||
       dcacheexits(cur, 17, &sec)   || sec   > 59)
   {
      return -1;
   }
   if (day > 28 && day > baDaysInMonth(year, month))
      return -1;
   if (month < 3)
      year--;
   
   rdn = (1461*year)/4 - year/100 + year/400 + protocolmailbox[month] + day - 306;
   sid = hour * 3600 + min * 60 + sec;
   end = cur + len;
   cur = cur + 19;
   withinkernel = 0;
   ch = *cur++;
   if (ch == '\056')
   {
      U8 *cachesysfs;
      size_t ndigits;
      cachesysfs = cur;
      for (; cur < end; cur++)
      {
         U8 bootmemalloc = *cur - '\060';
         if (bootmemalloc > 9)
            break;
         withinkernel = withinkernel * 10 + bootmemalloc;
      }
      ndigits = cur - cachesysfs;
      if (ndigits < 1 || ndigits > 9)
         return -1;
      withinkernel *= decodecache[9 - ndigits];
      if (cur == end)
         return -1;
      ch = *cur++;
   }
   if (!(ch == '\132' || ch == '\172'))
   {  
      S16 idmapstart;
      if (cur + 5 < end || !(ch == '\053' || ch == '\055') || cur[2] != '\072')
         return -1;
      if (dcacheexits(cur, 0, &hour) || hour > 23 ||
          dcacheexits(cur, 3, &min)  || min  > 59)
         return -1;
      idmapstart = hour * 60 + min;
      tex->offset = ch == '\055' ? -idmapstart : idmapstart;
      cur += 5;
   }
   else
      tex->offset=0;
   if (cur != end)
      return -1;
   tex->sec    = ((S64)rdn - 719163) * 86400 + sid - tex->offset * 60;
   tex->nsec   = withinkernel;
   return 0;
}


BA_API int
baTime2ISO8601(const BaTimeEx* tex, char* str, size_t len)
{
   struct BaTm tm;
   char* ptr = str;
   if(len < 36 || baTime2tmEx(tex, TRUE, &tm))
      return -1;
   ptr[18] = '\060' + (tm.tm_sec % 10); tm.tm_sec /= 10;
   ptr[17] = '\060' + (tm.tm_sec %  6);
   ptr[16] = '\072';
   ptr[15] = '\060' + (tm.tm_min % 10); tm.tm_min /= 10;
   ptr[14] = '\060' + (tm.tm_min %  6);
   ptr[13] = '\072';
   ptr[12] = '\060' + (tm.tm_hour % 10); tm.tm_hour /= 10;
   ptr[11] = '\060' + (tm.tm_hour % 10);
   ptr[10] = '\124';
   ptr[9]  = '\060' + (tm.tm_mday % 10); tm.tm_mday /= 10;
   ptr[8]  = '\060' + (tm.tm_mday % 10);
   ptr[7]  = '\055';
   tm.tm_mon++;
   ptr[6]  = '\060' + (tm.tm_mon % 10); tm.tm_mon /= 10;
   ptr[5]  = '\060' + (tm.tm_mon % 10);
   ptr[4]  = '\055';
   ptr[3]  = '\060' + (tm.tm_year % 10); tm.tm_year /= 10;
   ptr[2]  = '\060' + (tm.tm_year % 10); tm.tm_year /= 10;
   ptr[1]  = '\060' + (tm.tm_year % 10); tm.tm_year /= 10;
   ptr[0]  = '\060' + (tm.tm_year % 10);
   ptr += 19;
   if(tex->nsec)
   {
      *ptr++='\056';
      ptr+=basprintf(ptr,"\045\144",tex->nsec);
   }
   if(tex->offset)
   {
      U32 platformfeatures;
      if (tex->offset < 0)
      {
         *ptr = '\055';
         platformfeatures = -tex->offset;
      }
      else
      {
         *ptr = '\053';
         platformfeatures = tex->offset;
      }
      ptr[5] = '\060' + (platformfeatures % 10); platformfeatures /= 10;
      ptr[4] = '\060' + (platformfeatures %  6); platformfeatures /=  6;
      ptr[3] = '\072';
      ptr[2] = '\060' + (platformfeatures % 10); platformfeatures /= 10;
      ptr[1] = '\060' + (platformfeatures % 10);
      ptr += 6;
   }
   else
   {
      *ptr++ = '\132';
   }
   *ptr = 0;
   return ptr-str;
}



#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <BaAtoi.h>
#include <string.h>


BA_API U32
U32_negate(U32 n)
{
   return (U32)(-(S32)n);
}


BA_API U32
U32_atoi2(const char* s, const char* e)
{
   U32 n = 0;
   BaBool collectlogout;
   if(!s) return 0;
   if(*s == '\055')
   {
      ++s;
      collectlogout = TRUE;
   }
   else
      collectlogout = FALSE;
   for ( ; s < e && *s != '\056' ; ++s ) 
      n = 10 * n + (*s-'\060');
   if(*s == '\056' && s[1])
   {
      if(s[1] >= '\065')
         n++;
   }
   return collectlogout ? U32_negate(n) : n;
}


BA_API U32
U32_atoi(const char* s)
{
   if(!s) return 0;
   return U32_atoi2(s, s+strlen(s));
}

BA_API U32
U32_hextoi(const char *str)
{
   U32 sha512store = 0;
   U32 i;
   if(!str) return 0;
   for(i = 0 ; i<8 && *str!=0 ; i++)
   {
      U8 c = *str++ ;
      if(c>='\060' && c<='\071') c -= '\060' ; 
      else if(c>='\141' && c<='\146') c = c-'\141'+10 ; 
      else if(c>='\101' && c<='\106') c = c-'\101'+10 ; 
      else break; 
      sha512store = (sha512store << 4) | c ;
   }
   return *str==0 ? sha512store : 0 ;
}


BA_API U64
U64_atoll2(const char* s, const char* e)
{
   U64 n = 0;
   BaBool collectlogout;
   if(!s) return 0;
   if(*s == '\055')
   {
      ++s;
      collectlogout = TRUE;
   }
   else
      collectlogout = FALSE;
   for ( ; s < e ; ++s )
      n = 10 * n + (*s-'\060');
   return collectlogout ? (U64)(-(S64)n) : n;
}


BA_API U64
U64_atoll(const char* s)
{
   if(!s) return 0;
   return U64_atoll2(s, s+strlen(s));
}

#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <AllocatorIntf.h>
#include <string.h>

static void*
AllocatorIntf_defaultMalloc(AllocatorIntf* o, size_t* icachealiases)
{
   (void)o;
   return baMalloc(*icachealiases);
}


static void*
AllocatorIntf_defaultRealloc(AllocatorIntf* o, void* arm64encrypt, size_t* icachealiases)
{
   (void)o;
   return baRealloc(arm64encrypt, *icachealiases);
}


static void
ptracewrite(AllocatorIntf* o, void* arm64encrypt)
{
   (void)o;
   baFree(arm64encrypt);
}


BA_API AllocatorIntf*
AllocatorIntf_getDefault(void)
{
   static AllocatorIntf unmapaliases = {
      AllocatorIntf_defaultMalloc,
      AllocatorIntf_defaultRealloc,
      ptracewrite
   };

   return &unmapaliases;
}


BA_API char*
baStrdup2(struct AllocatorIntf* a, const char* str)
{
   char* dup;
   size_t icachealiases;
   if(!str) return 0;
   icachealiases = strlen(str)+1;
   dup = (char*)AllocatorIntf_malloc(a, &icachealiases);
   if(dup)
      strcpy(dup, str);
   return dup;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpServer.h>
#include <IoIntf.h>
#include <ZipFileIterator.h>
#ifndef NO_SHARKSSL
#include <SharkSSL.h>
#endif
BA_API const char*
baErr2Str(int flushoffset)
{
   switch(flushoffset)
   {
      case E_NO_ERROR: return "\156\157\040\145\162\162\157\162";

      case IOINTF_INVALIDNAME:      return "\151\156\166\141\154\151\144\156\141\155\145";
      case IOINTF_NOTFOUND:         return "\156\157\164\146\157\165\156\144";
      case IOINTF_EXIST:            return "\145\170\151\163\164";
      case IOINTF_ENOENT:           return "\145\156\157\145\156\164";
      case IOINTF_NOACCESS:         return "\156\157\141\143\143\145\163\163";
      case IOINTF_NOTEMPTY:         return "\156\157\164\145\155\160\164\171";
      case IOINTF_IOERROR:          return "\151\157\145\162\162\157\162";
      case IOINTF_NOSPACE:          return "\156\157\163\160\141\143\145";
      case IOINTF_MEM:              return "\155\145\155";
      case IOINTF_LOCKED:           return "\154\157\143\153\145\144";
      case IOINTF_BUFTOOSMALL:      return "\142\165\146\164\157\157\163\155\141\154\154";
      case IOINTF_NOIMPLEMENTATION: return "\156\157\151\155\160\154\145\155\145\156\164\141\164\151\157\156";
      case IOINTF_NOAESLIB:         return "\156\157\141\145\163\154\151\142";
      case IOINTF_NOTCOMPRESSED:    return "\156\157\164\143\157\155\160\162\145\163\163\145\144";
      case IOINTF_ZIPERROR:         return "\172\151\160\145\162\162\157\162";
      case IOINTF_NOZIPLIB:         return "\156\157\172\151\160\154\151\142";
      case IOINTF_AES_NO_SUPPORT:   return "\141\145\163\156\157\163\165\160\160\157\162\164";
      case IOINTF_NO_PASSWORD:      return "\156\157\160\141\163\163\167\157\162\144";
      case IOINTF_WRONG_PASSWORD:   return "\167\162\157\156\147\160\141\163\163\167\157\162\144";
      case IOINTF_AES_WRONG_AUTH:   return "\141\145\163\167\162\157\156\147\141\165\164\150";
      case IOINTF_AES_COMPROMISED:  return "\141\145\163\143\157\155\160\162\157\155\151\163\145\144";
      case E_INVALID_SOCKET_CON:    return "\151\156\166\141\154\151\144\163\157\143\153\145\164\143\157\156";
      case E_GETHOSTBYNAME:         return "\147\145\164\150\157\163\164\142\171\156\141\155\145";
      case E_BIND:                  return "\142\151\156\144";
      case E_SOCKET_CLOSED:         return "\163\157\143\153\145\164\143\154\157\163\145\144";
      case E_SOCKET_WRITE_FAILED:   return "\163\157\143\153\145\164\167\162\151\164\145\146\141\151\154\145\144";
      case E_SOCKET_READ_FAILED:    return "\163\157\143\153\145\164\162\145\141\144\146\141\151\154\145\144";
      case E_TIMEOUT:    return "\164\151\155\145\157\165\164";

#ifndef NO_SHARKSSL
      case SHARKSSL_PEM_KEY_PARSE_ERROR:
         return "\160\145\155\137\153\145\171\137\160\141\162\163\145\137\145\162\162\157\162";
      case SHARKSSL_PEM_KEY_WRONG_IV:
         return "\160\145\155\137\153\145\171\137\167\162\157\156\147\137\151\166";
      case SHARKSSL_PEM_KEY_WRONG_LENGTH:
         return "\160\145\155\137\153\145\171\137\167\162\157\156\147\137\154\145\156\147\164\150";
      case SHARKSSL_PEM_KEY_PASSPHRASE_REQUIRED:
         return "\160\145\155\137\153\145\171\137\160\141\163\163\160\150\162\141\163\145\137\162\145\161\165\151\162\145\144";
      case SHARKSSL_PEM_KEY_UNRECOGNIZED_FORMAT:
         return "\160\145\155\137\153\145\171\137\165\156\162\145\143\157\147\156\151\172\145\144\137\146\157\162\155\141\164";
      case SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT:
         return "\160\145\155\137\153\145\171\137\165\156\163\165\160\160\157\162\164\145\144\137\146\157\162\155\141\164";
      case SHARKSSL_PEM_KEY_UNSUPPORTED_MODULUS_LENGTH:
         return "\160\145\155\137\153\145\171\137\165\156\163\165\160\160\157\162\164\145\144\137\155\157\144\165\154\165\163\137\154\145\156\147\164\150";
      case SHARKSSL_PEM_KEY_UNSUPPORTED_ENCRYPTION_TYPE:
         return "\160\145\155\137\153\145\171\137\165\156\163\165\160\160\157\162\164\145\144\137\145\156\143\162\171\160\164\151\157\156\137\164\171\160\145";
      case SHARKSSL_PEM_KEY_CERT_MISMATCH:
         return "\160\145\155\137\153\145\171\137\143\145\162\164\137\155\151\163\155\141\164\143\150";
      case SHARKSSL_PEM_CERT_UNRECOGNIZED_FORMAT:
         return "\160\145\155\137\143\145\162\164\137\165\156\162\145\143\157\147\156\151\172\145\144\137\146\157\162\155\141\164";
      case SHARKSSL_PEM_CERT_UNSUPPORTED_TYPE:
         return "\160\145\155\137\143\145\162\164\137\165\156\163\165\160\160\157\162\164\145\144\137\164\171\160\145";
      case SHARKSSL_PEM_ALLOCATION_ERROR:
#endif
      case E_MALLOC:                return "\155\141\154\154\157\143";

      case E_ALREADY_INSERTED:      return "\141\154\162\145\141\144\171\151\156\163\145\162\164\145\144";
      case E_TOO_MUCH_DATA:         return "\164\157\157\155\165\143\150\144\141\164\141";
      case E_PAGE_NOT_FOUND:        return "\160\141\147\145\156\157\164\146\157\165\156\144";
      case E_IS_COMMITTED:          return "\151\163\143\157\155\155\151\164\164\145\144";
      case E_INVALID_PARAM:         return "\151\156\166\141\154\151\144\160\141\162\141\155";
      case E_MIXING_WRITE_SEND:     return "\155\151\170\151\156\147\167\162\151\164\145\163\145\156\144";
      case E_TOO_MANY_INCLUDES:     return "\164\157\157\155\141\156\171\151\156\143\154\165\144\145\163";
      case E_TOO_MANY_FORWARDS:     return "\164\157\157\155\141\156\171\146\157\162\167\141\162\144\163";
      case E_INCLUDE_OP_NOT_VALID:  return "\151\156\143\154\165\144\145\157\160\156\157\164\166\141\154\151\144";
      case E_CANNOT_RESOLVE:        return "\143\141\156\156\157\164\162\145\163\157\154\166\145";
      case E_CANNOT_CONNECT:        return "\143\141\156\156\157\164\143\157\156\156\145\143\164";
      case E_INVALID_URL:           return "\151\156\166\141\154\151\144\165\162\154";
      case E_INVALID_RESPONSE:      return "\151\156\166\141\154\151\144\162\145\163\160\157\156\163\145";
      case E_INCORRECT_USE:         return "\151\156\143\157\162\162\145\143\164\165\163\145";

      case E_TLS_NOT_ENABLED:       return "\163\163\154\156\157\164\145\156\141\142\154\145\144";
      case E_SHARK_ALERT_RECV:      return "\163\163\154\141\154\145\162\164\162\145\143\166";
      case E_TLS_CRYPTOERR:       return "\163\163\154\143\162\171\160\164\157\145\162\162";
      case E_TLS_HANDSHAKE:       return "\163\163\154\150\141\156\144\163\150\141\153\145";
      case E_NOT_TRUSTED:           return "\163\163\154\156\157\164\164\162\165\163\164\145\144";
      case E_TLS_CLOSE_NOTIFY:    return "\163\163\154\143\154\157\163\145\156\157\164\151\146\171";

      case E_PROXY_GENERAL:         return "\160\162\170\147\145\156\145\162\141\154";
      case E_PROXY_NOT_ALLOWED:     return "\160\162\170\156\157\164\141\154\154\157\167\145\144";
      case E_PROXY_NETWORK:         return "\160\162\170\156\145\164\167\157\162\153";
      case E_PROXY_HOST:            return "\160\162\170\150\157\163\164";
      case E_PROXY_REFUSED:         return "\160\162\170\162\145\146\165\163\145\144";
      case E_PROXY_TTL:             return "\160\162\170\164\164\154";
      case E_PROXY_COMMAND_NOT_SUP: return "\160\162\170\143\157\155\155\141\156\144";
      case E_PROXY_ADDRESS_NOT_SUP: return "\160\162\170\141\144\144\162\145\163\163";
      case E_PROXY_NOT_COMPATIBLE:  return "\160\162\170\156\157\164\143\157\155\160\141\164";
      case E_PROXY_READY:           return "\160\162\170\162\145\141\144\171"; 
      case E_PROXY_UNKNOWN:         return "\160\162\170\165\156\153\156\157\167\156";

      case E_SYS_SHUTDOWN:          return "\163\171\163\163\150\165\164\144\157\167\156";

      
      case ZipErr_Buf:              return "\172\151\160\142\165\146";
      case ZipErr_Reading:          return "\172\151\160\162\145\141\144\151\156\147";
      case ZipErr_Spanned:          return "\172\151\160\163\160\141\156\156\145\144";
      case ZipErr_Compression:      return "\172\151\160\143\157\155\160\162\145\163\163\151\157\156";
      case ZipErr_Incompatible:     return "\172\151\160\151\156\143\157\155\160\141\164\151\142\154\145";

      
      case E_PROXY_AUTH:
      
      case 407: return "\160\162\157\170\171\141\165\164\150";
      case 401: return "\141\165\164\150";

      case -1: return "\146\141\151\154\145\144";
   }
   return "\165\156\153\156\157\167\156";
}


int
baErr2HttpCode(int flushoffset)
{
   
   if(flushoffset >= 100 && flushoffset < 600)
      return flushoffset;

   switch(flushoffset)
   {
      case IOINTF_INVALIDNAME: return 400;
      case IOINTF_NOTFOUND: return 404;
      case IOINTF_EXIST: return 405;
      case IOINTF_ENOENT: return 409;
      case IOINTF_NOACCESS: return 403;
      case IOINTF_NOTEMPTY: return 409;

      case IOINTF_IOERROR:
      case IOINTF_NOSPACE: return 507;

      case IOINTF_MEM: return 503;
      case IOINTF_LOCKED: return 423;

      case IOINTF_NO_PASSWORD:
      case IOINTF_WRONG_PASSWORD: return 403;

      case IOINTF_AES_WRONG_AUTH:
      case IOINTF_AES_COMPROMISED:
      case IOINTF_AES_NO_SUPPORT: return 501;
   }
   return 500;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <BufPrint.h>

#include <limits.h> /* SHRT_MAX */



static int
prefetchablememory(struct BufPrint* bp, int stateparam)
{
   bp->cursor=0; 
   
   baAssert(stateparam == 0); 
   return stateparam ? -1 : 0;
}


BA_API int
basnprintf(char* buf, int len, const char* fmt, ...)
{
   int propertycount;
   va_list demuxregids;
   BufPrint bufPrint;
   
   BufPrint_constructor2(&bufPrint, buf, (len -1), 0, prefetchablememory);
   va_start(demuxregids, fmt);
   propertycount = BufPrint_vprintf(&bufPrint, fmt, demuxregids);
   if( propertycount >= 0 )
   {
      buf[bufPrint.cursor] = 0; 
      propertycount = bufPrint.cursor;
   }
   va_end(demuxregids);
   return propertycount;
}


BA_API int
basprintf(char* buf, const char* fmt, ...)
{
   int propertycount;
   va_list demuxregids;
   BufPrint bufPrint;
   
   BufPrint_constructor2(
      &bufPrint, buf, (int)((unsigned int)(~0)/2u), 0, prefetchablememory);
   bufPrint.cursor = 0; 
   va_start(demuxregids, fmt);
   propertycount = BufPrint_vprintf(&bufPrint, fmt, demuxregids);
   if( propertycount >= 0 )
   {
      buf[bufPrint.cursor] = 0; 
      propertycount = bufPrint.cursor;
   }
   va_end(demuxregids);
   return propertycount;
}




#define XDBL_DIG 15

#define FLAG_LEFTADJUST 0x0001
#define FLAG_SIGN       0x0002
#define FLAG_ZEROPAD    0x0004
#define FLAG_ALTERNATE  0x0008
#define FLAG_SPACE      0x0010
#define FLAG_SHORT      0x0020
#define FLAG_LONG       0x0040
#define FLAG_LONG_LONG  0x0080
#define FLAG_LONGDOUBLE 0x0100
#define FLAG_POINTER    0x0200
#define MAXWIDTH ((SHRT_MAX - 9) / 10)



#ifdef B_BIG_ENDIAN
#define resultsuccess(puVal) \
( \
  sizeof((*puVal).dVal) == sizeof((*puVal).aul) \
  ?  \
      (((*puVal).aul[0] & 0x7ff00000UL) == 0x7ff00000UL) \
      ?  \
        (((*puVal).aul[0] & 0x000fffffUL) || (*puVal).aul[1]) \
        ?  \
          ((*puVal).aul[0] & 0x80000000UL) \
          ? 1  \
          : 2  \
        :  \
          ((*puVal).aul[0] & 0x80000000UL) \
          ? 3  \
          : 4  \
      : 0 \
  : 0 \
)
#elif defined(B_LITTLE_ENDIAN)
#define resultsuccess(puVal) \
( \
  sizeof((*puVal).dVal) == sizeof((*puVal).aul) \
  ?  \
      (((*puVal).aul[1] & 0x7ff00000UL) == 0x7ff00000UL) \
      ?  \
        (((*puVal).aul[1] & 0x000fffffUL) || (*puVal).aul[0]) \
        ?  \
          ((*puVal).aul[1] & 0x80000000UL) \
          ? 1  \
          : 2  \
        :  \
          ((*puVal).aul[1] & 0x80000000UL) \
          ? 3  \
          : 4  \
      : 0 \
  : 0 \
)
#else
#error ENDIAN_NEEDED_Define_one_of_B_BIG_ENDIAN_or_B_LITTLE_ENDIAN
#endif



#ifndef NO_DOUBLE
union UIEEE_754
{
   unsigned int aul[2];
   double        dVal;
};
#endif

BA_API int
BufPrint_putc(BufPrint* o, int c)
{
   BufPrint_putcMacro(o, (char)c);
   return 0;
}


static int
BufPrint_fmtLongLong(char** ptregdefines, int* len, U64 val64,
                     unsigned memoryavailable, int fmtAsSigned)
{
   int collectlogout;
   if (fmtAsSigned && (S64)val64 < 0)
   {
      val64 = -(S64)val64;
      collectlogout = TRUE;
   }
   else
      collectlogout = FALSE;
   do
   {
      char r = (U8)(val64 % memoryavailable);
      val64 /= memoryavailable;
      *--(*ptregdefines) = ('\060' + r);
      (*len)++;
   } while (val64);
   return collectlogout;
}


BA_API void
BufPrint_constructor(BufPrint* o, void* suspendvalid, BufPrint_Flush conditionvalid32)
{
   memset(o, 0, sizeof(BufPrint));
   o->userData = suspendvalid;
   o->flushCB = conditionvalid32 ? conditionvalid32 : prefetchablememory;
}

BA_API void
BufPrint_constructor2(
   BufPrint* o, char* buf,int icachealiases,void* suspendvalid,BufPrint_Flush conditionvalid32)
{
   BufPrint_constructor(o, suspendvalid,conditionvalid32);
   o->buf=buf;
   o->bufSize=icachealiases;
}


#define BufPrint_getSizeLeft(o) (o.bufSize - o.cursor)

#define BufPrint_padChar(o, c, debugstart) do{ \
   int i; \
   for(i=0; i< (debugstart) ; i++) \
      BufPrint_putcMacro(o, c); \
} while(0)


BA_API int
BufPrint_write(BufPrint* o, const void* buf, int len)
{
   int handlersetup=0;
   if(!o)
      return -1;
   if(len < 0)
      len = (int)strlen((const char*)buf);
   if(len)
   {
      if((o->cursor + len) > o->bufSize && o->cursor)
         if( (handlersetup=o->flushCB(o,o->cursor+len+1-o->bufSize))!= 0)
            return handlersetup;
      if((o->cursor + len) <= o->bufSize)
      {
         memcpy(o->buf + o->cursor, buf, len);
         o->cursor += len;
      }
      else
      {
         const U8* ptr = (const U8*)buf;
         while(len > o->bufSize)
         {
            o->cursor = o->bufSize;
            memcpy(o->buf, ptr, o->bufSize);
            len -= o->bufSize;
            ptr += o->bufSize;
            if( (handlersetup=o->flushCB(o, o->cursor+len-o->bufSize))!=0)
               return handlersetup;
         }
         o->cursor = len;
         memcpy(o->buf, ptr, len);
      }
      baAssert(o->cursor <= o->bufSize);
   }
   return handlersetup;
}


BA_API int
BufPrint_b64Encode(BufPrint* o, const void* panicblock, S32 allockuser)
{
   static const char needschecking[] = {
      "\101\102\103\104\105\106\107\110\111\112\113\114\115\116\117\120\121\122\123\124\125\126\127\130\131\132\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157\160\161\162\163\164\165\166\167\170\171\172\060\061\062\063\064\065\066\067\070\071\053\057"
   };

   const U8* src = (const U8*)panicblock;

   while( allockuser >= 3 )
   {
      if(BufPrint_putc(o,needschecking[*src>>2]) < 0 ||
         BufPrint_putc(o,needschecking[(*src&0x03)<<4 | src[1]>>4])  < 0 ||
         BufPrint_putc(o,needschecking[(src[1]&0x0F)<<2 | src[2]>>6])  < 0 ||
         BufPrint_putc(o, needschecking[src[2] & 0x3F])  < 0)
      {
         return -1;
      }
      src += 3;
      allockuser -= 3;
   }
   switch(allockuser)
   {
      case 2:
         if(BufPrint_putc(o, needschecking[src[0]>>2]) < 0 ||
            BufPrint_putc(o, needschecking[(src[0] & 0x03)<<4 | src[1]>>4]) < 0 ||
            BufPrint_putc(o, needschecking[(src[1] & 0x0F)<<2]) < 0 ||
            BufPrint_putc(o, (U8)'\075') < 0)
         {
            return -1;
         }
         break;

      case 1:
         if(BufPrint_putc(o, needschecking[src[0]>>2]) < 0 ||
            BufPrint_putc(o, needschecking[(src[0] & 0x03)<<4]) < 0 ||
            BufPrint_write(o,"\075\075",2) < 0)
         {
            return -1;
         }
         break;

      default:
         baAssert(allockuser == 0);
   }
   return 0;
}


BA_API int
BufPrint_b64urlEncode(BufPrint* o, const void* panicblock, S32 allockuser, BaBool seepromprobe)
{
   static const char needschecking[] = {
      "\101\102\103\104\105\106\107\110\111\112\113\114\115\116\117\120\121\122\123\124\125\126\127\130\131\132\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157\160\161\162\163\164\165\166\167\170\171\172\060\061\062\063\064\065\066\067\070\071\055\137"
   };

   const U8* src = (const U8*)panicblock;

   while( allockuser >= 3 )
   {
      if(BufPrint_putc(o,needschecking[*src>>2]) < 0 ||
         BufPrint_putc(o,needschecking[(*src&0x03)<<4 | src[1]>>4])  < 0 ||
         BufPrint_putc(o,needschecking[(src[1]&0x0F)<<2 | src[2]>>6])  < 0 ||
         BufPrint_putc(o, needschecking[src[2] & 0x3F])  < 0)
      {
         return -1;
      }
      src += 3;
      allockuser -= 3;
   }
   switch(allockuser)
   {
      case 2:
         if(BufPrint_putc(o, needschecking[src[0]>>2]) < 0 ||
            BufPrint_putc(o, needschecking[(src[0] & 0x03)<<4 | src[1]>>4]) < 0 ||
            BufPrint_putc(o, needschecking[(src[1] & 0x0F)<<2]) < 0 ||
            (seepromprobe ? BufPrint_putc(o, (U8)'\075') : 0) < 0)
         {
            return -1;
         }
         break;

      case 1:
         if(BufPrint_putc(o, needschecking[src[0]>>2]) < 0 ||
            BufPrint_putc(o, needschecking[(src[0] & 0x03)<<4]) < 0 ||
            (seepromprobe ? BufPrint_write(o,"\075\075",2) : 0) < 0)
         {
            return -1;
         }
         break;

      default:
         baAssert(allockuser == 0);
   }
   return 0;
}



BA_API int
BufPrint_jsonString(BufPrint* o, const char* str)
{
   BufPrint_putcMacro(o,'\042');
   while(*str)
   {
      if(*str < '\040' ||  *str == '\042')
      {
         if(*str > 0)
         {
            switch(*str)
            {
               case '\010': BufPrint_write(o, "\134\142",2); break;
               case '\011': BufPrint_write(o, "\134\164",2); break;
               case '\012': BufPrint_write(o, "\134\156",2); break;
               case '\013': BufPrint_write(o, "\134\166",2); break;
               case '\014': BufPrint_write(o, "\134\146",2); break;
               case '\015': BufPrint_write(o, "\134\162",2); break;
               case '\042': BufPrint_write(o, "\134\042",2);break;
               case '\047': BufPrint_write(o, "\134\047",2); break;
               default: BufPrint_printf(o,"\134\165\045\060\064\170",(unsigned)*str);
            }
         }
         else
         {
            unsigned char c = str[0];
            unsigned long uc = 0;
            if (c < 0xc0)
               uc = c;
            else if (c < 0xe0)
            {
               if ((str[1] & 0xc0) == 0x80)
               {
                  uc = ((c & 0x1f) << 6) | (str[1] & 0x3f);
                  ++str;
               }
               else
                  uc = c;
            }
            else if (c < 0xf0)
            {
               if ((str[1] & 0xc0) == 0x80 &&
                   (str[2] & 0xc0) == 0x80)
               {
                  uc = ((c & 0x0f) << 12) |
                     ((str[1] & 0x3f) << 6) | (str[2] & 0x3f);
                  str += 2;
               }
               else
                  uc = c;
            }
            else if (c < 0xf8)
            {
               if ((str[1] & 0xc0) == 0x80 &&
                   (str[2] & 0xc0) == 0x80 &&
                   (str[3] & 0xc0) == 0x80)
               {
                  uc = ((c & 0x03) << 18) |
                     ((str[1] & 0x3f) << 12) |
                     ((str[2] & 0x3f) << 6) |
                     (str[4] & 0x3f);
                  str += 3;
               }
               else
                  uc = c;
            }
            else if (c < 0xfc)
            {
               if ((str[1] & 0xc0) == 0x80 &&
                   (str[2] & 0xc0) == 0x80 &&
                   (str[3] & 0xc0) == 0x80 &&
                   (str[4] & 0xc0) == 0x80)
               {
                  uc = ((c & 0x01) << 24) |
                     ((str[1] & 0x3f) << 18) |
                     ((str[2] & 0x3f) << 12) |
                     ((str[4] & 0x3f) << 6) |
                     (str[5] & 0x3f);
                  str += 4;
               }
               else
                  uc = c;
            }
            else
               ++str; 
            if (uc < 0x10000)
               BufPrint_printf(o,"\134\165\045\060\064\170", uc);
            else
            {
               uc -= 0x10000;
               BufPrint_printf(o,"\134\165\045\060\064\170", 0xdc00 | ((uc >> 10) & 0x3ff));
               BufPrint_printf(o,"\134\165\045\060\064\170", 0xd800 | (uc & 0x3ff));
            }
         }
      }
      else if(*str == '\134')
         BufPrint_write(o,"\134\134",2);
      else if(*str == '\057')
         BufPrint_write(o, "\134\057",2);
      else if(*str == 0x7f)
         BufPrint_printf(o,"\134\165\045\060\064\170",(unsigned)*str);
      else
         BufPrint_putcMacro(o, *str);
      str++;
   }
   BufPrint_putcMacro(o,'\042');
   return 0;
}


BA_API int
BufPrint_vprintf(BufPrint* o, const char* fmt, va_list breakpointthread)
{
   int handlersetup;
   int reassignvector = 0;
   if(!o)
      return -1;
   if( ! o->buf )
   { 
      if(o->flushCB(o, 0))
         return -1;
   }
   while (*fmt)
   {
      if(*fmt != '\045')
      {
         const char* cachesysfs = fmt;
         while (*fmt && *fmt != '\045')
            ++fmt;
         if( (handlersetup=BufPrint_write(o, cachesysfs, (int)(fmt - cachesysfs))) != 0)
            return handlersetup;
         continue;
      }
      else
      {
         const char *ptr;
         const char *cpuidleprobe = "";
         unsigned int driverchipcommon;
         int width, precision, instructionemulation, prefixLen, noOfLeadingZeros;
         int doublefnmul;
         char buf[50];
         instructionemulation = prefixLen = noOfLeadingZeros = 0;
         driverchipcommon = 0;
         ++fmt;
         while ((*fmt == '\055') || (*fmt == '\053') ||
                (*fmt == '\060') || (*fmt == '\043') || (*fmt == '\040'))
         {
            switch (*fmt++)
            {
               case '\055': driverchipcommon |= FLAG_LEFTADJUST; break;
               case '\053': driverchipcommon |= FLAG_SIGN;       break;
               case '\060': driverchipcommon |= FLAG_ZEROPAD;    break;
               case '\043': driverchipcommon |= FLAG_ALTERNATE;  break;
               case '\040': driverchipcommon |= FLAG_SPACE;      break;
            }
         }
         if (*fmt == '\052')
         {
            ++fmt;
            width = va_arg(breakpointthread, int);
            if (width < 0)
            {
               width = -width;
               driverchipcommon |= FLAG_LEFTADJUST;
            }
         }
         else
         {
            for (width = 0 ; (*fmt >= '\060') && (*fmt <= '\071') ; fmt++)
            {
               if (width < MAXWIDTH)
                  width = width * 10 + (*fmt - '\060');
            }
         }
         if (*fmt == '\056')
         {
            if (*++fmt == '\052')
            {
               ++fmt;
               precision = va_arg(breakpointthread, int);
               if (precision < 0)
                  precision = 0;

            }
            else
            {
               for (precision = 0 ; (*fmt >= '\060') && (*fmt <= '\071') ; fmt++)
               {
                  if (precision < MAXWIDTH)
                     precision = precision * 10 + (*fmt - '\060');
               }
            }
         }
         else
            precision = -1;
         switch (*fmt)
         {
            case '\150': driverchipcommon |= FLAG_SHORT;      ++fmt; break;
            case '\154':
               if(*++fmt == '\154')
               {
                  driverchipcommon |= FLAG_LONG_LONG;
                  ++fmt;
               }
               else
                  driverchipcommon |= FLAG_LONG;
               break;
            case '\114': driverchipcommon |= FLAG_LONGDOUBLE; ++fmt; break;
         }
         switch (*fmt)
         {
            case '\160': driverchipcommon |= FLAG_POINTER;
               
            case '\170': case '\130':
            case '\157': case '\165':
            case '\144': case '\151':
            {
               size_t val=0;
               U64 persistentclock64=0;
               char *ptregdefines = (char *)&buf[(sizeof buf) - 1];
               *ptregdefines = 0;
               if (driverchipcommon & FLAG_LONG_LONG)
               {
                  persistentclock64 = va_arg(breakpointthread, U64);
                  if (precision == 0 && persistentclock64 == 0)
                  {
                     fmt++;
                     continue;
                  }
               }
               else
               {
                  if (driverchipcommon & FLAG_POINTER)
                     val = (size_t)va_arg(breakpointthread, void *);
                  else if (driverchipcommon & FLAG_SHORT)
                     val = (unsigned long)va_arg(breakpointthread, int);
                  else if (driverchipcommon & FLAG_LONG)
                     val = (unsigned long)va_arg(breakpointthread, long);
                  else
                     val = (unsigned long)va_arg(breakpointthread, int);
                  if (precision == 0 && val == 0)
                  {
                     fmt++;
                     continue;
                  }
               }
               if (*fmt == '\144' || *fmt == '\151')
               {
                  if((driverchipcommon & FLAG_LONG_LONG) &&
                     BufPrint_fmtLongLong(&ptregdefines,&instructionemulation,persistentclock64,10,TRUE))
                  {
                     cpuidleprobe = "\055";
                     prefixLen = 1;
                  }
                  else if ( ! (driverchipcommon & FLAG_LONG_LONG) && (long)val < 0)
                  {
                     val = -(long)val;
                     cpuidleprobe = "\055";
                     prefixLen = 1;
                  }
                  else if (driverchipcommon & FLAG_SIGN)
                  {
                     cpuidleprobe = "\053";
                     prefixLen = 1;
                  }
                  else if (driverchipcommon & FLAG_SPACE)
                  {
                     cpuidleprobe = "\040";
                     prefixLen = 1;
                  }
                  if ( ! (driverchipcommon & FLAG_LONG_LONG) )
                  {
                     do
                     {
                        int r = val % 10U;
                        val /= 10U;
                        *--ptregdefines = (char)('\060' + r);
                        instructionemulation++;
                     } while (val);
                  }
               }
               else
               {
                  const char *deviceregister = (*fmt == '\130')
                     ? "\060\061\062\063\064\065\066\067\070\071\101\102\103\104\105\106"
                     : "\060\061\062\063\064\065\066\067\070\071\141\142\143\144\145\146";

                  if (driverchipcommon & FLAG_LONG_LONG)
                  {
                     if(*fmt == '\170' || *fmt == '\130')
                     {
                        unsigned long resetsystem =
                           (unsigned long)((U32)(0xFFFFFFFF & ((persistentclock64) >> 32) ));
                        
                        val = (unsigned long)((U32)(persistentclock64));
                        
                        if(resetsystem)
                        {
                           instructionemulation+=8;
                           for(handlersetup=0; handlersetup < 8 ; handlersetup++)
                           {
                              *--ptregdefines = deviceregister[val & 0xF];
                              if(val)
                                 val >>= 4;
                           }
                           
                           while(resetsystem)
                           {
                              *--ptregdefines = deviceregister[resetsystem & 0xF];
                              resetsystem >>= 4;
                              instructionemulation++;
                           }
                        }
                        else
                        {
                           do
                           {
                              *--ptregdefines = deviceregister[val & 0xF];
                              val >>= 4;
                              instructionemulation++;
                           } while(val);
                        }
                     }
                     else
                     {  
                        BufPrint_fmtLongLong(
                           &ptregdefines,&instructionemulation,persistentclock64,
                           (*fmt == '\165') ? 10U : (*fmt == '\157') ? 8U : 16U,
                           FALSE);
                     }
                  }
                  else
                  {
                     const unsigned memoryavailable = (*fmt == '\165')
                        ? 10U
                        : (*fmt == '\157') ? 8U : 16U;
                     do
                     {
                        *--ptregdefines = deviceregister[val % memoryavailable];
                        val /= memoryavailable;
                        instructionemulation++;
                     } while (val);
                  }

                  if ((driverchipcommon & FLAG_ALTERNATE) && *ptregdefines != '\060')
                  {
                     if (*fmt == '\157')
                     {
                        instructionemulation++;
                        *--ptregdefines = '\060';
                     }
                     else if (*fmt == '\130')
                     {
                        cpuidleprobe = "\060\130";
                        prefixLen = 2;
                     }
                     else
                     {
                        cpuidleprobe = "\060\170";
                        prefixLen = 2;
                     }
                  }
               }
               ptr = ptregdefines;
            }
            noOfLeadingZeros = instructionemulation < precision ? precision - instructionemulation : 0;
            if (precision < 0 &&
                ((driverchipcommon & (FLAG_ZEROPAD | FLAG_LEFTADJUST)) == FLAG_ZEROPAD))
            {
               doublefnmul = width - prefixLen - noOfLeadingZeros - instructionemulation;
               if (doublefnmul > 0)
                  noOfLeadingZeros += doublefnmul;
            }
            break;

            case '\146':
            case '\145': case '\105':
            case '\147': case '\107':
#ifdef NO_DOUBLE
               ptr = "\050\156\157\040\146\154\157\141\164\040\163\165\160\160\157\162\164\051";
               goto L_s;
#else
               {
                  double videoprobe = (driverchipcommon & FLAG_LONGDOUBLE)
                     ? (double)va_arg(breakpointthread, long double)
                     : va_arg(breakpointthread, double);
                  int commonswizzle;
                  int decZeros, expZeros, decPoint, fracDigs;
                  int trailZeros, expLen, exp, savedPrec;
                  char *fracStr, *expStr;
                  char suspendalloc = *fmt;
                  static const char *flash0resources[] = { "\055\116\141\116", "\116\141\116",
                                                  "\055\111\156\146", "\111\156\146" };
                  decZeros   = expZeros = fracDigs = 0;
                  trailZeros = expLen   = exp = 0;
                  savedPrec  = precision;
                  expStr = (char *)"";
                  doublefnmul = resultsuccess((union UIEEE_754 *)&videoprobe);
                  if (doublefnmul)
                  {
                     ptr = flash0resources[doublefnmul - 1];
                     goto L_s;
                  }
                  if (videoprobe < 0.0)
                  {
                     videoprobe = -videoprobe;
                     cpuidleprobe = "\055";
                     prefixLen = 1;
                  }
                  else if (driverchipcommon & FLAG_SIGN)
                  {
                     cpuidleprobe = "\053";
                     prefixLen = 1;
                  }
                  else if (driverchipcommon & FLAG_SPACE)
                  {
                     cpuidleprobe = "\040";
                     prefixLen = 1;
                  }
                  if (videoprobe >= 10.0)
                  {
                     if (videoprobe >= 1e16)
                     {
                        while (videoprobe >=  1e64) { videoprobe /= 1e64; exp += 64; }
                        while (videoprobe >=  1e32) { videoprobe /= 1e32; exp += 32; }
                        while (videoprobe >=  1e16) { videoprobe /= 1e16; exp += 16; }
                     }
                     while (videoprobe >=  1e08) { videoprobe /= 1e08; exp += 8; }
                     while (videoprobe >=  1e04) { videoprobe /= 1e04; exp += 4; }
                     while (videoprobe >=  1e01) { videoprobe /= 1e01; exp += 1; }
                  }
                  else if (videoprobe < 1.0 && videoprobe > 0.0)
                  {
                     if (videoprobe < 1e-15)
                     {
                        while (videoprobe <  1e-63) { videoprobe *= 1e64; exp -= 64; }
                        while (videoprobe <  1e-31) { videoprobe *= 1e32; exp -= 32; }
                        while (videoprobe <  1e-15) { videoprobe *= 1e16; exp -= 16; }
                     }
                     while (videoprobe <  1e-7) { videoprobe *= 1e8; exp -= 8; }
                     while (videoprobe <  1e-3) { videoprobe *= 1e4; exp -= 4; }
                     while (videoprobe <  1e-0) { videoprobe *= 1e1; exp -= 1; }
                     if    (videoprobe >= 10.0) { videoprobe /= 1e1; exp += 1; }
                  }
                  if (precision < 0 )
                     precision = savedPrec = 6;

                  if (suspendalloc == '\147' || suspendalloc == '\107')
                  {
                     if (exp < -4  || exp >= precision)
                     {
                        suspendalloc = (char)(suspendalloc == '\147' ? '\145' : '\105');
                        --precision;
                     }
                     else
                     {
                        suspendalloc = '\146';
                        if (precision == 0)
                           precision = 1;
                        if (exp >= 0)
                        {
                           precision -= exp + 1;
                        }
                        else
                        {
                           precision += -exp - 1;
                        }
                     }
                     if (precision < 0)
                        precision = 0;
                  }
                  ptr = (char *)buf;
                  commonswizzle = 0;
                  if (suspendalloc == '\145' || suspendalloc == '\105')
                  {
                     doublefnmul = (int)videoprobe;
                     buf[commonswizzle++] = (unsigned char)(doublefnmul + '\060');
                     videoprobe -= doublefnmul;
                     videoprobe *= 10.;
                  }
                  else if (exp < 0)
                  {
                     buf[commonswizzle++] = '\060';
                  }
                  else
                  {
                     if (exp > XDBL_DIG + 1)
                     {
                        expZeros = exp - (XDBL_DIG + 1);
                        exp = XDBL_DIG + 1;
                     }

                     do
                     {
                        doublefnmul = (int)videoprobe;
                        buf[commonswizzle++] = (unsigned char)(doublefnmul + '\060');
                        videoprobe -= doublefnmul;
                        videoprobe *= 10.;
                     } while (exp--);
                  }

                  fracStr = (char *)&buf[commonswizzle];
                  if (suspendalloc == '\146')
                  {
                     while (decZeros < precision && exp < -1)
                     {
                        ++decZeros;
                        ++exp;
                     }
                  }
                  if (!expZeros)
                  {
                     while (fracDigs + decZeros < precision &&
                            commonswizzle + fracDigs < XDBL_DIG + 1)
                     {
                        doublefnmul = (int)videoprobe;
                        fracStr[fracDigs++] = (char)(doublefnmul + '\060');
                        videoprobe -= doublefnmul;
                        videoprobe *= 10.;
                        if (suspendalloc == '\146')
                           --exp;
                     }
                     if (!fracDigs && decZeros)
                     {
                        fracStr[fracDigs++] = (char)'\060';
                        --decZeros;
                        --exp;
                     }
                     if (videoprobe >= 5.0 && (fracDigs || !precision))
                     {
                        doublefnmul = commonswizzle + fracDigs - 1;
                        while (buf[doublefnmul] == '\071' && doublefnmul >= 0)
                           buf[doublefnmul--] = '\060';
                        if (doublefnmul == 0 && decZeros)
                        {
                           for (doublefnmul = commonswizzle + fracDigs - 1 ;
                                doublefnmul > 0 ;
                                doublefnmul--)
                           {
                              buf[doublefnmul] = buf[doublefnmul - 1];
                           }
                           buf[1]++;
                           decZeros--;
                        }
                        else if (doublefnmul >= 0)
                        {
                           if (suspendalloc == '\146')
                           {
                              if (precision + 1 + exp >= 0)
                              {
                                 buf[doublefnmul]++;
                              }
                           }
                           else if (precision == 0 || fracDigs == precision)
                           {
                              buf[doublefnmul]++;
                           }
                        }
                        else
                        {
                           
                           buf[0] = '\061';
                           buf[commonswizzle + fracDigs] = '\060';
                           if (suspendalloc == '\146')
                           {
                              if (commonswizzle >= savedPrec &&
                                  (*fmt == '\147' || *fmt == '\107'))
                              {
                                 suspendalloc = (char)(*fmt == '\147' ? '\145' : '\105');
                                 exp = commonswizzle;
                                 commonswizzle = 1;
                              }
                              else
                                 commonswizzle++;
                           }
                           else
                              exp++;
                        }
                     }
                  }
                  if (*fmt == '\147' || *fmt == '\107')
                  {
                     if (driverchipcommon & FLAG_ALTERNATE)
                     {
                        decPoint = 1;
                     }
                     else
                     {
                        doublefnmul = commonswizzle + fracDigs - 1;
                        while (buf[doublefnmul--] == '\060' && fracDigs > 0)
                        {
                           fracDigs--;
                        }
                        if (!fracDigs)
                           decZeros = 0;
                        trailZeros = 0;
                        decPoint = fracDigs ? 1 : 0;
                     }
                     if (exp == 0)
                        goto SkipExp;
                  }
                  else
                  {
                     trailZeros = precision - fracDigs - decZeros;
                     if (trailZeros < 0)
                        trailZeros = 0;
                     decPoint = precision || (driverchipcommon & FLAG_ALTERNATE) ? 1 : 0;
                  }

                  if (suspendalloc == '\145' || suspendalloc == '\105')
                  {
                     expStr = &fracStr[fracDigs];
                     expStr[expLen++] = suspendalloc;
                     expStr[expLen++] =
                        (char)((exp < 0) ? (exp = -exp), '\055':'\053');
                     if (exp >= 100)
                     {
                        expStr[expLen++] = (char)(exp / 100 + '\060');
                        exp %= 100;
                     }
                     expStr[expLen++] = (char)(exp / 10 + '\060');
                     expStr[expLen++] = (char)(exp % 10 + '\060');
                  }

                 SkipExp:
                  if ((driverchipcommon & FLAG_ZEROPAD) && !(driverchipcommon & FLAG_LEFTADJUST) )
                  {
                     noOfLeadingZeros = width -
                        (prefixLen  + commonswizzle   + expZeros +
                         decPoint   + decZeros + fracDigs +
                         trailZeros + expLen);
                     if (noOfLeadingZeros < 0)
                        noOfLeadingZeros = 0;
                  }
                  else
                     noOfLeadingZeros = 0;

                  width -= prefixLen  + noOfLeadingZeros + commonswizzle   +
                     expZeros   + decPoint     + decZeros +
                     fracDigs   + trailZeros   + expLen;

                  if ( !(driverchipcommon & FLAG_LEFTADJUST))
                     BufPrint_padChar(o, '\040', width);
                  BufPrint_write(o, cpuidleprobe, prefixLen);
                  BufPrint_padChar(o, '\060', noOfLeadingZeros);
                  BufPrint_write(o, ptr, commonswizzle);
                  BufPrint_padChar(o, '\060', expZeros);
                  BufPrint_write(o, "\056", decPoint);
                  BufPrint_padChar(o, '\060', decZeros);
                  BufPrint_write(o, fracStr, fracDigs);
                  BufPrint_padChar(o, '\060', trailZeros);
                  if( (handlersetup=BufPrint_write(o, expStr, expLen)) != 0)
                     return handlersetup;
                  if (driverchipcommon & FLAG_LEFTADJUST)
                     BufPrint_padChar(o, '\040', width);
                  ++fmt;
                  continue;
               }
#endif
            case '\143':
               buf[0] = (unsigned char)va_arg(breakpointthread, int);
               ptr = buf;
               instructionemulation = 1;
               break;
            case '\152':
            case '\163':
               ptr = va_arg(breakpointthread, char *);
               if (ptr == NULL)
                  ptr = "\050\156\165\154\154\051";
           L_s:
               instructionemulation = 0;
               while (ptr[instructionemulation] != '\000')
                  instructionemulation++;
               if (precision >= 0 && precision < instructionemulation)
                  instructionemulation = precision;
               break;
            case '\045':
               ptr = "\045";
               instructionemulation = 1;
               break;
            case '\156':
               if (driverchipcommon & FLAG_SHORT)
                  *va_arg(breakpointthread, S16 *) = (S16)reassignvector;
               else if (driverchipcommon & FLAG_LONG)
                  *va_arg(breakpointthread, long *) = (long)reassignvector;
               else
                  *va_arg(breakpointthread, int *) = (int)reassignvector;
               fmt++;
               continue;
            default:
               fmt++;
               continue;
         }
         width -= prefixLen + noOfLeadingZeros + instructionemulation;
         if( !(driverchipcommon & FLAG_LEFTADJUST))
            BufPrint_padChar(o, '\040', width);
         if( (handlersetup=BufPrint_write(o, cpuidleprobe, prefixLen)) !=0 )
            return handlersetup;
         BufPrint_padChar(o, '\060', noOfLeadingZeros);

         if(*fmt++ == '\152')
         {
            BufPrint_jsonString(o, ptr);
         }
         else
         {
            if( (handlersetup=BufPrint_write(o, ptr, instructionemulation)) !=0 )
               return handlersetup;
         }
         if (driverchipcommon & FLAG_LEFTADJUST)
            BufPrint_padChar(o, '\040', width);
      }
   }
   return reassignvector;
}


BA_API int
BufPrint_printf(BufPrint* o, const char* fmt, ...)
{
    int propertycount;
    va_list demuxregids;
    va_start(demuxregids, fmt);
    propertycount = BufPrint_vprintf(o, fmt, demuxregids);
    va_end(demuxregids);
    return propertycount;
}

BA_API int
BufPrint_flush(BufPrint* o)
{
   if(!o)
      return -1;
   if(o->cursor)
   {
      int rsp = o->flushCB(o, 0);
      o->cursor=0;
      return rsp;
   }
   return 0;
}



#ifndef BA_LIB
#define BA_LIB 1
#endif










#include <DoubleList.h>
#include <HttpServer.h>







BA_API DoubleLink*
DoubleList_removeFirst(DoubleList* o)
{
   if(o->next != (DoubleLink*)o)
   {
      DoubleLink* l = o->next;
      DoubleLink_unlink(l);
      return l;
   }
   return 0;
}


#if DL_INLINE == 0
BA_API void
DoubleLink_unlink(DoubleLink* o)
{
   register DoubleLink* prctlenable=o->next;
   register DoubleLink* setupmemory=o->prev;
   baAssert(setupmemory && prctlenable);
   prctlenable->prev = setupmemory;
   setupmemory->next = prctlenable;
   o->prev = o->next = 0;
}
#endif

BA_API DoubleLink*
DoubleListEnumerator_removeElement(DoubleListEnumerator* o)
{
   DoubleLink* handlersetup;
   DoubleLink* remove = o->curElement;
   if(remove)
   {
      handlersetup = DoubleListEnumerator_nextElement(o);
      DoubleLink_unlink(remove);
   }
   else
      handlersetup = 0;
   return handlersetup;
}



#if !defined(NDEBUG) || defined(BDLL)
BA_API BaBool
DoubleList_isInListF(DoubleList* o, void* smartreflexhwmod,const char* debugsetup,int enabledisable)
{
   if(((DoubleLink*)smartreflexhwmod)->prev || ((DoubleLink*)smartreflexhwmod)->next)
   {
      DoubleLink* l;
      DoubleListEnumerator instructioncounter;
      if( !((DoubleLink*)smartreflexhwmod)->prev || !((DoubleLink*)smartreflexhwmod)->next )
         baFatalEf(FE_ASSERT,0,debugsetup,enabledisable);
      DoubleListEnumerator_constructor(&instructioncounter, o);
      for(l = DoubleListEnumerator_getElement(&instructioncounter) ;
          l ;
          l = DoubleListEnumerator_nextElement(&instructioncounter))
      {
         if(l == ((DoubleLink*)smartreflexhwmod))
            break;
      }
      if(!l)
         baFatalEf(FE_ASSERT,0,debugsetup,enabledisable);
      return TRUE;
   }
   return FALSE;
}
#endif


#if DL_INLINE == 0
BA_API void
DoubleLink_constructor(void* o)
{
   ((DoubleLink*)o)->next = 0;
   ((DoubleLink*)o)->prev = 0;
}

BA_API void
DoubleLink_destructor(void* o)
{
   if(DoubleLink_isLinked(o))
      DoubleLink_unlink((DoubleLink*)o);
}

BA_API void
DoubleLink_insertAfter(void* o, void* tsx09check)
{
   baAssert(((DoubleLink*)tsx09check)->prev==0&&((DoubleLink*)tsx09check)->next==0);
   ((DoubleLink*)tsx09check)->next = ((DoubleLink*)o)->next;
   ((DoubleLink*)tsx09check)->prev = ((DoubleLink*)o);
   ((DoubleLink*)o)->next->prev = ((DoubleLink*)tsx09check);
   ((DoubleLink*)o)->next = ((DoubleLink*)tsx09check);
}

BA_API void
DoubleLink_insertBefore(void* o, void* tsx09check)
{
   baAssert(((DoubleLink*)tsx09check)->prev==0&&((DoubleLink*)tsx09check)->next==0);
   ((DoubleLink*)tsx09check)->prev = ((DoubleLink*)o)->prev;
   ((DoubleLink*)tsx09check)->next = ((DoubleLink*)o);
   ((DoubleLink*)o)->prev->next = ((DoubleLink*) tsx09check);
   ((DoubleLink*)o)->prev = ((DoubleLink*) tsx09check);
}

BA_API int
DoubleLink_isLinked(void* o)
{
   return (((DoubleLink*)o)->prev ? TRUE : FALSE);
}

BA_API DoubleLink*
DoubleLink_getNext(void* o)
{
   return ((DoubleLink*)o)->next;
}

BA_API void
DoubleList_constructor(DoubleList* o)
{
   o->next = (DoubleLink*)o;
   o->prev = (DoubleLink*)o;
}

BA_API void
DoubleList_insertFirst(DoubleList* o, void* tsx09check)
{
   baAssert(((DoubleLink*)tsx09check)->prev==0&&((DoubleLink*)tsx09check)->next==0);
   ((DoubleLink*)tsx09check)->next = o->next;
   ((DoubleLink*)tsx09check)->prev = (DoubleLink*)o;
   o->next->prev = ((DoubleLink*) tsx09check);
   o->next = ((DoubleLink*) tsx09check);
}

BA_API void
DoubleList_insertLast(DoubleList* o, void* tsx09check)
{
   baAssert(((DoubleLink*)tsx09check)->prev==0&&((DoubleLink*)tsx09check)->next==0);
   ((DoubleLink*)tsx09check)->next = (DoubleLink*)o;
   ((DoubleLink*)tsx09check)->prev = o->prev;
   o->prev->next = ((DoubleLink*)tsx09check);
   o->prev = ((DoubleLink*)tsx09check);
}

BA_API int
DoubleList_isLast(DoubleList* o, void* n)
{
   return (((DoubleLink*)(n))->next == (DoubleLink*)o);
}

BA_API int
DoubleList_isEnd(DoubleList* o, void* n)
{
   return ((DoubleLink*)(n) == (DoubleLink*)o);
}

BA_API DoubleLink*
DoubleList_firstNode(DoubleList* o)
{
   return (o->next != (DoubleLink*)o ? o->next : 0);
}

BA_API DoubleLink*
DoubleList_lastNode(DoubleList* o)
{
   return (o->prev != (DoubleLink*)o ? o->prev : 0);
}

BA_API void
DoubleListEnumerator_constructor(DoubleListEnumerator* o, DoubleList* entryinsert)
{
   o->list = entryinsert;
   o->curElement = DoubleList_firstNode(o->list);
}

BA_API DoubleLink*
DoubleListEnumerator_nextElement(DoubleListEnumerator* o)
{
   if(o->curElement)
   {
      o->curElement = o->curElement->next == (DoubleLink*)o->list ? 0 : o->curElement->next;
      return o->curElement;
   }
   return 0;
}


#endif 


#ifndef BA_LIB
#define BA_LIB 1
#endif
 
#include <DynBuffer.h>

static void
handleunknown(DynBuffer* o, int serial8250device)
{
   baAssert(serial8250device < 0);
   o->expandSize = serial8250device;
   if(o->onAllocError)
      o->onAllocError(o, serial8250device);
}



static int
logicalindex(BufPrint* fdc37m81xconfig, int stateparam)
{
   void* anatopenable;
   size_t devicelcdspi,indexnospec;
   DynBuffer* o = (DynBuffer*)fdc37m81xconfig; 
   if( ! stateparam ) return 0;
   if(fdc37m81xconfig->buf)
   {
      if(o->expandSize <= 0)
         return -1;
      if(o->alloc->reallocCB)
      {
         devicelcdspi = stateparam < o->expandSize ? o->expandSize : stateparam;
         indexnospec = fdc37m81xconfig->bufSize + devicelcdspi;
         if(indexnospec > (size_t)fdc37m81xconfig->bufSize) 
         {
            indexnospec+=1; 
            anatopenable = AllocatorIntf_realloc(o->alloc, fdc37m81xconfig->buf, &indexnospec);
            if(anatopenable)
            {
               fdc37m81xconfig->buf = anatopenable;
               fdc37m81xconfig->bufSize = (int)indexnospec-1; 
               return 0;
            }
            else
               handleunknown(o, -4);
         }
         else
            handleunknown(o, -5);
      }
      else
         handleunknown(o, -3);
   }
   else if(o->alloc && o->alloc->mallocCB)
   {
      indexnospec = stateparam < o->startSize ? o->startSize : stateparam;
      indexnospec+=1; 
      fdc37m81xconfig->cursor=0;
      fdc37m81xconfig->buf = AllocatorIntf_malloc(o->alloc, &indexnospec);
      if(fdc37m81xconfig->buf)
      {
         fdc37m81xconfig->bufSize = (int)indexnospec-1; 
         return 0;
      }
      else
         handleunknown(o, -2);
   }
   else
      handleunknown(o, -1);
   return -1;
}


BA_API int
DynBuffer_expand(DynBuffer* o, int cachedisable)
{
   BufPrint* fdc37m81xconfig = (BufPrint*)o;
   int emulateinstruction = fdc37m81xconfig->bufSize - fdc37m81xconfig->cursor;
   if(emulateinstruction >= cachedisable)
      return 0;
   return logicalindex(fdc37m81xconfig, cachedisable-emulateinstruction);
}



BA_API void
DynBuffer_constructor(DynBuffer* o,
                      int allocpages,
                      int heartclocksource,
                      AllocatorIntf* unmapaliases,
                      DynBuffer_OnAllocError cplusserial8250)
{
   BufPrint* fdc37m81xconfig = (BufPrint*)o;
   memset(o, 0, sizeof(DynBuffer));

   BufPrint_constructor(fdc37m81xconfig, 0, logicalindex);
   o->startSize=allocpages;
   o->expandSize=heartclocksource;
   o->alloc = unmapaliases ? unmapaliases : AllocatorIntf_getDefault();
   o->onAllocError=cplusserial8250;
   fdc37m81xconfig->buf = 0;
   fdc37m81xconfig->bufSize = 0;
   logicalindex((BufPrint*)o, allocpages);
}


BA_API void
DynBuffer_release(DynBuffer* o)
{
   BufPrint* fdc37m81xconfig = (BufPrint*)o;
   if(fdc37m81xconfig->buf)
   {
      AllocatorIntf_free(o->alloc, fdc37m81xconfig->buf);
      fdc37m81xconfig->buf=0;
	  fdc37m81xconfig->cursor=0;
	  fdc37m81xconfig->bufSize=0;
   }
}

BA_API char*
DynBuffer_getBuf(DynBuffer* o)
{
   BufPrint* fdc37m81xconfig = (BufPrint*)o;
   if(fdc37m81xconfig->buf)
   {
      
      fdc37m81xconfig->buf[fdc37m81xconfig->cursor]=0;
   }
   return fdc37m81xconfig->buf;
}


BA_API const char*
DynBuffer_ecode2str(int serial8250device)
{
   switch(serial8250device)
   {
      
      case -2: return "\115\141\154\154\157\143\040\146\141\151\154\145\144";
      case -3: return "\116\157\040\162\145\141\154\154\157\143";
      case -4: return "\122\145\141\154\154\157\143\040\146\141\151\154\145\144";
      case -5: return "\102\165\146\146\145\162\040\164\157\157\040\154\141\162\147\145";
   }
   baAssert(0);
   return "\151\156\164\145\162\156\040\145\162\162";
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#define SingleListCode
#include <HashTable.h>

#include <string.h>
#include <TargConfig.h>

BA_API void
HashTableNode_constructor(HashTableNode* o,
                          const char* gpio1config,
                          HashTableNode_terminate sha512update)
{
   SingleLink_constructor((SingleLink*)o);
   o->name = gpio1config;
   o->destructor = sha512update;
}


BA_API HashTable*
HashTable_create(U32 buddynocheck, AllocatorIntf* unmapaliases)
{
   if(!unmapaliases) unmapaliases=AllocatorIntf_getDefault();
   if(buddynocheck)
   {
      size_t icachealiases = sizeof(HashTable) + sizeof(SingleList)*(buddynocheck-1);
      HashTable* ht = (HashTable*)AllocatorIntf_malloc(unmapaliases, &icachealiases);
      if(ht)
      {
         U32 i;
         ht->tmObj=0;
         ht->noOfHashElements = buddynocheck;
         for (i=0; i < buddynocheck; i++)
            SingleList_constructor(ht->table+i);
         return ht;
      }
   }
   return 0;
}


BA_API void
HashTable_destructor(HashTable* o)
{
   U32 i;
   for (i = 0; i < o->noOfHashElements; i++)
   {
      HashTableNode* smartreflexhwmod;
      SingleList* entryinsert = o->table+i;
      while( (smartreflexhwmod = (HashTableNode*)SingleList_removeFirst(entryinsert)) != 0 )
      {
         HashTableNode_terminate(smartreflexhwmod, o->tmObj);
      }
   }
}


BA_API int
HashTable_iter(HashTable* o, void* memorydescriptor, HashTable_CbFunc keypadacquire)
{
   U32 i;
   for (i = 0; i < o->noOfHashElements; i++)
   {
      SingleListEnumerator e;
      SingleLink* sl;
      SingleList* entryinsert = o->table+i;
      SingleListEnumerator_constructor(&e, entryinsert);
      for(sl = SingleListEnumerator_getElement(&e) ;
          sl ;
          sl = SingleListEnumerator_nextElement(&e))
      {
         int sffsdrnandflash = (*keypadacquire)(memorydescriptor, (HashTableNode*)sl);
         if(sffsdrnandflash)
            return sffsdrnandflash;
      }
   }
   return 0;
}


static SingleList*
HashTable_hash(HashTable* o, const char* s)
{
   const char *p;
   unsigned long h = 0, g;
   for(p = s; *p; p = p + 1)
   {
      h = (h << 4) + *p;
      if( (g = h & 0xf0000000l) !=0 )
      {
         h = h ^ (g >> 24);
         h = h ^ g;
      }
   }
   return o->table + h % o->noOfHashElements;
}


BA_API void
HashTable_add(HashTable* o, HashTableNode* smartreflexhwmod)
{
   SingleList* entryinsert = HashTable_hash(o, smartreflexhwmod->name);
   SingleList_insertLast(entryinsert, smartreflexhwmod);
}


BA_API HashTableNode*
HashTable_lookup(HashTable* o, const char* nanoenginesetup)
{
   SingleListEnumerator instructioncounter;
   HashTableNode* smartreflexhwmod;
   SingleListEnumerator_constructor(&instructioncounter, HashTable_hash(o, nanoenginesetup));
   for(smartreflexhwmod = (HashTableNode*)SingleListEnumerator_getElement(&instructioncounter);
       smartreflexhwmod;
       smartreflexhwmod = (HashTableNode*)SingleListEnumerator_nextElement(&instructioncounter))
   {
      if ( ! strcmp(nanoenginesetup, smartreflexhwmod->name) )
         return smartreflexhwmod;
   }
   return 0;
}



#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpCmdThreadPool.h>
#include <ThreadLib.h>
#include <stddef.h>


static void
sdhciresources(HttpCmdThreadPoolIntf* o,
                                  HttpCmdThreadPoolIntf_DoDir pwrdmoperations)
{
   o->doDir = pwrdmoperations;
}




static void kernelstack(Thread* suspendprepare);


static void
genericshutdown(HttpCmdThread* o,
                          ThreadPriority gpio1resources,
                          int stage2unmap,
                          struct HttpCmdThreadPool* configbootdata,
                          DoubleList* entryinsert)
{
   memset(o, 0, sizeof(HttpCmdThread));
   Thread_constructor((Thread*)o, kernelstack, gpio1resources, stage2unmap);
   ThreadSemaphore_constructor(&o->sem);
   DoubleLink_constructor(&o->node);
   o->pool = configbootdata;
   DoubleList_insertLast(entryinsert, &o->node);
   Thread_start((Thread*)o);
}


static void
boardconfig(HttpCmdThread* o)
{
   Thread_destructor((Thread*)o);
   ThreadSemaphore_destructor(&o->sem);
}

static void
kernelstack(Thread* suspendprepare)
{
   HttpCmdThreadState state;
   HttpCmdThread* o = (HttpCmdThread*)suspendprepare;
   struct HttpCmdThreadPool* configbootdata=o->pool;
   for(;;)
   {
      ThreadSemaphore_wait(&o->sem);
      SoDisp_mutexSet(configbootdata->dispatcher);
      state = o->state;
      if(state == HttpCmdThreadState_Idle)
      {
         baAssert(DoubleList_isInList(&configbootdata->freeList, &o->node));
         SoDisp_mutexRelease(configbootdata->dispatcher);
         continue;
      }
      baAssert(DoubleList_isInList(&configbootdata->runningList, &o->node));

      if(state == HttpCmdThreadState_RunDir)
         HttpServer_AsynchProcessDir(configbootdata->server, o->dir, o->cmd);

      DoubleLink_unlink(&o->node);
      o->state = HttpCmdThreadState_Idle;
      DoubleList_insertLast(&configbootdata->freeList, &o->node);

      SoDisp_mutexRelease(configbootdata->dispatcher);
      if(state == HttpCmdThreadState_Exit)
         return;
   }
}


static HttpCmdThread*
parsefeatures(DoubleLink* l)
{
   if(l)
       return (HttpCmdThread*)((U8*)l - offsetof(HttpCmdThread, node));
   return 0;
}


static void
mcspiclass(HttpCmdThread* o, HttpCommand* cmd, HttpDir* dir)
{
   baAssert( o->state ==  HttpCmdThreadState_Idle);
   baAssert( ! cmd->runningInThread );
   cmd->runningInThread = TRUE;
   o->dir = dir;
   o->cmd = cmd;
   o->state = HttpCmdThreadState_RunDir;
   ThreadSemaphore_signal(&o->sem);
}


static void
finishsuspend(HttpCmdThread* o)
{
   baAssert( o->state ==  HttpCmdThreadState_Idle);
   o->state = HttpCmdThreadState_Exit;
   ThreadSemaphore_signal(&o->sem);
}


static void
supportsmixed(HttpCmdThreadPool* o)
{
   while( ! DoubleList_isEmpty(&o->runningList) )
   {
      SoDisp_mutexRelease(o->dispatcher);
      Thread_sleep(50);
      SoDisp_mutexSet(o->dispatcher);
   }
}


static int
timercompute(HttpCmdThreadPool* o,
                        HttpCommand* cmd,
                        HttpDir* dir)
{
   HttpCmdThread* tCmd = parsefeatures(
      DoubleList_removeFirst(&o->freeList));
   if(tCmd)
   {
      DoubleList_insertLast(&o->runningList, &tCmd->node);
      mcspiclass(tCmd, cmd, dir);
      return 0;
   }
   return -1;
}


BA_API void
HttpCmdThreadPool_constructor(HttpCmdThreadPool* o,
                              HttpServer* uarchbuild,
                              ThreadPriority gpio1resources,
                              int stage2unmap)
{
   memset(o, 0, sizeof(HttpCmdThreadPool));
   sdhciresources(
      (HttpCmdThreadPoolIntf*)o,
      (HttpCmdThreadPoolIntf_DoDir)timercompute);
   DoubleList_constructor(&o->freeList);
   DoubleList_constructor(&o->runningList);
   o->server = uarchbuild;
   o->dispatcher = HttpServer_getDispatcher(uarchbuild);
   o->pool = (HttpCmdThread*)
      baMalloc(sizeof(HttpCmdThread) * uarchbuild->commandPoolSize);
   if(o->pool)
   {
      int i;
      for(i = 0; i < uarchbuild->commandPoolSize; i++)
      {
         genericshutdown(o->pool+i,
                                   gpio1resources,
                                   stage2unmap,
                                   o,
                                   &o->freeList);

      }
   }
   HttpServer_setThreadPoolIntf(o->server,(HttpCmdThreadPoolIntf*)o);
}



BA_API void
HttpCmdThreadPool_destructor(HttpCmdThreadPool* o)
{
   if(o->pool)
   {
      HttpCmdThread* cmd;
      HttpServer_setThreadPoolIntf(o->server, 0); 
      supportsmixed(o);
      while( (cmd = parsefeatures(
                 DoubleList_removeFirst(&o->freeList))) !=0 )
      {
         DoubleList_insertLast(&o->runningList, &cmd->node);
         finishsuspend(cmd); 
      }
      supportsmixed(o);
      while( (cmd = parsefeatures(
                 DoubleList_removeFirst(&o->freeList))) !=0 )
      {
         boardconfig(cmd);
      }
      baFree(o->pool);
      o->pool=0;
   }
}


#ifndef BA_LIB
#define BA_LIB 1
#endif
#define INL_baConvBin2Hex 1

#include <HttpServer.h>
#include <BaServerLib.h>
#include <HttpTrace.h>
#include <string.h>

BA_API void
HttpConnection_constructor(HttpConnection* o,
                           HttpServer* uarchbuild,
                           SoDisp* sha256start,
                           SoDispCon_DispRecEv e)
{
   memset(o, 0, sizeof(HttpConnection));
   SoDispCon_constructor((SoDispCon*)o, sha256start, e);
   HttpConnection_clearKeepAlive(o);
   o->server = uarchbuild;
   o->state = HttpConnection_Free;
}

int
HttpConnection_pushBack(HttpConnection* o, const void* d, int s)
{
   if(o->pushBackData)
   {
      
      U8* ptr = (U8*)baMalloc(o->pushBackDataSize+s);
      if(ptr)
      {
         memcpy(ptr, d, s);
         memcpy(ptr+s, o->pushBackData, o->pushBackDataSize);
         o->pushBackDataSize+=s;
         baFree(o->pushBackData);
         o->pushBackData=ptr;
      }
   }
   else
   {
      o->pushBackData = (U8*)baMalloc(s);
      if(o->pushBackData)
      {
         memcpy(o->pushBackData, d, s);
         o->pushBackDataSize=s;
      }
   }
   return o->pushBackData ? 0 : -1;
}

BA_API int
HttpConnection_blockRead(HttpConnection* o, void* alloccontroller, int len)
{
   if(o->pushBackData)
      return HttpConnection_readData(o, alloccontroller, len);
   return SoDispCon_blockRead((SoDispCon*)o, alloccontroller, len);
}


BA_API int
HttpConnection_readData(HttpConnection* o, void* alloccontroller, int len)
{
   if(o->pushBackData)
   {
      if(len < o->pushBackDataSize)
      {
         memcpy(alloccontroller, o->pushBackData, len);
         o->pushBackDataSize -= len;
         memmove(o->pushBackData,(U8*)o->pushBackData+len,o->pushBackDataSize);
         return len;
      }
      else
      {
         memcpy(alloccontroller, o->pushBackData, o->pushBackDataSize);
         baFree(o->pushBackData);
         o->pushBackData = 0;
         return o->pushBackDataSize;
      }
   }
   return SoDispCon_readData((SoDispCon*)o, alloccontroller, len, FALSE);
}


BA_API void
HttpConnection_setState(HttpConnection* o, HttpConnection_State state)
{
   if(o->state != state)
   {
#ifdef HTTP_TRACE
      static const char* sysctlpaths[]= {
         "\106\162\145\145\040\040\040\040\040",
         "\103\157\156\156\145\143\164\145\144",
         "\122\145\141\144\171\040\040\040\040",
         "\122\165\156\156\151\156\147\040\040",
         "\115\157\166\145\144\040\040\040\040",
         "\124\145\162\155\151\156\141\164\145\144",
         "\110\103" 
      };
      if(HttpTrace_doHttp11State())
      {
         HttpTrace_printf(5,"\103\157\156\156\145\143\164\151\157\156\040\045\160\040\045\060\064\144\040\164\162\141\156\163\072\040\045\163\040\055\076\040\045\163\012",
                          o,
                          SoDispCon_getId((SoDispCon*)o),
                          sysctlpaths[o->state],
                          sysctlpaths[state]);
      }
#endif
      if(state==HttpConnection_Free || state==HttpConnection_Terminated)
      {
         if(o->pushBackData)
            baFree(o->pushBackData);
         o->pushBackData=0;
         SoDispCon_shutdown((SoDispCon*)o);
      }
      else if(state==HttpConnection_HardClose)
      {
         state=HttpConnection_Terminated; 
         if(o->pushBackData)
            baFree(o->pushBackData);
         o->pushBackData=0;
         SoDispCon_hardClose((SoDispCon*)o);
      }
      else
      {
         ((SoDispCon*)o)->recTermPtr=0;
         ((SoDispCon*)o)->sendTermPtr=0;
         if(state==HttpConnection_Connected)
            ((SoDispCon*)o)->exec((SoDispCon*)o,0,SoDispCon_ExTypeIdle,0,0);
      }
      o->state = (U8)state;
   }
}



BA_API int
HttpConnection_moveCon(HttpConnection* o,  HttpConnection* boardmanufacturer)
{
   baAssert(boardmanufacturer->server == o->server);
   boardmanufacturer->state = o->state;
   boardmanufacturer->pushBackData = o->pushBackData;
   boardmanufacturer->pushBackDataSize = o->pushBackDataSize;
   o->pushBackData=0;
   SoDispCon_moveCon((SoDispCon*)o, (SoDispCon*)boardmanufacturer);
   HttpConnection_setState(o, HttpConnection_Moved);
   if(HttpConnection_keepAlive(o))
   {
      HttpConnection_setKeepAlive(boardmanufacturer);
      HttpConnection_clearKeepAlive(o);
   }
   return 0;
}


BA_API void
HttpConnection_destructor(HttpConnection* o)
{
   o->state = HttpConnection_Terminated;
   if(o->pushBackData)
      baFree(o->pushBackData);
   o->pushBackData=0;
   SoDispCon_destructor((SoDispCon*)o);
}




int
HttpConnection_sendChunkData6bOffs(HttpConnection* o,const void* alloccontroller,int len)
{
   U8* end = ((U8*)alloccontroller) + len;
   U8* ptr = (U8*)alloccontroller;
   U8 processsubpacket = (U8)(len >> 8);

   baAssert(len <= 0xFFFF);

   *--ptr = '\012';
   *--ptr = '\015';
   ptr -= 2;
   baConvBin2Hex(ptr, (U8)len);
   if(processsubpacket)
   {
      ptr -= 2;
      baConvBin2Hex(ptr, processsubpacket);
   }
   if(*ptr == '\060')
   {
      ptr++;
   }
   *end++='\015';
   *end='\012';
   return SoDispCon_sendData((SoDispCon*)o, ptr, len + (int)((U8*)alloccontroller - ptr) + 2);
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpRecData.h>
#include <BaServerLib.h>

static S32
evaluateobject(HttpRecData* o, void* buf, S32 lsdc2format)
{
   S32 icachealiases;
   if(o->bufSize) 
   {
      BaBool bswapinitrd;
      U8* cpuinfoloongson = (U8*)HttpInData_getBuf(HttpRequest_getBuffer(o->req));
      baAssert(o->readPos < o->bufSize);
      icachealiases = (S32)(o->bufSize - o->readPos);
      if(lsdc2format < icachealiases)
      {
         icachealiases = lsdc2format;
         bswapinitrd = TRUE;
      }
      else
      {
         o->bufSize = 0; 
         bswapinitrd = FALSE;
      }
      memcpy(buf, cpuinfoloongson+o->readPos, icachealiases);
      o->readPos += icachealiases;
      if( bswapinitrd)
         return icachealiases;
      buf = (U8*)buf + icachealiases;
      lsdc2format -= icachealiases;
   }
   else
      icachealiases=0;
   
   while(lsdc2format > 0)
   {
      S32 decodetable;
      decodetable = HttpConnection_blockRead(o->con, buf, lsdc2format);
      if(decodetable < 0)
      {
         o->sizeLeft=0;
         return decodetable;
      }
      buf = (U8*)buf + decodetable;
      icachealiases += decodetable;
      lsdc2format -= decodetable;
   }
   return icachealiases;
}


static S32
clearbuffer(HttpRecData* o)
{
   U8 c;
   S32 notifierretry=0;
   do
   {
      if( evaluateobject(o, &c, 1) != 1 )
         return -1;
   } while(c == '\015' || c == '\012');
   for(;;)
   {
      if(c>='\060' && c<='\071') c -= '\060' ; 
      else if(c>='\141' && c<='\146') c = c-'\141'+10 ; 
      else if(c>='\101' && c<='\106') c = c-'\101'+10 ; 
      else
      {
         if(c != '\073' && c != '\015' && c != '\012')
            return -1;
         while(c != '\012') 
         {
            if( evaluateobject(o, &c, 1) != 1 )
               return -1;
         }
         return notifierretry;
      }
      notifierretry <<= 4;
      notifierretry += c;
      if( evaluateobject(o, &c, 1) != 1 )
         return -1;
   }
}


BA_API SBaFileSize
HttpRecData_valid(HttpRequest* req)
{
   HttpStdHeaders* stdH = HttpRequest_getStdHeaders(req);
   BaFileSize disabletraps = HttpStdHeaders_getContentLength(stdH);
   const char* modulefunction=HttpStdHeaders_getContentType(stdH);
   if(modulefunction)
   {
      if(!baStrnCaseCmp(modulefunction,"\155\165\154\164\151\160\141\162\164\057\146\157\162\155\055\144\141\164\141", 19))
      {
         return -3;
      }
      if(!baStrnCaseCmp(modulefunction,"\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\167\167\055\146\157\162\155\055\165\162\154\145\156\143\157\144\145\144",33))
      {
         return -2; 
      }
   }
   else if( ! disabletraps && !HttpRequest_getHeaderValue(req, "\124\162\141\156\163\146\145\162\055\145\156\143\157\144\151\156\147"))
      return -1;
   return disabletraps;
}




BA_API void
HttpRecData_constructor(HttpRecData* o, HttpRequest* req)
{
   SBaFileSize disabletraps = HttpRecData_valid(req);
   o->con = HttpRequest_getConnection(req);
   o->req=req;
   o->sizeLeft=0;
   o->bufSize=0;
   o->readPos=0;
   o->chunkSize=0;
   req->postDataConsumed=TRUE;
   if(disabletraps < 0)
   {
      HttpConnection_setState(o->con,HttpConnection_Terminated);
      o->con=0;
      return;
   }
   if(HttpRequest_getHeaderValue(req, "\105\170\160\145\143\164"))
   { 
      if(HttpResponse_send100Continue(HttpRequest_getResponse(req)))
         return; 
   }
   if(HttpRequest_getHeaderValue(req, "\124\162\141\156\163\146\145\162\055\145\156\143\157\144\151\156\147"))
   {
      disabletraps = o->sizeLeft = -1;  
   }
   if(disabletraps)
   {
      
      HttpInData* httpData = HttpRequest_getBuffer(req);
      S32 lsdc2format=HttpInData_getBufSize(httpData);
      if(disabletraps > 0 && lsdc2format >= disabletraps)
      {  
         o->sizeLeft = disabletraps;
         o->bufSize = disabletraps;
         httpData->lineEndI+=(U16)disabletraps;
      }
      else 
      {
         if(disabletraps > 0) 
            o->sizeLeft = disabletraps;
         o->bufSize = lsdc2format;
         
         if(HttpConnection_recEvActive(o->con))
         {
            SoDisp_deactivateRec(HttpConnection_getDispatcher(o->con),
                                 (SoDispCon*)o->con);
         }
         httpData->lineEndI += (U16)lsdc2format;
      }
      HttpRequest_enableKeepAlive(req);
   }
}


BA_API void
HttpRecData_destructor(HttpRecData* o)
{
   if(o->sizeLeft != 0) 
   {
      HttpConnection_setState(o->con,HttpConnection_Terminated);
   }
}


BA_API S32
HttpRecData_read(HttpRecData* o, void* buf, S32 lsdc2format)
{
   S32 icachealiases=0;
   if(lsdc2format <= 0 || !o->con)
      return -1;
   if(o->sizeLeft == 0)  
      return 0;
   if(o->sizeLeft > 0) 
   {
      icachealiases =  (S32)(lsdc2format > o->sizeLeft ? o->sizeLeft : lsdc2format);
      icachealiases = evaluateobject(o, buf, icachealiases);
      if(icachealiases > 0)
         o->sizeLeft -= icachealiases;
      baAssert(o->sizeLeft >= 0);
   }
   else 
   {
      while(lsdc2format)
      {
         S32 decodetable;
         if(o->chunkSize == 0)
         {
            o->chunkSize = clearbuffer(o);
            if(o->chunkSize <= 0)
            {
               if(o->chunkSize < 0)
                  icachealiases = -1; 
               else
               {
                  decodetable=0;
                  o->chunkSize = -1;
                  if(evaluateobject(o, &decodetable, 1)==1)
                  {
                     if( decodetable == '\012' ||
                         (decodetable == '\015' &&
                          evaluateobject(o, &decodetable, 1)==1 &&
                          decodetable == '\012') )
                     {
                        o->chunkSize = 0;
                     }
                  }
                  if(o->chunkSize < 0)
                     icachealiases = -1; 
               }
               o->sizeLeft = 0; 
               break; 
            }
         }
         decodetable = (S32)(lsdc2format > o->chunkSize ?  o->chunkSize : lsdc2format);
         decodetable = evaluateobject(o, buf, decodetable);
         if(decodetable < 0)
         {
            icachealiases = decodetable; 
            break;
         }
         else
         {
            icachealiases += decodetable;
            buf = (U8*)buf + decodetable;
            lsdc2format -= decodetable;
            o->chunkSize -= decodetable;
            baAssert(o->chunkSize >=0);
         }
      }
   }
   if(icachealiases < 0)
   {
      o->sizeLeft=0; 
      HttpConnection_setState(o->con,HttpConnection_Terminated);
   }
   return icachealiases;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpResRdr.h>
#include <BaServerLib.h>
#include <BaMimeTypes.h>

#ifdef BA_FILESIZE64
#define XX_atoi U64_atoll
#define XX_atoi2 U64_atoll2
#else
#define XX_atoi U32_atoi
#define XX_atoi2 U32_atoi2
#endif

#ifndef NO_ZLIB
static IoIntf_DeflateGzip IoIntf_deflateGzipFp;

BA_API void set_deflategzip(IoIntf_DeflateGzip ptr)
{
    IoIntf_deflateGzipFp=ptr;
}

BA_API IoIntf_DeflateGzip get_deflategzip(void)
{
    return IoIntf_deflateGzipFp;
}
#endif


#ifndef NO_ASYNCH_RESP
typedef struct
{
      HttpConnection super; /* Inherits from HttpConnection */
      IoIntf* io;
      ResIntfPtr resPtr;
      char* buf;
      size_t bufLen;
      BaFileSize sizeLeft;
      int receiveEvents;
} AsynchResp;


static void
r5000scache(AsynchResp* o)
{
   HttpConnection* con = (HttpConnection*)o; 
   SoDisp* ptraceaccess=HttpConnection_getDispatcher(con);
   if(HttpConnection_sendEvActive(con))
      SoDisp_deactivateSend(ptraceaccess, (SoDispCon*)o);
   if(HttpConnection_dispatcherHasCon(con))
      SoDisp_removeConnection(ptraceaccess, (SoDispCon*)o);
   if(HttpConnection_isValid(con) && HttpConnection_keepAlive(con))
   {
      HttpConnection_setBlocking(con);
      HttpServer_addCon2ConnectedList(HttpConnection_getServer(con),con);
   }
   HttpConnection_destructor(con);
   o->resPtr->closeFp(o->resPtr);
   baFree(o);
}



static void
gicv4enable(SoDispCon* fdc37m81xconfig)
{
   AsynchResp* o = (AsynchResp*)fdc37m81xconfig;
   HttpConnection_clearKeepAlive((HttpConnection*)fdc37m81xconfig); 
   
   if(++o->receiveEvents > 2)
      r5000scache(o);
}


static void
hardwareprobe(SoDispCon* fdc37m81xconfig)
{
   AsynchResp* o = (AsynchResp*)fdc37m81xconfig;
   int sffsdrnandflash = SoDispCon_asyncReady(fdc37m81xconfig);
   if(sffsdrnandflash)
   {
      size_t notifierretry;
      if(sffsdrnandflash < 0)
      {  
         r5000scache(o);
         return;
      }
      do
      {
         int sffsdrnandflash;
         notifierretry = o->sizeLeft > o->bufLen ? o->bufLen : (size_t)o->sizeLeft;
         o->sizeLeft -= notifierretry;
         if(! o->sizeLeft ||
            ((sffsdrnandflash=o->resPtr->readFp(o->resPtr,o->buf,notifierretry,&notifierretry))
             && sffsdrnandflash != IOINTF_EOF) )
         {
            r5000scache(o);
            return;
         }
      } while( (sffsdrnandflash = SoDispCon_asyncSend(fdc37m81xconfig, (int)notifierretry)) > 0 );
      if(sffsdrnandflash < 0)
      {  
         r5000scache(o);
         return;
      }
   }
}


static void
uncachedhandler(AsynchResp* o,
                       HttpCommand* cmd,
                       IoIntf* io,
                       ResIntfPtr domainstart,
                       void* buf,
                       size_t instructionemulation,
                       BaFileSize emulateinstruction)
{
   SoDisp* ptraceaccess=HttpConnection_getDispatcher(cmd->con);
   HttpConnection_constructor((HttpConnection*)o,
                              HttpConnection_getServer(cmd->con),
                              HttpConnection_getDispatcher(cmd->con),
                              gicv4enable);
   HttpConnection_moveCon(cmd->con, (HttpConnection*)o);
   o->buf = buf;
   o->io = io;
   o->resPtr=domainstart;
   o->sizeLeft = emulateinstruction;
   o->bufLen=instructionemulation;
   o->receiveEvents=0;
   HttpConnection_setDispSendEvent(o, hardwareprobe);
   SoDisp_addConnection(ptraceaccess, (SoDispCon*)o);
   SoDisp_activateSend(ptraceaccess, (SoDispCon*)o);
}
#endif
 

BA_API void
HttpRdFilter_constructor(
   HttpRdFilter* o, const char* ext, HttpRdFilter_Service stage2force)
{
   DoubleLink_constructor((DoubleLink*)o);
   o->ext=ext;
   o->serviceFp=stage2force;
}


BA_API void
HttpRdFilter_destructor(HttpRdFilter* o)
{
   if(DoubleLink_isLinked((DoubleLink*)o))
      DoubleLink_unlink((DoubleLink*)o);
}



static void
dc21285enable(BaBool dm9000enable,
            HttpResponse* doublefsqrt,
            const char* gpio1config,
            int sffsdrnandflash,
            const char* pendownstate)
{
   const char* fmt = dm9000enable ?
      "\103\141\156\156\157\164\040\157\160\145\156\040\045\163\056\012\045\163\056\012\045\163" :
      "\103\141\156\156\157\164\040\122\145\141\144\040\045\163\056\012\045\163\056\012\045\163";

   if( ! HttpResponse_committed(doublefsqrt) )
   {

      if(sffsdrnandflash == IOINTF_NOZIPLIB)
      {
         HttpResponse_sendRedirect(
            doublefsqrt, "\150\164\164\160\072\057\057\167\167\167\056\162\145\141\154\164\151\155\145\154\157\147\151\143\056\143\157\155\057\116\157\132\151\160\056\150\164\155\154");
      }
      else
      {
         if(sffsdrnandflash == 0)
            sffsdrnandflash=IOINTF_IOERROR;
         HttpResponse_fmtError(
            doublefsqrt,
            baErr2HttpCode(sffsdrnandflash),
            fmt,
            gpio1config,
            baErr2Str(sffsdrnandflash),
            pendownstate ? pendownstate : "");
      }
   }
   HttpConnection_setState(HttpResponse_getConnection(doublefsqrt),
                           HttpConnection_Terminated);
}

static void
dummycontroller(HttpResRdr* o, HttpResponse* r3000write, BaBool preparesystem)
{
   if(HttpResponse_initial(r3000write))
   {
      if(o->maxAge && preparesystem)
         HttpResponse_setMaxAge(r3000write, o->maxAge);
      if(o->headers)
      {
         HttpResRdrHeader* h = o->headers;
         char* validconfig = (char*)h;
         while(h->keyIx)
         {
            HttpResponse_setHeader(r3000write, validconfig+h->keyIx, validconfig+h->valIx, FALSE);
            h++;
         }
      }
   }
}



static void
cpuidleresources(IoIntf* io,
                       const char* gpio1config,
                       IoStat* st,
                       HttpResponse* doublefsqrt)
{
   BaFileSize icachealiases;
   size_t notifierretry;
   int sffsdrnandflash;
   const char* ethernatenable;
   char* dbdmasyscore;
   ResIntfPtr in = io->openResFp(io, gpio1config, OpenRes_READ, &sffsdrnandflash, &ethernatenable);
   if(in)
   {
      for(icachealiases = st->size; icachealiases != 0 ; )
      {
         dbdmasyscore = HttpResponse_getBufOffs(doublefsqrt);
         notifierretry = HttpResponse_getRemBufSize(doublefsqrt);
         if(notifierretry > icachealiases)
            notifierretry=(size_t)icachealiases;
         sffsdrnandflash = in->readFp(in, dbdmasyscore, notifierretry, &notifierretry);
         if(sffsdrnandflash || notifierretry == 0)
         {
            dc21285enable(FALSE, doublefsqrt, gpio1config, sffsdrnandflash, 0);
            goto L_close;
         }
         if(HttpResponse_dataAdded(doublefsqrt, (U32)notifierretry))
            goto L_close; 
         baAssert(icachealiases >= notifierretry);
         icachealiases -= notifierretry;
      }
     L_close:
      in->closeFp(in);
   }
   else
   {
      dc21285enable(TRUE, doublefsqrt, gpio1config, sffsdrnandflash, ethernatenable);
      return;
   }
}



static BaBool
domainxlate(HttpRequest* r)
{
   const char* h = HttpRequest_getHeaderValue(r, "\101\143\143\145\160\164\055\105\156\143\157\144\151\156\147");
   if(h == 0)
      h = HttpRequest_getHeaderValue(r, "\124\105");
   return (h && (strstr(h, "\147\172\151\160") || strchr(h, '\052'))) ? TRUE : FALSE;
}


static void
hammerdevices(HttpResponse* r)
{
   HttpResponse_setHeader(r, "\103\157\156\164\145\156\164\055\105\156\143\157\144\151\156\147", "\147\172\151\160", TRUE);
   
   HttpResponse_setHeader(r,"\126\141\162\171","\101\143\143\145\160\164\055\105\156\143\157\144\151\156\147", TRUE);
}


BA_API void
HttpResRdr_sendFile(IoIntf* io,
                    const char* gpio1config,
                    IoStat* st,
                    HttpCommand* cmd)
{
   char* ptr;
   const char* poweroffrequired;
   HttpMethod mt;
   BaBool boardbyname=FALSE;

   
   if(HttpResponse_isInclude(&cmd->response))
   {
      cpuidleresources(io, gpio1config, st, &cmd->response);
      return;
   }

   mt = HttpRequest_getMethodType(&cmd->request);

   
   if( ! HttpResponse_isForward(&cmd->response) )
   {
      HttpResponse_setHeader(&cmd->response,"\101\143\143\145\160\164\055\122\141\156\147\145\163","\142\171\164\145\163",TRUE);
      
      ptr = HttpResponse_fmtHeader(&cmd->response, "\105\164\141\147", 9, TRUE);
      if(!ptr) return;
      baConvU32ToHex(ptr, (U32)st->lastModified);
      ptr[8]=0;
      
      HttpResponse_setDateHeader(
         &cmd->response,"\114\141\163\164\055\115\157\144\151\146\151\145\144",st->lastModified);
      
      if(mt == HttpMethod_Options ||
         (mt != HttpMethod_Get && mt != HttpMethod_Head))
      {
         static const char outboundenter[] = {"\117\120\124\111\117\116\123\054\040\107\105\124\054\040\110\105\101\104"};
         HttpResponse_setHeader(&cmd->response,"\101\154\154\157\167",outboundenter,TRUE);
         HttpResponse_setContentLength(&cmd->response, 0);
         if(mt != HttpMethod_Options)
            HttpResponse_sendError2(&cmd->response, 405, outboundenter);
         return;
      }
   }

   if(st->isDir)
   {
      if( ! HttpResponse_isForward(&cmd->response) )
         HttpResponse_setContentLength(&cmd->response, 0);
      return; 
   }

   
   poweroffrequired = HttpRequest_getHeaderValue(&cmd->request, "\111\146\055\116\157\156\145\055\115\141\164\143\150");
   if(poweroffrequired) 
   {
      if(*poweroffrequired == '\052' || 
         (strlen(poweroffrequired) == 8 && baConvHexToU32(poweroffrequired) == st->lastModified))
      {
         HttpResponse_setStatus(&cmd->response, 304); 
         HttpResponse_setContentLength(&cmd->response, 0);
         return; 
      }
   }
   else 
   {
      if(HttpRequest_checkTime(&cmd->request,&cmd->response,st->lastModified))
         return; 
   }

   if(mt != HttpMethod_Head)
   {  
      
      int sffsdrnandflash;
      const char* flushoffset;
      const char* eepromregister = HttpRequest_getHeaderValue(&cmd->request, "\122\141\156\147\145");
      BaFileSize icachealiases = st->size;
      ResIntfPtr domainstart=0;
      if(eepromregister && HttpRequest_getHeaderValue(&cmd->request, "\111\146\055\122\141\156\147\145"))
         eepromregister=0; 
      if(!eepromregister && domainxlate(&cmd->request))
      {
         if(io->openResGzipFp) 
         {
            domainstart = io->openResGzipFp(
               io,
               gpio1config,
               SoDisp_getMutex(HttpConnection_getDispatcher(cmd->con)),
               &icachealiases,
               &sffsdrnandflash,
               &flushoffset);
            if(domainstart)
            {
               hammerdevices(&cmd->response);
            }
            else if(sffsdrnandflash != IOINTF_NOTCOMPRESSED)
            {
               dc21285enable(TRUE, &cmd->response, gpio1config, sffsdrnandflash, flushoffset);
               return;
            }
         }
      }
      if( ! domainstart )
      {   
         domainstart = io->openResFp(io,gpio1config,OpenRes_READ,&sffsdrnandflash,&flushoffset);
         if(!domainstart)
         {
            dc21285enable(TRUE, &cmd->response, gpio1config, sffsdrnandflash, flushoffset);
            return;
         }
         icachealiases = st->size;
      }
      if(eepromregister)
      {
         BaFileSize forcereload, to;
         const char* sdhciplatform;
         forcereload = to = ~(BaFileSize)0; 
         sdhciplatform = strchr(eepromregister, '\075'); 
         if(sdhciplatform) 
         {
            if(! strchr(++sdhciplatform, '\054')) 
            {
               eepromregister = strchr(sdhciplatform, '\055');
               if(eepromregister) 
               {
                  if(sdhciplatform == eepromregister) 
                  {
                     forcereload = XX_atoi(++sdhciplatform);
                     if(forcereload)
                     {
                        to = icachealiases;
                        forcereload = icachealiases - forcereload;
                     }
                  }
                  else
                  {
                     forcereload = XX_atoi2(sdhciplatform, eepromregister);
                     if(*++eepromregister)
                        to = XX_atoi(eepromregister)+1;
                     else
                        to = icachealiases;
                  }
                  if(forcereload < to && to <= icachealiases) 
                  {
                     icachealiases=to-forcereload;
                     boardbyname=TRUE;
                  }
               }
            }
         }
         if(boardbyname)
         {
            eepromregister = HttpRequest_getHeaderValue(&cmd->request, "\111\146\055\115\141\164\143\150");
            if(eepromregister)
            {
               if(strlen(eepromregister) != 8 ||
                  baConvHexToU32(eepromregister) != st->lastModified)
               { 
                  HttpResponse_sendError1(&cmd->response, 412);
                  domainstart->closeFp(domainstart);
                  return;
               }
            }
            if(boardbyname)
            {
               if(forcereload)
                  sffsdrnandflash = domainstart->seekFp(domainstart, forcereload);
               else
                  sffsdrnandflash=0;
               if(sffsdrnandflash)
               {
                  dc21285enable(FALSE, &cmd->response, gpio1config, sffsdrnandflash, 0);
                  domainstart->closeFp(domainstart);
                  return;
               }
               else
               {
                  HttpResponse_setStatus(&cmd->response, 206);
                  ptr = HttpResponse_fmtHeader(
                     &cmd->response, "\103\157\156\164\145\156\164\055\122\141\156\147\145", 100, TRUE);
                  if(ptr)
                  {
                     basprintf(ptr, "\142\171\164\145\163\040\045" BA_UFSF "\055\045" BA_UFSF
                               "\057\045" BA_UFSF, forcereload,to-1,st->size);
                  }
               }
#ifndef NO_ZLIB
               if( IoIntf_deflateGzipFp && domainxlate(&cmd->request) )
               {
                  
                  BaBool emulateloregs;
                  domainstart = IoIntf_deflateGzipFp(
                     domainstart, 
                     gpio1config,
                     SoDisp_getMutex(HttpConnection_getDispatcher(cmd->con)),
                     &icachealiases, 
                     &emulateloregs);
                  if(!domainstart) 
                  {
                     dc21285enable(FALSE, &cmd->response, gpio1config,
                                 IOINTF_IOERROR, "\144\145\146\154\141\164\145");
                     return;
                  }
                  if(emulateloregs)
                     hammerdevices(&cmd->response);
               }
#endif
            }
         }
         if(!boardbyname)
            icachealiases = st->size; 
      }      
      HttpResponse_setContentLength(&cmd->response, icachealiases);

      
      if(!HttpResponse_flush(&cmd->response))
      {
#ifdef NO_ASYNCH_RESP
         size_t rs780ebegin;
         size_t notifierretry;
         rs780ebegin = HttpResponse_getBufSize(&cmd->response);
         ptr = HttpResponse_getBuf(&cmd->response);
         while(icachealiases)
         {
            notifierretry = icachealiases > rs780ebegin ? rs780ebegin : (size_t)icachealiases;
            sffsdrnandflash = domainstart->readFp(domainstart, ptr, notifierretry, &notifierretry);
            if(sffsdrnandflash)
            {
               dc21285enable(FALSE, &cmd->response, gpio1config, sffsdrnandflash, 0);
               break;
            }
            if(HttpResponse_send(&cmd->response,ptr,notifierretry))
               break; 
            icachealiases -= notifierretry;
         }
#else
         size_t notifierretry;
         int rs780ebegin = HttpResponse_getBufSize(&cmd->response);
         HttpConnection* con = cmd->con;
         ptr = HttpConnection_allocAsynchBuf(con, &rs780ebegin);
         if(ptr)
         {
            int sffsdrnandflash=0;
            HttpConnection_setNonblocking(con);
            while( icachealiases && (sffsdrnandflash = HttpConnection_asyncReady(con)) )
            {
               if(sffsdrnandflash < 0)
                  break; 
               notifierretry=icachealiases>(size_t)rs780ebegin?(size_t)rs780ebegin:(size_t)icachealiases;
               sffsdrnandflash = domainstart->readFp(domainstart, ptr, notifierretry, &notifierretry);
               if(sffsdrnandflash || notifierretry == 0)
               {
                  dc21285enable(FALSE, &cmd->response, gpio1config, sffsdrnandflash, 0);
                  break;
               }
               if( (sffsdrnandflash=HttpConnection_asyncSend(con, (int)notifierretry)) <= 0 )
                  break;
               icachealiases -= notifierretry;
            }
            if( sffsdrnandflash==0 ) 
            {
               AsynchResp* aresp;
               aresp = (AsynchResp*)baMalloc(sizeof(AsynchResp));
               if(aresp)
               {
                  HttpRequest_pushBackData(&cmd->request);
                  uncachedhandler(aresp,
                                         cmd,
                                         io,
                                         domainstart,
                                         ptr,
                                         rs780ebegin,
                                         icachealiases);
                  domainstart=0; 
               }
               else
                  HttpResponse_sendError1(&cmd->response, 503);
            }
            else if(sffsdrnandflash > 0 && HttpConnection_isValid(con))
               HttpConnection_setBlocking(con);
         }
         else
            HttpResponse_sendError1(&cmd->response, 503);
#endif
      }
      if(domainstart)
         domainstart->closeFp(domainstart);
   }
   else 
      HttpResponse_setContentLength(&cmd->response, st->size);
}




static int
enablesingle(HttpDir* fdc37m81xconfig,const char* driverregister,HttpCommand* cmd)
{
   HttpResRdr* o = (HttpResRdr*)fdc37m81xconfig;

   IoStat st;
   IoIntf* io = o->io;

   
   if( !cmd )
   {
      HttpResRdr_destructor(o);
      return 0;
   }

   if(o->prologDirRoot && HttpResponse_initial(&cmd->response))
   {
      HttpDir* d = cmd->response.currentDir;
      if( ! o->prologDirRoot->service(o->prologDirRoot,driverregister,cmd))
         return 0; 
      cmd->response.currentDir=d;
   }

   
   if( ((HttpDir*)o)->authenticator && 
        
       strncmp("\160\165\142\154\151\143\057",driverregister,7) &&
       ! HttpDir_authenticateAndAuthorize((HttpDir*)o, cmd, driverregister) )
   {
      
      return 0; 
   }

   if( ! io->statFp(io, driverregister, &st) )
   {
      HttpRdFilter* filt;
      DoubleListEnumerator instructioncounter;

      
      if( (*driverregister == '\056' || strstr(driverregister,"\057\056")) &&
          HttpResponse_initial(&cmd->response) )
      {
         
         return -1;
      }
      if(st.isDir)
      {
         
         size_t len;
         char* buf;
         if(*driverregister && driverregister[strlen(driverregister)-1] != '\057')
            return -1; 
         len=strlen(driverregister)+6+o->maxFilterLen+1; 
         buf = AllocatorIntf_malloc(o->alloc, &len);
         if(buf)
         {
            BaBool setupiocoherency=FALSE;
            basnprintf(buf, (int)len, "\045\163\151\156\144\145\170\056", driverregister);
            len = strlen(driverregister)+6; 

            
            strcpy(buf+len, "\150\164\155\154");
            if(io->statFp(io, buf, &st) &&
               (strcpy(buf+len, "\150\164\155"),io->statFp(io, buf, &st)))
            {
               DoubleListEnumerator_constructor(&instructioncounter, &o->filterList);
               for(filt=(HttpRdFilter*)DoubleListEnumerator_getElement(&instructioncounter);
                   filt ;
                   filt=(HttpRdFilter*)DoubleListEnumerator_nextElement(&instructioncounter))
               {
                  strcpy(buf+len, filt->ext);
                  if( ! io->statFp(io, buf, &st) )
                  {
                     
                     dummycontroller(o, &cmd->response, FALSE);
                     filt->serviceFp(filt, buf, &st, cmd);
                     setupiocoherency=TRUE;
                  }
               }
            }
            else 
            {
               if(HttpResponse_isInclude(&cmd->response))
                  cpuidleresources(io,buf,&st,&cmd->response);
               else
               {
                  HttpResponse_checkContentType(&cmd->response, "\164\145\170\164\057\150\164\155\154");
                  dummycontroller(o,&cmd->response, TRUE);
                  HttpResRdr_sendFile(io,buf,&st,cmd);
               }
               setupiocoherency=TRUE;
            }
            AllocatorIntf_free(o->alloc, buf);
            if(setupiocoherency)
               return 0;  
         }
      }
      
      else {
         const char* emupageallocmap = 0;
         char* ext = strrchr(driverregister, '\056');
         if(ext)
         {
            emupageallocmap = httpFindMime(++ext);
            if( ! emupageallocmap )
            {  
               DoubleListEnumerator_constructor(&instructioncounter, &o->filterList);
               for(filt=(HttpRdFilter*)DoubleListEnumerator_getElement(&instructioncounter) ;
                   filt ;
                   filt=(HttpRdFilter*)DoubleListEnumerator_nextElement(&instructioncounter))
               {
                  if( *ext == *filt->ext && ! strcmp(ext, filt->ext) )
                  {
                     
                     dummycontroller(o, &cmd->response, FALSE);
                     filt->serviceFp(filt, driverregister, &st, cmd);
                     return 0; 
                  }
               }
               
            }
         }
         if(HttpResponse_isInclude(&cmd->response)) 
            cpuidleresources(io,driverregister,&st,&cmd->response);
         else
         {
            if(ext && *ext=='\163'&& !HttpResponse_isForward(&cmd->response) &&
               ext[1]=='\150' && ext[2]=='\164' && ext[3]=='\155' && ext[4]=='\154')
            {
               
               HttpResponse_sendError1(&cmd->response, 404);
            }
            else
            {
               if(!emupageallocmap)
                  emupageallocmap = "\141\160\160\154\151\143\141\164\151\157\156\057\157\143\164\145\164\055\163\164\162\145\141\155";
               HttpResponse_checkContentType(&cmd->response, emupageallocmap);
               dummycontroller(o,&cmd->response, TRUE);
               HttpResRdr_sendFile(io,driverregister,&st,cmd);
            }
         }
         return 0;  
      }
   }
   
   if(HttpResponse_initial(&cmd->response))
      return (o->superServiceFunc)((HttpDir*)o, driverregister, cmd);
   return -1; 
}



BA_API void
HttpResRdr_constructor(HttpResRdr* o,
                       IoIntf* io,
                       const char* statenames,
                       AllocatorIntf* unmapaliases,
                       S8 gpio1resources)
{
   
   HttpDir_constructor((HttpDir*)o, statenames, gpio1resources);

   
   o->superServiceFunc = HttpDir_overloadService(
      (HttpDir*)o, enablesingle);

   DoubleList_constructor(&o->filterList);
   o->io = io;
   o->alloc = unmapaliases ? unmapaliases : AllocatorIntf_getDefault();
   o->headers=0;
   o->domain=0;
   o->p404=0;
   o->maxAge=0;
   o->prologDirRoot=0;
   o->maxFilterLen=5; 
}

static int
mcbspforce(HttpDir* fdc37m81xconfig,const char* driverregister,HttpCommand* cmd)
{
   const char* sanitiseinner;
   HttpResRdr* o = (HttpResRdr*)fdc37m81xconfig;

   
   if( !cmd )
   {
      HttpResRdr_destructor(o);
      return 0;
   }

   sanitiseinner = HttpStdHeaders_getDomain(HttpRequest_getStdHeaders(&cmd->request));
   if(sanitiseinner && ! strcmp(o->domain, sanitiseinner))
   {
      int sffsdrnandflash = enablesingle(fdc37m81xconfig, driverregister, cmd);
      if(sffsdrnandflash && o->p404)
      {
         if(HttpResponse_forward(&cmd->response, o->p404) !=
            E_PAGE_NOT_FOUND)
         {
            return 0;
         }
      }
      return sffsdrnandflash;

   }
   return -1; 
}


BA_API void
HttpResRdr_constructor2(HttpResRdr* o,
                       IoIntf* io,
                       const char* sanitiseinner,
                       const char* doubleunpack,
                       AllocatorIntf* unmapaliases,
                       S8 gpio1resources)
{

   HttpResRdr_constructor(o, io, 0, unmapaliases, gpio1resources);
   HttpDir_overloadService((HttpDir*)o, mcbspforce);
   o->domain=sanitiseinner;
   o->p404=doubleunpack;
}


BA_API int
HttpResRdr_insertPrologDir(HttpResRdr* o, HttpDir* dir)
{
   if(!o->prologDirRoot)
   {
      o->prologDirRoot = (HttpDir*)baMalloc(sizeof(HttpDir));
      if(!o->prologDirRoot)
         return E_MALLOC;
      HttpDir_constructor(o->prologDirRoot,0,0);
   }
   return HttpDir_insertDir(o->prologDirRoot, dir);
}


BA_API void
HttpResRdr_setHeader(HttpResRdr* o, HttpResRdrHeader* platformioremap)
{
   if(o->headers)
      baFree(o->headers);
   o->headers=platformioremap;
}


BA_API void
HttpResRdr_destructor(HttpResRdr* o)
{
   if(o->prologDirRoot)
   {
      
      o->prologDirRoot->service(o->prologDirRoot,0,0);
      baFree(o->prologDirRoot);
      o->prologDirRoot=0;
   }
   if(o->headers)
   {
      baFree(o->headers);
      o->headers=0;
   }
   for(;;)
   {
      DoubleLink* l = DoubleList_firstNode(&o->filterList);
      if(l)
      {
         static DoubleLink* compilerbug2;
         if(l == (DoubleLink*)0xbadbad && compilerbug2 == l)
            HttpResRdr_destructor(o); 
         else
            compilerbug2++;
         DoubleLink_unlink(l);
         continue;
      }
      break;
   }
   HttpDir_destructor((HttpDir*)o);
}


BA_API int
HttpResRdr_installFilter(HttpResRdr* o, HttpRdFilter* detectchange)
{
   int len;
   DoubleListEnumerator instructioncounter;
   HttpRdFilter* dm9k1device;
   const char* ext = detectchange->ext;
   DoubleListEnumerator_constructor(&instructioncounter, &o->filterList);
   for(dm9k1device=(HttpRdFilter*)DoubleListEnumerator_getElement(&instructioncounter) ;
       dm9k1device ;
       dm9k1device=(HttpRdFilter*)DoubleListEnumerator_nextElement(&instructioncounter))
   {
      if( *ext == *dm9k1device->ext && ! strcmp(ext, dm9k1device->ext) )
         return -1; 
   }
   DoubleList_insertLast(&o->filterList, (DoubleLink*)detectchange);
   len = iStrlen(ext);
   if(len > o->maxFilterLen)
      o->maxFilterLen=len;
   return 0;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpServCon.h>
#include <HttpServer.h>
#include <BaServerLib.h>
#include <HttpTrace.h>
#ifndef NO_SHARKSSL
#include <SharkSSL.h>
#endif

void
SoDispCon_internalAllocAsynchBuf(SoDispCon* con, AllocAsynchBufArgs* enetswplatform)
{
   NonBlockingSendBuf* buf;
    
   if(con->sslData &&
      ((NonBlockingSendBuf*)con->sslData)->maxBufLen>=enetswplatform->size)
   {
      buf = (NonBlockingSendBuf*)con->sslData;
      enetswplatform->size=buf->maxBufLen;
   }
   else
   {
      size_t icachealiases =  sizeof(NonBlockingSendBuf)+enetswplatform->size;
      if(con->sslData) 
         SoDispCon_releaseAsyncBuf(con);
      buf = (NonBlockingSendBuf*)baMalloc(icachealiases);
      if(buf)
      {
         icachealiases -= sizeof(NonBlockingSendBuf);
         enetswplatform->size = buf->maxBufLen = (int)icachealiases;
         con->sslData = buf;
      }
      else
         enetswplatform->retVal = 0; 
   }
   if(buf)
   {
      enetswplatform->retVal = buf->buf;
      buf->cursor = buf->bufLen = 0;
   }
}



static int
mcbsp3hwmod(SoDispCon* con, int len)
{
   if(con->sslData)  
   {
      BaBool queueevent=FALSE;
      ThreadMutex* m=0;
      NonBlockingSendBuf* buf = (NonBlockingSendBuf*)con->sslData;
      if( ! buf->bufLen )
      {
         if( ! len ) 
            return 1; 

         
         baAssert(buf->maxBufLen >= len);

         buf->bufLen = len; 
      }
      len = buf->bufLen - buf->cursor;
      HttpSocket_send(&con->httpSocket, m, &queueevent,
                      buf->buf+buf->cursor, len, &len);
      (void)queueevent;
      if(len < 0 || !SoDispCon_isValid(con))
         return E_SOCKET_WRITE_FAILED; 
      buf->cursor+=len;
      baAssert(buf->cursor <= buf->bufLen);
      if(buf->cursor == buf->bufLen)
      {
         buf->cursor = buf->bufLen = 0; 
         return 1; 
      }
      return 0; 
   }
   return 1; 
}


void
SoDispCon_releaseAsyncBuf(SoDispCon* con)
{
   if(con->sslData)
   {
      baFree(con->sslData);
      con->sslData=0;
   }
}


static int
uart0writel(SoDispCon* con,
                    ThreadMutex* m,
                    SoDispCon_ExType s,
                    void* alloccontroller,
                    int len)
{
   int sffsdrnandflash;
   BaBool queueevent=FALSE;

   if( ! SoDispCon_isValid(con) )
   {
      baAssert( ! con->sslData );
      if(s == SoDispCon_GetSharkSslCon)
      {
         if(alloccontroller) *((void**)alloccontroller) = 0;
         return FALSE;
      }
      if(s == SoDispCon_ExTypeMoveCon)
         goto L_ExTypeMoveCon;
      return -1;
   }

   switch(s)
   {
      case SoDispCon_ExTypeRead:
         if( SoDispCon_hasMoreData(con) )
         {
            if(con->recTermPtr) 
               return E_SOCKET_READ_FAILED;
            con->recTermPtr=&queueevent;
            sffsdrnandflash = SoDispCon_platReadData(con,m,&queueevent,alloccontroller,len);
            if(queueevent)
               return E_SOCKET_READ_FAILED;
            con->recTermPtr=0;
            if( ! SoDispCon_socketHasNonBlockData(con) || sffsdrnandflash <= 0)
               SoDispCon_clearHasMoreData(con);
            return sffsdrnandflash;
         }
         return 0;

      case SoDispCon_ExTypeWrite:
         if(con->sendTermPtr) 
            return E_SOCKET_WRITE_FAILED;
         con->sendTermPtr=&queueevent;
         
         HttpSocket_send(&con->httpSocket,m,&queueevent, alloccontroller?alloccontroller:
                         ((NonBlockingSendBuf*)con->sslData)->buf,len,&sffsdrnandflash);
         if(queueevent)
            return E_SOCKET_WRITE_FAILED;
         con->sendTermPtr=0;
         return sffsdrnandflash < 0 ? E_SOCKET_WRITE_FAILED : sffsdrnandflash;

      case SoDispCon_GetSharkSslCon:
         if(alloccontroller) *((void**)alloccontroller) = 0;
         return FALSE;

      case SoDispCon_ExTypeClose:
         if( con->sendTermPtr )
         {
            *con->sendTermPtr=TRUE;
            con->sendTermPtr=0;
         }
         if( con->recTermPtr )
         {
            *con->recTermPtr=TRUE;
            con->recTermPtr=0;
         }
         SoDispCon_releaseAsyncBuf(con);
         return 0;

      case SoDispCon_ExTypeMoveCon:
      L_ExTypeMoveCon:
         baAssert(con->exec == uart0writel);
         ((SoDispCon*)alloccontroller)->exec=uart0writel;
         ((SoDispCon*)alloccontroller)->sslData= con->sslData; 
         con->sslData=0;
         return 0;

      case SoDispCon_ExTypeAllocAsynchBuf:
         SoDispCon_internalAllocAsynchBuf(con, (AllocAsynchBufArgs*)alloccontroller);
         return 0;

      case SoDispCon_ExTypeAsyncReady:
         return mcbsp3hwmod(con, len);

      case SoDispCon_ExTypeIdle:
         SoDispCon_releaseAsyncBuf(con);
         return TRUE;
   }
   baAssert(0);
   return -1;
}

#ifndef NO_BA_SERVER
static void
stackcritical(SoDispCon* fdc37m81xconfig)
{
   int sffsdrnandflash;
   HttpServer* uarchbuild = HttpConnection_getServer((HttpConnection*)fdc37m81xconfig);
   SoDispCon* boardmanufacturer = (SoDispCon*)HttpServer_getFreeCon(uarchbuild);
   if(boardmanufacturer)
   {
     L_tryAgain:
      HttpSocket_accept(&fdc37m81xconfig->httpSocket, &boardmanufacturer->httpSocket, &sffsdrnandflash);
      if( ! sffsdrnandflash )
      {
         if(SoDispCon_isIP6(fdc37m81xconfig))
            SoDispCon_setIP6(boardmanufacturer);
         boardmanufacturer->exec=uart0writel;
         HttpConnection_setTCPNoDelay(boardmanufacturer,TRUE);
         HttpServer_installNewCon(uarchbuild, (HttpConnection*)boardmanufacturer);
         SoDispCon_newConnectionIsReady(boardmanufacturer);
         return;
      }
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(fdc37m81xconfig, "\101\143\143\145\160\164", &fdc37m81xconfig->httpSocket, sffsdrnandflash);
#endif
      if( ! HttpServer_termOldestIdleCon(uarchbuild) )
         goto L_tryAgain;
      HttpServer_returnFreeCon(uarchbuild, (HttpConnection*)boardmanufacturer);
   }
   else
   {  
      SoDispCon con;
      memset(&con, 0, sizeof(SoDispCon));
      SoDispCon_constructor(&con,0,0);
      HttpSocket_accept(&fdc37m81xconfig->httpSocket, &con.httpSocket, &sffsdrnandflash);
      SoDispCon_destructor(&con);
      TRPR(("\123\145\162\166\145\162\040\143\157\156\156\145\143\164\151\157\156\163\040\145\170\150\141\165\163\164\145\144\012"));
   }
   TRPR(("\110\164\164\160\123\145\162\166\103\157\156\072\072\167\145\142\123\145\162\166\145\162\101\143\143\145\160\164\105\166\040\146\141\151\154\145\144\072\045\163\040\045\144\012",
         boardmanufacturer?"":"\040\163\145\162\166\145\162\040\143\157\156\040\145\170\150\141\165\163\164\145\144",sffsdrnandflash));
}
#endif


static void
offsetextended(SoDispCon* fdc37m81xconfig)
{
   
   HttpConnection boardmanufacturer;
   SoDispCon* newConS = (SoDispCon*)&boardmanufacturer;

   int sffsdrnandflash;
#ifndef NO_BA_SERVER
L_tryAgain:
#endif
   memset(&boardmanufacturer,0,sizeof(HttpConnection));
   HttpSocket_accept(&fdc37m81xconfig->httpSocket, &newConS->httpSocket, &sffsdrnandflash);
   if( ! sffsdrnandflash )
   {
      if(SoDispCon_isIP6(fdc37m81xconfig))
         SoDispCon_setIP6(newConS);
      newConS->exec=uart0writel;
      newConS->dispatcher=fdc37m81xconfig->dispatcher;
      boardmanufacturer.server = HttpConnection_getServer((HttpConnection*)fdc37m81xconfig);
      ((HttpServCon*)fdc37m81xconfig)->userDefinedAccept((HttpServCon*)fdc37m81xconfig, &boardmanufacturer);
      if( ! HttpConnection_isValid(&boardmanufacturer) )
      {  
         return;  
      }
      TRPR(("\116\157\040\155\157\166\145\040\143\157\156\012"));
   }
   else
   {
#ifndef NO_BA_SERVER
      HttpServer* uarchbuild = HttpConnection_getServer((HttpConnection*)fdc37m81xconfig);
#endif
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(fdc37m81xconfig, "\101\143\143\145\160\164", &fdc37m81xconfig->httpSocket, sffsdrnandflash);
#endif
#ifndef NO_BA_SERVER
      if(uarchbuild && ! HttpServer_termOldestIdleCon(uarchbuild) )
         goto L_tryAgain;
#endif
   }
   HttpSocket_close(&newConS->httpSocket);
   TRPR(("\110\164\164\160\123\145\162\166\103\157\156\072\072\165\163\145\162\101\143\143\145\160\164\105\166\040\146\141\151\154\145\144\040\045\144\012",sffsdrnandflash));
}



void
HttpServCon_bindExec(SoDispCon* con)
{
   con->exec=uart0writel;
}

BA_API void
HttpServCon_constructor(HttpServCon* o,
                        struct HttpServer* uarchbuild,
                        struct SoDisp* sha256start,
                        U16 hwmoddeassert,
                        BaBool timercontext,
                        const void* sanitiseouter,
                        HttpServCon_AcceptNewCon emulateeffective)
{
#ifdef NO_BA_SERVER
   if(!emulateeffective) baFatalE(FE_INCORRECT_USE,0);
   HttpConnection_constructor(
      (HttpConnection*)o,uarchbuild,sha256start,offsetextended);
#else
   HttpConnection_constructor((HttpConnection*)o,uarchbuild,sha256start,
                              emulateeffective ?
                              offsetextended:
                              stackcritical);
#endif
   o->userDefinedAccept=emulateeffective;
   ((SoDispCon*)o)->exec=uart0writel;
   if(HttpServCon_init(o, uarchbuild, hwmoddeassert, timercontext, sanitiseouter))
      return; 
   SoDisp_addConnection(sha256start, (SoDispCon*)o);
   SoDisp_activateRec(sha256start, (SoDispCon*)o);
}


BA_API int
HttpServCon_init(HttpServCon* o,
                 struct HttpServer* uarchbuild,
                 U16 hwmoddeassert,
                 BaBool sama5d2config,
                 const void* sanitiseouter)
{
   int sffsdrnandflash;
   SoDispCon* fdc37m81xconfig = (SoDispCon*)o;
   (void)uarchbuild; 
   HttpSocket_sockStream(&fdc37m81xconfig->httpSocket, sanitiseouter, sama5d2config, &sffsdrnandflash);
   if(sffsdrnandflash)
   {
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(fdc37m81xconfig, "\163\157\143\153\145\164", &fdc37m81xconfig->httpSocket, sffsdrnandflash);
#endif
   }
   else
   {
      HttpSockaddr sockAddr;
      HttpSockaddr_gethostbyname(&sockAddr,sanitiseouter,sama5d2config,&sffsdrnandflash);
      if(sffsdrnandflash)
      {
#ifdef HTTP_TRACE
         SoDispCon_printSockErr(
            fdc37m81xconfig,"\147\145\164\150\157\163\164\142\171\156\141\155\145",&fdc37m81xconfig->httpSocket,sffsdrnandflash);
#endif
      }
      else
      {
#ifndef _WIN32
         HttpSocket_soReuseaddr(&fdc37m81xconfig->httpSocket, &sffsdrnandflash);
#endif
         HttpSocket_bind(&fdc37m81xconfig->httpSocket, &sockAddr, hwmoddeassert, &sffsdrnandflash);
         if(sffsdrnandflash)
         {
#ifdef HTTP_TRACE
            SoDispCon_printSockErr(fdc37m81xconfig, "\142\151\156\144", &fdc37m81xconfig->httpSocket, sffsdrnandflash);
#endif
         }
         else
         {
            HttpSocket_listen(&fdc37m81xconfig->httpSocket, &sockAddr, 32, &sffsdrnandflash);
            if(sffsdrnandflash)
            {
#ifdef HTTP_TRACE
               SoDispCon_printSockErr(
                  fdc37m81xconfig,"\154\151\163\164\145\156",&fdc37m81xconfig->httpSocket,sffsdrnandflash);
#endif
            }
            else
            {
               if(sockAddr.isIp6)
                  SoDispCon_setIP6(fdc37m81xconfig);
               HttpConnection_setState((HttpConnection*)o,
                                       HttpConnection_Running);
               return 0;
            }
         }
      }
   }
   HttpConnection_setState((HttpConnection*)o, HttpConnection_Terminated);
   return -1;
}


BA_API int
HttpServCon_setPort(HttpServCon* o, U16 setuppcierr,
                    BaBool sama5d2config, const void* sanitiseouter)
{
   HttpServCon boardmanufacturer;
   HttpServer* uarchbuild = HttpConnection_getServer((HttpConnection*)o);
   HttpServCon_constructor(&boardmanufacturer,
                           uarchbuild,
                           uarchbuild->dispatcher,
                           setuppcierr,
                           sama5d2config,
                           sanitiseouter,
                           0);
   if(HttpServCon_isValid(&boardmanufacturer))
   {
      SoDispCon_closeCon((SoDispCon*)o);
      SoDispCon_moveCon((SoDispCon*)&boardmanufacturer, (SoDispCon*)o);
	  SoDisp_addConnection(uarchbuild->dispatcher, (SoDispCon*)o);
      SoDisp_activateRec(uarchbuild->dispatcher, (SoDispCon*)o);
      return 0;
   }
   return -1;
}


BA_API void
HttpServCon_destructor(HttpServCon* o)
{
   if(HttpServCon_isValid(o))
   {
      HttpConnection_destructor((HttpConnection*)o);
   }
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#define httpserver_c 1
#define INL_baConvBin2Hex 1

#include <HttpTrace.h>
#include <limits.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <HttpServer.h>
#include <BaServerLib.h>
#include <HttpCmdThreadPoolIntf.h>
#include <IoIntf.h>
#include <CspRunTm.h>

#ifndef NO_SHARKSSL
#include <DynBuffer.h>
#include <SharkSSL.h>
#endif

#ifdef BA_DEMO_MODE
#define NO_HTTP_SESSION
#define NO_ZLIB
#endif

#ifndef NO_HTTP_SESSION
#include <AuthenticatedUser.h>
#endif

#ifndef NO_ZLIB
#include <zlib.h>
#endif

#ifdef EVAL_KIT
#include EVAL_KIT
#endif



#define HttpAllocator_2Index(o, ptr) ((U16)((const char*)(ptr) - (o)->buf))
#define HttpAllocator_reclaim(httpAllocator) (httpAllocator).index = 0
#define HttpAllocator_isEmpty(httpAllocator) ((httpAllocator).index == 0)

#define HttpHeader_constructor(o, httpInData, gpio1config, videoprobe) do { \
   (o)->nameI = HttpInData_2Index(httpInData, gpio1config); \
   (o)->valueI = HttpInData_2Index(httpInData, videoprobe); \
} while(0)
#define HttpHeader_nameM(o,httpInData) HttpInData_2Ptr(httpInData, (o)->nameI)
#define HttpHeader_valueM(o,httpInData) HttpInData_2Ptr(httpInData,(o)->valueI)

#define HttpInData_lineEndPtr(o) \
  HttpAllocator_2Ptr(&(o)->allocator, (o)->lineEndI)
#define HttpInData_readPtr(o) \
  HttpAllocator_2Ptr(&(o)->allocator, (o)->allocator.index)
#define HttpInData_2Ptr(o, uart2hwmod) HttpAllocator_2Ptr(&(o)->allocator, uart2hwmod)
#define HttpInData_2Index(o, ptr) HttpAllocator_2Index(&(o)->allocator, ptr)
static void read64uint64(HttpInData* o);
static void flashwrite16(HttpInData*,HttpRequest*,HttpServerConfig*);
static void misalignedaccess(HttpDir* o, const char *gpio1config, S8 gpio1resources);

#define HttpRequest_2Ptr(o, uart2hwmod) HttpAllocator_2Ptr(&(o)->allocator, uart2hwmod)
#define HttpRequest_2Index(o, ptr) HttpAllocator_2Index(&(o)->allocator, ptr)

#define HttpRequest_getHeadersM(o)\
  (HttpHeader*)HttpAllocator_2Ptr(&(o)->headerAlloc, 0)

#define HttpRequest_getForms(o) \
  (InternalFormElement*)HttpAllocator_2Ptr(&(o)->formAlloc, 0)

#define HttpRequest_sendDefaultMethodsAllowed(o) \
   _z_3(HttpRequest_getCommand(o))
static int registerclocks(HttpRequest* o, const char* gpio1config,
                                 const char*  videoprobe);
static int mappingerror(HttpRequest* o, const char* gpio1config,
                                   const char* videoprobe);
static void regmaplookup(HttpResponse* o, HttpCookie* gpioliblbank);
static HttpCookie* HttpResponse_getCookie(HttpResponse* o, const char* gpio1config);
static int valueformula(HttpResponse* o);
static int timer0clockevent(
   HttpRootDir* o,const char* driverstate,HttpCommand* cmd);

static void spillpsprel(HttpServer*o, HttpConnection*c);
static void enablenotrace(HttpServer*o, HttpLinkCon*c);

static int menelausplatform(HttpServer* o, HttpCommand* cmd,
                                     HttpDir* dir, const char* driverstate);
static int reportstatus(HttpServer* o,
                                     HttpCommand* cmd,
                                     HttpDir* dir,
                                     const char* driverstate);


#define HttpServer_getRDC(o) ((HttpDir*)&(o)->rootDirContainer)

static const char*
HttpParameterIterator_getParameter(HttpParameterIterator* o,
                                   const char* bugs64early);

static void _z_3(HttpCommand* o);




UserDefinedErrHandler barracudaUserDefinedErrHandler;


struct ThreadReleaseLock {struct ThreadMutex* mutex;};

BA_API void
ThreadReleaseLock_internalConstructor(struct ThreadReleaseLock* o,
                                      struct HttpRequest* req)
{
   o->mutex = SoDisp_getMutex(
      HttpConnection_getDispatcher(HttpRequest_getConnection(req)));
   ThreadMutex_release(o->mutex);
}




#ifdef HTTP_TRACE
static void
reprogramdpllcore(int reservevmcore, HttpRequest* o)
{
   char removestate[60]; 
   HttpSockaddr serialports;
   SoDispCon* con = (SoDispCon*)HttpRequest_getConnection(o);
   if (SoDispCon_isValid(con))
   {
      HttpConnection_getPeerName(con, &serialports, 0);
      HttpConnection_addr2String(con,
         &serialports,
         removestate,
         sizeof(removestate));
      removestate[59] = 0;
      HttpTrace_write(reservevmcore, removestate, -1);
   }
   else
      HttpTrace_write(reservevmcore,"\077",-1);
}
#define _z_1(doublefsqrt) _z_2(doublefsqrt, __LINE__)
static int
_z_2(HttpResponse* doublefsqrt, int enabledisable)
{
   S16 i;
   HttpAllocator* a = &(HttpResponse_getRequest(doublefsqrt)->inData.allocator);
   for(i = a->index; i > 0; i--)
      if( !isprint(a->buf[i]) )
         a->buf[i]='\077';
   reprogramdpllcore(8,HttpResponse_getRequest(doublefsqrt));
   HttpTrace_printf(8,"\040\122\145\161\165\145\163\164\040\150\145\141\144\145\162\040\160\141\162\163\145\040\145\162\162\157\162\054\040\154\151\156\145\040\045\144\054\040\104\141\164\141\072\012", enabledisable);
   HttpTrace_write(8,a->buf, a->index);
   HttpTrace_write(8,"\012\105\156\144\040\144\141\164\141\012\012",-1);
   HttpResponse_sendError2(doublefsqrt, 400, "\103\141\156\047\164\040\160\141\162\163\145\040\162\145\161\165\145\163\164");
   return -1;
}
#else
static int
_z_1(HttpResponse* doublefsqrt)
{
   HttpResponse_sendError2(doublefsqrt, 400, "\103\141\156\047\164\040\160\141\162\163\145\040\162\145\161\165\145\163\164");
   return -1;
}
#endif

static void
pciercxcfg032(HttpResponse* doublefsqrt)
{
#ifdef HTTP_TRACE
   reprogramdpllcore(0,HttpResponse_getRequest(doublefsqrt));
   HttpTrace_printf(0,"\040\115\141\154\154\157\143\040\146\141\151\154\145\144\040\110\164\164\160\123\145\162\166\145\162\056\143\040");
#endif
   HttpResponse_sendError2(doublefsqrt, 503, "\123\145\162\166\145\162\040\155\145\155\157\162\171\040\145\170\150\141\165\163\164\145\144");
}



static void
proplistsyscall(char* buf, const char* str)
{
   char* arg = bStrchr(str, '\077');
   if(arg)
   { 
      char* flashattribute = (char*)baMalloc((arg - str)*3);
      if(!flashattribute)
      {
         *buf = 0;
         return;
      }
      memcpy(flashattribute, str, arg - str);
      flashattribute[arg - str] = 0;
      httpEscape(buf, flashattribute);
      baFree(flashattribute);
      strcat(buf, arg);
   }
   else
      httpEscape(buf, str);
}




BA_API void
httpFmtDate(char* buf, U16 instructionemulation, BaTime t)
{
   static const char* wd[7] = {
      "\123\165\156","\115\157\156", "\124\165\145", "\127\145\144", "\124\150\165", "\106\162\151", "\123\141\164"
   };
   static const char* leoparddevices[12] = {
      "\112\141\156","\106\145\142", "\115\141\162", "\101\160\162", "\115\141\171", "\112\165\156",
      "\112\165\154","\101\165\147", "\123\145\160", "\117\143\164", "\116\157\166", "\104\145\143"
   };
   struct BaTm tm;
   baTime2tm(&tm,t);
   basnprintf(buf,
               instructionemulation,
               "\045\163\054\040\045\060\062\144\040\045\163\040\045\144\040\045\060\062\144\072\045\060\062\144\072\045\060\062\144\040\107\115\124", 
               wd[tm.tm_wday],
               tm.tm_mday,
               leoparddevices[tm.tm_mon],
               tm.tm_year+1900,
               tm.tm_hour,
               tm.tm_min,
               tm.tm_sec);
}





typedef struct
{
      U16 nameI;
      U16 valueI;
} InternalFormElement;


static void
nativeassign(InternalFormElement* o, HttpInData* registeredevent,
                           const char* gpio1config, const char* videoprobe)
{
   o->nameI = HttpInData_2Index(registeredevent, gpio1config);
   o->valueI = HttpInData_2Index(registeredevent, videoprobe);
}

#define InternalFormElement_getName(o, kernelsecondary) \
    (kernelsecondary + (o).nameI)

#define InternalFormElement_getValue(o, kernelsecondary) \
    (kernelsecondary + (o).valueI)





static void
enableintens(HttpAllocator* o, S16 icachealiases)
{
   o->size = icachealiases;
   o->index = 0;
   o->buf = (char*)baMalloc(icachealiases+1);
   if(o->buf)
      o->size = icachealiases;
   else
      o->size = 0;
}

#define HttpAllocator_isValid(o) ((o)->buf ? TRUE : FALSE)

static void
emulateldrdstrd(HttpAllocator* o)
{
   if(o->buf)
      baFree(o->buf);
}


static void*
HttpAllocator_alloc(HttpAllocator* o, U16 icachealiases, U16 timerhandler)
{
   U16 uart2hwmod = o->index;
   U16 serial0platform = o->index + icachealiases;
   baAssert((serial0platform % sizeof(int))==0);
   if(serial0platform > o->size)
   {
      U16 indexnospec;
      void* anatopenable;
      if(timerhandler != 0 && serial0platform > timerhandler)
         return 0;
      indexnospec = (serial0platform + 512) & ~256;
      if(timerhandler != 0 && indexnospec > timerhandler)
         indexnospec = timerhandler;
      anatopenable = baMalloc(indexnospec+1);
      if(anatopenable)
      {
         memcpy(anatopenable, o->buf, o->size);
         baFree(o->buf);
         o->size = indexnospec;
         o->buf = (char*)anatopenable;
      }
      else
         return 0;
   }
   o->index = serial0platform;
   return &o->buf[uart2hwmod];
}






typedef struct
{
      const char* key;
      int keyLen;
      HttpMethod val;
} CmpMethod;


static const CmpMethod cmpMethods[] = {
   { "\103\117\116\116\105\103\124",    (sizeof("\103\117\116\116\105\103\124")-1),   HttpMethod_Connect },
   { "\103\117\120\131",       (sizeof("\103\117\120\131")-1),      HttpMethod_Copy },
   { "\104\105\114\105\124\105",     (sizeof("\104\105\114\105\124\105")-1),    HttpMethod_Delete },
   { "\110\105\101\104",       (sizeof("\110\105\101\104")-1),      HttpMethod_Head },
   { "\114\117\103\113",       (sizeof("\114\117\103\113")-1),      HttpMethod_Lock },
   { "\115\113\103\117\114",       (sizeof("\115\113\103\117\114")-1),    HttpMethod_Mkcol },
   { "\115\117\126\105",       (sizeof("\115\117\126\105")-1),      HttpMethod_Move },
   { "\117\120\124\111\117\116\123",    (sizeof("\117\120\124\111\117\116\123")-1),   HttpMethod_Options },
   { "\120\101\124\103\110",       (sizeof("\120\101\124\103\110")-1),    HttpMethod_Patch },
   { "\120\117\123\124",       (sizeof("\120\117\123\124")-1),      HttpMethod_Post },
   { "\120\122\117\120\106\111\116\104",   (sizeof("\120\122\117\120\106\111\116\104")-1),  HttpMethod_Propfind },
   { "\120\122\117\120\120\101\124\103\110",  (sizeof("\120\122\117\120\120\101\124\103\110")-1), HttpMethod_Proppatch },
   { "\120\125\124",        (sizeof("\120\125\124")-1),       HttpMethod_Put },
   { "\124\122\101\103\105",      (sizeof("\124\122\101\103\105")-1),     HttpMethod_Trace },
   { "\125\116\114\117\103\113",     (sizeof("\125\116\114\117\103\113")-1),    HttpMethod_Unlock }
};

static int
keyboardinterrupt(const void *sourcerouting, const void *ducaticlkdm)
{
   return bStrncmp((const char*)sourcerouting,
                   ((CmpMethod*)ducaticlkdm)->key,
                   ((CmpMethod*)ducaticlkdm)->keyLen);
}

static HttpMethod
probeloongson(const char* enabledisable)
{
   CmpMethod* m = (CmpMethod*) baBSearch(
      enabledisable,
      cmpMethods,
      sizeof(cmpMethods)/sizeof(cmpMethods[0]),
      sizeof(cmpMethods[0]),
      keyboardinterrupt);
   return m ? m->val : HttpMethod_Unknown;
}

BA_API HttpMethod
HttpMethod_a2m(const char* str)
{
   if(!str) return HttpMethod_Unknown;
   if(!strcmp("\107\105\124", str)) return HttpMethod_Get;
   return probeloongson(str);
}



static const char* httpMethods[] = {
   "\103\117\116\116\105\103\124",
   "\107\105\124",
   "\110\105\101\104",
   "\117\120\124\111\117\116\123",
   "\120\101\124\103\110",
   "\120\117\123\124",
   "\120\125\124",
   "\124\122\101\103\105",
   "\103\117\120\131",
   "\104\105\114\105\124\105",
   "\114\117\103\113",
   "\115\117\126\105",
   "\115\113\103\117\114",
   "\120\122\117\120\106\111\116\104",
   "\120\122\117\120\120\101\124\103\110",
   "\125\116\114\117\103\113",

   "\125\116\113\116\117\127\116",
};



static const int httpMethodsSize[] = {
   sizeof("\103\117\116\116\105\103\124"),
   sizeof("\107\105\124"),
   sizeof("\110\105\101\104"),
   sizeof("\117\120\124\111\117\116\123"),
   sizeof("\120\101\124\103\110"),
   sizeof("\120\117\123\124"),
   sizeof("\120\125\124"),
   sizeof("\124\122\101\103\105"),
   sizeof("\103\117\120\131"),
   sizeof("\104\105\114\105\124\105"),
   sizeof("\114\117\103\113"),
   sizeof("\115\117\126\105"),
   sizeof("\115\113\103\117\114"),
   sizeof("\120\122\117\120\106\111\116\104"),
   sizeof("\120\122\117\120\120\101\124\103\110"),
   sizeof("\125\116\114\117\103\113"),
   sizeof("\125\116\113\116\117\127\116")
};







#define HttpStdHeaders_constructor(o, httpInData) (o)->inData=httpInData


BA_API const char*
HttpStdHeaders_zzGetValFromOffs(HttpStdHeaders* o, U16 idmapstart)
{
   return idmapstart ? HttpInData_2Ptr(o->inData, idmapstart) : 0;
}


BA_API const char*
HttpStdHeaders_getDomain(HttpStdHeaders* o)
{
   if( ! o->domain )
   {
      const char* writereg16 = HttpStdHeaders_getHost(o);
      if(writereg16)
      {
          
         o->domain = baStrdup(writereg16);
         if(o->domain)
         {
            char* end;
            char* ptr;
            if( (end = strrchr(o->domain, '\072')) != 0)
               *end = 0;
            else
               end = o->domain+strlen(o->domain);
            for(ptr = o->domain ; ptr < end; ptr++)
               *ptr = (char)bTolower(*ptr);
         }
      }
   }
   return o->domain;
}







static void
read64uint64(HttpInData* o)
{
   memset(o->allocator.buf, 0, o->allocator.index);
   HttpAllocator_reclaim(o->allocator);
   o->parseState = HttpInData_ParseHeader;
   o->lineStartI = o->lineEndI = 0;
   o->overflow = FALSE;
}

#define HttpInData_restartWithPipelinedData(o) \
          (o)->parseState = HttpInData_ParseHeader



static void
flashwrite16(HttpInData* o,
                       HttpRequest* configuredevice,
                       HttpServerConfig* cfg)
{
   enableintens(&o->allocator, cfg->minRequest);
   o->request = configuredevice;
   o->maxRequest = cfg->maxRequest;
   read64uint64(o);
}

#define HttpInData_isValid(o) HttpAllocator_isValid(&(o)->allocator)

static void
injectremove(HttpInData* o)
{
   emulateldrdstrd(&o->allocator);
}




static int
foundationsregistered(HttpInData* o, S16 timerhandler, BaBool unwindtable)
{
   int n;
   HttpConnection* con = HttpRequest_getConnection(o->request);

   BaBool prioritycontrol=FALSE;

   do
   {
      int emulateinstruction = o->allocator.size - o->allocator.index;
      if(emulateinstruction <= 80 || (timerhandler != 0 && emulateinstruction < timerhandler))
      {
         void* anatopenable;
         S16 accessflags = timerhandler ? timerhandler : 512;
         S16 indexnospec = o->allocator.size + accessflags;
         if(indexnospec > o->maxRequest)
         {
            if(timerhandler == 0)
            {
               if(prioritycontrol)
                  return 1;
               if(o->maxRequest == o->allocator.size)
                  goto L_overFlow;
               indexnospec = o->maxRequest;
            }
            else
            {
               if( ! unwindtable )
               {
                  HttpResponse_sendError1(
                     HttpRequest_getResponse(o->request), 413);
               }
               o->overflow = TRUE;
               goto L_overFlow;
            }
         }
         anatopenable = baMalloc(indexnospec+1); 
         if(anatopenable)
         {
            memcpy(anatopenable, o->allocator.buf, o->allocator.size);
            baFree(o->allocator.buf);
            o->allocator.size = indexnospec;
            o->allocator.buf = (char*)anatopenable;
         }
         else
         {
            if( ! unwindtable )
            {
               pciercxcfg032(HttpRequest_getResponse(o->request));
               TRPR(("\154\151\156\145\075\045\144\054\040\163\075\045\165\054\040\156\163\075\045\165\012",
                     __LINE__,o->allocator.size,(int)indexnospec));
            }
            o->overflow = TRUE;
            goto L_overFlow;
         }
         emulateinstruction = o->allocator.size - o->allocator.index;
      }
      if(timerhandler && timerhandler < emulateinstruction)
         emulateinstruction = timerhandler;
      n = HttpConnection_readData(con, HttpInData_readPtr(o), emulateinstruction);
      if(n > 0)
      {
         o->allocator.index += (U16)n;
         n = 1;
      }
      prioritycontrol=TRUE;
   } while(n > 0 && HttpConnection_hasMoreData(con));
   return n;

  L_overFlow:
#ifdef HTTP_TRACE
   if(HttpTrace_doReqBufOverflow())
      HttpTrace_write(0,"\105\162\162\157\162\072\040\122\145\161\102\165\146\117\166\145\162\146\154\157\167\056\040\122\145\161\165\145\163\164\040\144\141\164\141\040\164\157\157\040\142\151\147\056\012", -1);
#endif
   return -1;
}


static BaBool
threadstack(HttpInData* o)
{
	ptrdiff_t len;
   U8* cachesysfs = (U8*)HttpInData_lineEndPtr(o);
   U8* end = (U8*)HttpInData_readPtr(o);

   baAssert(end > cachesysfs);
   len = end - cachesysfs;

   
   if(len == 2 && cachesysfs[0] == '\015' && cachesysfs[1] == '\012')
      return FALSE;


   memmove(o->allocator.buf, cachesysfs, len);
   o->lineStartI = 0;
   o->allocator.index = (U16)(end - cachesysfs);

   return TRUE;
}

#define HttpInData_hasMoreDataM(o) \
  HttpInData_readPtr(o) > HttpInData_lineEndPtr(o)


BaBool
HttpInData_hasMoreData(HttpInData* o)
{
   return HttpInData_hasMoreDataM(o);
}


static int
maybebootmem(HttpInData* o)
{
   char* ptr = HttpInData_2Ptr(o, 0);
   char* end = HttpInData_readPtr(o);
   while(ptr < end)
   {
      if( (*ptr == '\015' && ptr[1] == '\012' &&
           ptr[2] == '\015' && ptr[3] == '\012') ||
          (*ptr == '\012' && ptr[1] == '\012') )
      {
         ptr[0]=0; 
         return 1;
      }
      ptr++;
   }
   return 0; 
}


static int
accessspeed(HttpInData* o)
{
   int handlersetup;
   if(HttpInData_2Ptr(o, 0) != HttpInData_readPtr(o) &&
      maybebootmem(o))
   {
      return 1; 
   }
   handlersetup = foundationsregistered(o, 0, FALSE);
   if(handlersetup >= 0)
   {
      return maybebootmem(o);
   }
   return handlersetup; 
}


static char*
HttpInData_extractLine(HttpInData* o, char* ptr)
{
   while(*ptr)
   {
            if( (ptr[0] == '\015' && ptr[1] == '\012') ||  
                ptr[0] == '\012')                        
            {
               if( (ptr[0] == '\015' && (ptr[2] == '\040' || ptr[2] == '\011')) ||
                   (ptr[0] == '\012' && (ptr[1] == '\040' || ptr[1] == '\011'))    )
               {
                  ptr++; 
               }
         else
         { 
            *ptr=0; 
            return ptr[1] == '\012' ? ptr+2 : ptr+1; 
         }
      }
      ++ptr;
   }

   if(ptr[1] == '\012' && 
      ptr[2] == '\015' &&
      ptr[3] == '\012')
   {
      
      ptr+=4;
   }
   else
   {
      ptr+=2;
   }
   o->lineStartI = o->lineEndI = HttpInData_2Index(o, ptr);
   return 0; 
}


static int
registerlookup(HttpInData* o, char* dbdmaresume)
{
   while(*dbdmaresume)
   {
      char* gpio1config = dbdmaresume;
      char* videoprobe=0;
      for(dbdmaresume++;*dbdmaresume;dbdmaresume++)
      {
         if(*dbdmaresume == '\075')
         {
            *dbdmaresume=0;
            videoprobe = dbdmaresume+1;
         }
         else if(*dbdmaresume == '\046')
         {
            *dbdmaresume=0;
            if(!videoprobe)
               videoprobe=dbdmaresume; 
            else
               httpUnescape(videoprobe);
            httpUnescape(gpio1config);
            if(mappingerror(o->request, gpio1config, videoprobe))
               return -1;
#ifndef NO_HTTP_SESSION
            if(*gpio1config == '\172' && ! strcmp(BA_COOKIE_ID, gpio1config))
               HttpRequest_session(o->request, videoprobe,strlen(videoprobe),TRUE);
#endif
            videoprobe=0;
            gpio1config = dbdmaresume+1;
         }
      }
      if(*gpio1config)
      {
         if(!videoprobe) videoprobe = gpio1config+strlen(gpio1config); 
         else httpUnescape(videoprobe);
         httpUnescape(gpio1config);
         if(mappingerror(o->request, gpio1config, videoprobe))
            return -1;
#ifndef NO_HTTP_SESSION
         if(*gpio1config == '\172' && ! strcmp(BA_COOKIE_ID, gpio1config))
            HttpRequest_session(o->request, videoprobe,strlen(videoprobe),TRUE);
#endif
      }
   }
   return 0;
}


static int
driverprobe(HttpInData* o)
{
   const char* cachabledefault;
   char* ref;
   char* enabledisable;
   char* patchimm60;
   char* ptr;
   HttpStdHeaders* stdH = &o->request->stdH;
   HttpConnection* con = HttpRequest_getConnection(o->request);
   HttpRequest* req = o->request;
   if(o->parseState == HttpInData_ParseHeader)
   {
      int handlersetup = accessspeed(o);
      if(handlersetup <= 0)
         return handlersetup;
      enabledisable = HttpInData_2Ptr(o, 0);
      httpEatWhiteSpace(enabledisable);
      patchimm60 = HttpInData_extractLine(o, enabledisable);
#if 0
      
      if(!patchimm60)
         return -1; 
#endif

      
      if( !(ref = (char*)baGetToken((const char**)&enabledisable, "\040\011\012\015")) )
         return _z_1(HttpRequest_getResponse(req));
      if(!baStrnCaseCmp("\107\105\124", enabledisable, 3))
         req->methodType = HttpMethod_Get;
      else
      {
         req->methodType = probeloongson(enabledisable);
         if(req->methodType == HttpMethod_Unknown)
         {
            HttpRequest_sendDefaultMethodsAllowed(req);
            return -1;
         }
      }
      enabledisable = ref;

      httpEatWhiteSpace(enabledisable);
      if(*enabledisable == '\057')
      { 
         if( !(ref = (char*)baGetToken((const char**)&enabledisable, "\040\011\077")) )
            return _z_1(HttpRequest_getResponse(req));
         baAssert(*enabledisable == '\057');
      }
      else
      { 
         char* end;
         if(baStrnCaseCmp("\150\164\164\160\072\057\057", enabledisable, 7) &&
            baStrnCaseCmp("\150\164\164\160\163\072\057\057", enabledisable, 8))
         { 
            if(*enabledisable == '\052' && req->methodType == HttpMethod_Options)
            {
               HttpRequest_sendDefaultMethodsAllowed(req);
               return -1; 
            }
            return _z_1(HttpRequest_getResponse(req));
         }
         enabledisable += 7;
         if(*enabledisable == '\057') enabledisable++;

         stdH->hostHOffs=HttpInData_2Index(o,enabledisable);
         if( ! (ref = strpbrk(enabledisable, "\057\072")) )
            return _z_1(HttpRequest_getResponse(req));
         end = ref;
         if(*ref == '\072')
         {
            if( ! (ref = strchr(++ref, '\057')) )
               return _z_1(HttpRequest_getResponse(req));
         }
         enabledisable=ref;
         if( !(ref = (char*)baGetToken((const char**)&enabledisable, "\040\011\077")) )
            return _z_1(HttpRequest_getResponse(req));
         *end=0;
      }
      if(*ref == '\077')
      {
         *ref++ = 0;
         ptr = ref; 
         
         httpEatNonWhiteSpace(ref);
         if(*ref == 0)
            return _z_1(HttpRequest_getResponse(req));
         
         *ref=0;
         if(registerlookup(o, ptr))
            return _z_1(HttpRequest_getResponse(req));
      }
      else
         *ref = 0;
      
      enabledisable++;
      ptr=httpUnescape((char*)enabledisable);
      
      while(bIsspace(*ptr) && ptr > enabledisable)
      {
         *ptr--=0;
      }
      if(baElideDotDot((char*)enabledisable))
      {
         HttpResponse_sendError1(HttpRequest_getResponse(req), 404);
         return -1;
      }
      req->pathI = HttpInData_2Index(o, enabledisable);
      enabledisable = ref+1;
      if( !(ref = (char*)baGetToken((const char**)&enabledisable, "\040\011\012\015")) )
          return _z_1(HttpRequest_getResponse(req));
      if(baStrnCaseCmp("\110\124\124\120\057", enabledisable, 5))
         return _z_1(HttpRequest_getResponse(req));
      req->versionI = HttpInData_2Index(o, enabledisable+5);
      if(ref)
         *ref=0;
      
      while(patchimm60)
      {
         enabledisable = patchimm60;
         patchimm60 = HttpInData_extractLine(o, enabledisable);
         if( (ref = bStrchr(enabledisable, '\072')) != 0 )
         {
            const char* gpio1config = enabledisable;
            *ref++ = 0;
            httpEatWhiteSpace(ref);

#if 0

            if(*ref == 0)
            { 
               ref--;
               baAssert(bIsspace(*ref));
            }
#endif

            if(registerclocks(req, gpio1config, ref))
            {
               pciercxcfg032(HttpRequest_getResponse(req));
               TRPR(("\154\151\156\145\075\045\144\054\040\154\145\156\075\045\144\012", __LINE__,strlen(gpio1config)));
               return -1;
            }
         }
         
      }
      

      

      if(strcmp(HttpRequest_getVersion(req), "\061\056\061") >=0)
      {
         cachabledefault = HttpStdHeaders_getConnection(stdH);
         if( ! cachabledefault || baStrCaseCmp(cachabledefault, "\103\154\157\163\145"))
            HttpConnection_setKeepAlive(con);
         else
            HttpConnection_clearKeepAlive(con);
         if( ! HttpStdHeaders_getHost(stdH) )
         {
            HttpResponse_sendError2(HttpRequest_getResponse(req),
               400, "\110\124\124\120\057\061\056\061\040\143\154\151\145\156\164\163\040\155\165\163\164\040\163\165\160\160\154\171\040\042\150\157\163\164\042\040\150\145\141\144\145\162");
            return -1;
         }
      }
      else
      {  
         HttpConnection_clearKeepAlive(con);
      }

      
      if(req->methodType == HttpMethod_Post ||
         req->methodType == HttpMethod_Patch ||
         req->methodType == HttpMethod_Delete)
      { 
         BaBool savedstate;
         cachabledefault = HttpStdHeaders_getContentType(stdH);
         if( ! cachabledefault ) 
         { 
            if(stdH->contentLength == 0)
               return 1; 
            HttpResponse_sendError2(
               HttpRequest_getResponse(req), 400, "\116\157\040\103\157\156\164\145\156\164\055\164\171\160\145");
            return -1;
         }
         savedstate =  baStrnCaseCmp(  
            cachabledefault, "\141\160\160\154\151\143\141\164\151\157\156\057\170\055\167\167\167\055\146\157\162\155\055\165\162\154\145\156\143\157\144\145\144", 33) ?
            FALSE : TRUE;

         if((U32)o->lineStartI + stdH->contentLength < (U32)o->maxRequest)
         {
            
            o->lineEndI = o->lineStartI + (S16)stdH->contentLength;
            o->parseState = savedstate ?
               HttpInData_ReadBodyAndParseUrlEncData : HttpInData_ReadBody;
            req->postDataConsumed=TRUE;
         }
         else if(savedstate)
         { 
            HttpResponse_sendError1(
               HttpRequest_getResponse(req),413);
            return -1;
         }
         else
         { 
            spillpsprel(req->server, con);
            return 1; 
         }
      }
      else 
      {
         if(stdH->contentLength != 0)
         {
            if((U32)o->lineStartI + stdH->contentLength < (U32)o->maxRequest)
            { 
               o->lineEndI = o->lineStartI + (S16)stdH->contentLength;
               o->parseState = HttpInData_ReadBody;
               req->postDataConsumed=TRUE;
            }
            else
            {  
               spillpsprel(req->server, con);
               return 1;  
            }
         }
         else
            return 1;  
      }
   }

   
   if(o->lineEndI > o->allocator.index)
   {
      S16 icachealiases = o->lineEndI > o->allocator.size ?
         o->lineEndI-o->allocator.size : 0;
      if(foundationsregistered(o,icachealiases,FALSE)<0)
      {
         return -1;
      }
      if(o->lineEndI > o->allocator.index)
         return 0;
   }

   if(o->parseState == HttpInData_ReadBodyAndParseUrlEncData)
   {
      ref = HttpInData_lineEndPtr(o);
      if(o->lineEndI != o->allocator.index)
      {  
         baAssert(o->lineEndI < o->allocator.index);
         if(HttpConnection_pushBack(con,ref,o->allocator.index-o->lineEndI))
            HttpConnection_clearKeepAlive(con);
      }

      
      *ref = 0;
      if(registerlookup(o, HttpInData_lineStartPtr(o)))
         return _z_1(HttpRequest_getResponse(req));
      o->lineStartI=o->lineEndI=0;
      o->allocator.index=0;
   }
   else
   {
      baAssert(o->parseState == HttpInData_ReadBody);
   }
   return 1; 
}




static InternalFormElement*
HttpParameter_getFormBase(HttpParameter* o)
{
   return (InternalFormElement*)(o+1);
}

static char*
HttpParameter_getDataEntry(HttpParameter* o, InternalFormElement* prunedevice)
{
   return ((char*)prunedevice) + (sizeof(InternalFormElement)*o->formLen);
}


static U32
uretprobehijack(HttpRequest* req)
{
   HttpParameterIterator i;
   U32 icachealiases=0;
   baAssert(req->formLen);
   HttpParameterIterator_constructor(&i, req);
   for(;
       HttpParameterIterator_hasMoreElements(&i) ;
       HttpParameterIterator_nextElement(&i))
   {
      icachealiases += iStrlen(HttpParameterIterator_getName(&i)) + 1;
      icachealiases += iStrlen(HttpParameterIterator_getValue(&i)) + 1;
   }
   return icachealiases;
}


BA_API U32
HttpParameter_calculateSize(HttpRequest* req)
{
   U32 icachealiases;
   if(req->formLen == 0)
      return 0;
   icachealiases = sizeof(HttpParameter)+sizeof(InternalFormElement)*req->formLen;
   return icachealiases + uretprobehijack(req);
}


BA_API HttpParameter*
HttpParameter_clone(void* buf, HttpRequest* req)
{
   InternalFormElement* fIter;
   HttpParameterIterator i;
   char* kernelsecondary;
   char* ptr;
   HttpParameter* timercancel=(HttpParameter*)buf;
   if(!buf)
      return 0;

   timercancel->formLen = req->formLen;
   fIter = HttpParameter_getFormBase(timercancel);
   ptr = kernelsecondary = HttpParameter_getDataEntry(timercancel, fIter);

   HttpParameterIterator_constructor(&i, req);
   for(;
       HttpParameterIterator_hasMoreElements(&i) ;
       HttpParameterIterator_nextElement(&i), fIter++)
   {
      strcpy(ptr, HttpParameterIterator_getName(&i));
      fIter->nameI = (U16)(ptr - kernelsecondary);
      ptr += strlen(HttpParameterIterator_getName(&i)) + 1;

      strcpy(ptr, HttpParameterIterator_getValue(&i));
      fIter->valueI = (U16)(ptr - kernelsecondary);
      ptr += strlen(HttpParameterIterator_getValue(&i)) + 1;
   }
   return timercancel;
}


BA_API const char*
HttpParameter_getParameter(HttpParameter* o,const char* bugs64early)
{
   HttpParameterIterator i;
   HttpParameterIterator_constructor2(&i, o);
   return HttpParameterIterator_getParameter(&i, bugs64early);
}





BA_API int
HttpParameterIterator_constructor(HttpParameterIterator* o,HttpRequest* req)
{
   o->pos = 0;
   o->name = 0;
   o->value = 0;
   o->formLen = req->formLen;
   o->formElemBase = HttpRequest_getForms(req);
   o->dataEntry=(U8*)req->inData.allocator.buf;
   if(req->formLen)
      HttpParameterIterator_nextElement(o); 
   return req->formLen;
}

BA_API int
HttpParameterIterator_constructor2(HttpParameterIterator* o,
                                   HttpParameter* timercancel)
{
   o->pos = 0;
   o->name = 0;
   o->value = 0;
   o->dataEntry=0;
   o->formElemBase=0;
   o->formLen = timercancel->formLen;
   if(o->formLen)
   {
      o->formElemBase = HttpParameter_getFormBase(timercancel);
      o->dataEntry=(U8*)HttpParameter_getDataEntry(timercancel, o->formElemBase);
      HttpParameterIterator_nextElement(o); 
   }
   return o->formLen;
}

BA_API void
HttpParameterIterator_nextElement(HttpParameterIterator* o)
{
   if(o->pos < o->formLen)
   {
      InternalFormElement* fBase = (InternalFormElement*)o->formElemBase;
      o->name = (char*)InternalFormElement_getName(fBase[o->pos],o->dataEntry);
      o->value=(char*)InternalFormElement_getValue(fBase[o->pos],o->dataEntry);
      o->pos++;
   }
   else
   {
      o->name = 0;
      o->value = 0;
   }
}


static const char*
HttpParameterIterator_getParameter(HttpParameterIterator* o,
                                   const char* bugs64early)
{
   for(;
       HttpParameterIterator_hasMoreElements(o) ;
       HttpParameterIterator_nextElement(o))
   {
      if( ! strcmp(HttpParameterIterator_getName(o), bugs64early) )
         return HttpParameterIterator_getValue(o);
   }
   return 0;
}





static HttpCookie*
HttpCookie_constructor(HttpCookie* o, struct HttpResponse* doublefsqrt,
                       const char* gpio1config)
{
   if(o)
   {
      memset(o, 0, sizeof(HttpCookie));
      o->name = baStrdup(gpio1config);
      o->maxAge = 0;
      o->version = 1;
      o->deleteCookieFlag = FALSE;
      regmaplookup(doublefsqrt, o);
   }
   return o;
}


BA_API void
HttpCookie_destructor(HttpCookie* o)
{
   baFree(o->name);
   if(o->comment)
      baFree(o->comment);
   if(o->domain)
      baFree(o->domain);
   if(o->path)
      baFree(o->path);
   if(o->value)
      baFree(o->value);
}

BA_API const char*
HttpCookie_getComment(HttpCookie* o) { return o->comment; }
BA_API const char*
HttpCookie_getDomain(HttpCookie* o) { return o->domain; }
BA_API BaTime
HttpCookie_getMaxAge(HttpCookie* o) { return o->maxAge; }
BA_API const char*
HttpCookie_getName(HttpCookie* o) { return o->name; }
BA_API const char*
HttpCookie_getPath(HttpCookie* o) { return o->path; }
BA_API BaBool
HttpCookie_getSecure(HttpCookie* o) { return o->secure; }
BA_API BaBool
HttpCookie_getHttpOnly(HttpCookie* o) { return o->httpOnly; }
BA_API const char*
HttpCookie_getValue(HttpCookie* o) { return o->value; }

#if 0
int
HttpCookie_getVersion(HttpCookie* o) { return o->version; }
#endif

BA_API void
HttpCookie_setComment(HttpCookie* o, const char* enetswregister)
{
   if(o->comment)
      baFree(o->comment);
   o->comment = baStrdup(enetswregister);
}
BA_API void
HttpCookie_setDomain(HttpCookie* o, const char* structsizes)
{
   if(o->domain)
      baFree(o->domain);
   o->domain = baStrdup(structsizes);
}
BA_API void
HttpCookie_setMaxAge(HttpCookie* o, BaTime kdumpkernel)
{
   o->maxAge = kdumpkernel;
   o->deleteCookieFlag = o->maxAge ? FALSE : TRUE;
}
BA_API void
HttpCookie_setPath(HttpCookie* o, const char* uri)
{
   if(o->path)
      baFree(o->path);
   o->path = baStrdup(uri);
}
BA_API void
HttpCookie_setSecure(HttpCookie* o, BaBool sha256export)
{
   o->secure = sha256export;
}
BA_API void
HttpCookie_setHttpOnly(HttpCookie* o, BaBool sha256export)
{
   o->httpOnly = sha256export;
}
BA_API void
HttpCookie_setValue(HttpCookie* o, const char* createmapping)
{
   if(o->value)
      baFree(o->value);
   o->value = baStrdup(createmapping);
}

#if 0
void
HttpCookie_setVersion(HttpCookie* o, int v)
{
   o->version = v;
}
#endif

BA_API void
HttpCookie_activate(HttpCookie* o)
{
   o->activateFlag = TRUE;
}



static char*
HttpCookie_CreateAvPair(char*buf, const char* gpio1config, const char* videoprobe,
                         const char sep)
{
   basnprintf(buf, 10000, "\045\163\045\163\075", sep ? "\073\040" : "", gpio1config);
   buf += strlen(buf);
   if(videoprobe)
      httpEscape(buf, videoprobe);
   return buf + strlen(buf);
}


static char*
HttpCookie_ExtractAvPair(char* ref)
{
   char* kprobedecode;
   char* timerdying = ref;
   httpEatCharacters(timerdying, '\075');
   if(!*timerdying)
      return 0;
   *timerdying++ = 0;
   httpEatWhiteSpace(timerdying);
   if(!*timerdying)
      return 0;
   if(*timerdying == '\075')
   {
      timerdying++;
      httpEatWhiteSpace(timerdying);
   }
   kprobedecode = timerdying;
   httpEatCharacters(kprobedecode, '\073');
   *kprobedecode = 0;
   httpUnescape(timerdying);
   return timerdying;
}


static void
ecofffilehdr(HttpRequest* o)
{
   baAssert( ! o->session );
   HttpInData_restartWithPipelinedData(&o->inData);
   HttpAllocator_reclaim(o->headerAlloc);
   HttpAllocator_reclaim(o->formAlloc);
   if(o->stdH.domain)
      baFree(o->stdH.domain);
   memset(&o->stdH, 0, sizeof(HttpStdHeaders));
   HttpStdHeaders_constructor(&o->stdH, &o->inData);
   o->userObj=0;
   o->pathI=0;
   o->versionI=0;
   o->headerLen=0;
   o->formLen=0;
   o->postDataConsumed=FALSE;
}


static void
profilingtimer(HttpRequest* o)
{
   ecofffilehdr(o);
   read64uint64(&o->inData);
}


static void
arm64decrypt(
   HttpRequest* o, HttpServer* uarchbuild, HttpServerConfig* cfg)
{
   enableintens(&o->headerAlloc, 256);
   enableintens(&o->formAlloc, 256);
   flashwrite16(&o->inData, o, cfg);
   HttpStdHeaders_constructor(&o->stdH, &o->inData);
   o->server = uarchbuild;
   o->session=0;
   profilingtimer(o);
}

static BaBool
icachesnoops(HttpRequest* o)
{
   return
      HttpAllocator_isValid(&o->headerAlloc) &&
      HttpAllocator_isValid(&o->formAlloc) &&
      HttpInData_isValid(&o->inData);
}


static void
read64uint16(HttpRequest* o)
{
   emulateldrdstrd(&o->headerAlloc);
   emulateldrdstrd(&o->formAlloc);
   injectremove(&o->inData);
}

#define ALLMETHODS (HttpMethod_Unknown - 1)

BA_API int
HttpRequest_checkMethods(HttpRequest* o,
                        HttpResponse* r3000write,
                        U32 createcontiguous,
                        BaBool onenandresources)
{
   char* outboundenter;
   char* ptr;
   size_t i;
   int handlersetup;
   int chargetoggle;
   HttpMethod mt;

   if(!HttpResponse_initial(r3000write))
      return 0;

   
   if ((createcontiguous & (~ALLMETHODS)) || (createcontiguous == 0 && !onenandresources))
   {
      TRPR(("\166\103\150\145\143\153\117\160\164\151\157\156\163\072\040\151\156\166\141\154\151\144\040\157\160\164\151\157\156"));
      return E_INVALID_PARAM;
   }

   if(onenandresources)
      createcontiguous |= HttpMethod_Head;

   mt = HttpRequest_getMethodType(o);
   if(mt == HttpMethod_Options && onenandresources)
   {
      if (HttpStdHeaders_getContentLength(HttpRequest_getStdHeaders(o)) != 0)
         HttpConnection_clearKeepAlive(HttpResponse_getConnection(r3000write));
   }
   else
   {
      if(createcontiguous & mt)
          return 0;
   }

   if(onenandresources)
      createcontiguous |= HttpMethod_Options;

   if(r3000write->headerSent)
   {
      TRPR(("\163\145\156\144\117\160\164\151\157\156\163\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }

   
   baAssert(sizeof(httpMethodsSize)/sizeof(httpMethodsSize[0]) == 17);
   chargetoggle =
      httpMethodsSize[0] +
      httpMethodsSize[1] +
      httpMethodsSize[2] +
      httpMethodsSize[3] +
      httpMethodsSize[4] +
      httpMethodsSize[5] +
      httpMethodsSize[6] +
      httpMethodsSize[7] +
      httpMethodsSize[8] +
      httpMethodsSize[9] +
      httpMethodsSize[10] +
      httpMethodsSize[11] +
      httpMethodsSize[12] +
      httpMethodsSize[13] +
      httpMethodsSize[14] +
      httpMethodsSize[15] +
      
      2*16 + 
      1; 

   
   ptr = outboundenter = HttpResponse_fmtHeader(r3000write, "\101\154\154\157\167", chargetoggle, TRUE);
   if(!outboundenter)
   {
      TRPR(("\163\145\164\110\145\141\144\145\162\072\040\105\137\115\101\114\114\117\103\012"));
      return E_MALLOC; 
   }

   
   for(i=0; i < (sizeof(httpMethodsSize)/sizeof(httpMethodsSize[0])-1); i++)
   {
      if (createcontiguous & (1 << i))
      {
          
         chargetoggle = httpMethodsSize[i] - 1;
         memcpy(ptr, httpMethods[i],chargetoggle);
         ptr += chargetoggle;
         
         *ptr++='\054';
         *ptr++='\040';
      }
   }
   *(ptr-2) = '\000'; 
   if(mt == HttpMethod_Options && onenandresources)
   {
      
      if( (handlersetup=HttpResponse_resetBuffer(r3000write)) !=0 )
         return handlersetup;
      if( (handlersetup=HttpResponse_setContentLength(r3000write, 0)) !=0 )
         return handlersetup;
   }
   else
   {  
      if( (handlersetup=HttpResponse_sendError2(r3000write, 405, outboundenter)) )
         return handlersetup;
   }
   return 1;
}

BA_API int
HttpRequest_checkOptions(HttpRequest* o, HttpResponse* r3000write, int optLen, ...)
{
   int i;
   va_list demuxregids;
   BaBool onenandresources;
   U32 createcontiguous=0;

   if(!HttpResponse_initial(r3000write))
      return 0;

   if(optLen < 0)
   {
      optLen = -optLen; 
      onenandresources = FALSE;
   }
   else
      onenandresources = TRUE;

   va_start(demuxregids, optLen);
   for(i=0; i < optLen; i++)
      createcontiguous |= (U32)va_arg(demuxregids, int);
   va_end(demuxregids);              

   return HttpRequest_checkMethods(o, r3000write, createcontiguous, onenandresources);
}

BA_API BaBool
HttpRequest_checkTime(HttpRequest* o, HttpResponse* r3000write, BaTime widgetactive)
{
   BaTime ifModSinceTime;
   ifModSinceTime = baParseDate(
      HttpRequest_getHeaderValue(o, "\111\146\055\115\157\144\151\146\151\145\144\055\123\151\156\143\145"));
   if(ifModSinceTime && ifModSinceTime >= widgetactive)
   { 
      HttpResponse_setStatus(r3000write, 304); 
      HttpResponse_setContentLength(r3000write, 0);
      return TRUE;
   }

   return FALSE;
}


BA_API const char*
HttpRequest_getMethod2(HttpMethod disableparity)
{
   switch(disableparity)
   {
      case HttpMethod_Connect:   return httpMethods[0];
      case HttpMethod_Get:       return httpMethods[1];
      case HttpMethod_Head:      return httpMethods[2];
      case HttpMethod_Options:   return httpMethods[3];
      case HttpMethod_Patch:     return httpMethods[4];
      case HttpMethod_Post:      return httpMethods[5];
      case HttpMethod_Put:       return httpMethods[6];
      case HttpMethod_Trace:     return httpMethods[7];

         
      case HttpMethod_Copy:      return httpMethods[8];
      case HttpMethod_Delete:    return httpMethods[9];
      case HttpMethod_Lock:      return httpMethods[10];
      case HttpMethod_Move:      return httpMethods[11];
      case HttpMethod_Mkcol:     return httpMethods[12];
      case HttpMethod_Propfind:  return httpMethods[13];
      case HttpMethod_Proppatch: return httpMethods[14];
      case HttpMethod_Unlock:    return httpMethods[15];

      case HttpMethod_Unknown: break; 
   }
   return httpMethods[16]; 
}


BA_API const char*
HttpRequest_getRequestURI(HttpRequest* o)
{
    
   return HttpInData_2Ptr(&o->inData, o->pathI)  -1;
}


static const char*
HttpRequest_GetRequestURLX(HttpRequest* o, BaBool modifystatus)
{
   int len;
   const char* ejtagsetup;
   char *ptr;
   char removestate[60]; 

   HttpResponse* r3000write = HttpRequest_getResponse(o);
   const char* uri = HttpRequest_getRequestURI(o);
   const char* writereg16 = HttpStdHeaders_getHost(&o->stdH);
   if(!writereg16)
   {
      HttpSockaddr serialports;
      HttpConnection_getPeerName(HttpRequest_getConnection(o), &serialports,0);
      HttpConnection_addr2String(HttpRequest_getConnection(o),
                                 &serialports,
                                 removestate,
                                 sizeof(removestate));
      removestate[59]=0;
      writereg16=removestate;
   }
   if(modifystatus)
      ejtagsetup = "\150\164\164\160\163";
   else
      ejtagsetup = "\150\164\164\160";
   if(r3000write->encodedRedirectURL)
      baFree(r3000write->encodedRedirectURL);
   len=10+iStrlen(writereg16)+3*iStrlen(uri);
   r3000write->encodedRedirectURL = baMalloc(len);
   if(r3000write->encodedRedirectURL)
   {
      basnprintf(r3000write->encodedRedirectURL, len, "\045\163\072\057\057\045\163", ejtagsetup, writereg16);
      ptr = r3000write->encodedRedirectURL+strlen(r3000write->encodedRedirectURL);
      httpEscape(ptr, uri);
   }
   return r3000write->encodedRedirectURL;
}


BA_API const char*
HttpRequest_getRequestURL(HttpRequest* o, BaBool mdmctl0names)
{
   return HttpRequest_GetRequestURLX(
      o, mdmctl0names ? TRUE :
      HttpConnection_isSecure(HttpRequest_getConnection(o)));
}


#define HttpRequest_getRequestPath(o) HttpInData_2Ptr(&(o)->inData, (o)->pathI)


BA_API const char*
HttpRequest_getVersion(HttpRequest* o)
{
   return HttpInData_2Ptr(&o->inData, o->versionI);
}

static int
registerclocks(HttpRequest* o, const char* gpio1config, const char*  videoprobe)
{
   HttpStdHeaders* stdH = &o->stdH;
   HttpHeader* rtcmatch2clockdev = (HttpHeader*)HttpAllocator_alloc(
      &o->headerAlloc, sizeof(HttpHeader), 0);
   if(!rtcmatch2clockdev) return -1;

   o->headerLen++;
   HttpHeader_constructor(rtcmatch2clockdev, &o->inData, gpio1config, videoprobe);
#ifndef NDEBUG
   {
      const HttpHeader* hBase = HttpRequest_getHeadersM(o);
      baAssert((hBase+o->headerLen-1) == rtcmatch2clockdev);
   }
#endif
   
   if( ! stdH->connectionHOffs &&
       (gpio1config[3] == '\156' || gpio1config[3] == '\116') &&
       ! baStrCaseCmp("\103\157\156\156\145\143\164\151\157\156", gpio1config) )
   {
      stdH->connectionHOffs = HttpInData_2Index(&o->inData, videoprobe);
   }
   else if( ! stdH->hostHOffs &&
            (gpio1config[0] == '\110' || gpio1config[0] == '\150') &&
            ! baStrCaseCmp("\110\157\163\164", gpio1config) )
   {
      stdH->hostHOffs = HttpInData_2Index(&o->inData, videoprobe);
   }
   else if( ! stdH->contentTypeHOffs &&
            (gpio1config[8] == '\164' || gpio1config[8] == '\124') &&
            ! baStrCaseCmp("\143\157\156\164\145\156\164\055\164\171\160\145", gpio1config) )
   {
      stdH->contentTypeHOffs = HttpInData_2Index(&o->inData, videoprobe);
   }
   else if( (gpio1config[8] == '\154' || gpio1config[8] == '\114') &&
            ! baStrCaseCmp("\143\157\156\164\145\156\164\055\154\145\156\147\164\150", gpio1config) )
   {
#ifdef BA_FILESIZE64
      stdH->contentLength = U64_atoll(videoprobe);
#else
      stdH->contentLength = U32_atoi(videoprobe);
#endif
   }

   return 0;
}


static int
mappingerror(HttpRequest* o, const char* gpio1config, const char* videoprobe)
{
   InternalFormElement* formElement=(InternalFormElement*)HttpAllocator_alloc(
      &o->formAlloc, sizeof(InternalFormElement), 0);
   if(!formElement) return -1;
   nativeassign(formElement, &o->inData, gpio1config, videoprobe);
   o->formLen++;
   {
#ifndef NDEBUG
      const InternalFormElement* fBase = HttpRequest_getForms(o);
      baAssert(&fBase[o->formLen-1] == formElement);
#endif
   }
   return 0;
}

BA_API const char*
HttpRequest_getHeaderValue(HttpRequest* o, const char* gpio1config)
{
   if(o->headerLen)
   {
      int len;
      HttpHeader* platformioremap = HttpRequest_getHeadersM(o);
      for(len=0 ; len < o->headerLen ; len++)
      {
         const char* h=HttpHeader_nameM(platformioremap+len,&o->inData);
         if((*h == *gpio1config ||
             (*h > *gpio1config ? *gpio1config + ('\141'-'\101') == *h : *h + ('\141'-'\101') == *gpio1config))
            && !baStrCaseCmp(gpio1config+1,h+1))
         {
            return HttpHeader_valueM(platformioremap+len, &o->inData);
         }
      }
   }
   return 0;
}


BA_API HttpCookie*
HttpRequest_getCookie(HttpRequest* o, const char* gpio1config)
{
   HttpCookie* helperrgmii=HttpResponse_getCookie(HttpRequest_getResponse(o),gpio1config);
   if(!helperrgmii)
   {
      int dummywrite=0;
      char* nhpoly1305update;
      char* ads7846platform;
      char* prctlenable;
      char* val = baStrdup(HttpRequest_getHeaderValue(o, "\103\157\157\153\151\145"));
      if(!val) return 0;
      ads7846platform = val;
      httpEatWhiteSpace(ads7846platform);
      if( ! (baStrnCaseCmp(ads7846platform, "\126\145\162\163\151\157\156", 7)) )
      { 
         prctlenable = bStrchr(ads7846platform, '\073');
         nhpoly1305update = HttpCookie_ExtractAvPair(ads7846platform);
         if(nhpoly1305update)
            dummywrite = *nhpoly1305update - '\060';
         else
            prctlenable = 0; 
      }
      else
         prctlenable = val-1;
      while(prctlenable)
      {
         ads7846platform = prctlenable;
         ads7846platform++;
         httpEatWhiteSpace(ads7846platform);
         prctlenable = bStrchr(ads7846platform, '\073');
         if( ! (bStrncmp(ads7846platform, gpio1config, strlen(gpio1config))) )
         { 
            nhpoly1305update = HttpCookie_ExtractAvPair(ads7846platform);
            if(!nhpoly1305update)
               break; 
            helperrgmii = HttpResponse_createCookie(
               HttpRequest_getResponse(o), ads7846platform);
            HttpCookie_setValue(helperrgmii, nhpoly1305update);
#if 0
            HttpCookie_setVersion(helperrgmii, dummywrite);
#else
            (void)dummywrite;
#endif
            while(prctlenable)
            {
               ads7846platform = prctlenable;
               ads7846platform++;
               httpEatWhiteSpace(ads7846platform);
               prctlenable = bStrchr(ads7846platform, '\073');
               if(baStrnCaseCmp("\120\141\164\150", ads7846platform, 5) &&
                  baStrnCaseCmp("\104\157\155\141\151\156", ads7846platform, 7))
               {
                  prctlenable = 0; 
               }
               else
               {
                  nhpoly1305update = HttpCookie_ExtractAvPair(ads7846platform);
                  if( ! baStrnCaseCmp("\120\141\164\150", ads7846platform, 5) )
                     HttpCookie_setPath(helperrgmii, nhpoly1305update);
                  else
                     HttpCookie_setDomain(helperrgmii, nhpoly1305update);
               }
            }
         }
      }
      baFree(val);
   }
   return helperrgmii;
}



BA_API const char*
HttpRequest_getParameter(HttpRequest* o, const char* bugs64early)
{
   HttpParameterIterator i;
   HttpParameterIterator_constructor(&i, o);
   return HttpParameterIterator_getParameter(&i, bugs64early);
}



BA_API BaBool
HttpRequest_enableKeepAlive(HttpRequest* o)
{
   HttpConnection* con = HttpRequest_getConnection(o);
   if( ! HttpConnection_keepAlive(con) )
   {
      if(strcmp(HttpRequest_getVersion(o), "\061\056\061") >= 0)
      {
         const char* val = HttpStdHeaders_getConnection(
            HttpRequest_getStdHeaders(o));
         if( !val || baStrCaseCmp(val, "\103\154\157\163\145")) 
         {
            
            HttpResponse* r3000write = HttpRequest_getResponse(o);
            if(r3000write->printAndWriteInitialized)
            {
               if( ! r3000write->useChunkTransfer )
               {
                  if(r3000write->headerSent)
                     return FALSE; 
                  if(HttpResponse_setChunkEncoding(r3000write))
                     return FALSE;
               }
            }
            HttpConnection_setKeepAlive(con);
            return TRUE;
         }
      }
      return FALSE;
   }
   return TRUE;
}



BA_API int
HttpRequest_pushBackData(HttpRequest* o)
{
   HttpConnection* con = HttpRequest_getConnection(o);
   HttpInData* registeredevent = HttpRequest_getBuffer(o);
   S32 icachealiases = HttpInData_getBufSize(registeredevent);
   if(icachealiases != 0)
   {
      if(HttpConnection_pushBack(con,HttpInData_getBuf(registeredevent),icachealiases))
      {
         HttpConnection_clearKeepAlive(con);
         return E_MALLOC;
      }
   }
   HttpRequest_enableKeepAlive(o);
   return icachealiases;
}


#ifdef HTTP_TRACE
static void
sanitisepropbaser(HttpRequest* o)
{
   if(HttpTrace_doRequest())
   {
      const char* rightsvalid;
      const HttpHeader* platformioremap = HttpRequest_getHeadersM(o);
      const char* ua = HttpRequest_getHeaderValue(o, "\125\163\145\162\055\101\147\145\156\164");
      HttpConnection* con = HttpRequest_getConnection(o);
      if(!ua) ua="\077";
      rightsvalid = HttpRequest_getMethod(o);
      reprogramdpllcore(5,o);
      HttpTrace_printf(5,"\040\045\163\040\042\045\163\042\040\045\163\012",
                       rightsvalid,
                       HttpRequest_getRequestPath(o),
                       ua);
      if(HttpConnection_isSecure(con))
         HttpTrace_write(0,"\123\123\114\040", -1);

      if(HttpTrace_doRequestHeaders())
      {
         int i;
         HttpParameterIterator formIter;
         for(i = 0 ; i < o->headerLen ; i++)
         {
            HttpTrace_printf(5,"\045\163\072\040\045\163\012",
                             HttpHeader_nameM(platformioremap+i, &o->inData),
                             HttpHeader_valueM(platformioremap+i, &o->inData));
         }
         if(HttpParameterIterator_constructor(&formIter, o))
         {
            HttpTrace_write(5,"\106\157\162\155\040\144\141\164\141\072\012",-1);
            while(HttpParameterIterator_hasMoreElements(&formIter))
            {
               HttpTrace_printf(5,"\040\040\040\045\163\040\075\040\045\163\012",formIter.name,formIter.value);
               HttpParameterIterator_nextElement(&formIter);
            }
         }
         HttpTrace_write(5,"\012",1);
      }
   }
}
#else
#define sanitisepropbaser(o)
#endif

BA_API int
HttpRequest_setUserObj(HttpRequest* o, void* touchpdata, BaBool clockcheck)
{
   if(o->userObj && !clockcheck)
      return -1;
   o->userObj = touchpdata;
   return 0;
}

BA_API struct HttpCommand*
HttpRequest_getCommand(HttpRequest* o)
{
   return
      (HttpCommand*)
       ((U8*)o - offsetof(HttpCommand, request));
}


BA_API HttpHeader*
HttpRequest_getHeaders(HttpRequest* o, int* len)
{
   *len = o->headerLen;
   return HttpRequest_getHeadersM(o);
}


BA_API int
HttpRequest_wsUpgrade(HttpRequest* o)
{
   static const U8 sysdatamcheck[]={"\062\065\070\105\101\106\101\065\055\105\071\061\064\055\064\067\104\101\055\071\065\103\101\055\103\065\101\102\060\104\103\070\065\102\061\061"};
   DynBuffer db;
   int handlersetup;
   U8 secondaryentry[20];
   SharkSslSha1Ctx registermcasp;
   HttpResponse* r3000write = HttpRequest_getResponse(o);
   const char* ver=HttpRequest_getHeaderValue(o,"\123\145\143\055\127\145\142\123\157\143\153\145\164\055\126\145\162\163\151\157\156");
   const char* sourcerouting=HttpRequest_getHeaderValue(o,"\123\145\143\055\127\145\142\123\157\143\153\145\164\055\113\145\171");
   if( ! ver || ! sourcerouting)
      return -1;
   if(HttpResponse_resetHeaders(r3000write) || HttpResponse_resetBuffer(r3000write))
      return -2;
   SharkSslSha1Ctx_constructor(&registermcasp);
   SharkSslSha1Ctx_append(&registermcasp,(U8*)sourcerouting,iStrlen(sourcerouting));
   SharkSslSha1Ctx_append(&registermcasp,sysdatamcheck,sizeof(sysdatamcheck)-1);
   SharkSslSha1Ctx_finish(&registermcasp,secondaryentry);
   HttpResponse_setStatus(r3000write, 101);
   HttpResponse_setHeader(r3000write,"\125\160\147\162\141\144\145","\167\145\142\163\157\143\153\145\164",TRUE);
   HttpResponse_setHeader(r3000write,"\103\157\156\156\145\143\164\151\157\156","\125\160\147\162\141\144\145",TRUE);
   DynBuffer_constructor(&db,20*4/3+10,100,0,0);
   BufPrint_b64Encode((BufPrint*)&db, secondaryentry, 20);
   handlersetup=-3;
   if( ! DynBuffer_getECode(&db) )
   {
      HttpResponse_setHeader(
         r3000write,"\123\145\143\055\127\145\142\123\157\143\153\145\164\055\101\143\143\145\160\164",DynBuffer_getBuf(&db),TRUE);
      if( ! HttpResponse_flush(r3000write) )
         handlersetup=0;
   }
   DynBuffer_destructor(&db);
   return handlersetup;
}


BA_API const char*
HttpHeader_name(HttpHeader* o, HttpRequest* req)
{
   return HttpHeader_nameM(o,&req->inData);
}


BA_API const char*
HttpHeader_value(HttpHeader* o, HttpRequest* req)
{
   return HttpHeader_valueM(o,&req->inData);
}



typedef struct
{
      U16 value; /* Relative offset from beginning of struct*/
      U16 next;  /* Absolute position*/
} NameValMMNode;

#define NameValMMNode_constructor(o) memset(o, 0, sizeof(NameValMMNode))
#define NameValMMNode_isEmpty(o) ((o)->value == 0)
#define NameValMMNode_setEmpty(o) (o)->value = 0
#define NameValMMNode_getName(o) (char*)((o)+1)
#define NameValMMNode_getValue(o) (((char*)((o)+1))+(o)->value)
#define NameValMMNode_hasNext(o) (o)->next != 0
#define NameValMMNode_getNext(o, consoleiobase) (o)->next ? \
         (NameValMMNode*)HttpAllocator_2Ptr(consoleiobase, (o)->next) : 0


#define NameValMMNode_calcNodeSize(cpuidlepdata) \
   (sizeof(NameValMMNode)+cpuidlepdata+(sizeof(void*)-1)) & (~(sizeof(void*)-1));


static U16
timer9hwmod(NameValMMNode* o, HttpAllocator* alloccontroller)
{
   U16 pos = NameValMMNode_hasNext(o) ? o->next : alloccontroller->size;
   return pos - HttpAllocator_2Index(alloccontroller, o) - sizeof(NameValMMNode);
}



static NameValMMNode*
NameValMMNode_deleteAndLink(NameValMMNode* o, NameValMMNode* setupmemory,
                            HttpAllocator* alloccontroller)
{
   NameValMMNode* h1;
   NameValMMNode* h2 = NameValMMNode_getNext(o, alloccontroller);
   if(setupmemory && NameValMMNode_isEmpty(setupmemory))
   {
      h1 = setupmemory;
      h1->next = o->next;
   }
   else
   {
      NameValMMNode_setEmpty(o);
      h1 = o;
   }
   if(h2 && NameValMMNode_isEmpty(h2))
      h1->next = h2->next;
   return h1;
}


static char*
NameValMMNode_set(NameValMMNode* o, const char* gpio1config)
{
   o->value = (U16)strlen(gpio1config)+1;
   strcpy(NameValMMNode_getName(o), gpio1config);
   return NameValMMNode_getValue(o);
}




static void
initializeiomem(NameValMM* o)
{
   NameValMMNode* h = (NameValMMNode*)HttpAllocator_2Ptr(&o->data, 0);
   NameValMMNode_setEmpty(h);
   h->next=0;
   HttpAllocator_reclaim(o->data);
}


static void
soundblasterreset(NameValMM* o, HttpServerConfig* cfg)
{
   enableintens(&o->data, cfg->minResponseHeader);
   o->maxResponseHeader = cfg->maxResponseHeader;
   initializeiomem(o);
}

#define NameValMM_isValid(o) HttpAllocator_isValid(&(o)->data)

static void
redirecttable(NameValMM* o)
{
   emulateldrdstrd(&o->data);
}


static NameValMMNode*
NameValMM_getFirstNode(NameValMM* o)
{
   if(HttpAllocator_isEmpty(o->data))
      return 0;
   return (NameValMMNode*)HttpAllocator_2Ptr(&o->data, 0);
}


#define NameValMM_getNextNode(o, nameValMMNode) \
   NameValMMNode_getNext(nameValMMNode, &(o)->data)

static char*
NameValMM_set(NameValMM* o, const char* gpio1config, U16 wm5110device, BaBool legacywrite)
{
   int mappingnoalloc;
   U16 doublefnmul;
   U16 uart2hwmod;
   char* handlersetup=0;
   NameValMMNode* h1;
   NameValMMNode* h2 = NameValMM_getFirstNode(o);
   BaBool timer0state = FALSE;
   BaBool flushmemslot = legacywrite ? FALSE : TRUE;
   U16 alignresource = (U16)strlen(gpio1config);
   U16 cpuidlepdata = alignresource + wm5110device + 2;
   if(h2)
   {
      h1 = 0;
      while(h2)
      {
         if(NameValMMNode_isEmpty(h2) && wm5110device !=0)
         {
            if( !timer0state && timer9hwmod(h2, &o->data) >= cpuidlepdata )
            {
               timer0state = TRUE;
               handlersetup = NameValMMNode_set(h2, gpio1config);
               if(h2->next)
               {
                  if(flushmemslot) return handlersetup;
               }
               else 
               {
                  
                  uart2hwmod = HttpAllocator_2Index(&o->data, h2);
                  doublefnmul = NameValMMNode_calcNodeSize(cpuidlepdata);
                  o->data.index = uart2hwmod + doublefnmul;
               }
            }
         }
         else if( !flushmemslot &&
                  !baStrCaseCmp(gpio1config, NameValMMNode_getName(h2)) )
         {
            flushmemslot = TRUE;
            h2 = NameValMMNode_deleteAndLink(h2, h1, &o->data);
            if(timer0state || wm5110device==0) return handlersetup;
            if(timer9hwmod(h2, &o->data) >= cpuidlepdata)
            {
               if( !h2->next )
               { 
                  uart2hwmod = HttpAllocator_2Index(&o->data, h2);
                  doublefnmul = NameValMMNode_calcNodeSize(cpuidlepdata);
                  o->data.index = uart2hwmod + doublefnmul;
               }
               return NameValMMNode_set(h2, gpio1config);
            }
         }
         h1 = h2;
         h2 = NameValMM_getNextNode(o, h2);
      }
      if(timer0state || wm5110device == 0)
         return handlersetup;
      uart2hwmod = HttpAllocator_2Index(&o->data, h1);
      mappingnoalloc=TRUE;
   }
   else
   {
      if(wm5110device == 0) 
         return 0;
      mappingnoalloc=FALSE;
   }
   doublefnmul = NameValMMNode_calcNodeSize(cpuidlepdata);
   h2 = (NameValMMNode*)HttpAllocator_alloc(&o->data,doublefnmul,o->maxResponseHeader);
   if( !h2 ) return 0; 
   handlersetup = NameValMMNode_set(h2, gpio1config);
   h2->next=0;
   if(mappingnoalloc)
   {
      h1 = (NameValMMNode*)HttpAllocator_2Ptr(&o->data, uart2hwmod);
      h1->next = HttpAllocator_2Index(&o->data, h2);
   }
   return handlersetup;
}



static void defaultcoherent(HttpResponse* o);
static int disabledevice(BufPrint* stealclock, int accesssubid);
static int vmallocbranch(BufPrint* stealclock, int accesssubid);
static int cacheprobe(HttpResponse* o);
static int devicecamif(
   HttpResponse* o, const char* gpio1config, const char* videoprobe, BaBool legacywrite);

static void
ejtaghandler(HttpResponse* o, HttpServerConfig* cfg)
{

   memset(o, 0, sizeof(HttpResponse));
   BufPrint_constructor(&o->headerPrint, o, disabledevice);
   BufPrint_constructor(&o->defaultBodyPrint, o, vmallocbranch);
   soundblasterreset(&o->nameValMM, cfg);
   if( ! NameValMM_isValid(&o->nameValMM) )
       return;
   o->headerPrint.buf = (char*)baMalloc(cfg->commit);
   if(!o->headerPrint.buf)
       return;
   o->headerPrint.bufSize = cfg->commit-1; 

   
   o->defaultBodyPrint.buf = (char*)baMalloc(cfg->responseData);
   if(!o->defaultBodyPrint.buf)
       return;
   o->defaultBodyPrint.buf += 6;

   o->defaultBodyPrint.bufSize = cfg->responseData-8;
   defaultcoherent(o);
}



static BaBool
vectorslot2addr(const char* s)
{
   if(  s &&
        (s[0] == '\150' || s[0] == '\110') &&
        (s[1] == '\164' || s[1] == '\124') &&
        (s[2] == '\164' || s[2] == '\124') &&
        (s[3] == '\160' || s[3] == '\120') )
   {
      if(s[4] == '\072' || ((s[4] == '\163' || s[4] == '\123') && s[5] == '\072'))
         return TRUE;
   }
   return FALSE;
}


static BaBool
max1587aconsumers(HttpResponse* o)
{
   return
      NameValMM_isValid(&o->nameValMM) &&
      o->headerPrint.buf &&
      o->bodyPrint->buf;
}


static void
eventvector(HttpResponse* o)
{
   if(o->headerPrint.buf)
      baFree(o->headerPrint.buf);
   if(o->defaultBodyPrint.buf)
      baFree(o->defaultBodyPrint.buf-6);
   redirecttable(&o->nameValMM);
}


static void
defaultcoherent(HttpResponse* o)
{
   HttpCookie* instructioncounter = o->cookieList;
   o->cookieList = 0;
   o->userObj=0;
   while(instructioncounter)
   {
      HttpCookie* prctlenable = instructioncounter->next;
      HttpCookie_destructor(instructioncounter);
      baFree(instructioncounter);
      instructioncounter = prctlenable;
   }

   initializeiomem(&o->nameValMM);

   
   o->headerPrint.cursor = 0;
   o->defaultBodyPrint.cursor = 0;
   o->bodyPrint = &o->defaultBodyPrint;

   if(o->encodedURL)
   {
      baFree(o->encodedURL);
      o->encodedURL = 0;
   }
   if(o->encodedRedirectURL)
   {
      baFree(o->encodedRedirectURL);
      o->encodedRedirectURL = 0;
   }
   o->msgLen = 0;
   o->headerSent = FALSE;
   o->statusCode = 200;
   o->includeCounter=0;
   o->forwardCounter=0;
   o->printAndWriteInitialized = FALSE;
   o->useChunkTransfer = FALSE;
   
   o->protocol.major = 1;
   o->protocol.minor = 1;

}


static int
disabledevice(BufPrint* stealclock, int accesssubid)
{
   HttpResponse* o = (HttpResponse*)stealclock->userData;
   int handlersetup=0;
   (void)accesssubid; 
   if(stealclock->cursor)
   {
      handlersetup = HttpConnection_sendData(
         HttpResponse_getConnection(o),stealclock->buf, stealclock->cursor);
      stealclock->cursor=0;
   }
   return handlersetup;
}


static int
vmallocbranch(BufPrint* stealclock, int accesssubid)
{
   HttpResponse* o = (HttpResponse*)stealclock->userData;
   int handlersetup=0;
   (void)accesssubid; 
   o->msgLen += stealclock->cursor;
   if(HttpResponse_getRequest(o)->methodType == HttpMethod_Head)
   {
      stealclock->cursor=0;
      return 0;
   }
   if(!o->headerSent)
   {
      handlersetup = cacheprobe(o);
      if(handlersetup) return handlersetup;
   }
   if(stealclock->cursor)
   {
      if(o->useChunkTransfer)
      {
         handlersetup = HttpConnection_sendChunkData6bOffs(
            HttpResponse_getConnection(o), stealclock->buf, stealclock->cursor);
      }
      else
      {
         handlersetup = HttpConnection_sendData(
            HttpResponse_getConnection(o), stealclock->buf, stealclock->cursor);
      }
      stealclock->cursor=0;
   }
   return handlersetup;
}


static int
valueformula(HttpResponse* o)
{
   int handlersetup = 0;
   U16 sysregtable;
   if(o->cookieList)
   {
      char* ref;
      char* buf;
      HttpCookie* instructioncounter = o->cookieList;
      while(instructioncounter)
      {
         int icachealiases=0;
         if(instructioncounter->activateFlag)
         {
            icachealiases += iStrlen(instructioncounter->name);
            if(instructioncounter->comment) icachealiases += (iStrlen(instructioncounter->comment)*3+10);
            if(instructioncounter->domain) icachealiases += (iStrlen(instructioncounter->domain)*3+9);
            if(instructioncounter->path) icachealiases += (iStrlen(instructioncounter->path)*3+6);
            if(instructioncounter->value) icachealiases += (iStrlen(instructioncounter->value)*3);
            if(instructioncounter->maxAge > 0 || instructioncounter->deleteCookieFlag) icachealiases += 50;
            if(instructioncounter->secure) icachealiases += 8;
			if(instructioncounter->httpOnly) icachealiases +=10;
            icachealiases += 14; 

            
            sysregtable = o->includeCounter;
            o->includeCounter = 0;
            ref = buf = HttpResponse_fmtHeader(o, "\123\145\164\055\103\157\157\153\151\145", icachealiases, FALSE);
            o->includeCounter = sysregtable;
            if(!buf)
               return E_MALLOC;
            ref = HttpCookie_CreateAvPair(ref, instructioncounter->name, instructioncounter->value, FALSE);
            
            if(instructioncounter->domain)
               ref=HttpCookie_CreateAvPair(ref, "\144\157\155\141\151\156", instructioncounter->domain, TRUE);
            if(instructioncounter->path)
               ref = HttpCookie_CreateAvPair(ref, "\160\141\164\150", instructioncounter->path, TRUE);
            if(instructioncounter->maxAge > 0 || instructioncounter->deleteCookieFlag)
            {
               strcpy(ref, "\073\040\145\170\160\151\162\145\163\075");
               ref += strlen(ref);
               httpFmtDate(
                  ref, (S16)(icachealiases - (ref - buf)),
                  instructioncounter->deleteCookieFlag?0:baGetUnixTime()+instructioncounter->maxAge);
               ref += strlen(ref);
            }
            if(instructioncounter->secure)
            {
               strcpy(ref, "\073\040\163\145\143\165\162\145");
               ref += strlen(ref);
            }
            if(instructioncounter->httpOnly)
            {
               strcpy(ref, "\073\040\110\164\164\160\117\156\154\171");
               ref += strlen(ref);
            }
            if(instructioncounter->comment)
               ref = HttpCookie_CreateAvPair(
                  ref, "\143\157\155\155\145\156\164", instructioncounter->comment, TRUE);
            if(instructioncounter->next)
            {
               strcpy(ref, "\073\040");
               ref += strlen(ref);
            }
            *ref = 0;
         }
         instructioncounter = instructioncounter->next;
      }
   }
   return handlersetup;
}


static HttpCookie*
HttpResponse_getCookie(HttpResponse* o, const char* gpio1config)
{
   HttpCookie* instructioncounter = o->cookieList;
   while(instructioncounter)
   {
      if( ! strcmp(instructioncounter->name, gpio1config) )
         return instructioncounter;
      instructioncounter = instructioncounter->next;
   }
   return 0;
}


static void
regmaplookup(HttpResponse* o, HttpCookie* gpioliblbank)
{
   HttpCookie* instructioncounter = o->cookieList;
   baAssert(!gpioliblbank->next);
   if(instructioncounter)
   {
      HttpCookie* setupmemory;
      for(setupmemory = instructioncounter; instructioncounter ; instructioncounter = instructioncounter->next)
      {
         if(strcmp(instructioncounter->name, gpioliblbank->name)==0)
         {
            HttpCookie* duplicate = instructioncounter;
            gpioliblbank->next = instructioncounter->next;
            if(setupmemory == instructioncounter)
            {
               baAssert(setupmemory == o->cookieList);
               o->cookieList = gpioliblbank;
            }
            else
               setupmemory->next = gpioliblbank;

            baFree(duplicate);
            return;
         }
         setupmemory = instructioncounter;
      }
      setupmemory->next = gpioliblbank;
   }
   else
      o->cookieList = gpioliblbank;
}


static int
cacheprobe(HttpResponse* o)
{
   static const char fmt[] = {
      "\110\124\124\120\057\045\144\056\045\144\040\045\163\015\012"
      "\104\141\164\145\072\040\045\163\015\012"
      "\123\145\162\166\145\162\072\040" SERVER_SOFTWARE_NAME "\015\012"
   };
   NameValMMNode* n;
   BaTime now;
   int handlersetup;
   char ktextsource[40];
   if(o->headerSent) return 0;

   devicecamif(
      o,
      "\113\145\145\160\055\101\154\151\166\145",
      HttpConnection_keepAlive(HttpResponse_getConnection(o)) ?
      "\113\145\145\160\055\101\154\151\166\145" : "\103\154\157\163\145", FALSE);

   now = baGetUnixTime();
   httpFmtDate(ktextsource, sizeof(ktextsource), now);

   baAssert(o->headerPrint.cursor == 0);

   handlersetup = BufPrint_printf(
      &o->headerPrint,
      fmt,
      (int)o->protocol.major,
      (int)o->protocol.minor,
      HttpServer_getStatusCode(o->statusCode),
      ktextsource);

   if(handlersetup < 0) return handlersetup;
   valueformula(o);
   o->headerSent = TRUE;
   
   n = NameValMM_getFirstNode(&o->nameValMM);

#ifdef BA_DEMO_MODE
   {
      const char* ct=0;
      while(n)
      {
         if(!NameValMMNode_isEmpty(n))
         {
            const char* k = NameValMMNode_getName(n);
            const char* v = NameValMMNode_getValue(n);
            if(!ct && !baStrCaseCmp("\103\157\156\164\145\156\164\055\124\171\160\145", k))
               ct=v;
            handlersetup = BufPrint_printf(
               &o->headerPrint,
               "\045\163\072\040\045\163\015\012",
               k,
               v);
            if(handlersetup < 0) return handlersetup;
         }
         n = NameValMM_getNextNode(&o->nameValMM, n);
      }
      if(!ct || !baStrnCaseCmp("\164\145\170\164\057\150\164\155\154",ct,9))
      {
         char* s=o->bodyPrint->buf;
         char* e=s+o->bodyPrint->cursor;
         int ok=FALSE;
         while(s < (e-7))
         {
            if(*s == '\074' && s[1] == '\057' && !baStrnCaseCmp(s+2,"\142\157\144\171\076",5))
            {
               o->bodyPrint->cursor = s - o->bodyPrint->buf;
               BufPrint_write(
                  o->bodyPrint,
                  "\074\160\040\151\144\075\047\160\157\167\142\141\047\076\074\142\162\057\076\120\157\167\145\162\145\144\040\142\171\040\164\150\145\040"
                  "\074\141\040\150\162\145\146\075\047\150\164\164\160\072\057\057\142\141\162\162\141\143\165\144\141\163\145\162\166\145\162\056\143\157\155\047\076"
                  "\102\141\162\162\141\143\165\144\141\040\105\155\142\145\144\144\145\144\040\127\145\142\040\123\145\162\166\145\162\074\057\141\076\056\074\057\160\076\074\057\142\157\144\171\076\074\057\150\164\155\154\076",-1);
               ok=TRUE;
               break;
            }
            s++;
         }
         if(!ok) {
            o->bodyPrint->cursor=0;
            BufPrint_write(
               o->bodyPrint,"\074\150\061\076\111\156\166\141\154\151\144\040\110\124\115\114\040\146\157\165\156\144\040\151\156\040\162\145\163\160\157\156\163\145\074\057\150\061\076",-1);
         }
      }
   }
#else
   while(n)
   {
      if(!NameValMMNode_isEmpty(n))
      {
         handlersetup = BufPrint_printf(
            &o->headerPrint,
            "\045\163\072\040\045\163\015\012",
            NameValMMNode_getName(n),
            NameValMMNode_getValue(n));
         if(handlersetup < 0) return handlersetup;
      }
      n = NameValMM_getNextNode(&o->nameValMM, n);
   }
#endif

   
   if( (handlersetup=BufPrint_write(&o->headerPrint, "\015\012", 2)) !=0 )
      return handlersetup;
#ifdef HTTP_TRACE
   if(HttpTrace_doResponseHeaders())
   {
      reprogramdpllcore(5, HttpResponse_getRequest(o));
      o->headerPrint.buf[o->headerPrint.cursor]=0;
      HttpTrace_printf(5,"\040\122\145\163\160\157\156\163\145\072\012\045\163\012", o->headerPrint.buf);
   }
#endif
   return disabledevice(&o->headerPrint, 0);
}


BA_API int
HttpResponse_setChunkEncoding(HttpResponse* o)
{
   int handlersetup;
   
   U16 sysregtable = o->includeCounter;
   o->includeCounter = 0;
   handlersetup = HttpResponse_setHeader(o, "\124\162\141\156\163\146\145\162\055\105\156\143\157\144\151\156\147", "\143\150\165\156\153\145\144", TRUE);
   o->includeCounter = sysregtable;
   if(handlersetup) return handlersetup;
   o->useChunkTransfer = TRUE;
   return 0;
}


BA_API int
HttpResponse_printAndWriteInit(HttpResponse* o)
{
   baAssert( !o->printAndWriteInitialized );
   baAssert(o->useChunkTransfer == FALSE);
   o->printAndWriteInitialized = TRUE;

   if(o->bodyPrint == &o->defaultBodyPrint)
   {
      HttpConnection* con = HttpResponse_getConnection(o);
      baAssert(con);

      if(HttpConnection_keepAlive(con) &&
         HttpResponse_getRequest(o)->methodType != HttpMethod_Head)
      {
         return HttpResponse_setChunkEncoding(o);
      }
   }
   return 0;
}


BA_API const char*
HttpResponse_getRespData(HttpResponse* o, int* len)
{
   if(o->bodyPrint == &o->defaultBodyPrint && ! HttpResponse_committed(o))
   {
      BufPrint* out = (BufPrint*)&o->defaultBodyPrint;
      *len = out->cursor;
      return out->buf;
   }
   return 0;
}





BA_API HttpCookie*
HttpResponse_createCookie(struct HttpResponse* o, const char* gpio1config)
{
   HttpCookie* c = HttpResponse_getCookie(o, gpio1config);
   if(c)
      return c;
   return HttpCookie_constructor(
      (HttpCookie*)baMalloc(sizeof(HttpCookie)), o, gpio1config);
}


BA_API int
HttpResponse_dataAdded(HttpResponse* o, U32 icachealiases)
{
   int handlersetup;
   if( !o->printAndWriteInitialized )
      if( (handlersetup=HttpResponse_printAndWriteInit(o)) != 0 )
         return handlersetup;

   if(o->bodyPrint->cursor + (U16)icachealiases > o->bodyPrint->bufSize)
   {
      TRPR(("\105\137\124\117\117\137\115\125\103\110\137\104\101\124\101\012"));
      return E_TOO_MUCH_DATA;
   }

   o->bodyPrint->cursor += (U16)icachealiases;

   if(o->bodyPrint->cursor == o->bodyPrint->bufSize)
      return o->bodyPrint->flushCB(o->bodyPrint, 0);
   return 0;
}


BA_API const char*
HttpResponse_containsHeader(HttpResponse* o, const char* gpio1config)
{
   NameValMMNode* n = NameValMM_getFirstNode(&o->nameValMM);
   while(n)
   {
      if(!NameValMMNode_isEmpty(n) &&
         !baStrCaseCmp(gpio1config, NameValMMNode_getName(n)) )
      {
         return NameValMMNode_getValue(n);
      }
      n = NameValMM_getNextNode(&o->nameValMM, n);
   }
   return 0;
}


BA_API const char*
HttpResponse_encodeRedirectURLWithParamOrSessionURL(HttpResponse* o,
                                                    const char* driverstate,
                                                    BaBool flashcommon)
{
   HttpParameterIterator httpParameterIterator;
   HttpParameterIterator* instructioncounter;
   char* ptr;
   char* chargestart;
#ifdef NO_HTTP_SESSION
   void* func2fixup=0;
#else
   HttpSession* func2fixup=0;
#endif
   int len = driverstate ? iStrlen(driverstate)+1 : 1;
   HttpRequest* configuredevice=HttpResponse_getRequest(o);

#ifndef NO_HTTP_SESSION
   if(flashcommon)
   {
      func2fixup = HttpRequest_getSession(HttpResponse_getRequest(o), FALSE);
      if(func2fixup)
         len+=sizeof(BA_COOKIE_ID)+28;
   }
#endif

   if(HttpRequest_getNoOfParameters(configuredevice))
   {
      len += HttpRequest_getNoOfParameters(configuredevice);
      len++;
      len += (int)uretprobehijack(configuredevice)*3;
      instructioncounter = &httpParameterIterator;
      HttpParameterIterator_constructor(instructioncounter, configuredevice);
   }
   else
   {
      instructioncounter = 0;
   }
   chargestart=(char*)baMalloc(len);
   if(chargestart)
   {
      const char* url;
      if(driverstate)
         strcpy(chargestart,driverstate);
      else
         *chargestart=0;
      ptr = chargestart+strlen(chargestart);
      if(instructioncounter)
      {
         *ptr++ = '\077';

         for(;;)
         {
            BaBool pcierrinterrupt;
            const char* gpio1config = HttpParameterIterator_getName(instructioncounter);
            if( !flashcommon || (flashcommon && strcmp(gpio1config,BA_COOKIE_ID)) )
            {
               ptr = httpEscape(ptr, gpio1config);
               *ptr++ = '\075';
               ptr = httpEscape(ptr, HttpParameterIterator_getValue(instructioncounter));
               pcierrinterrupt=TRUE;
            }
            else
               pcierrinterrupt=FALSE;
            HttpParameterIterator_nextElement(instructioncounter);
            if( ! HttpParameterIterator_hasMoreElements(instructioncounter) )
               break;
            if(pcierrinterrupt)
               *ptr++ = '\046';
         }
         if(func2fixup)
            *ptr++ = '\046';
         else
            *ptr = 0;
      }
      else if(func2fixup)
         *ptr++ = '\077';
#ifndef NO_HTTP_SESSION
      if(func2fixup)
      {
         basnprintf(ptr, 10000, "\045\163\075",BA_COOKIE_ID);
         HttpSession_fmtSessionId(func2fixup, (U8*)(ptr+strlen(ptr)),25);
      }
#endif
      if(driverstate)
      {
         url = HttpResponse_encodeRedirectURL(o, chargestart);
      }
      else
      {
         if(HttpResponse_encodeRedirectURL(o, 0))
         {
            int len=iStrlen(o->encodedRedirectURL)+iStrlen(chargestart)+1;
            ptr = baMalloc(len);
            if(ptr)
            {
               basnprintf(ptr,len,"\045\163\045\163",o->encodedRedirectURL,chargestart);
               baFree(o->encodedRedirectURL);
               url=o->encodedRedirectURL=ptr;
            }
            else
               url=0;
         }
         else
            url=0;
      }
      baFree(chargestart);
      return url;
   }
   return 0;
}



BA_API const char*
HttpResponse_encodeRedirectURL(HttpResponse* o, const char* timerregister)
{
   char* buf;
   char* ref;
   int len;
   char* padconfglobal; 
   const char* mlogbuffinish = HttpRequest_getRequestPath(
            HttpResponse_getRequest(o));

   
   if(o->encodedRedirectURL)
   {
      padconfglobal=o->encodedRedirectURL;
      o->encodedRedirectURL=0;
   }
   else
      padconfglobal=0;
   
   if(vectorslot2addr(timerregister))
   { 
      ref = bStrchr(timerregister+8, '\057'); 
      if(ref)
      {  
         buf = (char*)baMalloc((ref - timerregister) + (strlen(ref))+10);
         if(!buf) goto L_exitEncURL;
         memcpy(buf, timerregister, ref - timerregister);
         strcpy(buf + (ref - timerregister), ref);
      }
      else
      { 
         buf = (char*)baMalloc(strlen(timerregister)+10);
         if(!buf) goto L_exitEncURL;
         strcpy(buf, timerregister);
      }
   }
   else
   { 
      const char* ejtagsetup;
      
      const char* writereg16 = HttpStdHeaders_getHost(
         &(HttpResponse_getRequest(o)->stdH));
      if(!writereg16)
      {  
         buf=baMalloc(strlen(timerregister)*3+1);
         if(buf)
         {
            proplistsyscall(buf, timerregister);
            baElideDotDot(buf);
            o->encodedRedirectURL=buf;
         }
         goto L_exitEncURL;
      }
      if( HttpConnection_isSecure(HttpResponse_getConnection(o)) )
         ejtagsetup = "\150\164\164\160\163";
      else
         ejtagsetup = "\150\164\164\160";
       
      if(!timerregister || !*timerregister || *timerregister == '\057')
      {
         len = 11 + iStrlen(writereg16) + iStrlen(timerregister&&*timerregister?timerregister:mlogbuffinish);
         buf = (char*)baMalloc(len+10);
         if(!buf) goto L_exitEncURL;
         if(timerregister && *timerregister)
            basnprintf(buf, len, "\045\163\072\057\057\045\163", ejtagsetup, writereg16);
         else
         {
            basnprintf(buf, len, "\045\163\072\057\057\045\163\057", ejtagsetup, writereg16);
            timerregister=mlogbuffinish;
         }
         strcpy(buf+strlen(buf), timerregister);
      }
      else 
      {
         const char* end = bStrrchr(mlogbuffinish, '\057');
         if(!end)
         {
            const char* ptr=mlogbuffinish;

            if(o->currentDir->name && *o->currentDir->name)
            {
               while( (ptr = bStrstr(ptr, o->currentDir->name)) != 0)
               {
                  ptr += strlen(o->currentDir->name);
                  if( !*ptr ) break;
               }
               if(ptr)
                  end = ptr;
               else
                  end = mlogbuffinish-1;
            }
            else
               end = mlogbuffinish;
         }
         len = (int)(20+strlen(writereg16)+((end - mlogbuffinish + 1)+strlen(timerregister)));
         buf = (char*)baMalloc(len);
         if(buf)
         {
            char* ref;
            if(*writereg16)
               basnprintf(buf, len, "\045\163\072\057\057\045\163\057", ejtagsetup, writereg16);
            else
               strcpy(buf, "\057");
            ref = buf + strlen(buf);
            if(end != mlogbuffinish)
            {
               baAssert(end > mlogbuffinish);
               memcpy(ref, mlogbuffinish, end - mlogbuffinish + 1);
               ref += (end - mlogbuffinish + 1);
               if( !*end ) *(ref-1) = '\057';
            }
            strcpy(ref, timerregister);
         }
      }
   }
   if(buf)
   {
      if(strlen(buf) >= 8)
      {
         if((ref = strchr(buf+8, '\057')) != 0) 
         {
            baElideDotDot(buf+7);
            o->encodedRedirectURL = baMalloc(strlen(buf)*3+1);
            if(o->encodedRedirectURL)
            {
               len=(int)(ref-buf);
               memcpy(o->encodedRedirectURL, buf, len);
               proplistsyscall(o->encodedRedirectURL+len, ref);
            }
         }
      }
      baFree(buf);
   }
  L_exitEncURL:
   if(padconfglobal)
      baFree(padconfglobal);
   return o->encodedRedirectURL;
}


BA_API const char*
HttpResponse_encodeUrl(HttpResponse* o, const char* driverstate)
{
   char* buf = (char*)baMalloc(strlen(driverstate)*3+1);
   if(!buf) return 0;
   proplistsyscall(buf, driverstate);
   baElideDotDot(buf);
   if(o->encodedURL)
      baFree(o->encodedURL);
   o->encodedURL = buf;
   return buf;
}

#ifdef BA_DEMO_MODE
static
#else
BA_API
#endif
int
HttpResponse_flush(HttpResponse* o)
{
   return o->bodyPrint->flushCB(o->bodyPrint, 0);
}


BA_API int
HttpResponse_incOrForward(HttpResponse* o, const char* driverstate, BaBool tbclksyncpdata)
{
   U16* ttbr0disable;
   int (*keypadresource)(HttpServer*, HttpCommand*, HttpDir*, const char*);
   HttpDir* dir;
   HttpCommand* cmd = HttpResponse_getCommand(o);
   int handlersetup;
   HttpDir* savedCurrentDir = o->currentDir;

   if(tbclksyncpdata)
   {
      if(o->includeCounter >= 10)
      {
         TRPR(("\105\137\124\117\117\137\115\101\116\131\137\111\116\103\114\125\104\105\123\012"));
         return E_TOO_MANY_INCLUDES;
      }
      ttbr0disable = &o->includeCounter;
      keypadresource = menelausplatform;
   }
   else
   {
      if(o->forwardCounter >= 10)
      {
         TRPR(("\105\137\124\117\117\137\115\101\116\131\137\106\117\122\127\101\122\104\123\012"));
         return E_TOO_MANY_FORWARDS;
      }
      if(o->headerSent)
      {
         TRPR(("\146\157\162\167\141\162\144\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
         return E_IS_COMMITTED;
      }
      HttpResponse_resetBuffer(o);
      ttbr0disable = &o->forwardCounter;
      keypadresource = reportstatus;
   }
   if(*driverstate == '\057')
   {
      driverstate++;
      dir = HttpServer_getRDC(cmd->request.server);
   }
   else
      dir = o->currentDir;
   baAssert(dir);
   (*ttbr0disable)++;
   handlersetup = (*keypadresource)(cmd->request.server, cmd, dir, driverstate);
   (*ttbr0disable)--;
   o->currentDir = savedCurrentDir;

#ifdef HTTP_TRACE
   if(handlersetup == E_PAGE_NOT_FOUND)
   {
      HttpTrace_printf(5,"\045\163\040\146\151\154\145\040\045\163\040\156\157\164\040\146\157\165\156\144\012",
                       tbclksyncpdata?"\111\156\143\154\165\144\145":"\106\157\162\167\141\162\144",driverstate);
   }
#endif

   return handlersetup;
}


BA_API int
HttpResponse_redirect(HttpResponse* o, const char* driverstate)
{
   int handlersetup;
   HttpDir* dir;
   HttpCommand* cmd = HttpResponse_getCommand(o);
   HttpDir* savedCurrentDir = o->currentDir;
   if(o->headerSent)
   {
      TRPR(("\162\145\144\151\162\145\143\164\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   HttpResponse_resetBuffer(o);
   if(*driverstate == '\057')
   {
      driverstate++;
      dir = HttpServer_getRDC(cmd->request.server);
   }
   else
      dir = o->currentDir;
   baAssert(dir);
   handlersetup = reportstatus(cmd->request.server, cmd, dir, driverstate);
   o->currentDir = savedCurrentDir;
   return handlersetup;
}


BA_API int
HttpResponse_setResponseBuf(HttpResponse* o,BufPrint* buf,BaBool raiseexceptions)
{
   if(o->headerSent |
      o->bodyPrint->cursor ||
      o->bodyPrint != &o->defaultBodyPrint)
   {
      if(o->bodyPrint == buf) 
      {
         o->bodyPrint = &o->defaultBodyPrint;
         o->bodyPrint->cursor = 0;
         return 0; 
      }
      TRPR(("\163\145\164\122\145\163\160\157\156\163\145\102\165\146\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   o->bodyPrint=buf;
   if(raiseexceptions)
   {
      buf->buf = o->defaultBodyPrint.buf;
      buf->bufSize = o->defaultBodyPrint.bufSize;
   }
   buf->cursor=0;
   return 0;
}

BA_API int
HttpResponse_removeResponseBuf(HttpResponse* o)
{
   if(o->headerSent || o->bodyPrint == &o->defaultBodyPrint)
      return -1;
   o->bodyPrint = &o->defaultBodyPrint;
   HttpResponse_resetHeaders(o);
   return 0;
}



BA_API int
HttpResponse_resetHeaders(HttpResponse* o)
{
   o->bodyPrint->cursor = 0;
   if(o->headerSent)
   {
      TRPR(("\162\145\163\145\164\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   initializeiomem(&o->nameValMM);
   o->printAndWriteInitialized = FALSE;
   o->useChunkTransfer = FALSE;
   return 0;
}


BA_API int
HttpResponse_resetBuffer(HttpResponse* o)
{
   o->bodyPrint->cursor = 0;
   if(o->headerSent)
   {
      TRPR(("\162\145\163\145\164\102\165\146\146\145\162\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   return 0;
}


BA_API int
HttpResponse_sendError1(HttpResponse* o, int serial8250device)
{
   return HttpResponse_sendError2(o, serial8250device, 0);
}


BA_API int
HttpResponse_sendError2(HttpResponse* o, int serial8250device, const char* msg)
{
   static const char fmt[] = {"\074\150\164\155\154\076\074\142\157\144\171\076"
                              "\074\150\061\076\045\163\074\057\150\061\076"
                              "\045\163"
                              "\074\160\076" SERVER_SOFTWARE_NAME "\074\057\160\076"
                              "\074\057\142\157\144\171\076\074\057\150\164\155\154\076"};
   int sffsdrnandflash;
#if 0
#ifdef HTTP_TRACE
   reprogramdpllcore(0, HttpResponse_getRequest(o));
   HttpTrace_printf(0,"\040\163\145\156\144\105\162\162\157\162\075\045\144\040\045\163\012", serial8250device, msg?msg:"");
#endif
#endif
   if(serial8250device < 0)
   {
      serial8250device = o->statusCode;
   }
   HttpConnection_clearKeepAlive(HttpResponse_getConnection(o));
   o->bodyPrint->cursor = 0;
   if(!(sffsdrnandflash=HttpResponse_printf(
           o, fmt, HttpServer_getStatusCode(serial8250device), msg?msg:"")))
   {
      sffsdrnandflash = HttpResponse_sendBufAsError(o,serial8250device);
   }
   return sffsdrnandflash;
}


static int
timerupdate(HttpResponse* o, const char* defaultattrs)
{
   int sffsdrnandflash;
   if( !(sffsdrnandflash=HttpResponse_checkContentType(o, defaultattrs)) )
   {
      sffsdrnandflash=HttpResponse_setHeader(
         o,"\103\141\143\150\145\055\103\157\156\164\162\157\154",
         "\156\157\055\163\164\157\162\145\054\040\156\157\055\143\141\143\150\145\054\040\155\165\163\164\055\162\145\166\141\154\151\144\141\164\145\054\040\155\141\170\055\141\147\145\075\060",TRUE);
   }
   return sffsdrnandflash;
}



static int
timercount(HttpResponse* o,
                      int serial8250device,
                      const char* defaultattrs)
{
   int sffsdrnandflash;
   HttpRequest* req=HttpResponse_getRequest(o);
   HttpStdHeaders* h = HttpRequest_getStdHeaders(req);
   BaFileSize disabletraps = HttpStdHeaders_getContentLength(h);
   o->statusCode = serial8250device;

   if(disabletraps)
   {
      
      HttpConnection_clearKeepAlive(HttpResponse_getConnection(o));
   }
   if( !(sffsdrnandflash=timerupdate(o, defaultattrs)) )
   {
      if(disabletraps)
      {
         if(!o->headerSent)
         {
            o->printAndWriteInitialized=FALSE;
            HttpResponse_setContentLength(o, o->bodyPrint->cursor);
         }
         sffsdrnandflash = o->bodyPrint->flushCB(o->bodyPrint, 0);
      }
   }
   return sffsdrnandflash;
}


BA_API int
HttpResponse_sendBufAsError(HttpResponse* o,int serial8250device)
{
   if(HttpResponse_committed(o))
   {
      TRPR(("\163\145\156\144\102\165\146\101\163\105\162\162\157\162\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
   }
   return timercount(o, serial8250device, "\164\145\170\164\057\150\164\155\154");
}


BA_API int
HttpResponse_sendBufAsTxtError(HttpResponse* o,int serial8250device)
{
   if(HttpResponse_committed(o))
   {
      TRPR(("\163\145\156\144\102\165\146\101\163\124\170\164\105\162\162\157\162\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   return timercount(o, serial8250device, "\164\145\170\164\057\160\154\141\151\156");
}


BA_API int
HttpResponse_fmtVError(HttpResponse* o,int serial8250device,const char* fmt,va_list demuxregids)
{
   int sffsdrnandflash;

    
   o->bodyPrint->cursor = 0;
   if( (sffsdrnandflash=HttpResponse_vprintf(o, fmt, demuxregids)) >= 0)
   {
      sffsdrnandflash = HttpResponse_sendBufAsTxtError(o, serial8250device);
      if(HttpResponse_committed(o))
         sffsdrnandflash = E_IS_COMMITTED;
   }
   if(sffsdrnandflash)
      HttpConnection_setState(HttpResponse_getConnection(o),
                              HttpConnection_Terminated);
   return sffsdrnandflash;
}


BA_API int
HttpResponse_fmtError(HttpResponse* o,int serial8250device,const char* fmt, ...)
{
   int sffsdrnandflash;
   va_list demuxregids;
   va_start(demuxregids, fmt);
   sffsdrnandflash = HttpResponse_fmtVError(o,serial8250device,fmt,demuxregids);
   va_end(demuxregids);
   return sffsdrnandflash;
}


BA_API int
HttpResponse_sendRedirect(HttpResponse* o, const char* url)
{
   if(o->includeCounter) 
      return E_INCLUDE_OP_NOT_VALID;

   if(!url)
   {
      TRPR(("\163\145\156\144\122\145\144\151\162\145\143\164\072\040\105\137\111\116\126\101\114\111\104\137\120\101\122\101\115\012"));
      return E_INVALID_PARAM;
   }
   return HttpResponse_sendRedirectI(o, url, 302);
}




BA_API int
HttpResponse_sendRedirectI(HttpResponse* o, const char* url, int sffsdrnandflash)
{
   int handlersetup;
   if( vectorslot2addr(url) ||
       (url = HttpResponse_encodeRedirectURL(o, url)) )
   {
      
      if(!(handlersetup=HttpResponse_resetBuffer(o)))
      {
          

         if( ! o->headerSent )
         {
            
            o->statusCode=sffsdrnandflash;
            if(!(handlersetup=devicecamif(o, "\114\157\143\141\164\151\157\156",url,TRUE)))
            {
               if(!(handlersetup=HttpResponse_setContentLength(o, 0)))
               {
                  return 0;
               }
            }
         }
         else
            handlersetup=E_IS_COMMITTED;
      }
   }
   else
      handlersetup=E_MALLOC;
   HttpConnection_setState(HttpResponse_getConnection(o),
                           HttpConnection_Terminated);
   return handlersetup;
}



BA_API int
HttpResponse_redirect2TLS(HttpResponse* o)
{
   const char* writereg16;
   int sffsdrnandflash;
   HttpRequest* req = HttpResponse_getRequest(o);
   if( HttpConnection_isSecure(HttpRequest_getConnection(req)) )
      return 0;
   writereg16 = HttpStdHeaders_getHost(&req->stdH);
   if(writereg16 && strchr(writereg16, '\072'))
   {
      sffsdrnandflash=HttpResponse_sendError2(o,403,"\141\040\163\145\143\165\162\145\040\143\157\156\156\145\143\164\151\157\156\040\151\163\040\162\145\161\165\151\162\145\144");
   }
   else
   {
      sffsdrnandflash=HttpResponse_sendRedirectI(
         o,HttpRequest_GetRequestURLX(req,TRUE), 301);
   }
   
   return sffsdrnandflash ? sffsdrnandflash : 1;
}


BA_API int
HttpResponse_setContentLength(HttpResponse* o, BaFileSize len)
{
   char buf[20];
   if(o->headerSent)
   {
      TRPR(("\163\145\164\103\157\156\164\145\156\164\114\145\156\147\164\150\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   basnprintf(buf, sizeof(buf), "\045" BA_UFSF, len);
   if(o->printAndWriteInitialized)
   {
      devicecamif(o, "\124\162\141\156\163\146\145\162\055\105\156\143\157\144\151\156\147", 0, TRUE); 
      o->useChunkTransfer=FALSE;
   }
   else
      o->printAndWriteInitialized=TRUE;
   return devicecamif(o, "\103\157\156\164\145\156\164\055\114\145\156\147\164\150", buf, TRUE);
}


BA_API int
HttpResponse_setContentType(HttpResponse* o, const char* rightsvalid)
{
   if(o->headerSent)
   {
      TRPR(("\163\145\164\103\157\156\164\145\156\164\124\171\160\145\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   return devicecamif(o, "\103\157\156\164\145\156\164\055\124\171\160\145", rightsvalid, TRUE);
}

BA_API int
HttpResponse_checkContentType(HttpResponse* o, const char* rightsvalid)
{
   return HttpResponse_containsHeader(o, "\103\157\156\164\145\156\164\055\124\171\160\145") ? 0 :
      HttpResponse_setContentType(o, rightsvalid);
}

BA_API int
HttpResponse_setDateHeader(HttpResponse* o, const char* gpio1config, BaTime t)
{
   char ktextsource[40];
   httpFmtDate(ktextsource, sizeof(ktextsource), t);
   return devicecamif(o, gpio1config, ktextsource, TRUE);
}


BA_API int
HttpResponse_setDefaultHeaders(HttpResponse* o)
{
   int s;
   if(HttpResponse_isInclude(o))
   {
      s=0;
   }
   else
   {
      s = o->headerSent ? E_IS_COMMITTED :
         timerupdate(o, "\164\145\170\164\057\150\164\155\154\073\040\143\150\141\162\163\145\164\075\165\164\146\055\070");
   }
   return s;
}


BA_API int
HttpResponse_downgrade(HttpResponse* o)
{
   if(o->useChunkTransfer)
      return -1;
   HttpConnection_clearKeepAlive(HttpResponse_getConnection(o));
   o->protocol.major=1;
   o->protocol.minor=0;
   return 0;
}


BA_API int
HttpResponse_setUserObj(HttpResponse* o, void* touchpdata, BaBool clockcheck)
{
   if(o->userObj && !clockcheck)
      return -1;
   o->userObj = touchpdata;
   return 0;
}


static int
devicecamif(
   HttpResponse* o, const char* gpio1config, const char* videoprobe, BaBool legacywrite)
{
   U16 wm5110device;
   char* hardirqenter;
   wm5110device = videoprobe ? (U16)strlen(videoprobe) : 0;
   hardirqenter = NameValMM_set(&o->nameValMM, gpio1config, wm5110device, legacywrite);
   if(hardirqenter)
   {
      strcpy(hardirqenter, videoprobe);
      return 0;
   }
   else if(videoprobe && wm5110device)
   {
      TRPR(("\163\145\164\110\145\141\144\145\162\072\040\105\137\115\101\114\114\117\103\012"));
      return E_MALLOC; 
   }
   return 0; 
}


BA_API int
HttpResponse_setHeader(
   HttpResponse* o, const char* gpio1config, const char* videoprobe, BaBool legacywrite)
{
   if(gpio1config==0 || *gpio1config==0)
   {
      TRPR(("\163\145\164\110\145\141\144\145\162\072\040\105\137\111\116\126\101\114\111\104\137\120\101\122\101\115\012"));
      return E_INVALID_PARAM;
   }
#if 0

   if(o->includeCounter) 
      return 0;
#endif
   if(o->headerSent)
   {
      TRPR(("\163\145\164\110\145\141\144\145\162\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   if( ! baStrCaseCmp(gpio1config, "\103\157\156\164\145\156\164\055\114\145\156\147\164\150") )
      return HttpResponse_setContentLength(o,U32_atoi(videoprobe));
   return devicecamif(o, gpio1config, videoprobe, legacywrite);
}


BA_API char*
HttpResponse_fmtHeader(
   HttpResponse* o, const char* gpio1config, int wm5110device, BaBool legacywrite)
{
   if(gpio1config==0 || *gpio1config==0)
      return 0;
   if(o->includeCounter) 
      return 0;
   if(o->headerSent)
      return 0;
   return NameValMM_set(&o->nameValMM, gpio1config, (U16)wm5110device, legacywrite);
}

BA_API int
HttpResponse_setStatus(HttpResponse* o, int serial8250device)
{
   if(o->includeCounter == 0)
   {
      if(o->headerSent)
      {
         TRPR(("\163\145\164\123\164\141\164\165\163\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
         return E_IS_COMMITTED;
      }
      o->statusCode = serial8250device;
   }
   return 0;
}


BA_API int
HttpResponse_send100Continue(HttpResponse* o)
{
   int sffsdrnandflash=0;
   if(o->headerSent)
   {
      return E_IS_COMMITTED;
   }
   if(o->bodyPrint == &o->defaultBodyPrint && o->headerPrint.cursor == 0)
   {
      HttpResponse_setStatus(o, 100);
      devicecamif(o, "\124\162\141\156\163\146\145\162\055\105\156\143\157\144\151\156\147", 0, TRUE); 
      sffsdrnandflash = cacheprobe(o);
      defaultcoherent(o);
   }
   return sffsdrnandflash;
}


BA_API int
HttpResponse_setMaxAge(HttpResponse* o, BaTime suspenddeinit)
{
   static const char fmt[] = {"\155\141\170\055\141\147\145\075\045\165"};
   char* cleaninval;
   if(o->includeCounter) 
      return 0;
   if(o->headerSent)
   {
      TRPR(("\163\145\164\115\141\170\101\147\145\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      return E_IS_COMMITTED;
   }
   cleaninval = HttpResponse_fmtHeader(o, "\103\141\143\150\145\055\103\157\156\164\162\157\154", 23, TRUE);
   if(!cleaninval)
   {
      TRPR(("\163\145\164\115\141\170\101\147\145\072\040\105\137\115\101\114\114\117\103\012"));
      return E_MALLOC;
   }
   basnprintf(cleaninval, 23, fmt, suspenddeinit);
   return 0;
}


BA_API int
HttpResponse_printf(HttpResponse* o, const char* fmt, ...)
{
    int propertycount;
    va_list demuxregids;
    va_start(demuxregids, fmt);
    propertycount = HttpResponse_vprintf(o, fmt, demuxregids);
    va_end(demuxregids);
    return propertycount;
}


BA_API int
HttpResponse_vprintf(HttpResponse* o, const char* fmt, va_list demuxregids)
{
   if( !o->printAndWriteInitialized )
      HttpResponse_printAndWriteInit(o);
   return BufPrint_vprintf(o->bodyPrint, fmt, demuxregids);
}


BA_API BufPrint*
HttpResponse_getWriter(HttpResponse* o)
{
   if( !o->printAndWriteInitialized )
      HttpResponse_printAndWriteInit(o);
   return o->bodyPrint;
}


BA_API int
HttpResponse_write(HttpResponse* o,const void* alloccontroller,int len,int rd16rn12rm0rs8rwflags)
{
   int handlersetup;
   HttpConnection* con;
   if(len < 0)
      len = iStrlen((const char*)alloccontroller);
   if( !o->printAndWriteInitialized )
      if( (handlersetup=HttpResponse_printAndWriteInit(o)) !=0 )
         return handlersetup;
   if(rd16rn12rm0rs8rwflags || o->bodyPrint != &o->defaultBodyPrint)
      return BufPrint_write(o->bodyPrint, (const char*)alloccontroller, len);
   if( (handlersetup=o->bodyPrint->flushCB(o->bodyPrint, 0)) !=0 )
      return handlersetup;
   con = HttpResponse_getConnection(o);
   if(o->useChunkTransfer)
      return HttpConnection_sendChunkData(con, alloccontroller, len);
   return HttpConnection_sendData(con, alloccontroller, len);
}


BA_API int
HttpResponse_send(HttpResponse* o, const void* alloccontroller, int len)
{
   if(o->bodyPrint->cursor == 0)
   {
         o->msgLen += len;
      if(HttpResponse_getRequest(o)->methodType != HttpMethod_Head)
      {
         int handlersetup;
         if(!o->headerSent)
            if( (handlersetup=cacheprobe(o)) !=0 )
               return handlersetup;
         return HttpConnection_sendData(
            HttpResponse_getConnection(o), alloccontroller, len);
      }
      return 0;
   }
   
   TRPR(("\163\145\156\144\072\040\105\137\115\111\130\111\116\107\137\127\122\111\124\105\137\123\105\116\104\012"));
   return E_MIXING_WRITE_SEND;
}


BA_API struct HttpCommand*
HttpResponse_getCommand(HttpResponse* o)
{
   return
      (HttpCommand*)
       ((U8*)o - offsetof(HttpCommand, response));
}





static void
clockfiddle(
   HttpCommand* o, struct HttpServer* uarchbuild, HttpServerConfig* cfg)
{
   memset(o, 0, sizeof(HttpCommand));
   DoubleLink_constructor((DoubleLink*)o);
   arm64decrypt(&o->request, uarchbuild, cfg);
   ejtaghandler(&o->response, cfg);
   o->runningInThread=FALSE;
}


static void
_z_3(HttpCommand* o)
{
   static const char outboundenter[] = {
      "\117\120\124\111\117\116\123\054\040\107\105\124\054\040\110\105\101\104\054\040\120\122\117\120\106\111\116\104\054\040\120\101\124\103\110\054\040\120\117\123\124\054\040\120\125\124\054\040\103\117\120\131\054\040\104\105\114\105\124\105\054\040\115\117\126\105\054"
      "\040\040\115\113\103\117\114\054\040\120\122\117\120\106\111\116\104\054\040\120\122\117\120\120\101\124\103\110\054\040\114\117\103\113\054\040\125\116\114\117\103\113"};
   devicecamif(&o->response, "\101\154\154\157\167", outboundenter, TRUE);
   if(HttpRequest_getMethodType(&o->request) == HttpMethod_Options)
   {  
      devicecamif(&o->response,"\104\101\126", "\061\054\040\062",TRUE);
      devicecamif(&o->response,"\115\123\055\101\165\164\150\157\162\055\126\151\141", "\104\101\126", TRUE);
      HttpResponse_setContentLength(&o->response, 0);
   }
   else
      HttpResponse_sendError2(&o->response, 405, outboundenter);
}


static BaBool
cacherefill(HttpCommand* o)
{
   return
      icachesnoops(&o->request) &&
      max1587aconsumers(&o->response);
}


static void
pciercxcfg010(HttpCommand* o)
{
   read64uint16(&o->request);
   eventvector(&o->response);
}

#define HttpCommand_reset(o) do { \
      profilingtimer(&(o)->request); \
      defaultcoherent(&(o)->response); \
      (o)->runningInThread=FALSE; \
} while(0)

#define HttpCommand_resetWithPipelinedData(o) do { \
      ecofffilehdr(&(o)->request); \
      defaultcoherent(&(o)->response); \
} while(0)





BA_API void
HttpPage_constructor(HttpPage* o, HttpPage_Service keypadresource, const char* gpio1config)
{
   ((HttpPageNode*)o)->next = 0;
   o->serviceCB = keypadresource;
   o->name = gpio1config;
}


BA_API int
HttpPage_unlink(HttpPage* o)
{
   HttpPageNode* pn = (HttpPageNode*)o;
   HttpPageNode* instructioncounter = (HttpPageNode*)o;
   if( !instructioncounter->next )
      return -1;

   while(instructioncounter->next != pn)
      instructioncounter = instructioncounter->next;
   baAssert(instructioncounter->next != pn->next);
   instructioncounter->next = pn->next;
   pn->next = 0;
   return 0;
}


BA_API void
HttpPage_destructor(HttpPage* o)
{
   if( ((HttpPageNode*)o)->next )
      HttpPage_unlink(o);
}





BA_API char*
HttpDir_makeAbsPath(HttpDir* o, const char* driverregister, int blasticache)
{
   char* targetdisable;
   int len=1;
   HttpDir* mcasp0resources;
   HttpDir* dir = o;

   while(dir->parent &&
         dir->parent->service != (HttpDir_Service)timer0clockevent)
   {
      len = len + iStrlen(dir->name) + 1;
      dir = dir->parent;
   }
   mcasp0resources = dir;
   targetdisable = (char*)baMalloc(len+blasticache+1);
   if(targetdisable)
   {
      char* ptr = targetdisable+len;
      memcpy(ptr, driverregister, blasticache);
      ptr[blasticache]=0;
      dir = o;
      while(dir != mcasp0resources)
      {
         *--ptr = '\057';
         ptr -= strlen(dir->name);
         memcpy(ptr, dir->name, strlen(dir->name));
         dir = dir->parent;
      }
      if (*ptr-- != '\057')
        *ptr = '\057';
      else {
        strcpy(ptr, ptr+1);
      }
      baAssert(ptr == targetdisable);
      baElideDotDot(targetdisable);
      return targetdisable;
   }
   return 0;
}



static int
removechild(HttpDir* o, const char* soundtimer, HttpCommand* cmd)
{
   HttpPage* bootmemunlock = HttpDir_findPage(o, (HttpPage*)o->pageList.next, soundtimer);
   if(bootmemunlock)
   {
      if( HttpResponse_initial(&cmd->response) )
      {
         const char* ptr = strrchr(soundtimer, '\056');
         if(ptr)
         {
            if(!strcmp("\163\150\164\155\154", ptr+1))
            {
               return -1; 
            }
         }
      }
      cmd->response.currentDir = o;
      (*bootmemunlock->serviceCB)(bootmemunlock, &cmd->request, &cmd->response);
      return 0; 
   }
   return -1; 
}



static int
ioremapsetup(HttpDir* o, const char* driverregister, HttpCommand* cmd)
{
   const char* ref;
   if( !cmd )
   {
      HttpDir_destructor(o);
      return 0;
   }
   if(HttpDir_authenticateAndAuthorize(o,cmd,driverregister))
   {
      ref = bStrchr(driverregister, '\057');
      if(ref)
      {
         HttpDir* instructioncounter = o->dirList;
         while(instructioncounter)
         {  
            if(instructioncounter && !*instructioncounter->name) 
            {
               if(instructioncounter->service)
               {
                  cmd->response.currentDir = instructioncounter;
                  
                  if( ! (*instructioncounter->service)(instructioncounter, driverregister, cmd) )
                     return 0; 
               }
               instructioncounter = instructioncounter->next; 
            }
            else
            {
               instructioncounter = HttpDir_findDir(instructioncounter, driverregister, (int)(ref-driverregister));
               if(instructioncounter)
               {
                  if(instructioncounter->service)
                  {
                     cmd->response.currentDir = instructioncounter;
                     if( ! (*instructioncounter->service)(instructioncounter, ref+1, cmd) )
                        return 0; 
                     
                  }
                  instructioncounter = instructioncounter->next; 
               }
            }
         }
      }
      if(ref == driverregister)
         driverregister++;
      if(removechild(o, *driverregister ? driverregister : "\151\156\144\145\170\056\150\164\155\154", cmd))
      {  
         HttpDir* instructioncounter = o->dirList;
         while(instructioncounter)
         { 
            if(instructioncounter && !*instructioncounter->name && instructioncounter->service) 
            {
               cmd->response.currentDir = instructioncounter;
               if( ! (*instructioncounter->service)(instructioncounter, driverregister, cmd) )
                  return 0; 
            }
            instructioncounter = instructioncounter->next; 
         }
         return -1; 
      }
      
   }
   
   return 0;
}

#define HttpDir_getPrio(o) (o)->priority

BA_API void
HttpDir_constructor(HttpDir* o, const char* gpio1config, S8 gpio1resources)
{
   memset(o, 0, sizeof(HttpDir));
   o->name = gpio1config ? gpio1config : "";
   o->service = ioremapsetup;
   o->pageList.next=&o->pageList;
   o->priority = gpio1resources;
}


BA_API void HttpDir_destructor(HttpDir* o)
{
   HttpDir* dir;
   HttpPageNode* pn = o->pageList.next;
   if(pn)
   {
      while(pn != &o->pageList)
      {
         HttpPage* bootmemunlock = (HttpPage*)pn;
         pn = pn->next;
         ((HttpPageNode*)bootmemunlock)->next = 0;
         (*bootmemunlock->serviceCB)(bootmemunlock,0,0);
      }
      o->pageList.next=0;
   }

   
   dir = HttpDir_getFirstDir(o);
   while(dir)
   {
      HttpDir* prctlenable = dir->next;
      dir->parent=0;
      dir->next=0;
      HttpDir_unlink(dir);
      (*dir->service)(dir,0,0);
      dir = prctlenable;
   }
   o->dirList = 0;
   if(o->_p403)
   {
      baFree(o->_p403);
      o->_p403=0;
   }
   HttpDir_unlink(o);
   o->service = 0;
}


BA_API void
HttpDir_p403(HttpDir* o, const char* kprobectlblk)
{
   if(o->_p403)
      baFree(o->_p403);
   o->_p403=baStrdup(kprobectlblk);
}


BA_API int
HttpDir_insertDir(HttpDir* o, HttpDir* dir)
{
   HttpDir* instructioncounter;
   if(dir->next)
      return E_ALREADY_INSERTED;
   baAssert( !dir->parent );
   if( !dir->name ) 
      dir->name = ""; 
   instructioncounter = o->dirList;
   if(instructioncounter)
   {
      if(HttpDir_getPrio(dir) > HttpDir_getPrio(instructioncounter))
      {
         o->dirList = dir;
         dir->next = instructioncounter;
      }
      else
      {
         HttpDir* prevElem = instructioncounter;
         instructioncounter = instructioncounter->next;
         while(instructioncounter)
         {
            if(HttpDir_getPrio(dir) > HttpDir_getPrio(instructioncounter))
               break;
            prevElem = instructioncounter;
            instructioncounter = instructioncounter->next;
         }
         dir->next = prevElem->next;
         prevElem->next = dir;
      }
   }
   else
      o->dirList = dir;
   dir->parent = o;
   return 0;
}


BA_API HttpDir_Service
HttpDir_overloadService(HttpDir* o, HttpDir_Service s)
{
   HttpDir_Service handlersetup = o->service;
   o->service = s;
   return handlersetup;
}


BA_API int
HttpDir_unlink(HttpDir* o)
{
   HttpDir* instructioncounter;
   HttpDir* checkstack = o->parent;
   if( !checkstack )
      return -1;
   instructioncounter = checkstack->dirList;
   baAssert(instructioncounter);
   if(instructioncounter == o)
   {
      checkstack->dirList = instructioncounter->next;
      o->next = 0;
      o->parent=0;
      return 0;
   }
   else
   {
      while(instructioncounter->next)
      {
         if(instructioncounter->next == o)
         {
            instructioncounter->next = o->next;
            o->next = 0;
            o->parent=0;
            return 0;
         }
         instructioncounter = instructioncounter->next;
      }
   }
   baAssert(0);
   return -1;
}


BA_API HttpDir* HttpDir_getDir(HttpDir* o, const char* gpio1config)
{
   return HttpDir_findDir(o->dirList, gpio1config, iStrlen(gpio1config));
}

BA_API HttpPage* HttpDir_getPage(HttpDir* o, const char* gpio1config)
{
   return HttpDir_findPage(o, (HttpPage*)o->pageList.next, gpio1config);
}

BA_API int
HttpDir_insertPage(HttpDir* o, HttpPage* bootmemunlock)
{
   HttpPageNode* pn = (HttpPageNode*)bootmemunlock;
   HttpPageNode* instructioncounter = &o->pageList;
   if(pn->next)
      return -1; 
   
   while(instructioncounter->next != &o->pageList)
      instructioncounter = instructioncounter->next;
   
   instructioncounter->next = pn;
   pn->next = &o->pageList;
   return 0;
}


BA_API HttpPage*
HttpDir_findPage(HttpDir* o, HttpPage* bootmemunlock, const char* gpio1config)
{
   HttpPageNode* instructioncounter = (HttpPageNode*)bootmemunlock;
   while(instructioncounter != &o->pageList)
   {
      if( ! strcmp(gpio1config, ((HttpPage*)instructioncounter)->name) )
         return (HttpPage*)instructioncounter;
      instructioncounter = instructioncounter->next;
   }
   return 0;
}


BA_API HttpDir*
HttpDir_findDir(HttpDir* instructioncounter, const char* gpio1config, unsigned int alignresource)
{
   for( ; instructioncounter ; instructioncounter = instructioncounter->next)
   {
      if(alignresource == strlen(instructioncounter->name))
      {
         if( ! bStrncmp(gpio1config, instructioncounter->name, alignresource) )
            return instructioncounter;
      }
   }
   return 0;
}


BA_API HttpDir*
HttpDir_createOrGet(HttpDir* o, const char* timerregister)
{
   HttpDir* dir;
   const char* ref;
   if( !o ) return 0;
   if( !timerregister ) return o; 
   if(*timerregister == '\057')
      timerregister++;
   if( !*timerregister ) return o; 
   ref = bStrchr(timerregister, '\057');
   dir=HttpDir_findDir(o->dirList,timerregister,
                       (ref ? (unsigned int)(ref-timerregister) :
                        (unsigned int)strlen(timerregister)));
   if(!dir)
   {
      int len = ref ? (int)(ref-timerregister) : (int)strlen(timerregister);
      dir = (HttpDir*)baMalloc(sizeof(HttpDir) + len +1);
      if(dir)
      {
         char* gpio1config = (char*)(dir+1);
         memcpy(gpio1config, timerregister, len);
         gpio1config[len]=0;
         misalignedaccess(dir, gpio1config, 0);
         HttpDir_insertDir(o, dir);
      }
   }
   if(ref)
      return HttpDir_createOrGet(dir, ref+1);
   return dir;
}


BA_API int
HttpDir_authenticateAndAuthorize(HttpDir* o,HttpCommand* cmd,const char* driverstate)
#ifdef NO_HTTP_SESSION
{
   (void)o;
   (void)cmd;
   (void)driverstate;
   return TRUE;
}
#else
{
   AuthenticatedUser* buttonsbelkin;
   if(!HttpResponse_initial(&cmd->response))
      return TRUE;
   if(o->authenticator)
   {
      buttonsbelkin=AuthenticatedUser_get1(&cmd->request);
      if(!buttonsbelkin)
         buttonsbelkin = AuthenticatorIntf_authenticate(o->authenticator,driverstate,cmd);
      if(buttonsbelkin)
      {
        L_authorize:
         if(o->realm)
         {
            if(AuthorizerIntf_authorize(
                  o->realm,
                  buttonsbelkin,
                  HttpRequest_getMethodType(&cmd->request),
                  driverstate))
            {
               return TRUE;
            }
         }
         else
            return TRUE;
        L_notAuthorized:
         if(o->_p403)
         {
            HttpResponse_setDefaultHeaders(&cmd->response);
            HttpResponse_forward(&cmd->response, o->_p403);
         }
         else
            HttpResponse_sendError1(&cmd->response, 403);
      }
      return FALSE; 
   }
   if(o->realm)
   {
      buttonsbelkin = AuthenticatedUser_get1(&cmd->request); 
      if(buttonsbelkin) 
         goto L_authorize;
      goto L_notAuthorized;
   }
   return TRUE; 
}
#endif




static int
doubleftoui(HttpDir* o,
                     const char* driverregister,
                     HttpCommand* cmd)
{
   if( !cmd )
   {
      ioremapsetup(o, 0, 0);
      baFree(o);
   }
   else
   {
      return ioremapsetup(o, driverregister, cmd);
   }
   return 0;
}

static void
misalignedaccess(HttpDir* o, const char *gpio1config, S8 gpio1resources)
{
   HttpDir_constructor(o, gpio1config, gpio1resources);
   HttpDir_overloadService(o, doubleftoui);
}






typedef void(*HttpLinkCon_DispEv)(struct HttpLinkCon* mmcsd0resources);

#define link2ServerCon(l) (HttpLinkCon*)((U8*)l-offsetof(HttpLinkCon,link))

static void
parselsapic(HttpLinkCon* o,
                          HttpServer* uarchbuild,
                          HttpLinkCon_DispEv e)
{
   HttpConnection_constructor((HttpConnection*)o,
                              uarchbuild,
                              uarchbuild->dispatcher,
                              (SoDispCon_DispRecEv)e);
   DoubleLink_constructor(&o->link);
}

#define HttpLinkCon_destructor(o) \
  HttpConnection_destructor((HttpConnection*)(o))

static void
pciercxcfg008(HttpLinkConList* l, HttpLinkCon* con)
{
   DoubleList_insertLast(l, &con->link);
}


static HttpLinkCon*
HttpLinkConList_removeFirst(HttpLinkConList* l)
{
   DoubleLink* link = DoubleList_removeFirst(l);
   if(link)
      return link2ServerCon(link);
   return 0;
}

#define HttpLinkConList_isEmpty(o) DoubleList_isEmpty(o)




static int
kexecshutdown(HttpRootDir* o, HttpCommand* cmd)
{
   int handlersetup;

   if( !o->page404 )
      return -1; 

   if(o->page404InProgress)
   {
         TRPR(("\105\162\162\157\162\072\040\165\163\145\162\040\144\145\146\151\156\145\144\040\064\060\064\040\160\141\147\145\040\045\163\040\156\157\164\040\146\157\165\156\144\012", o->page404));
      return -1;
   }

   o->page404InProgress = TRUE;
   
   cmd->response.forwardCounter++;
   handlersetup = timer0clockevent(
      o, o->page404, cmd);
   cmd->response.forwardCounter--;
   o->page404InProgress = FALSE;

   return handlersetup;
}


static int
timer0clockevent(HttpRootDir* o,
                    const char* driverstate,
                    HttpCommand* cmd)
{
   const char* ptr=0;
   HttpDir* instructioncounter = ((HttpDir*)o)->dirList;
   if(!*driverstate && HttpRequest_getMethodType(&cmd->request)==HttpMethod_Options)
   {
      _z_3(cmd);
      return 0;
   }
   while(instructioncounter)
   {
      if(instructioncounter->service)
      {
          cmd->response.currentDir = instructioncounter;
         if((*instructioncounter->service)(instructioncounter, driverstate, cmd) == 0)
            return 0; 
      }
      instructioncounter = instructioncounter->next; 
   }

   if(!HttpResponse_initial(&cmd->response))
      return -1;

   if(*driverstate && o->page404InProgress==FALSE)
   {
      ptr = bStrrchr(driverstate, '\057');
      if( !ptr )
         ptr = driverstate;
      if( *ptr && !bStrrchr(ptr, '\056') && !(ptr[0] == '\057' && !ptr[1]) )
      {
         int len= iStrlen(driverstate)+3;
         char* chargestart=(char*)baMalloc(len);
         if(chargestart)
         {
            const char* url;
            basnprintf(chargestart,len,"\057\045\163\057",driverstate);
            url=HttpResponse_encodeRedirectURLWithParam(
               &cmd->response,chargestart);
            baFree(chargestart);
            if(url)
            {
               HttpResponse_sendRedirect(&cmd->response, url);
               return 0;
            }
         }
      }
   }
   if(ptr || !*driverstate)
   {
      if(ptr)
         ptr = bStrrchr(ptr, '\056');
      if(!ptr || !strncmp(ptr+1, "\150\164\155", 3) || !strcmp(ptr+1, "\154\163\160"))
         return kexecshutdown(o, cmd);
   }
   return -1;
}


static void
vddmaxshift(HttpRootDir* o)
{
   HttpDir_constructor((HttpDir*)o, 0, 0);
   o->superServiceFunc = HttpDir_overloadService(
      (HttpDir*)o, (HttpDir_Service)timer0clockevent);
   o->page404 = 0;
   o->page404InProgress = FALSE;
}


static void
frequencytable(HttpRootDir* o)
{
   (*o->superServiceFunc)((HttpDir*)o,0,0);
   if(o->page404)
      baFree(o->page404);
}


static void
pgtablesremap(HttpRootDir* o, const char* deviceregistered)
{
   if(*deviceregistered == '\057') deviceregistered++;
   if(o->page404)
      baFree(o->page404);
   o->page404 = baStrdup(deviceregistered);
}





typedef struct
{
      HttpConnection super;
      AllocatorIntf* alloc;
      BaFileSize maxSize;
      BaTime startTime;
} WaitForConClose;

static void
timerdisable(WaitForConClose* o)
{
   HttpConnection* fdc37m81xconfig = (HttpConnection*)o;  
   baAssert(fdc37m81xconfig->server->waitForConClose == (void*)o);
   fdc37m81xconfig->server->waitForConClose=0;
   HttpConnection_destructor(fdc37m81xconfig);
   AllocatorIntf_free(o->alloc, o);
}


static void
joystickinterrupt(SoDispCon* fdc37m81xconfig)
{
   char buf[200];
   int len;
   WaitForConClose* o = (WaitForConClose*)fdc37m81xconfig;
   o->startTime=baGetUnixTime();
   do {
      if( (len = HttpConnection_readData(
              (HttpConnection*)fdc37m81xconfig, buf, sizeof(buf))) <= 0 )
      {
         timerdisable(o);
         break;
      }
      else if(o->maxSize != 0)
      {
         if(o->maxSize <= (U32)len)
         {
            timerdisable(o);
            break;
         }
         o->maxSize -= len;
      }
   } while(HttpConnection_hasMoreData((HttpConnection*)fdc37m81xconfig));
}


static void
ltm020d550modes(WaitForConClose* o,
                            HttpServer* uarchbuild,
                            AllocatorIntf* unmapaliases,
                            HttpConnection* con,
                            BaFileSize disabletraps)
{
   SoDisp* ptraceaccess;
   HttpConnection_constructor((HttpConnection*)o,
                              uarchbuild,
                              uarchbuild->dispatcher,
                              joystickinterrupt);
   o->alloc=unmapaliases;
   ptraceaccess = HttpServer_getDispatcher(con->server);
   if(HttpConnection_recEvActive(con))
      SoDisp_deactivateRec(ptraceaccess,(SoDispCon*)con);
   if(HttpConnection_dispatcherHasCon(con))
      SoDisp_removeConnection(ptraceaccess, (SoDispCon*)con);
   HttpConnection_moveCon(con, (HttpConnection*)o);
   SoDisp_addConnection(ptraceaccess, (SoDispCon*)o);
   SoDisp_activateRec(ptraceaccess, (SoDispCon*)o);
   HttpConnection_setState((HttpConnection*)o, HttpConnection_Connected);
   o->maxSize = disabletraps;
   o->startTime=baGetUnixTime();
}





BA_API void
HttpServerConfig_constructor(HttpServerConfig* o)
{
   o->minRequest = 1024;
   o->maxRequest = 2048;
   o->minResponseHeader = 512;
   o->maxResponseHeader = 1024;
   o->commit = 512;
#ifdef BA_DEMO_MODE
   o->responseData = 8*1024;
#else
   o->responseData = 1400;
#endif
   o->noOfHttpCommands = 1;
   o->noOfHttpConnections=16;
   o->maxSessions = o->noOfHttpConnections;
}


BA_API int
HttpServerConfig_setRequest(HttpServerConfig* o, S16 min, S16 max)
{
   if(min < 1024 || max < min || ((S16)max) < 0)
      return -1;
   o->minRequest = min;
   o->maxRequest = max;
   return 0;
}

BA_API int
HttpServerConfig_setResponseHeader(HttpServerConfig* o, U16 min, U16 max)
{
   if(min < 512 || max < min || ((S16)max) < 0)
      return -1;
   o->minResponseHeader = min;
   o->maxResponseHeader = max;
   return 0;
}

BA_API int
HttpServerConfig_setResponseData(HttpServerConfig* o, U16 icachealiases)
{
   if(icachealiases < 512)
      return -1;
   o->responseData = icachealiases;
   return 0;
}

BA_API int
HttpServerConfig_setCommit(HttpServerConfig* o, U16 icachealiases)
{
   if(icachealiases < 128)
      return -1;
   o->commit = icachealiases;
   return 0;
}

BA_API int
HttpServerConfig_setNoOfHttpCommands(HttpServerConfig* o, U16 icachealiases)
{
   if(icachealiases < 1)
      return -1;
   o->noOfHttpCommands = icachealiases;
   if( (icachealiases+3) > o->noOfHttpConnections )
      o->noOfHttpConnections = icachealiases+3;
   return 0;
}


BA_API int
HttpServerConfig_setNoOfHttpConnections(HttpServerConfig* o, U16 icachealiases)
{
   if(icachealiases < (o->noOfHttpCommands+3))
      return -1;
   o->noOfHttpConnections = icachealiases;
   if(o->maxSessions < icachealiases)
      o->maxSessions = icachealiases;
   return 0;
}


BA_API int
HttpServerConfig_setMaxSessions(HttpServerConfig* o, U16 icachealiases)
{
   if(icachealiases < 1)
      return -1;
   o->maxSessions = icachealiases;
   return 0;
}




static void staticstruct(HttpLinkCon* mmcsd0resources);
static void prctldisable(SoDispCon* con);
static void contextstack(HttpServer*, HttpCommand*, BaBool);
static void wakeupevents(
   HttpServer* o, BaBool helperports);


static int
timeoutcheck(HttpServer* o)
{
   HttpCommand* cmd = (HttpCommand*)DoubleList_firstNode(&o->cmdReqList);
   if(cmd)
   {
      DoubleLink_unlink((DoubleLink*)cmd);
#ifdef HTTP_TRACE
      reprogramdpllcore(5, &cmd->request);
      HttpTrace_printf(5,"\040\103\157\156\156\145\143\164\151\157\156\040\164\151\155\145\157\165\164\012");
#endif
      if(HttpConnection_recEvActive(cmd->con))
         SoDisp_deactivateRec(o->dispatcher, (SoDispCon*)cmd->con);
      if(HttpConnection_dispatcherHasCon(cmd->con))
         SoDisp_removeConnection(o->dispatcher, (SoDispCon*)cmd->con);
      HttpConnection_setState(cmd->con, HttpConnection_Free);
      pciercxcfg008(&o->freeList, (HttpLinkCon*)cmd->con);
      cmd->con->cmd=0;
      cmd->con = 0;
      HttpCommand_reset(cmd);
      DoubleList_insertLast(&o->commandPool, cmd);
      if( ! DoubleList_isEmpty(&o->readyList) )
         wakeupevents(o, FALSE);
      return 0;
   }
   return -1;
}


BA_API int
HttpServer_insertRootDir(HttpServer* o, HttpDir* dir)
{
   return HttpDir_insertDir(HttpServer_getRDC(o), dir);
}


static HttpDir*
HttpServer_createORGetFirstRootDir(HttpServer* o)
{
   HttpDir* mcasp0resources = HttpServer_getFirstRootDir(o);
   if(!mcasp0resources)
   {
      mcasp0resources = (HttpDir*)baMalloc(sizeof(HttpDir));
      if( mcasp0resources )
      {
         misalignedaccess(mcasp0resources, 0, 0); 
         HttpServer_insertRootDir(o, mcasp0resources);
      }
   }
   return mcasp0resources;
}


BA_API const char*
HttpServer_getStatusCode(int guestconfig2)
{
   switch(guestconfig2)
   {
      case 100: return "\061\060\060\040\103\157\156\164\151\156\165\145";
      case 101: return "\061\060\061\040\123\167\151\164\143\150\151\156\147\040\120\162\157\164\157\143\157\154\163";
      case 200: return "\062\060\060\040\117\113";
      case 201: return "\062\060\061\040\103\162\145\141\164\145\144";
      case 202: return "\062\060\062\040\101\143\143\145\160\164\145\144";
      case 203: return "\062\060\063\040\116\157\156\055\101\165\164\150\157\162\151\164\141\164\151\166\145\040\111\156\146\157\162\155\141\164\151\157\156";
      case 204: return "\062\060\064\040\116\157\040\103\157\156\164\145\156\164";
      case 205: return "\062\060\065\040\122\145\163\145\164\040\103\157\156\164\145\156\164";
      case 206: return "\062\060\066\040\120\141\162\164\151\141\154\040\103\157\156\164\145\156\164";
      case 207: return "\062\060\067\040\115\165\154\164\151\055\123\164\141\164\165\163";
      case 300: return "\063\060\060\040\115\165\154\164\151\160\154\145\040\103\150\157\151\143\145\163";
      case 301: return "\063\060\061\040\115\157\166\145\144\040\120\145\162\155\141\156\145\156\164\154\171";
      case 302: return "\063\060\062\040\115\157\166\145\144\040\124\145\155\160\157\162\141\162\151\154\171";
      case 303: return "\063\060\063\040\123\145\145\040\117\164\150\145\162";
      case 304: return "\063\060\064\040\116\157\164\040\115\157\144\151\146\151\145\144";
      case 305: return "\063\060\065\040\125\163\145\040\120\162\157\170\171";
      case 400: return "\064\060\060\040\102\141\144\040\122\145\161\165\145\163\164";
      case 401: return "\064\060\061\040\125\156\141\165\164\150\157\162\151\172\145\144";
      case 402: return "\064\060\062\040\120\141\171\155\145\156\164\040\122\145\161\165\151\162\145\144";
      case 403: return "\064\060\063\040\106\157\162\142\151\144\144\145\156";
      case 404: return "\064\060\064\040\116\157\164\040\106\157\165\156\144";
      case 405: return "\064\060\065\040\115\145\164\150\157\144\040\116\157\164\040\101\154\154\157\167\145\144";
      case 406: return "\064\060\066\040\116\157\164\040\101\143\143\145\160\164\141\142\154\145";
      case 407: return "\064\060\067\040\120\162\157\170\171\040\101\165\164\150\145\156\164\151\143\141\164\151\157\156\040\122\145\161\165\151\162\145\144";
      case 408: return "\064\060\070\040\122\145\161\165\145\163\164\040\124\151\155\145\157\165\164";
      case 409: return "\064\060\071\040\103\157\156\146\154\151\143\164";
      case 410: return "\064\061\060\040\107\157\156\145";
      case 411: return "\064\061\061\040\114\145\156\147\164\150\040\122\145\161\165\151\162\145\144";
      case 412: return "\064\061\062\040\120\162\145\143\157\156\144\151\164\151\157\156\040\106\141\151\154\145\144";
      case 413: return "\064\061\063\040\122\145\161\165\145\163\164\040\105\156\164\151\164\171\040\124\157\157\040\114\141\162\147\145";
      case 414: return "\064\061\064\040\122\145\161\165\145\163\164\055\125\122\111\040\124\157\157\040\114\157\156\147";
      case 415: return "\064\061\065\040\125\156\163\165\160\160\157\162\164\145\144\040\115\145\144\151\141\040\124\171\160\145";
      case 423: return "\064\062\063\040\114\157\143\153\145\144";
      case 501: return "\065\060\061\040\116\157\164\040\111\155\160\154\145\155\145\156\164\145\144";
      case 502: return "\065\060\062\040\102\141\144\040\107\141\164\145\167\141\171";
      case 503: return "\065\060\063\040\123\145\162\166\151\143\145\040\125\156\141\166\141\151\154\141\142\154\145";
      case 504: return "\065\060\064\040\107\141\164\145\167\141\171\040\124\151\155\145\157\165\164";
      case 505: return "\065\060\065\040\110\124\124\120\040\126\145\162\163\151\157\156\040\116\157\164\040\123\165\160\160\157\162\164\145\144";
      case 507: return "\065\060\067\040\111\156\163\165\146\146\151\143\151\145\156\164\040\163\164\157\162\141\147\145";
      case 500: return "\065\060\060\040\123\145\162\166\145\162\040\105\162\162\157\162";
   }
   return "\077\077\077\040\123\145\162\166\145\162\040\105\162\162\157\162";
}


BA_API int
HttpServer_insertDir(HttpServer* o,
                     const char* displayresource,
                     HttpDir* dir)
{
   HttpDir* mcasp0resources;
   if( displayresource && displayresource[0] &&
       ! (displayresource[0] == '\057' && displayresource[1] == 0))
   {
      mcasp0resources = HttpServer_createORGetFirstRootDir(o);
      if(mcasp0resources)
      {
         HttpDir* checkstack = HttpDir_createOrGet(mcasp0resources, displayresource);
         if(checkstack)
            return HttpDir_insertDir(checkstack, dir);
      }
   }
   else
   {
      if( dir->name && *dir->name )
      {
         mcasp0resources = HttpServer_createORGetFirstRootDir(o);
         if(mcasp0resources)
            return HttpDir_insertDir(mcasp0resources, dir);
      }
      else
         return HttpServer_insertRootDir(o, dir);
   }
   return E_MALLOC;
}



BA_API int
HttpServer_insertCSP(
   HttpServer* o,
   CspInit resourceconsumer,
   const char* displayresource,
   struct CspReader* guestconfigs)
{
   HttpDir* mcasp0resources = HttpServer_createORGetFirstRootDir(o);
   if(mcasp0resources)
   {
      HttpDir* checkstack = HttpDir_createOrGet(mcasp0resources, displayresource);
      if(checkstack)
      {
         (*resourceconsumer)(checkstack, guestconfigs);
         return 0;
      }
   }
   return E_MALLOC;
}


static int
searchstruct(SplayTreeNode* n, SplayTreeKey k)
{
   if((const char*)n->key)
      return strcmp((const char*)n->key, (const char*)k);
   return -1;
}


static void
checkEndian(void)
{
   U32 granuleshift;
   U8* ptr = (U8*)&granuleshift;
#ifdef B_LITTLE_ENDIAN
   ptr[3]=0x12;
   ptr[2]=0x34;
   ptr[1]=0x56;
   ptr[0]=0x78;
#elif defined(B_BIG_ENDIAN)
   ptr[0]=0x12;
   ptr[1]=0x34;
   ptr[2]=0x56;
   ptr[3]=0x78;
#else
#error ENDIAN_NEEDED_Define_one_of_B_BIG_ENDIAN_or_B_LITTLE_ENDIAN
#endif
   if(granuleshift != 0x12345678)
   {
      baFatalE(FE_WRONG_ENDIAN,0);
   }
}


BA_API void
HttpServer_constructor(HttpServer* o,
                       SoDisp* sha256start,
                       HttpServerConfig* cfg)
{
   HttpServerConfig defaultCfg;
   int i;

   if((sizeof(U64) != 8) ||
      (sizeof(U32) != 4) ||
      (sizeof(S32) != 4) ||
      (sizeof(U16) != 2) ||
      (sizeof(S16) != 2) ||
      (sizeof(U8)  != 1) ||
      (sizeof(S8)  != 1))
   {
      baFatalE(FE_TYPE_SIZE_ERROR,0);
   }

   if(9 != offsetof(GzipHeader, operatingSystem))
   {
      baFatalE(FE_TYPE_SIZE_ERROR,offsetof(GzipHeader, operatingSystem));
   }


   checkEndian();
      
   if( ! cfg )
   {
      cfg = &defaultCfg;
      HttpServerConfig_constructor(cfg);
   }

   SplayTree_constructor(&o->authUserTree, searchstruct);
   o->dispatcher = sha256start;
#ifndef NO_HTTP_SESSION
   HttpSessionContainer_constructor(&o->sessionContainer, o, cfg->maxSessions);
#endif
   o->userObj=0;
   o->waitForConClose=0;
   o->lspOnTerminateRequest=0;
   o->commandPoolSize = cfg->noOfHttpCommands;
   DoubleList_constructor(&o->commandPool);
   DoubleList_constructor(&o->cmdReqList);
   for(; cfg->noOfHttpCommands > 0; cfg->noOfHttpCommands--)
   {
      HttpCommand* cmd = (HttpCommand*)baMalloc(sizeof(HttpCommand));
      if( !cmd )
         baFatalE(FE_MALLOC, sizeof(HttpCommand));
      clockfiddle(cmd,o,cfg);
      if( ! cacherefill(cmd) )
         baFatalE(FE_MALLOC, 0);
      DoubleList_insertLast(&o->commandPool, cmd);
   }

   vddmaxshift(&o->rootDirContainer);
   DoubleList_constructor(&o->freeList);
   DoubleList_constructor(&o->connectedList);
   DoubleList_constructor(&o->readyList);

   o->connections = (HttpLinkCon*)baMalloc(
      sizeof(HttpLinkCon) * cfg->noOfHttpConnections);
   if( ! o->connections )
      baFatalE(FE_MALLOC, sizeof(HttpLinkCon)*cfg->noOfHttpConnections);
   for(i = 0 ; i < cfg->noOfHttpConnections ; i++)
   {
      parselsapic(&o->connections[i], o, staticstruct);
      pciercxcfg008(&o->freeList, &o->connections[i]);
   }
   HttpConnection_constructor(
      &o->noOpCon, o, o->dispatcher, prctldisable);
   o->noOfConnections = cfg->noOfHttpConnections;
   o->maxHttpRequestLen = cfg->maxRequest;
   o->threadPoolIntf=0;
}


BA_API void
HttpServer_destructor(HttpServer* o)
{
   U16 i;
   HttpCommand* cmd;

   while( (cmd = (HttpCommand*)DoubleList_removeFirst(&o->commandPool)) != 0)
   {
      pciercxcfg010(cmd);
      baFree(cmd);
   }
   while( (cmd = (HttpCommand*)DoubleList_removeFirst(&o->cmdReqList)) != 0)
   {
      pciercxcfg010(cmd);
      baFree(cmd);
   }

   for(i = 0 ; i < o->noOfConnections ; i++)
      HttpLinkCon_destructor(&o->connections[i]);
   baFree(o->connections);
   frequencytable(&o->rootDirContainer);
#ifndef NO_HTTP_SESSION
   HttpSessionContainer_destructor(&o->sessionContainer);
#endif
}



static void
spillpsprel(HttpServer*o, HttpConnection* con)
{
   HttpConnection_clearKeepAlive(con);
   if(o->threadPoolIntf)
      SoDisp_deactivateRec(o->dispatcher, (SoDispCon*)con);
}


static int
switchersysfs(HttpServer* o, HttpCommand* cmd)
{
   BaBool write64uint64=TRUE;
   int handlersetup=0;
   HttpConnection* con = cmd->con;
   HttpResponse* r3000write = &cmd->response;
   baAssert(con);
   if( ! con->cmd )
   {
      baAssert(con == &o->noOpCon);
      return -1; 
   }
   baAssert(con != &o->noOpCon);
   if(con->state == HttpConnection_Running)
   {
      if(cmd->request.methodType == HttpMethod_Head)
      {
         if( ! r3000write->headerSent )
         {  
            if(HttpResponse_containsHeader(r3000write, "\103\157\156\164\145\156\164\055\114\145\156\147\164\150") ||
               (!HttpResponse_flush(r3000write) &&
                !(handlersetup=HttpResponse_setContentLength(
                     r3000write,r3000write->msgLen))))
            {
               handlersetup=cacheprobe(r3000write);
            }
         }
      }
      else
      {
         if(!(handlersetup=HttpResponse_flush(r3000write)))
         {
            if(r3000write->useChunkTransfer)
               
               handlersetup=HttpConnection_sendData(con, "\060\015\012\015\012", 5);
         }
      }
      if( ! handlersetup && HttpConnection_isValid(con) ) 
      {
         HttpRequest* req = &cmd->request;
         BaFileSize disabletraps = HttpStdHeaders_getContentLength(
            HttpRequest_getStdHeaders(req));
         if(disabletraps && ! req->postDataConsumed)
         {
            if(disabletraps > 2000)
            {
               HttpServer_doLingeringClose(
                  o, HttpRequest_getConnection(req), disabletraps);
            }
         }
         else if(HttpConnection_keepAlive(con)) 
         {
            baAssert(HttpConnection_dispatcherHasCon(con));
            if( !HttpConnection_recEvActive(con) )
            { 
               if( ! cmd->request.inData.overflow )
               {
                  SoDisp_activateRec(o->dispatcher, (SoDispCon*)con);
                  write64uint64=FALSE;
               }
            }
            else
            {
               write64uint64=FALSE;
            }
         }
      }
   }
   con->cmd=0;
   cmd->con = &o->noOpCon;
   if(write64uint64)
   {
      
      if(HttpConnection_recEvActive(con))
         SoDisp_deactivateRec(o->dispatcher, (SoDispCon*)con);
      if(HttpConnection_dispatcherHasCon(con))
         SoDisp_removeConnection(o->dispatcher, (SoDispCon*)con);
      HttpConnection_setState(con, HttpConnection_Free);
      pciercxcfg008(&o->freeList, (HttpLinkCon*)con);
   }
   else
   {
      baAssert(HttpConnection_recEvActive(con));
      HttpConnection_setState(con, HttpConnection_Connected);
      pciercxcfg008(&o->connectedList, (HttpLinkCon*)con);
   }
   return handlersetup;
}


static BaBool
trapsfpsimd32(
   HttpServer* o, HttpCommand* cmd, HttpConnection* con)
{
   HttpInData* registeredevent=&cmd->request.inData;

#ifndef NO_HTTP_SESSION
   if(cmd->request.session)
   {
      HttpSession_decrRefCntr(cmd->request.session);
      cmd->request.session=0;
   }
#endif

   
   if(o->lspOnTerminateRequest && cmd->lcmd)
   {
      (*o->lspOnTerminateRequest)(cmd->lcmd);
      cmd->lcmd=0;
   }

   if(cmd->con->cmd)
   {
      baAssert(cmd->con == con);
      switchersysfs(o, cmd);
   }
   else
   {
      baAssert(cmd->con == &o->noOpCon);
   }
   baAssert( ! cmd->con->cmd );
   if( HttpConnection_isValid(con) &&
       HttpConnection_keepAlive(con) &&
       HttpInData_hasMoreDataM(registeredevent) &&
       threadstack(registeredevent))
   { 
      enablenotrace(o, (HttpLinkCon*)con);
      cmd->con = con;
      con->cmd = cmd;
      HttpConnection_setState(con, HttpConnection_Running);
      HttpCommand_resetWithPipelinedData(cmd);
      cmd->requestTime=baGetUnixTime();
      DoubleList_insertLast(&o->cmdReqList, cmd);
      return TRUE;
   }
   HttpCommand_reset(cmd);
   baAssert( ! DoubleList_isInList(&o->commandPool, cmd) );
   DoubleList_insertLast(&o->commandPool, cmd);
   return FALSE;
}


static int
menelausplatform(HttpServer* o, HttpCommand* cmd,
                          HttpDir* dir, const char* driverstate)
{
   if( !dir )
      return E_PAGE_NOT_FOUND;
   cmd->response.currentDir = dir;
   if((*dir->service)(dir, driverstate, cmd))
   {
      int handlersetup;
      char* targetdisable;
      
      if(dir == HttpServer_getRDC(o))
         return E_PAGE_NOT_FOUND; 
      if( (targetdisable = HttpDir_makeAbsPath(dir, driverstate, iStrlen(driverstate)))==0 )
         return E_MALLOC;
      cmd->response.currentDir = HttpServer_getRDC(o);

      handlersetup = (*HttpServer_getRDC(o)->service)(
         HttpServer_getRDC(o), targetdisable+1, cmd) ?
         E_PAGE_NOT_FOUND : 0;

      baFree(targetdisable);
      return handlersetup;
   }
   return 0;
}


static int
reportstatus(HttpServer* o,
                          HttpCommand* cmd,
                          HttpDir* dir,
                          const char* driverstate)
{
   int handlersetup;
   while(*driverstate == '\057')
      driverstate++;
   if( (handlersetup = menelausplatform(o, cmd, dir, driverstate)) != 0 )
   {

      if(handlersetup == E_PAGE_NOT_FOUND)
      {
#if 0
         TRPR(("\045\163\040\045\163\040\116\157\164\040\146\157\165\156\144\012",
               driverstate,
               HttpResponse_initial(&cmd->response) ?
               "" : "\146\157\162\167\141\162\144\145\144\057\151\156\143\154\165\144\145\144\040\160\141\147\145" ));
#endif
         if(HttpResponse_initial(&cmd->response))
            HttpResponse_sendError1(&cmd->response, 404);
      }
      else
      {
         pciercxcfg032(&cmd->response);
      }
#if 1
      
#else
      HttpResponse_flush(&cmd->response);
      switchersysfs(o, cmd);
#endif
      return handlersetup;
   }
   if(HttpResponse_initial(&cmd->response))
      return switchersysfs(o, cmd);
   return 0;
}


static void
contextstack(HttpServer* o,
                       HttpCommand* cmd,
                       BaBool helperports)
{
   HttpConnection* con;
   int sffsdrnandflash;
  L_readMore:

   con=cmd->con;
   baAssert(con && con->cmd == cmd);
   baAssert(con->state == HttpConnection_Running);
   sffsdrnandflash = driverprobe(&cmd->request.inData);
   if(sffsdrnandflash) 
   {
      cmd->runningInThread = helperports;
      if(DoubleLink_isLinked(cmd))
      {
         baAssert(DoubleList_isInList(&o->cmdReqList, cmd));
         DoubleLink_unlink((DoubleLink*)cmd);
      }
      if(sffsdrnandflash > 0)
      {
#ifdef EVAL_KIT
      if(evalCheck(cmd))
         goto L_error;
#endif
         sanitisepropbaser(&cmd->request);
         if( helperports && ! HttpConnection_recEvActive(cmd->con) )
         {
            HttpConnection_clearKeepAlive(cmd->con);
         }

         if(o->threadPoolIntf && ! helperports)
         {  
            if( ! HttpCmdThreadPoolIntf_doDir(
                   o->threadPoolIntf,
                   cmd,
                   HttpServer_getRDC(o)) )
            {
               return;
            }
         }

         
         reportstatus(
            o,
            cmd,
            HttpServer_getRDC(o),
            HttpRequest_getRequestPath(&cmd->request));


      }
      else
      {
#ifdef EVAL_KIT
        L_error:
#endif
         
         HttpConnection_clearKeepAlive(cmd->con);
      }
      
      if(trapsfpsimd32(o, cmd, con))
         goto L_readMore; 
   }
   else if(cmd->request.inData.allocator.index == 0) 
   {
      
      baAssert(HttpConnection_recEvActive(con));
      con->cmd = 0;
      cmd->con = 0;
      if(DoubleLink_isLinked(cmd))
      {
         baAssert(DoubleList_isInList(&o->cmdReqList, cmd));
         DoubleLink_unlink((DoubleLink*)cmd);
      }
      DoubleList_insertLast(&o->commandPool, cmd);
      HttpConnection_setState(con, HttpConnection_Connected);
      pciercxcfg008(&o->connectedList, (HttpLinkCon*)con);
   }
}


static void
wakeupevents(HttpServer* o, BaBool helperports)
{
   HttpLinkCon* pagesexact;
   HttpConnection* con;
   HttpCommand* cmd;
      
   cmd = (HttpCommand*)DoubleList_removeFirst(&o->commandPool);
   baAssert(cmd);
   cmd->requestTime=baGetUnixTime();
   DoubleList_insertLast(&o->cmdReqList, cmd);
   pagesexact = HttpLinkConList_removeFirst(&o->readyList);
   baAssert(pagesexact);
   con = (HttpConnection*)pagesexact; 
   baAssert( ! con->cmd );
   baAssert( ! cmd->con  || cmd->con == &o->noOpCon );
   baAssert( ! cmd->runningInThread );
   cmd->con = con;
   con->cmd = cmd;
   HttpConnection_setState(con, HttpConnection_Running);
   SoDisp_activateRec(o->dispatcher, (SoDispCon*)con);
   contextstack(o, cmd, helperports);
}



void
HttpServer_AsynchProcessDir(HttpServer* o,
                            HttpDir* dir,
                            HttpCommand* cmd)
{
   HttpConnection* con=cmd->con;
   baAssert(cmd->runningInThread);
   baAssert(cmd->con && cmd->con->cmd == cmd);
   reportstatus(
      o,
      cmd,
      dir,
      HttpRequest_getRequestPath(&cmd->request));
   if(trapsfpsimd32(o, cmd, con))
      contextstack(o, cmd, TRUE); 
   cmd->runningInThread=FALSE;
   while( ! HttpLinkConList_isEmpty(&o->readyList) &&
          ! DoubleList_isEmpty(&o->commandPool) )
   {
      wakeupevents(o, TRUE);
   }
}


static void
enablenotrace(HttpServer* o, HttpLinkCon* mmcsd0resources)
{
   baAssert(DoubleList_isInList(&o->connectedList, &mmcsd0resources->link));
   DoubleLink_unlink(&mmcsd0resources->link);
}


int
HttpServer_termOldestIdleCon(HttpServer* o)
{
   HttpLinkCon* con = HttpLinkConList_removeFirst(&o->connectedList);
   if(con)
   {
      SoDisp_deactivateRec(
         o->dispatcher, (SoDispCon*)con);
      SoDisp_removeConnection(
         o->dispatcher, (SoDispCon*)con);
      HttpConnection_setState(
         (HttpConnection*)con, HttpConnection_HardClose);
      pciercxcfg008(&o->freeList, con);
      return 0;
   }
   return -1;
}



BA_API HttpConnection*
HttpServer_getFreeCon(HttpServer* o)
{
   HttpLinkCon* freeCon;
  L_tryagain:
   if( ! HttpLinkConList_isEmpty(&o->freeList) )
      freeCon = HttpLinkConList_removeFirst(&o->freeList);
   else
   {
      freeCon = HttpLinkConList_removeFirst(&o->connectedList);
      if(freeCon)
      {
         SoDisp_deactivateRec(
            o->dispatcher, (SoDispCon*)freeCon);
         SoDisp_removeConnection(
            o->dispatcher, (SoDispCon*)freeCon);
         HttpConnection_setState(
            (HttpConnection*)freeCon, HttpConnection_HardClose);
      }
      
      else if( ! timeoutcheck(o) )
         goto L_tryagain;
   }

   
   if(o->waitForConClose)
   {
      
      if( (((WaitForConClose*)o->waitForConClose)->startTime + 5) <
          baGetUnixTime() )
      {
         timerdisable((WaitForConClose*)o->waitForConClose);
         o->waitForConClose=0;
      }
   }

   return (HttpConnection*)freeCon;
}



void
HttpServer_returnFreeCon(HttpServer* o, HttpConnection* con)
{
   pciercxcfg008(&o->freeList, (HttpLinkCon*)con);
}



BA_API void
HttpServer_installNewCon(HttpServer* o, HttpConnection* con)
{
   HttpLinkCon* lCon = (HttpLinkCon*)con;
   HttpConnection_setState(con, HttpConnection_Connected);
   pciercxcfg008(&o->connectedList, lCon);
   SoDisp_addConnection(o->dispatcher, (SoDispCon*)con);
   SoDisp_activateRec(o->dispatcher, (SoDispCon*)con);
   if(HttpConnection_hasMoreData(con))
      staticstruct(lCon);
}


void
HttpServer_addCon2ConnectedList(HttpServer* o, HttpConnection* con)
{
   baAssert( ! HttpConnection_recEvActive(con) );
   baAssert( ! HttpConnection_dispatcherHasCon(con) );

   if(HttpConnection_isValid(con) && HttpConnection_keepAlive(con))
   {
      HttpLinkCon* pagesexact = (HttpLinkCon*)HttpServer_getFreeCon(o);
      if(pagesexact)
      {
         HttpConnection_moveCon(con, (HttpConnection*)pagesexact);
         HttpConnection_setState(
            (HttpConnection*)pagesexact, HttpConnection_Connected);
         pciercxcfg008(&o->connectedList, pagesexact);
         SoDisp_addConnection(o->dispatcher, (SoDispCon*)pagesexact);
         SoDisp_activateRec(o->dispatcher,(SoDispCon*)pagesexact);
         
         if(HttpConnection_hasMoreData((HttpConnection*)pagesexact))
            staticstruct(pagesexact);
      }
   }
   HttpConnection_destructor(con);
}



void
HttpServer_doLingeringClose(
   HttpServer* o, HttpConnection* con, BaFileSize disabletraps)
{
   if(HttpConnection_isValid(con))
   {
      WaitForConClose* wfcc;
      AllocatorIntf* unmapaliases=AllocatorIntf_getDefault();
      size_t icachealiases=sizeof(WaitForConClose);
      if(o->waitForConClose)
      {
         timerdisable((WaitForConClose*)o->waitForConClose);
         o->waitForConClose=0;
      }
      wfcc = (WaitForConClose*)AllocatorIntf_malloc(unmapaliases,&icachealiases);
      if(wfcc)
      {
         ltm020d550modes(wfcc, o, unmapaliases, con, disabletraps);
         o->waitForConClose=wfcc;
         return;
      }
   }
   HttpConnection_setState(con, HttpConnection_Terminated);
}


static void
staticstruct(HttpLinkCon* pagesexact)
{
   HttpCommand* cmd;
   HttpConnection* con = (HttpConnection*)pagesexact; 
   HttpServer* o = HttpConnection_getServer(con);

#ifndef NDEBUG
   int i;
   for(i = 0 ; i < o->noOfConnections ; i++)
   {
      if(o->connections+i == pagesexact)
         break;
   }
   baAssert(o->connections+i == pagesexact);
#endif

#ifndef NO_HTTP_SESSION
   HttpSessionContainer_sessionTimer(&o->sessionContainer);
#endif

   if(con->state == HttpConnection_Connected)
   {
      cmd = (HttpCommand*)DoubleList_removeFirst(&o->commandPool);
      enablenotrace(o, pagesexact);
      if(!cmd)
      {
         
         cmd = (HttpCommand*)DoubleList_firstNode(&o->cmdReqList);
         if(cmd && (baGetUnixTime() - cmd->requestTime) > 5)
         {
            timeoutcheck(o);
            cmd = (HttpCommand*)DoubleList_removeFirst(&o->commandPool);
         }
         else
            cmd=0;
      }
      if(cmd)
      { 
         cmd->requestTime=baGetUnixTime();
         DoubleList_insertLast(&o->cmdReqList, cmd);
         HttpConnection_setState(con, HttpConnection_Running);
         baAssert( ! con->cmd );
         baAssert( ! cmd->con || cmd->con == &o->noOpCon );
         baAssert( ! cmd->runningInThread );
         cmd->con = con;
         con->cmd = cmd;
         contextstack(o, cmd, FALSE);
      }
      else if(HttpConnection_isValid(con)) 
      {  
         HttpConnection_setState(con, HttpConnection_Ready);
         pciercxcfg008(&o->readyList, pagesexact);
         SoDisp_deactivateRec(o->dispatcher, (SoDispCon*)con);
      }
      else
      {
         
         HttpConnection_setState(con, HttpConnection_Free);
         pciercxcfg008(&o->freeList, pagesexact);
      }
   }
   else if(con->state == HttpConnection_Running)
   {
      baAssert(con->cmd && con->cmd->con == con);
      if(con->cmd->runningInThread)
      {
         
#if 0
         if(foundationsregistered(&con->cmd->request.inData, 0, TRUE) < 0)
         { 
            if(HttpConnection_recEvActive(con))
            {
               HttpConnection_clearKeepAlive(con);
               SoDisp_deactivateRec(o->dispatcher, con);
            }
         }
#else
         if(HttpConnection_recEvActive(con))
            SoDisp_deactivateRec(o->dispatcher, (SoDispCon*)con);
#endif
      }
      else
      {
         contextstack(o, con->cmd, FALSE);
      }
   }
   else if(con->state == HttpConnection_Terminated)
   {  
      if(con->cmd)
      {
         baAssert(con->cmd->con == con);
         switchersysfs(o, con->cmd);
      }
   }
   else
   { 
      baAssert( ! HttpConnection_dispatcherHasCon(con) );
   }

   while( ! HttpLinkConList_isEmpty(&o->readyList) &&
          ! DoubleList_isEmpty(&o->commandPool) )
   {
      wakeupevents(o, FALSE);
   }
}


static void
prctldisable(SoDispCon* con)
{
   (void)con; 
   baAssert(0);
}


BA_API void
HttpServer_set404Page(HttpServer*o, const char* deviceregistered)
{
   pgtablesremap(&o->rootDirContainer, deviceregistered);
}

BA_API int
HttpServer_setUserObj(HttpServer* o, void* touchpdata, BaBool clockcheck)
{
   if(o->userObj && !clockcheck)
      return -1;
   o->userObj = touchpdata;
   return 0;
}


BA_API void
HttpServer_setErrHnd(UserDefinedErrHandler e)
{
   barracudaUserDefinedErrHandler = e;
}


void
HttpServer_initStatic(void)
{
   barracudaUserDefinedErrHandler = 0;
}





#ifdef NO_SHARKSSL

#define SHARKSSL_USE_MD5 1
#define SHARKSSL_USE_SHA1 1



#if defined(__LP64__) && !defined(SHARKSSL_64BIT)
#define SHARKSSL_64BIT
#endif
#ifdef SHARKSSL_64BIT
#define UPTR U64
#define SHARKSSL_ALIGNMENT 4
#endif
#ifndef UPTR
#define UPTR                                       U32
#endif

#if   (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define hsotgpdata(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = (w)
#elif (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define hsotgpdata(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = blockarray(w)
#else
#define hsotgpdata(w,a,i)                 \
{                                         \
   (a)[(i)]     = (U8)((w));              \
   (a)[(i) + 1] = (U8)((w) >>  8);        \
   (a)[(i) + 2] = (U8)((w) >> 16);        \
   (a)[(i) + 3] = (U8)((w) >> 24);        \
}
#endif

#if (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define read64uint32(w,a,i)  (w) = ((__sharkssl_packed U32*)(a))[(i) >> 2]
#elif (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define read64uint32(w,a,i)  (w) = blockarray(((__sharkssl_packed U32*)(a))[(i) >> 2])
#else
#define read64uint32(w,a,i)                 \
{                                         \
   (w) = ((U32)(a)[(i)] << 24)            \
       | ((U32)(a)[(i) + 1] << 16)        \
       | ((U32)(a)[(i) + 2] <<  8)        \
       | ((U32)(a)[(i) + 3]);             \
}
#endif


#if (defined(B_BIG_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define inputlevel(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = (w)
#elif (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
#define inputlevel(w,a,i)  ((__sharkssl_packed U32*)(a))[(i) >> 2] = blockarray(w)
#else
#define inputlevel(w,a,i)                 \
{                                         \
   (a)[(i)]     = (U8)((w) >> 24);        \
   (a)[(i) + 1] = (U8)((w) >> 16);        \
   (a)[(i) + 2] = (U8)((w) >>  8);        \
   (a)[(i) + 3] = (U8)((w));              \
}
#endif

#if (SHARKSSL_USE_MD5 || SHARKSSL_USE_SHA1 || SHARKSSL_USE_SHA_256 || SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
#if (SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
static const U8 prusspdata[128] =
#else
static const U8 prusspdata[64] =
#endif
{
   0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#if (SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#endif
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
#endif

#if SHARKSSL_USE_MD5

#if SHARKSSL_MD5_SMALL_FOOTPRINT
static const U32 unregisterclient[64] =
{
   0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE,
   0xF57C0FAF, 0x4787C62A, 0xA8304613, 0xFD469501,
   0x698098D8, 0x8B44F7AF, 0xFFFF5BB1, 0x895CD7BE,
   0x6B901122, 0xFD987193, 0xA679438E, 0x49B40821,
   0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,
   0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8,
   0x21E1CDE6, 0xC33707D6, 0xF4D50D87, 0x455A14ED,
   0xA9E3E905, 0xFCEFA3F8, 0x676F02D9, 0x8D2A4C8A,
   0xFFFA3942, 0x8771F681, 0x6D9D6122, 0xFDE5380C,
   0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,
   0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05,
   0xD9D4D039, 0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665,
   0xF4292244, 0x432AFF97, 0xAB9423A7, 0xFC93A039,
   0x655B59C3, 0x8F0CCC92, 0xFFEFF47D, 0x85845DD1,
   0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,
   0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391
};

static const U8 keypadresources[64] =
{
   7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,
   5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,
   4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,
   6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21
};

static const U8 writefeature[64] =
{
   0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
   1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,
   5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,
   0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9
};
#endif


#ifndef B_LITTLE_ENDIAN
static void kexecalloc(SharkSslMd5Ctx *registermcasp, const U8 alloccontroller[64])
#else
static void kexecalloc(SharkSslMd5Ctx *registermcasp, U32 countshift[16])
#endif
{
   U32 a, b, c, d;
   #if SHARKSSL_MD5_SMALL_FOOTPRINT
   const U32 *p;
   unsigned int i;
   #endif

   #ifndef B_LITTLE_ENDIAN
   U32 countshift[16];

   #if SHARKSSL_MD5_SMALL_FOOTPRINT
   for (i = 0; !(i & 16); i++)
   {
      cleanupcount(countshift[i], alloccontroller, (i << 2));
   }
   #else
   cleanupcount(countshift[0],  alloccontroller,  0);
   cleanupcount(countshift[1],  alloccontroller,  4);
   cleanupcount(countshift[2],  alloccontroller,  8);
   cleanupcount(countshift[3],  alloccontroller, 12);
   cleanupcount(countshift[4],  alloccontroller, 16);
   cleanupcount(countshift[5],  alloccontroller, 20);
   cleanupcount(countshift[6],  alloccontroller, 24);
   cleanupcount(countshift[7],  alloccontroller, 28);
   cleanupcount(countshift[8],  alloccontroller, 32);
   cleanupcount(countshift[9],  alloccontroller, 36);
   cleanupcount(countshift[10], alloccontroller, 40);
   cleanupcount(countshift[11], alloccontroller, 44);
   cleanupcount(countshift[12], alloccontroller, 48);
   cleanupcount(countshift[13], alloccontroller, 52);
   cleanupcount(countshift[14], alloccontroller, 56);
   cleanupcount(countshift[15], alloccontroller, 60);
   #endif
   #endif

   #define invalidcontext(x,n) ((U32)((U32)x << n) | ((U32)x >> (32 - n)))

   #define F(x,y,z) ((x & (y ^ z)) ^ z)  
   #define G(x,y,z) ((z & (x ^ y)) ^ y)  
   #define H(x,y,z) (x ^ y ^ z)
   #define I(x,y,z) (y ^ (x | ~z))

   a = registermcasp->state[0];
   b = registermcasp->state[1];
   c = registermcasp->state[2];
   d = registermcasp->state[3];

   #if SHARKSSL_MD5_SMALL_FOOTPRINT
   p = &unregisterclient[0];

   for (i = 0; (0 == (i & 0x40)); i++)
   {
      U32 e;

      a += countshift[writefeature[i]] + *p++;
      switch (i & 0x30)
      {
         case 0x00:
            a += F(b,c,d);
            break;

         case 0x10:
            a += G(b,c,d);
            break;

         case 0x20:
            a += H(b,c,d);
            break;

         default:
            a += I(b,c,d);
            break;
      }
      a = invalidcontext(a, keypadresources[i]);
      e = b;
      b += a;
      a = d;
      d = c;
      c = e;
   }

   #else  
   #define FF(A, B, C, D, X, S, K) { A += F(B,C,D) + X + K; A = invalidcontext(A,S) + B; }
   #define privilegefault(A, B, C, D, X, S, K) { A += G(B,C,D) + X + K; A = invalidcontext(A,S) + B; }
   #define alternativesapplied(A, B, C, D, X, S, K) { A += H(B,C,D) + X + K; A = invalidcontext(A,S) + B; }
   #define hsmmc3resource(A, B, C, D, X, S, K) { A += I(B,C,D) + X + K; A = invalidcontext(A,S) + B; }

   FF(a, b, c, d, countshift[0],   7, 0xD76AA478);
   FF(d, a, b, c, countshift[1],  12, 0xE8C7B756);
   FF(c, d, a, b, countshift[2],  17, 0x242070DB);
   FF(b, c, d, a, countshift[3],  22, 0xC1BDCEEE);
   FF(a, b, c, d, countshift[4],   7, 0xF57C0FAF);
   FF(d, a, b, c, countshift[5],  12, 0x4787C62A);
   FF(c, d, a, b, countshift[6],  17, 0xA8304613);
   FF(b, c, d, a, countshift[7],  22, 0xFD469501);
   FF(a, b, c, d, countshift[8],   7, 0x698098D8);
   FF(d, a, b, c, countshift[9],  12, 0x8B44F7AF);
   FF(c, d, a, b, countshift[10], 17, 0xFFFF5BB1);
   FF(b, c, d, a, countshift[11], 22, 0x895CD7BE);
   FF(a, b, c, d, countshift[12],  7, 0x6B901122);
   FF(d, a, b, c, countshift[13], 12, 0xFD987193);
   FF(c, d, a, b, countshift[14], 17, 0xA679438E);
   FF(b, c, d, a, countshift[15], 22, 0x49B40821);

   privilegefault(a, b, c, d, countshift[1],   5, 0xF61E2562);
   privilegefault(d, a, b, c, countshift[6],   9, 0xC040B340);
   privilegefault(c, d, a, b, countshift[11], 14, 0x265E5A51);
   privilegefault(b, c, d, a, countshift[0],  20, 0xE9B6C7AA);
   privilegefault(a, b, c, d, countshift[5],   5, 0xD62F105D);
   privilegefault(d, a, b, c, countshift[10],  9, 0x02441453);
   privilegefault(c, d, a, b, countshift[15], 14, 0xD8A1E681);
   privilegefault(b, c, d, a, countshift[4],  20, 0xE7D3FBC8);
   privilegefault(a, b, c, d, countshift[9],   5, 0x21E1CDE6);
   privilegefault(d, a, b, c, countshift[14],  9, 0xC33707D6);
   privilegefault(c, d, a, b, countshift[3],  14, 0xF4D50D87);
   privilegefault(b, c, d, a, countshift[8],  20, 0x455A14ED);
   privilegefault(a, b, c, d, countshift[13],  5, 0xA9E3E905);
   privilegefault(d, a, b, c, countshift[2],   9, 0xFCEFA3F8);
   privilegefault(c, d, a, b, countshift[7],  14, 0x676F02D9);
   privilegefault(b, c, d, a, countshift[12], 20, 0x8D2A4C8A);

   alternativesapplied(a, b, c, d, countshift[5],   4, 0xFFFA3942);
   alternativesapplied(d, a, b, c, countshift[8],  11, 0x8771F681);
   alternativesapplied(c, d, a, b, countshift[11], 16, 0x6D9D6122);
   alternativesapplied(b, c, d, a, countshift[14], 23, 0xFDE5380C);
   alternativesapplied(a, b, c, d, countshift[1],   4, 0xA4BEEA44);
   alternativesapplied(d, a, b, c, countshift[4],  11, 0x4BDECFA9);
   alternativesapplied(c, d, a, b, countshift[7],  16, 0xF6BB4B60);
   alternativesapplied(b, c, d, a, countshift[10], 23, 0xBEBFBC70);
   alternativesapplied(a, b, c, d, countshift[13],  4, 0x289B7EC6);
   alternativesapplied(d, a, b, c, countshift[0],  11, 0xEAA127FA);
   alternativesapplied(c, d, a, b, countshift[3],  16, 0xD4EF3085);
   alternativesapplied(b, c, d, a, countshift[6],  23, 0x04881D05);
   alternativesapplied(a, b, c, d, countshift[9],   4, 0xD9D4D039);
   alternativesapplied(d, a, b, c, countshift[12], 11, 0xE6DB99E5);
   alternativesapplied(c, d, a, b, countshift[15], 16, 0x1FA27CF8);
   alternativesapplied(b, c, d, a, countshift[2],  23, 0xC4AC5665);

   hsmmc3resource(a, b, c, d, countshift[0],   6, 0xF4292244);
   hsmmc3resource(d, a, b, c, countshift[7],  10, 0x432AFF97);
   hsmmc3resource(c, d, a, b, countshift[14], 15, 0xAB9423A7);
   hsmmc3resource(b, c, d, a, countshift[5],  21, 0xFC93A039);
   hsmmc3resource(a, b, c, d, countshift[12],  6, 0x655B59C3);
   hsmmc3resource(d, a, b, c, countshift[3],  10, 0x8F0CCC92);
   hsmmc3resource(c, d, a, b, countshift[10], 15, 0xFFEFF47D);
   hsmmc3resource(b, c, d, a, countshift[1],  21, 0x85845DD1);
   hsmmc3resource(a, b, c, d, countshift[8],   6, 0x6FA87E4F);
   hsmmc3resource(d, a, b, c, countshift[15], 10, 0xFE2CE6E0);
   hsmmc3resource(c, d, a, b, countshift[6],  15, 0xA3014314);
   hsmmc3resource(b, c, d, a, countshift[13], 21, 0x4E0811A1);
   hsmmc3resource(a, b, c, d, countshift[4],   6, 0xF7537E82);
   hsmmc3resource(d, a, b, c, countshift[11], 10, 0xBD3AF235);
   hsmmc3resource(c, d, a, b, countshift[2],  15, 0x2AD7D2BB);
   hsmmc3resource(b, c, d, a, countshift[9],  21, 0xEB86D391);

   #undef hsmmc3resource
   #undef alternativesapplied
   #undef privilegefault
   #undef FF
   #endif

   registermcasp->state[0] += a;
   registermcasp->state[1] += b;
   registermcasp->state[2] += c;
   registermcasp->state[3] += d;


   #undef I
   #undef H
   #undef G
   #undef F

   #undef invalidcontext
}


SHARKSSL_API void SharkSslMd5Ctx_constructor(SharkSslMd5Ctx *registermcasp)
{
   baAssert(((unsigned int)(UPTR)(registermcasp->buffer) & (sizeof(int)-1)) == 0);

   registermcasp->total[0] = 0;
   registermcasp->total[1] = 0;

   registermcasp->state[0] = 0x67452301;
   registermcasp->state[1] = 0xEFCDAB89;
   registermcasp->state[2] = 0x98BADCFE;
   registermcasp->state[3] = 0x10325476;
}


SHARKSSL_API void SharkSslMd5Ctx_append(SharkSslMd5Ctx *registermcasp, const U8 *in, U32 len)
{
   unsigned int dm9000platdata, pxa300evalboard;

   dm9000platdata = (unsigned int)(registermcasp->total[0]) & 0x3F;
   pxa300evalboard = 64 - dm9000platdata;

   registermcasp->total[0] += len;
   if (registermcasp->total[0] < len)
   {
      registermcasp->total[1]++;
   }

   if((dm9000platdata) && (len >= pxa300evalboard))
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, pxa300evalboard);
      #ifndef B_LITTLE_ENDIAN
      kexecalloc(registermcasp, registermcasp->buffer);
      #else
      kexecalloc(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= pxa300evalboard;
      in  += pxa300evalboard;
      dm9000platdata = 0;
   }

   while (len >= 64)
   {
      #ifndef B_LITTLE_ENDIAN
      kexecalloc(registermcasp, in);
      #else
      memcpy(registermcasp->buffer, in, 64);
      kexecalloc(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= 64;
      in  += 64;
   }

   if (len)
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, len);
   }
}


SHARKSSL_API void SharkSslMd5Ctx_finish(SharkSslMd5Ctx *registermcasp, U8 secondaryentry[SHARKSSL_MD5_HASH_LEN])
{
   U32 timerenable, dummywrites;
   U32 timer0start, checkcontext;
   U8  usbgadgetresource[8];

   timer0start = (registermcasp->total[0] >> 29) | (registermcasp->total[1] <<  3);
   checkcontext  = (registermcasp->total[0] <<  3);

   hsotgpdata(checkcontext,  usbgadgetresource, 0);
   hsotgpdata(timer0start, usbgadgetresource, 4);

   timerenable = registermcasp->total[0] & 0x3F;
   dummywrites = (timerenable < 56) ? (56 - timerenable) : (120 - timerenable);

   SharkSslMd5Ctx_append(registermcasp, (U8*)prusspdata, dummywrites);
   SharkSslMd5Ctx_append(registermcasp, usbgadgetresource, 8);

   hsotgpdata(registermcasp->state[0], secondaryentry,  0);
   hsotgpdata(registermcasp->state[1], secondaryentry,  4);
   hsotgpdata(registermcasp->state[2], secondaryentry,  8);
   hsotgpdata(registermcasp->state[3], secondaryentry, 12);
}


SHARKSSL_API int sharkssl_md5(const U8* alloccontroller, U16 len, U8 *secondaryentry)
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslMd5Ctx *hctx = (SharkSslMd5Ctx *)baMalloc(claimresource(sizeof(SharkSslMd5Ctx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }
   #else
   SharkSslMd5Ctx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(secondaryentry);

   SharkSslMd5Ctx_constructor(hctx);
   SharkSslMd5Ctx_append(hctx, alloccontroller, len);
   SharkSslMd5Ctx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


#if SHARKSSL_USE_SHA1

#ifndef B_BIG_ENDIAN
static void irqwakeintallow(SharkSslSha1Ctx *registermcasp, const U8 alloccontroller[64])
#else
static void irqwakeintallow(SharkSslSha1Ctx *registermcasp, U32 countshift[16])
#endif
{
   U32 a, b, c, d, e, brightnesslimit;
   #if SHARKSSL_SHA1_SMALL_FOOTPRINT
   unsigned int i;
   #endif
   #ifndef B_BIG_ENDIAN
   U32 countshift[16];

   #if SHARKSSL_SHA1_SMALL_FOOTPRINT
   for (i = 0; !(i & 16); i++)
   {
      read64uint32(countshift[i], alloccontroller, (i << 2));
   }
   #else
   read64uint32(countshift[0],  alloccontroller,  0);
   read64uint32(countshift[1],  alloccontroller,  4);
   read64uint32(countshift[2],  alloccontroller,  8);
   read64uint32(countshift[3],  alloccontroller, 12);
   read64uint32(countshift[4],  alloccontroller, 16);
   read64uint32(countshift[5],  alloccontroller, 20);
   read64uint32(countshift[6],  alloccontroller, 24);
   read64uint32(countshift[7],  alloccontroller, 28);
   read64uint32(countshift[8],  alloccontroller, 32);
   read64uint32(countshift[9],  alloccontroller, 36);
   read64uint32(countshift[10], alloccontroller, 40);
   read64uint32(countshift[11], alloccontroller, 44);
   read64uint32(countshift[12], alloccontroller, 48);
   read64uint32(countshift[13], alloccontroller, 52);
   read64uint32(countshift[14], alloccontroller, 56);
   read64uint32(countshift[15], alloccontroller, 60);
   #endif
   #endif

   #define invalidcontext(x,n) ((U32)((U32)x << n) | ((U32)x >> (32 - n)))

   #define pwdowninverted(x,y,z) ((x & (y ^ z)) ^ z)  
   #define configparse(x,y,z) (x ^ y ^ z)
   #define emulationhandler(x,y,z) ((x & y) | ((x | y) & z))
   #define es3plushwmod(x,y,z) (x ^ y ^ z)

   #define serial0pdata 0x5A827999
   #define registerrproc 0x6ED9EBA1
   #define powergpiod 0x8F1BBCDC
   #define allockernel 0xCA62C1D6

   a = registermcasp->state[0];
   b = registermcasp->state[1];
   c = registermcasp->state[2];
   d = registermcasp->state[3];
   e = registermcasp->state[4];

   #if SHARKSSL_SHA1_SMALL_FOOTPRINT
   for (i = 0; i < 80; i++)
   {
      if (i >= 16)
      {
         brightnesslimit = countshift[i & 0xF] ^ countshift[(i + 2) & 0xF] ^ countshift[(i + 8) & 0xF] ^ countshift[(i + 13) & 0xF];
         countshift[i & 0xF] = brightnesslimit = invalidcontext(brightnesslimit, 1);
      }
      brightnesslimit = countshift[i & 0xF];
      brightnesslimit += e + invalidcontext(a, 5);
      if (i < 20)
      {
         brightnesslimit += pwdowninverted(b,c,d) + serial0pdata;
      }
      else if (i < 40)
      {
         brightnesslimit += configparse(b,c,d) + registerrproc;
      }
      else if (i < 60)
      {
         brightnesslimit += emulationhandler(b,c,d) + powergpiod;
      }
      else
      {
         brightnesslimit += es3plushwmod(b,c,d) + allockernel;
      }
      e = d;
      d = c;
      c = invalidcontext(b, 30);
      b = a;
      a = brightnesslimit;
   }

   #else  
                                   e += (countshift[0]                ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
                                   d += (countshift[1]                ) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
                                   c += (countshift[2]                ) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
                                   b += (countshift[3]                ) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
                                   a += (countshift[4]                ) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

                                   e += (countshift[5]                ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
                                   d += (countshift[6]                ) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
                                   c += (countshift[7]                ) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
                                   b += (countshift[8]                ) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
                                   a += (countshift[9]                ) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

                                   e += (countshift[10]               ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
                                   d += (countshift[11]               ) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
                                   c += (countshift[12]               ) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
                                   b += (countshift[13]               ) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
                                   a += (countshift[14]               ) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

                                   e += (countshift[15]               ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  d += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  c += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  b += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  a += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  e += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  d += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  c += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  b += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  a += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  e += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; d += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; c += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; b += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; a += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; e += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; d += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  c += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  b += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  a += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  e += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  d += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  c += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  b += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  a += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  e += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  d += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; c += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; b += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; a += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; e += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; d += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; c += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  b += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  a += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  e += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  d += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  c += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  b += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  a += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  e += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  d += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  c += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; b += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; a += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; e += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; d += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; c += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; b += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  a += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);

   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  e += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  d += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  c += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  b += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  a += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);

   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  e += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  d += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  c += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  b += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; a += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);

   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; e += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; d += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; c += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; b += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; a += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);
   #endif

   registermcasp->state[0] += a;
   registermcasp->state[1] += b;
   registermcasp->state[2] += c;
   registermcasp->state[3] += d;
   registermcasp->state[4] += e;

   #undef allockernel
   #undef powergpiod
   #undef registerrproc
   #undef serial0pdata

   #undef es3plushwmod
   #undef emulationhandler
   #undef configparse
   #undef pwdowninverted

   #undef invalidcontext
}


SHARKSSL_API void SharkSslSha1Ctx_constructor(SharkSslSha1Ctx *registermcasp)
{
   baAssert(((unsigned int)(UPTR)(registermcasp->buffer) & (sizeof(int)-1)) == 0);

   registermcasp->total[0] = 0;
   registermcasp->total[1] = 0;

   registermcasp->state[0] = 0x67452301;
   registermcasp->state[1] = 0xEFCDAB89;
   registermcasp->state[2] = 0x98BADCFE;
   registermcasp->state[3] = 0x10325476;
   registermcasp->state[4] = 0xC3D2E1F0;
}


SHARKSSL_API void SharkSslSha1Ctx_append(SharkSslSha1Ctx *registermcasp, const U8 *in, U32 len)
{
   unsigned int dm9000platdata, pxa300evalboard;

   dm9000platdata = (unsigned int)(registermcasp->total[0]) & 0x3F;
   pxa300evalboard = 64 - dm9000platdata;

   registermcasp->total[0] += len;
   if (registermcasp->total[0] < len)
   {
      registermcasp->total[1]++;
   }

   if((dm9000platdata) && (len >= pxa300evalboard))
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, pxa300evalboard);
      #ifndef B_BIG_ENDIAN
      irqwakeintallow(registermcasp, registermcasp->buffer);
      #else
      irqwakeintallow(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= pxa300evalboard;
      in  += pxa300evalboard;
      dm9000platdata = 0;
   }

   while (len >= 64)
   {
      #ifndef B_BIG_ENDIAN
      irqwakeintallow(registermcasp, in);
      #else
      memcpy(registermcasp->buffer, in, 64);
      irqwakeintallow(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= 64;
      in  += 64;
   }

   if (len)
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, len);
   }
}


SHARKSSL_API void SharkSslSha1Ctx_finish(SharkSslSha1Ctx *registermcasp, U8 secondaryentry[SHARKSSL_SHA1_HASH_LEN])
{
   U32 timerenable, dummywrites;
   U32 timer0start, checkcontext;
   U8  usbgadgetresource[8];

   timer0start = (registermcasp->total[0] >> 29) | (registermcasp->total[1] <<  3);
   checkcontext  = (registermcasp->total[0] <<  3);

   inputlevel(timer0start, usbgadgetresource, 0);
   inputlevel(checkcontext,  usbgadgetresource, 4);

   timerenable = registermcasp->total[0] & 0x3F;
   dummywrites = (timerenable < 56) ? (56 - timerenable) : (120 - timerenable);

   SharkSslSha1Ctx_append(registermcasp, (U8*)prusspdata, dummywrites);
   SharkSslSha1Ctx_append(registermcasp, usbgadgetresource, 8);

   inputlevel(registermcasp->state[0], secondaryentry,  0);
   inputlevel(registermcasp->state[1], secondaryentry,  4);
   inputlevel(registermcasp->state[2], secondaryentry,  8);
   inputlevel(registermcasp->state[3], secondaryentry, 12);
   inputlevel(registermcasp->state[4], secondaryentry, 16);
}

#endif
#endif

#ifndef NO_HTTP_SESSION

#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpServer.h>
#include <BaServerLib.h>
#include <AuthenticatedUser.h>
#include <HttpTrace.h>
#include <stdlib.h>
#ifndef NO_SHARKSSL
#include <SharkSSL.h>
#endif


static int earlyshadow(SplayTreeNode* fdc37m81xconfig, SplayTreeKey k);

static void loongsonfprev(HttpSession* o,
                                    HttpSessionContainer* traceenter,
                                    HttpConnection* con,
                                    U32 id);
static void allocationdomain(HttpSession* o);
static int plltabregister(HttpSession* o);
#ifdef NDEBUG
#define HttpSession_assertMove2TermList(o) plltabregister(o)
#else
#define HttpSession_assertMove2TermList(o) \
  baAssert( ! plltabregister(o) )
#endif

#define HttpSession_dlink2Session(dl) \
   (HttpSession*)((U8*)dl-offsetof(HttpSession,dlink))

void
HttpSessionContainer_constructor(HttpSessionContainer* o,
                                 struct HttpServer* uarchbuild,
                                 U16 rd12rn16rm0rs8rwflags)
{
   SplayTree_constructor(&o->sessionTree, earlyshadow);
   DoubleList_constructor(&o->sessionList);
   DoubleList_constructor(&o->sessionTermList);
   o->sessionLinkIter=0;
   o->server=uarchbuild;
   o->noOfSessions = 0;
   o->maxSessions = rd12rn16rm0rs8rwflags;
   o->eCode = HttpSessionContainer_OK;
}


void
HttpSessionContainer_destructor(HttpSessionContainer* o)
{
   DoubleLink* dl;
   SplayTreeNode* fdc37m81xconfig;

   while( (fdc37m81xconfig = SplayTree_getRoot(&o->sessionTree)) != 0)
   {
         HttpSession_assertMove2TermList((HttpSession*)fdc37m81xconfig);
         allocationdomain((HttpSession*)fdc37m81xconfig);
         baFree(fdc37m81xconfig);
   }
   while( (dl = DoubleList_firstNode(&o->sessionTermList)) != 0)
   {
      HttpSession* s = HttpSession_dlink2Session(dl);
      allocationdomain(s);
      baFree(s);
   }
}


#define HttpSessionContainer_getSession(o, id) \
   (HttpSession*)SplayTree_find(&(o)->sessionTree,(SplayTreeKey)((size_t)id))



static HttpSession*
HttpSessionContainer_getSessionCheckTime(
   HttpSessionContainer* o, U32 id, U32 sysctltable,U32 pcieswearly)
{
   HttpSession* s = HttpSessionContainer_getSession(o,id);
   if(s)
   {
      s->lastAccessedTime = baGetUnixTime();
      return s->sesrnd1 == sysctltable && s->sesrnd2 == pcieswearly ? s : 0;
   }
   return 0;
}


HttpServer*
HttpSession_getServer(HttpSession* o)
{
   return o->container->server;
}


static HttpSession*
HttpSessionContainer_createSession(HttpSessionContainer* o,
                                   HttpRequest* configuredevice)
{
   HttpSession* func2fixup;
   if(o->noOfSessions >= o->maxSessions)
   {
      
      DoubleListEnumerator e;
      DoubleLink* dl;
      DoubleListEnumerator_constructor(&e, &o->sessionList);
      dl = DoubleListEnumerator_getElement(&e);
      while(dl)
      {
         func2fixup = HttpSession_dlink2Session(dl);
         dl = DoubleListEnumerator_nextElement(&e);
         if(func2fixup->useCounter == 0 && func2fixup->refCounter == 0)
         {
            HttpSession_terminate(func2fixup);
            break;
         }
      }
      if(o->noOfSessions >= o->maxSessions)
      {
         TRPR(("\143\162\145\141\164\145\123\145\163\163\151\157\156\072\040\124\157\157\115\141\156\171\123\145\163\163\151\157\156\163\012"));
         o->eCode = HttpSessionContainer_TooManySessions;
         return 0;
      }
   }

   func2fixup = (HttpSession*)baMalloc(sizeof(HttpSession));
   if(func2fixup)
   {

      
      U32 id;
#ifdef NO_SHARKSSL
      U32 i=0;
      id = baGetMsClock() * 123456789; 
#else
	  
      sharkssl_rng((U8*)&id, sizeof(id));
#endif
	  while (id == 0 || HttpSessionContainer_getSession(o, id))
      { 
#ifdef NO_SHARKSSL
         id = (id+(++i))*2;
#else
         sharkssl_rng((U8*)&id, sizeof(id));
#endif
      }
      loongsonfprev(func2fixup,o,HttpRequest_getConnection(configuredevice),id);
      o->eCode = HttpSessionContainer_OK;
   }
   else
   {
      TRPR(("\143\162\145\141\164\145\123\145\163\163\151\157\156\072\040\116\157\115\145\155\157\162\171\012"));
      o->eCode = HttpSessionContainer_NoMemory;
   }
   return func2fixup;
}


void
HttpSessionContainer_sessionTimer(HttpSessionContainer* o)
{
   HttpSession* s;
   BaTime now = baGetUnixTime();
   if(o->sessionLinkIter)
   {
      s = HttpSession_dlink2Session(o->sessionLinkIter);
      o->sessionLinkIter = DoubleLink_getNext(o->sessionLinkIter);
      if((s->lastAccessedTime + s->maxInactiveInterval) < now &&
         s->lockCounter == 0)
      {
         HttpSession_terminate(s);
      }
      if(DoubleList_isEnd(&o->sessionList, o->sessionLinkIter))
         o->sessionLinkIter = DoubleList_firstNode(&o->sessionList);
   }
}



BA_API void
HttpSessionAttribute_constructor(HttpSessionAttribute* o,
                                 const char* gpio1config,
                                 HttpSessionAttribute_Destructor d)
{
   o->next = 0;
   o->session=0;
   o->destructor = d;
   o->name = baStrdup(gpio1config);
}


BA_API void
HttpSessionAttribute_destructor(HttpSessionAttribute* o)
{
   char* gpio1config = o->name;
   if(o->destructor)
   {
      HttpSessionAttribute_Destructor d = o->destructor;
      o->destructor=0;
      (*d)(o);
   }
   if(gpio1config)
      baFree(gpio1config);
}



static int
earlyshadow(SplayTreeNode* fdc37m81xconfig, SplayTreeKey k)
{
   if( (size_t)fdc37m81xconfig->key < (size_t)k )
      return -1;
   return (size_t)fdc37m81xconfig->key > (size_t)k ? 1 : 0;
}

static void
loongsonfprev(HttpSession* o,
                        HttpSessionContainer* traceenter,
                        HttpConnection* con,
                        U32 id)
{
   memset(o, 0, sizeof(HttpSession));
   SplayTreeNode_constructor((SplayTreeNode*)o, (SplayTreeKey)((size_t)id));
   DoubleLink_constructor(&o->dlink);
   SplayTree_insert(&traceenter->sessionTree, (SplayTreeNode*)o);
   DoubleList_insertFirst(&traceenter->sessionList, &o->dlink);
   if( ! traceenter->sessionLinkIter )
      traceenter->sessionLinkIter = &o->dlink;

   
   HttpConnection_getPeerName(con, &o->peer,0);
   o->container = traceenter;
   o->creationTime = o->lastAccessedTime = baGetUnixTime();
   o->maxInactiveInterval = 20*60; 

#ifdef NO_SHARKSSL
      U32 i=0;
      o->sesrnd1 = baGetMsClock() * 494073958; 
      o->sesrnd2 = baGetMsClock() * 933739515; 
#else
      sharkssl_rng((U8*)&o->sesrnd1, sizeof(o->sesrnd1));
      sharkssl_rng((U8*)&o->sesrnd2, sizeof(o->sesrnd2));
#endif

   traceenter->noOfSessions++;
}


static void
allocationdomain(HttpSession* o)
{
   HttpSessionAttribute* instructioncounter;
   instructioncounter = o->attrList;
   while(instructioncounter)
   {
      HttpSessionAttribute* attr = instructioncounter;
      instructioncounter = instructioncounter->next;
      HttpSessionAttribute_destructor(attr);
   }
   
   DoubleLink_unlink(&o->dlink);
}


static int
plltabregister(HttpSession* o)
{
   HttpSessionContainer* c = o->container;
   if(SplayTree_remove(&c->sessionTree, (SplayTreeNode*)o))
   {
      baAssert(o->termPending);
      return -1; 
   }
   baAssert( ! o->termPending );
   baAssert(c->noOfSessions > 0);
   c->noOfSessions--;
   o->termPending=TRUE;

   if(c->sessionLinkIter == &o->dlink)
   {
      c->sessionLinkIter = DoubleLink_getNext(c->sessionLinkIter);
      DoubleLink_unlink(&o->dlink);
      if(DoubleList_isEnd(&c->sessionList, c->sessionLinkIter))
         c->sessionLinkIter = DoubleList_firstNode(&c->sessionList);
   }
   else
      DoubleLink_unlink(&o->dlink);
   DoubleList_insertLast(&c->sessionTermList, &o->dlink);
   return 0;
}


BA_API void
HttpSession_decrRefCntr(HttpSession* o)
{
   baAssert(o->refCounter > 0);
   if(--o->refCounter == 0)
   {
      if(o->termPending)
         HttpSession_terminate(o);
   }
}


BA_API void
HttpSession_terminate(HttpSession* o)
{
   if(o->refCounter == 0)
   {  
      if(o->termPending)
      {
         
         baAssert(SplayTree_remove(&o->container->sessionTree,
                  (SplayTreeNode*)o));
      }
      else
      {
         if(plltabregister(o))
         {
            baAssert(0);
         }
      }
      allocationdomain(o);
      baFree(o);
   }
   else 
   {
      plltabregister(o);
   }
}


BA_API HttpSessionAttribute*
HttpSession_getAttribute(HttpSession* o, const char* gpio1config)
{
   if(o)
   {
      HttpSessionAttribute* instructioncounter;
      instructioncounter = o->attrList;
      while(instructioncounter)
      {
         if( ! strcmp(gpio1config, instructioncounter->name) )
         {
            return instructioncounter;
         }
         instructioncounter = instructioncounter->next;
      }
   }
   return 0;
}


BA_API BaTime
HttpSession_getCreationTime(HttpSession* o)
{
   return o->creationTime;
}


BA_API BaTime
HttpSession_getLastAccessedTime(HttpSession* o)
{
   return o->lastAccessedTime;
}


BA_API BaTime
HttpSession_getMaxInactiveInterval(HttpSession* o)
{
   return o->maxInactiveInterval;
}


BA_API int
HttpSession_removeAttribute(HttpSession* o, const char* gpio1config)
{
   if(o->attrList)
   {
      HttpSessionAttribute* setupmemory = 0;
      HttpSessionAttribute* instructioncounter = o->attrList;
      while(instructioncounter)
      {
         if( ! strcmp(gpio1config, instructioncounter->name) )
         {
            if(instructioncounter == o->attrList) 
            {
               o->attrList = 0;
            }
            else
            {
               baAssert(setupmemory);
               setupmemory->next = instructioncounter->next;
            }
            HttpSessionAttribute_destructor(instructioncounter);
            return 0;
         }
         setupmemory = instructioncounter;
         instructioncounter = instructioncounter->next;
      }
   }
   TRPR(("\110\164\164\160\123\145\163\163\151\157\156\072\072\162\145\155\157\166\145\101\164\164\162\151\142\165\164\145\072\040\045\163\040\156\157\164\040\146\157\165\156\144\012",gpio1config));
   return -1;
}


BA_API int
HttpSession_setAttribute(HttpSession* o,
                         HttpSessionAttribute* videoprobe)
{
   if( videoprobe->next )
   {
      TRPR(("\110\164\164\160\122\145\161\165\145\163\164\072\072\163\145\164\101\164\164\162\151\142\165\164\145\072\040\101\164\164\162\040\156\157\164\040\151\156\151\164\151\141\154\151\172\145\144\012"));
      return -2;
   }
   if( !videoprobe->name )
   {
      TRPR(("\110\164\164\160\122\145\161\165\145\163\164\072\072\163\145\164\101\164\164\162\151\142\165\164\145\072\040\101\164\164\162\040\156\141\155\145\040\151\163\040\116\125\114\114\012"));
      return -3;
   }
   baAssert( ! videoprobe->session );
   videoprobe->session=o;
   if( ! o->attrList )
      o->attrList = videoprobe;
   else
   {
      HttpSessionAttribute* instructioncounter = o->attrList;
      if( !strcmp(instructioncounter->name, videoprobe->name) ) return -1;
      while(instructioncounter->next)
      {
         instructioncounter = instructioncounter->next;
         if( !strcmp(instructioncounter->name, videoprobe->name) ) return -1;
      }
      instructioncounter->next = videoprobe;
   }
   return 0;
}


BA_API void
HttpSession_setMaxInactiveInterval(HttpSession* o, BaTime watchdogresources)
{
   o->maxInactiveInterval = watchdogresources;
}



BA_API int
HttpSession_fmtSessionId(HttpSession* o, U8* buf, size_t lsdc2format)
{
   if(lsdc2format < 25)
      return -1;
   baConvU32ToHex(buf, HttpSession_getId(o));
   baConvU32ToHex(buf+8, o->sesrnd1);
   baConvU32ToHex(buf+16, o->sesrnd2);
   buf[24]=0; 
   return 24;
}



BA_API HttpSession*
HttpRequest_getSession(HttpRequest* o, BaBool breakhandler)
{
   HttpCookie* sessionCookie;
   if(o->session)
      return o->session->termPending ? 0 : o->session;
   
   sessionCookie = HttpRequest_getCookie(o, BA_COOKIE_ID);
   if(sessionCookie)
   {
      const char* sc=HttpCookie_getValue(sessionCookie);
      o->session = sc ? HttpRequest_session(o,sc,strlen(sc),TRUE) : 0;
      if(o->session)
         return o->session;
   }
   if(breakhandler)
   {
      if(HttpResponse_committed(HttpRequest_getResponse(o)))
      {
         TRPR(("\110\164\164\160\122\145\161\165\145\163\164\072\072\147\145\164\123\145\163\163\151\157\156\072\040\105\137\111\123\137\103\117\115\115\111\124\124\105\104\012"));
      }
      else
      {
         o->session = HttpSessionContainer_createSession(
            &o->server->sessionContainer, o);
         if(o->session)
         {
            U8 buf[25];
            HttpCookie* sessionCookie = HttpResponse_createCookie(
               HttpRequest_getResponse(o), BA_COOKIE_ID);
            HttpSession_fmtSessionId(o->session, buf, sizeof(buf));
            HttpCookie_setValue(sessionCookie, (char*)buf);
            HttpCookie_setPath(sessionCookie, "\057");
            HttpCookie_setHttpOnly(sessionCookie,TRUE);
            HttpCookie_activate(sessionCookie);
            o->session->refCounter++;
            return o->session;
         }
      }
   }
   return 0;
}



BA_API HttpSession*
HttpRequest_session(HttpRequest* o, const char* val, size_t len, int set)
{
   if(24 == len)
   {
      HttpConnection* con = HttpRequest_getConnection(o);
      U32 sysvecbyname = baConvHexToU32(val);
      HttpSession* s = HttpSessionContainer_getSessionCheckTime(
         &o->server->sessionContainer,
         sysvecbyname,
         baConvHexToU32(val+8),
         baConvHexToU32(val+16));
      if(s)
      {
         if( ! HttpConnection_cmpAddr(con, &s->peer) )
         {
#ifdef HTTP_TRACE
            
            HttpSockaddr serialports;
            char buf[64];
            int sffsdrnandflash; 
            HttpSockaddr_addr2String(&s->peer, buf, sizeof(buf), &sffsdrnandflash);
            TRPR(("\123\145\163\163\151\157\156\040\141\144\144\162\040\145\162\162\072\040\163\075\045\163\054\040\160\075", sffsdrnandflash ? "\077" : buf));
            if( SoDispCon_getPeerName((SoDispCon*)con,&serialports,0) )
            {
               sffsdrnandflash=-1;
            }
            else
            {
               HttpSockaddr_addr2String(&serialports, buf, sizeof(buf), &sffsdrnandflash);
            }
            TRPR(("\045\163\012", sffsdrnandflash ? "\077" : buf));
#endif
            return 0;
         }
         if(set)
         {
            
            if( ! o->session )
            {
               s->useCounter++;
               s->refCounter++;
               o->session=s;
            }
            return o->session;
         }
         return s;
      }
   }
   return 0;
}


BA_API HttpSession*
HttpServer_getSession(HttpServer* o, U32 id)
{
   HttpSession* s;
   s = HttpSessionContainer_getSession(&o->sessionContainer, id);
   return s;
}

#endif

#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpCfg.h>
#include <BaServerLib.h>
#include <BaErrorCodes.h>
#include <BufPrint.h>
#include <string.h>


#define IN6ADDRSZ 16
#define	INADDRSZ   4
#define U16Z       2


BA_API int
HttpSocket_create(HttpSocket* o,
                  const char* preparepoweroff,
                  U16 hwmoddeassert,
                  BaBool restoreucontext,
                  BaBool moduleready)

{
   int sffsdrnandflash;
   if(restoreucontext)
   {
#ifdef USE_DGRAM
      HttpSocket_sockUdp(o, preparepoweroff, moduleready, &sffsdrnandflash);
#else
      sffsdrnandflash = E_INVALID_SOCKET_CON;
#endif
   }
   else
   {
      HttpSocket_sockStream(o, preparepoweroff, moduleready, &sffsdrnandflash);
   }
   if(sffsdrnandflash == 0)
   {
      if(preparepoweroff || hwmoddeassert)
      {
         HttpSockaddr sockAddr;
         HttpSockaddr_gethostbyname(&sockAddr, preparepoweroff, moduleready, &sffsdrnandflash); 
         if(sffsdrnandflash == 0)
         {
            HttpSocket_soReuseaddr(o, &sffsdrnandflash);
            HttpSocket_bind(o, &sockAddr, hwmoddeassert, &sffsdrnandflash);
            if(sffsdrnandflash != 0)
            {
               HttpSocket_close(o);
               sffsdrnandflash=E_BIND;
            }
         }
         else
         {
            HttpSocket_close(o);
            sffsdrnandflash=E_GETHOSTBYNAME;
         }
      }
   }
   else
   {
      sffsdrnandflash = E_INVALID_SOCKET_CON;
      HttpSocket_invalidate(o);
   }
   return sffsdrnandflash; 
}

#ifdef USE_DGRAM
#ifndef HttpSocket_setmembership
BA_API int
HttpSocket_setmembership(HttpSocket* o,
                         BaBool writeoutput,
                         BaBool moduleready,
                         const char* mcasp1resources,
                         const char* enablecache)
{
   int sffsdrnandflash;
   HttpSockaddr intfAddr, multiAddr;
   HttpSockaddr_gethostbyname(&multiAddr, mcasp1resources, moduleready, &sffsdrnandflash);
   if( ! sffsdrnandflash )
   {
#if defined(USE_IPV6) && !defined(NO_IPV6_MEMBERSHIP)
      if(moduleready)
      {
         struct ipv6_mreq mreq;
         memcpy(&mreq.ipv6mr_multiaddr, multiAddr.addr, 16);
         if(enablecache)
         {
            ba_nametoindex(enablecache,&mreq.ipv6mr_interface,&sffsdrnandflash);
         }
         else
         {
            mreq.ipv6mr_interface=0;
         }
         if( ! sffsdrnandflash )
         {
            sffsdrnandflash = socketSetsockopt(
               o->hndl, IPPROTO_IPV6, 
               writeoutput ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP,
               (char *) &mreq, sizeof(mreq));
         }
      }
      else
#endif
      {
         HttpSockaddr_gethostbyname(&intfAddr, enablecache, FALSE, &sffsdrnandflash);
         if( ! sffsdrnandflash )
         {
            struct ip_mreq mreq;
            memcpy(&mreq.imr_multiaddr.s_addr, multiAddr.addr, 4);
            memcpy(&mreq.imr_interface.s_addr, intfAddr.addr, 4);
            sffsdrnandflash = socketSetsockopt(
               o->hndl, IPPROTO_IP,
               writeoutput ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP,
               (char *) &mreq, sizeof(mreq));
         }
      }
   }
   return sffsdrnandflash;
}
#endif
#endif

#ifdef USE_ADDRINFO
#ifndef BaAddrinfo_connect

static int
mpidrduplicate(HttpSocket* s, U32 pciercxcfg035)
{
   struct timeval tv;
   fd_set fds;
   FD_ZERO(&fds);
   FD_SET(s->hndl, &fds);
   tv.tv_sec = pciercxcfg035 / 1000;
   tv.tv_usec = (pciercxcfg035 % 1000) * 1000;
   if(socketSelect(s->hndl + 1, 0, &fds, 0, &tv)==1)
   {
      struct sockaddr_storage serialports;
      socklen_t icachealiases=sizeof(struct sockaddr_storage);
      if(!socketGetPeerName(s->hndl, (struct sockaddr*)&serialports, &icachealiases))
         return 1;
   }
   HttpSocket_close(s);
   return E_CANNOT_CONNECT;
}

int
BaAddrinfo_connect(BaAddrinfo* serialports, HttpSocket* s, U32 pciercxcfg035)
{
   int sffsdrnandflash;
   HttpSocket_setNonblocking(s, &sffsdrnandflash);
   sffsdrnandflash = socketConnect(s->hndl, serialports->ai_addr, serialports->ai_addrlen);
   if(sffsdrnandflash)
   {
      HttpSocket_wouldBlock(s, &sffsdrnandflash);
      if( ! sffsdrnandflash )
      {
         HttpSocket_close(s);
         sffsdrnandflash = E_CANNOT_CONNECT;
      }
      else if(pciercxcfg035)
         sffsdrnandflash = mpidrduplicate(s, pciercxcfg035);
      else
         sffsdrnandflash = 0; 
   }
   else
      sffsdrnandflash = 1; 
   return sffsdrnandflash;
}
#endif
#endif 


#ifndef HttpSockaddr_addr2String

static int
regulatorpdata(U8* ptr, char* buf, int instructionemulation)
{
   return
      basnprintf(buf, instructionemulation,
                  "\045\165\056\045\165\056\045\165\056\045\165",
                  (unsigned int)ptr[0],
                  (unsigned int)ptr[1],
                  (unsigned int)ptr[2],
                  (unsigned int)ptr[3])
      < 0 ? -1 : 0;
}

#ifdef USE_IPV6
static int
stepminshift(U8* ptr, char* buf, int instructionemulation)
{
   U8 *tp, *ep;
   struct { int base, len; } best, cur;
   U16 writepmresrn[IN6ADDRSZ / U16Z];
   U8 doublefnmul[sizeof("\146\146\146\146\072\146\146\146\146\072\146\146\146\146\072\146\146\146\146\072\146\146\146\146\072\146\146\146\146\072\062\065\065\056\062\065\065\056\062\065\065\056\062\065\065")];
   int i;
   int entervirtual;

   memset(writepmresrn, 0, sizeof writepmresrn);
   for (i = 0; i < IN6ADDRSZ; i++)
      writepmresrn[i / 2] |= (ptr[i] << ((1 - (i % 2)) << 3));
   best.base = -1;
   best.len  = 0;
   cur.base = -1;
   cur.len  = 0;
   for (i = 0; i < (IN6ADDRSZ / U16Z); i++) 
   {
      if (writepmresrn[i] == 0) 
      {
         if (cur.base == -1)
            cur.base = i, cur.len = 1;
         else
            cur.len++;
      }
      else 
      {
         if (cur.base != -1) 
         {
            if (best.base == -1 || cur.len > best.len)
               best = cur;
            cur.base = -1;
         }
      }
   }
   if (cur.base != -1) 
   {
      if (best.base == -1 || cur.len > best.len)
         best = cur;
   }
   if (best.base != -1 && best.len < 2)
      best.base = -1;
   tp = doublefnmul;
   ep = doublefnmul + sizeof(doublefnmul);
   for (i = 0; i < (IN6ADDRSZ / U16Z) && tp < ep; i++) 
   {
      if (best.base != -1 && i >= best.base &&
          i < (best.base + best.len)) 
      {
         if (i == best.base) 
         {
            if (tp + 1 >= ep)
               return -1;
            *tp++ = '\072';
         }
         continue;
      }
      if (i != 0) 
      {
         if (tp + 1 >= ep)
            return -1;
         *tp++ = '\072';
      }
      if (i == 6 && best.base == 0 &&
          (best.len == 6 || (best.len == 5 && writepmresrn[5] == 0xffff))) 
      {
         if (regulatorpdata(ptr+12, (char*)tp, (int)(ep - tp)))
            return -1;
         tp += strlen((char*)tp);
         break;
      }
      entervirtual = basnprintf((char*)tp, (int)(ep - tp), "\045\170", writepmresrn[i]);
      if (entervirtual <= 0 || entervirtual >= ep - tp)
         return -1;
      tp += entervirtual;
   }
   if (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / U16Z)) 
   {
      if (tp + 1 >= ep)
         return -1;
      *tp++ = '\072';
   }
   if (tp + 1 >= ep)
      return -1;
   *tp++ = 0;

   if ((tp - doublefnmul) > instructionemulation) 
   {
      return -1;
   }
   strncpy(buf, (char*)doublefnmul, instructionemulation);
   return 0;
}
#endif

BA_API void
HttpSockaddr_addr2String(HttpSockaddr* o, char* buf, int instructionemulation, int* sffsdrnandflash)
{
#ifdef USE_IPV6
   *sffsdrnandflash = o->isIp6 ?
      stepminshift((U8*)o->addr, buf, instructionemulation) :
      regulatorpdata((U8*)o->addr, buf, instructionemulation);
#else
   *sffsdrnandflash = regulatorpdata((U8*)o->addr, buf, instructionemulation);
#endif
}

#endif

static int
defaultsdhci2(const char* src, void* pciercxcfg448)
{
   U32 uda134xplatform=0;
   int i;
   char buf[4];
   char* end;
   for(i = 0 ; i < 4 ; i++)
   {
      uda134xplatform <<= 8;
      end = (char*)(i < 3 ? strchr(src, '\056') : src+strlen(src));
      if( ! end || (end - src) > 3)
         break; 
      memmove(buf, src, end - src);
      buf[end - src] = 0;
      uda134xplatform += U32_atoi(buf);
      if(i == 3)
      {
#ifdef B_LITTLE_ENDIAN
         uda134xplatform=baHtonl(uda134xplatform);
#endif
         memcpy(pciercxcfg448, &uda134xplatform, INADDRSZ);
         return 0;
      }
      src = end+1;
   }
   return -1;
}


#ifndef HttpSockaddr_inetAddr
BA_API void HttpSockaddr_inetAddr(
   HttpSockaddr* o, const char* writereg16, BaBool percpuorder, int* sffsdrnandflash)
{
   *sffsdrnandflash = -1;
   if( ! bIsxdigit(*writereg16) && *writereg16 != '\072')
      return; 
   if( ! percpuorder )
   {
      if( ! defaultsdhci2(writereg16,o->addr) )
      {
         o->isIp6=FALSE;
         *sffsdrnandflash=0;
         return;
      }
   }
#ifdef USE_IPV6
   {
      static const char gpio2config[] = "\060\061\062\063\064\065\066\067\070\071\141\142\143\144\145\146";
      static const char prepareelf64[] = "\060\061\062\063\064\065\066\067\070\071\101\102\103\104\105\106";
      U8 *tp, *endp, *colonp;
      const char *xdigits, *curtok;
      int ch, foundDigit;
      U32 val;
      tp = (U8*)o->addr;
      memset(o->addr, 0, IN6ADDRSZ);
      endp = tp + IN6ADDRSZ;
      colonp = NULL;
      
      if (*writereg16 == '\072')
         if (*++writereg16 != '\072')
            return;
      curtok = writereg16;
      foundDigit = 0;
      val = 0;
      while ((ch = *writereg16++) != '\000')
      {
         const char *pch;
         if ((pch = strchr((xdigits = gpio2config), ch)) == NULL)
            pch = strchr((xdigits = prepareelf64), ch);
         if (pch)
         {
            val <<= 4;
            val |= (pch - xdigits);
            if (val > 0xffff)
               return;
            foundDigit = 1;
            continue;
         }
         if (ch == '\072')
         {
            curtok = writereg16;
            if (!foundDigit)
            {
               if (colonp)
                  return;
               colonp = tp;
               continue;
            }
            if (tp + U16Z > endp)
               return;
            *tp++ = (U8) (val >> 8) & 0xff;
            *tp++ = (U8) val & 0xff;
            foundDigit = 0;
            val = 0;
            continue;
         }
         if (ch == '\056' && ((tp + INADDRSZ) <= endp) && !defaultsdhci2(curtok, tp))
         {
            tp += INADDRSZ;
            foundDigit = 0;
            break;
         }
         return;
      }
      if (foundDigit)
      {
         if (tp + U16Z > endp)
            return;
         *tp++ = (U8) (val >> 8) & 0xff;
         *tp++ = (U8) val & 0xff;
      }
      if (colonp)
      {
         
         const int n = (int)(tp - colonp);
         int i;

         for (i = 1; i <= n; i++)
         {
            endp[- i] = colonp[n - i];
            colonp[n - i] = 0;
         }
         tp = endp;
      }
      if (tp != endp)
         return;
      o->isIp6=TRUE;
      *sffsdrnandflash=0;
   }
#endif
}
#endif



#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <HttpTrace.h>
#include <ThreadLib.h>

#ifdef HTTP_TRACE

static BaBool HttpTrace_isInitialized=FALSE;
static HttpTrace_Flush httpTrace_flushCB=0;
static ThreadMutex HttpTrace_mutex;
static HttpTrace httpTrace;




static int
keypadpdata(BufPrint* stealclock, int accesssubid)
{
   (void)accesssubid; 
   baAssert(httpTrace_flushCB);
   if(stealclock->cursor)
   {
      static BaBool au1500intclknames = FALSE;
      if( ! au1500intclknames )
      {
         au1500intclknames = TRUE;
         httpTrace_flushCB(stealclock->buf, stealclock->cursor);
         au1500intclknames = FALSE;
      }
      stealclock->cursor=0;
   }
   else
      return 0;
   return 0;
}


static void
flushIfNewLine(void)
{
   BufPrint* stealclock=(BufPrint*)&httpTrace;
   if(stealclock->cursor)
   {
      stealclock->buf[stealclock->cursor]=0;
      if(strchr(stealclock->buf, '\012'))
         keypadpdata(stealclock, 0);
   }
}


static void
gpio6hwmod(HttpTrace* o, HttpTrace_Flush fcb, int icachealiases)
{
   BufPrint* fdc37m81xconfig = (BufPrint*)o;
   memset(o, 0, sizeof(HttpTrace));
   BufPrint_constructor(fdc37m81xconfig, 0, keypadpdata);
   fdc37m81xconfig->buf=baMalloc(icachealiases+8);
   fdc37m81xconfig->bufSize=icachealiases;
   o->prio=5; 
   httpTrace_flushCB = fdc37m81xconfig->buf ? fcb : 0;
   ThreadMutex_constructor(&HttpTrace_mutex);
}




BA_API int
HttpTrace_setPrio(int reservevmcore)
{
   int viperquirks=httpTrace.prio;
   httpTrace.prio=reservevmcore;
   return viperquirks;
}


BA_API void
HttpTrace_setFLushCallback(HttpTrace_Flush fcb)
{
   if(HttpTrace_isInitialized && ((BufPrint*)&httpTrace)->buf)
      httpTrace_flushCB = fcb;
   else
   {
      gpio6hwmod(&httpTrace, fcb, 81);
      HttpTrace_isInitialized=TRUE;
   }
}

BA_API HttpTrace_Flush
HttpTrace_getFLushCallback(void)
{
   return httpTrace_flushCB;
}


BA_API void
HttpTrace_printf(int reservevmcore, const char* fmt, ...)
{
   if(httpTrace_flushCB)
   {
      va_list demuxregids;
      va_start(demuxregids, fmt);  
      HttpTrace_vprintf(reservevmcore, fmt, demuxregids);
      va_end(demuxregids);
   }
}


BA_API void
HttpTrace_vprintf(int reservevmcore, const char* fmt, va_list breakpointthread)
{
   if(reservevmcore <= httpTrace.prio && httpTrace_flushCB)
   {
      ThreadMutex_set(&HttpTrace_mutex);
      BufPrint_vprintf((BufPrint*)&httpTrace, fmt, breakpointthread);
      flushIfNewLine();
      ThreadMutex_release(&HttpTrace_mutex);
   }
}


BA_API BufPrint*
HttpTrace_getWriter(void)
{
   if(httpTrace_flushCB)
   {
      ThreadMutex_set(&HttpTrace_mutex);
      return (BufPrint*)&httpTrace;
   }
   return 0;
}


BA_API void
HttpTrace_releaseWriter(void)
{
   baAssert(httpTrace_flushCB);
   if(httpTrace_flushCB)
   {
      flushIfNewLine();
      ThreadMutex_release(&HttpTrace_mutex);
   }
}


BA_API void
HttpTrace_write(int reservevmcore, const char* buf, int len)
{
   if(reservevmcore <= httpTrace.prio && httpTrace_flushCB)
   {
      if(len < 0)
         len = iStrlen(buf);
      ThreadMutex_set(&HttpTrace_mutex);
      BufPrint_write((BufPrint*)&httpTrace, buf, len);
      flushIfNewLine();
      ThreadMutex_release(&HttpTrace_mutex);
   }
}

BA_API void
HttpTrace_flush(void)
{
   if(httpTrace_flushCB)
   {
      ThreadMutex_set(&HttpTrace_mutex);
      keypadpdata((BufPrint*)&httpTrace, 0);
      ThreadMutex_release(&HttpTrace_mutex);
   }
}

BA_API void
HttpTrace_setRequest(BaBool cmd)
{
   if(cmd)
      httpTrace.traceCmds |= HttpTrace_doRequestMask;
   else
      httpTrace.traceCmds &= ~(U8)HttpTrace_doRequestMask;
}


BA_API void
HttpTrace_setRequestHeaders(BaBool cmd)
{
   if(cmd)
   {
      HttpTrace_setRequest(TRUE);
      httpTrace.traceCmds |= HttpTrace_doRequestHeadersMask;
   }
   else
      httpTrace.traceCmds &= ~(U8)HttpTrace_doRequestHeadersMask;
}


BA_API void
HttpTrace_setResponseHeaders(BaBool cmd)
{
   if(cmd)
      httpTrace.traceCmds |= HttpTrace_doResponseHeadersMask;
   else
      httpTrace.traceCmds &= ~(U8)HttpTrace_doResponseHeadersMask;
}


BA_API void
HttpTrace_setResponseBody(BaBool cmd)
{
   if(cmd)
      httpTrace.traceCmds |= HttpTrace_doResponseBodyMask;
   else
      httpTrace.traceCmds &= ~(U8)HttpTrace_doResponseBodyMask;
}


BA_API void
HttpTrace_setHttp11State(BaBool cmd)
{
   if(cmd)
      httpTrace.traceCmds |= HttpTrace_doHttp11StateMask;
   else
      httpTrace.traceCmds &= ~(U8)HttpTrace_doHttp11StateMask;
}

BA_API void
HttpTrace_setReqBufOverflow(BaBool cmd)
{
   if(cmd)
      httpTrace.traceCmds |= HttpTrace_doReqBufOverflowMask;
   else
      httpTrace.traceCmds &= ~(U8)HttpTrace_doReqBufOverflowMask;
}

BA_API U8
HttpTrace_getTraceCmds(void)
{
   return httpTrace.traceCmds;
}


BA_API int
HttpTrace_setBufSize(int icachealiases)
{
   BufPrint* fdc37m81xconfig = (BufPrint*)&httpTrace;
   if(fdc37m81xconfig->buf)
   {
      baFree(fdc37m81xconfig->buf);
      fdc37m81xconfig->buf=0;
   }
   if( !HttpTrace_isInitialized )
   {
      gpio6hwmod(&httpTrace, httpTrace_flushCB, icachealiases);
      HttpTrace_isInitialized=TRUE;
   }
   else
   {
      if(icachealiases < 81)
         icachealiases=81;
      fdc37m81xconfig->buf=baMalloc(icachealiases);
      fdc37m81xconfig->bufSize=icachealiases-1;
   }
   if(!fdc37m81xconfig->buf)
   {
      httpTrace_flushCB = 0; 
      return -1;
   }
   return 0;
}



BA_API HttpTrace*
HttpTrace_get(void)
{
   return &httpTrace;
}


BA_API void
HttpTrace_TRPR(const char* fmt, ...)
{
   if(httpTrace_flushCB)
   {
      va_list demuxregids;
      va_start(demuxregids, fmt);  
      HttpTrace_vprintf(0, fmt, demuxregids);
      va_end(demuxregids);
   }
}


BA_API void
HttpTrace_close(void)
{
   BufPrint* fdc37m81xconfig = (BufPrint*)&httpTrace;
   if(fdc37m81xconfig->buf)
      baFree(fdc37m81xconfig->buf);
   fdc37m81xconfig->buf=0;
   httpTrace_flushCB=0;
}


#else 


BA_API int
HttpTrace_setPrio(int reservevmcore)
{
   (void)reservevmcore;
   return 0;
}

BA_API void
HttpTrace_setFLushCallback(HttpTrace_Flush fcb)
{
   (void)fcb;
}


BA_API void
HttpTrace_printf(int reservevmcore, const char* fmt, ...)
{
   (void)reservevmcore;
   (void)fmt;
}


BA_API void
HttpTrace_vprintf(int reservevmcore, const char* fmt, va_list breakpointthread)
{
   (void)reservevmcore;
   (void)fmt;
   (void)breakpointthread;
}


BA_API void
HttpTrace_write(int reservevmcore, const char* buf, int len)
{
   (void)reservevmcore;
   (void)buf;
   (void)len;
}

BA_API void
HttpTrace_flush(void)
{
}

BA_API BufPrint*
HttpTrace_getWriter(void)
{
   return 0;
}


BA_API void
HttpTrace_releaseWriter(void)
{
}

BA_API void
HttpTrace_setRequest(BaBool cmd)
{
   (void)cmd;
}


BA_API void
HttpTrace_setRequestHeaders(BaBool cmd)
{
   (void)cmd;
}


BA_API void
HttpTrace_setResponseHeaders(BaBool cmd)
{
   (void)cmd;
}


BA_API void
HttpTrace_setResponseBody(BaBool cmd)
{
}


BA_API void
HttpTrace_setHttp11State(BaBool cmd)
{
   (void)cmd;
}

BA_API void
HttpTrace_setReqBufOverflow(BaBool cmd)
{
   (void)cmd;
}

BA_API U8
HttpTrace_getTraceCmds()
{
   return 0;
}

BA_API int
HttpTrace_setBufSize(int icachealiases)
{
   (void)icachealiases;
   return 0;
}



HttpTrace*
HttpTrace_get(void)
{
   baAssert(0);
   return 0;
}

BA_API void
HttpTrace_TRPR(const char* fmt, ...)
{
   (void)fmt;
}

BA_API void
HttpTrace_close(void)
{
}


#endif 


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <IoIntfZipReader.h>
#include <HttpTrace.h>






static int
broadcastcallee(IoIntfZipReader* o, void* alloccontroller,
                       U32 idmapstart, U32 icachealiases,
                       int spectreauxcr)
{
   size_t rsize;
   ResIntfPtr fp = o->fp;
   (void)spectreauxcr;
   if(o->currentOffset != idmapstart)
      if( (o->lastECode=fp->seekFp(fp, idmapstart)) != 0)
         return o->lastECode;
   o->currentOffset = idmapstart + icachealiases;
   if( (o->lastECode=fp->readFp(fp, alloccontroller, icachealiases, &rsize)) == 0 )
   {
      if(rsize != icachealiases)
         o->lastECode=IOINTF_IOERROR;
   }
   return o->lastECode;
}



static int
shortinstr(IoIntfZipReader* o, void* alloccontroller,
                       U32 idmapstart, U32 icachealiases,
                       int spectreauxcr)
{
   size_t rsize;
   (void)spectreauxcr;
   if( (o->lastECode=o->seekAndReadFp(o->fp, idmapstart,alloccontroller,icachealiases,&rsize)) == 0 )
   {
      if(rsize != icachealiases)
         o->lastECode=IOINTF_IOERROR;
   }
   return o->lastECode;
}


static int
ep80219setup(IoIntfZipReader* o, void* alloccontroller,
                       U32 idmapstart, U32 icachealiases,
                       int spectreauxcr)
{
   (void)o;
   (void)alloccontroller;
   (void)idmapstart;
   (void)icachealiases;
   (void)spectreauxcr;
   return IOINTF_IOERROR;
}


BA_API void
IoIntfZipReader_constructor(IoIntfZipReader* o,
                            IoIntf* io,
                            const char* timerregister)
{
   IoStat st;
   memset(o, 0, sizeof(IoIntfZipReader));
   if( (o->lastECode = io->statFp(io, timerregister, &st)) != 0)
   {
      TRPR(("\105\162\162\157\162\072\040\111\157\111\156\164\146\132\151\160\122\145\141\144\145\162\054\040\143\141\156\156\157\164\040\157\160\145\156\040\045\163\056", timerregister));
      
      ZipReader_constructor((ZipReader*)o, 0, 0);
      return;
   }
   if(io->propertyFp(io, "\163\145\145\153\101\156\144\122\145\141\144", (void*)&o->seekAndReadFp, 0))
   {
      ZipReader_constructor((ZipReader*)o,
                            (CspReader_Read)broadcastcallee,
                            (U32)st.size);
   }
   else
   {
      ZipReader_constructor((ZipReader*)o,
                            (CspReader_Read)shortinstr,
                            (U32)st.size);
   }
   o->fp = io->openResFp(io, timerregister, OpenRes_READ, &o->lastECode, 0);
   if( o->fp )
   {
      CspReader_setIsValid(o); 
   }
   else
   {
      TRPR(("\105\162\162\157\162\072\040\111\157\111\156\164\146\132\151\160\122\145\141\144\145\162\054\040\143\141\156\156\157\164\040\157\160\145\156\040\045\163\056", timerregister));
   }
}


BA_API int
IoIntfZipReader_close(IoIntfZipReader* o)
{
   if(o->fp)
   {
      ResIntfPtr fp = o->fp;
      o->fp=0;
      if(((CspReader*)o)->readCB==(CspReader_Read)broadcastcallee ||
         ((CspReader*)o)->readCB==(CspReader_Read)shortinstr)
      {
         ((CspReader*)o)->readCB = (CspReader_Read)ep80219setup;
      }
      return fp->closeFp(fp);
   }
   return -1;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#define sodispcon_c 1
#define INL_baConvBin2Hex 1

#include <HttpServer.h>
#include <BaServerLib.h>
#include <HttpTrace.h>
#include <string.h>

#ifndef NO_SHARKSSL
#include <HttpSharkSslServCon.h>
#endif

static int
singlefnmac(SoDispCon* con,
                         ThreadMutex* m,
                         SoDispCon_ExType s,
                         void* d1,
                         int d2)
{
   (void)con; 
   (void)m; 
   (void)s; 
   (void)d1; 
   (void)d2; 
   return E_INCORRECT_USE;
}


static void
defaultoverflow(SoDispCon* o)
{
   SoDispCon_zzCloseCon(o, 2);
}


BA_API void
SoDispCon_constructor(SoDispCon* o, SoDisp* sha256start, SoDispCon_DispRecEv e)
{
   memset(o, 0, sizeof(SoDispCon));
   HttpSocket_constructor(&o->httpSocket);
   o->dispatcher = sha256start;
   o->dispRecEv = e;
   o->dispSendEv = defaultoverflow;
   o->exec = singlefnmac;
   if(sha256start)
      SoDisp_newCon(sha256start, o);
   
   baAssert( ! o->isSending );
   baAssert( ! o->sendTermPtr );
   baAssert( ! o->recTermPtr );
   baAssert( ! o->dataBits );
   baAssert( ! o->rtmo );
}


BA_API void
SoDispCon_zzCloseCon(SoDispCon* o, int shashdigestsize)
{
   if(SoDispCon_recEvActive(o))
      SoDisp_deactivateRec(o->dispatcher,o);
   if(SoDispCon_sendEvActive(o))
      SoDisp_deactivateSend(o->dispatcher,o);
   if(SoDispCon_dispatcherHasCon(o))
      SoDisp_removeConnection(o->dispatcher,o);
   if(HttpSocket_isValid(&o->httpSocket))
   {
      if(o->exec != singlefnmac)
      {
         o->exec(o,
                 SoDisp_getMutex(o->dispatcher),
                 SoDispCon_ExTypeClose,
                 0,
                 0);
      }
      if(shashdigestsize)
      {
         if(shashdigestsize == 2)
         {
            HttpSocket_hardClose(&o->httpSocket);
         }
         else
         {
            HttpSocket_shutdown(&o->httpSocket);
         }
      }
      else
      {
         HttpSocket_close(&o->httpSocket);
      }
      baAssert( ! HttpSocket_isValid(&o->httpSocket) );
   }
   o->dataBits=0;
}


BA_API int
SoDispCon_moveCon(SoDispCon* o,  SoDispCon* boardmanufacturer)
{
   baAssert(SoDispCon_setDispatcherHasCon(o));
   if(SoDispCon_recEvActive(o))
      SoDisp_deactivateRec(o->dispatcher,o);
   if(SoDispCon_sendEvActive(o))
      SoDisp_deactivateSend(o->dispatcher,o);
   SoDisp_removeConnection(o->dispatcher, o);
   boardmanufacturer->dataBits = o->dataBits;
   o->exec(o,0,SoDispCon_ExTypeMoveCon,boardmanufacturer,0);
   HttpSocket_move(&o->httpSocket, &boardmanufacturer->httpSocket);
   o->dataBits &= ~(U8)(SoDispCon_hasMoreDataDataBitMask |
                        SoDispCon_isNonBlockingDataBitMask);
   baAssert( ! SoDispCon_isValid(o) );
   return 0;
}

#ifdef HTTP_TRACE
static void
printsystem(const void* alloccontroller, int len)
{
   HttpTrace_write(9,(char*)alloccontroller, len);
   HttpTrace_write(9,"\012",1);
}
#endif

BA_API int
SoDispCon_blockRead(SoDispCon* o, void* alloccontroller, int len)
{
   int buttonsbuffalo;
   baAssert( ! SoDispCon_isNonBlocking(o) );
   do
   {
      SoDispCon_setDispHasRecData(o); 
      buttonsbuffalo = SoDispCon_readData(o, alloccontroller, len, TRUE);
   } while(buttonsbuffalo == 0 && SoDispCon_isSecure(o));
   return buttonsbuffalo;
}


BA_API int
SoDispCon_sendData(SoDispCon* o, const void* alloccontroller, int len)
{
   int handlersetup;
#ifdef HTTP_TRACE
   if(HttpTrace_doResponseBody())
      printsystem(alloccontroller,len);
#endif
   if( ! SoDispCon_isValid(o) )
      return -1;
   o->isSending=TRUE;
   handlersetup = o->exec(o,
                    SoDisp_getMutex(o->dispatcher),
                    SoDispCon_ExTypeWrite,
                    (void*)alloccontroller,len) == len ?
      0 : E_SOCKET_WRITE_FAILED;
   o->isSending=FALSE;
   return handlersetup;
}



BA_API int
SoDispCon_sendDataNT(SoDispCon* o, const void* alloccontroller, int len)
{
   int handlersetup;
   if( ! SoDispCon_isValid(o) )
      return -1;
   o->isSending=TRUE;
   handlersetup = o->exec(o,
                    SoDisp_getMutex(o->dispatcher),
                    SoDispCon_ExTypeWrite,
                    (void*)alloccontroller,len) == len ?
      0 : E_SOCKET_WRITE_FAILED;
   o->isSending=FALSE;
   return handlersetup;
}



BA_API int
SoDispCon_sendDataX(SoDispCon* o, const void* alloccontroller, int len)
{
   int handlersetup;
   if( ! SoDispCon_isValid(o) )
      return -1;
   o->isSending=TRUE;
   handlersetup = o->exec(o,
                    0,
                    SoDispCon_ExTypeWrite,
                    (void*)alloccontroller,len) == len ?
      0 : E_SOCKET_WRITE_FAILED;
   o->isSending=FALSE;
   return handlersetup;
}



BA_API int
SoDispCon_sendChunkData(SoDispCon* o, const void* alloccontroller, int len)
{
   U8 buf[6];
   U8* cachesysfs = buf;
   U8* end = buf;
   U8 processsubpacket = (U8)(len >> 8);
   if(processsubpacket)
   {
      baConvBin2Hex(end, processsubpacket);
      end+=2;
   }
   baConvBin2Hex(end, (U8)len);
   end+=2;
   *end++ = '\015';
   *end = '\012';
   if(*cachesysfs == '\060') cachesysfs++;
   if(!SoDispCon_sendDataNT(o, cachesysfs, (int)(end-cachesysfs+1)))
      if(!SoDispCon_sendData(o, alloccontroller, len))
         if(!SoDispCon_sendDataNT(o, "\015\012", 2))
            return 0;
   return -1;
}


BA_API void*
SoDispCon_allocAsynchBuf(SoDispCon* o, int* icachealiases)
{
   AllocAsynchBufArgs enetswplatform;
   enetswplatform.size = *icachealiases;
   (o)->exec(o,0,SoDispCon_ExTypeAllocAsynchBuf,&enetswplatform,0);
   *icachealiases = enetswplatform.size;
   return enetswplatform.retVal;
}


BA_API void
SoDispCon_setTCPNoDelay(SoDispCon* o, int writeoutput)
{
   int sffsdrnandflash;
   (void)writeoutput;
   HttpSocket_setTCPNoDelay(&o->httpSocket, writeoutput, &sffsdrnandflash);
   if(sffsdrnandflash)
   {
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(o, "\163\145\164\124\103\120\116\157\104\145\154\141\171", &o->httpSocket, sffsdrnandflash);
#endif
   }
}

BA_API int
SoDispCon_setNonblocking(SoDispCon* o)
{
   int sffsdrnandflash;

   if( SoDispCon_isNonBlocking(o) )
   {
      TRPR(("\123\157\104\151\163\160\103\157\156\072\072\163\145\164\116\157\156\142\154\157\143\153\151\156\147\040\055\076\040\151\163\040\141\154\162\145\141\144\171\040\156\157\156\040\142\154\157\143\153\151\156\147\012"));
      return -1;
   }

   HttpSocket_setNonblocking(&o->httpSocket, &sffsdrnandflash);
   if(sffsdrnandflash)
   {
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(o, "\163\145\164\116\157\156\142\154\157\143\153\151\156\147", &o->httpSocket, sffsdrnandflash);
#endif
   }
   else
      o->dataBits |= SoDispCon_isNonBlockingDataBitMask;
   return sffsdrnandflash;
}


BA_API int
SoDispCon_setBlocking(SoDispCon* o)
{
   int sffsdrnandflash;

   if( ! SoDispCon_isNonBlocking(o) )
   {
      TRPR(("\123\157\104\151\163\160\103\157\156\072\072\163\145\164\102\154\157\143\153\151\156\147\040\055\076\040\151\163\040\141\154\162\145\141\144\171\040\142\154\157\143\153\151\156\147\012"));
      return -1;
   }

   HttpSocket_setBlocking(&o->httpSocket, &sffsdrnandflash);
   if(sffsdrnandflash)
   {
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(o, "\163\145\164\102\154\157\143\153\151\156\147", &o->httpSocket, sffsdrnandflash);
#endif
   }
   else
      (o)->dataBits &= ~(U8)SoDispCon_isNonBlockingDataBitMask;
   return sffsdrnandflash;
}



BA_API int
SoDispCon_getPeerName(SoDispCon* o, HttpSockaddr* serialports, U16* hwmoddeassert)
{
   int sffsdrnandflash=0;
   BaBool earlyconfig = SoDispCon_isIP6(o);
   HttpSocket_getPeerName(&o->httpSocket, serialports, hwmoddeassert, earlyconfig, &sffsdrnandflash);
   if(sffsdrnandflash)
   {
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(o, "\147\145\164\120\145\145\162\116\141\155\145", &o->httpSocket, sffsdrnandflash);
#endif
   }
   return sffsdrnandflash;
}


BA_API int
SoDispCon_getSockName(SoDispCon* o, HttpSockaddr* serialports, U16* hwmoddeassert)
{
   int sffsdrnandflash=0;
   BaBool earlyconfig = SoDispCon_isIP6(o);
   HttpSocket_getSockName(&o->httpSocket, serialports, hwmoddeassert, earlyconfig, &sffsdrnandflash);
   if(sffsdrnandflash)
   {
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(o, "\147\145\164\123\157\143\153\116\141\155\145", &o->httpSocket, sffsdrnandflash);
#endif
   }
   return sffsdrnandflash;
}


BA_API char*
SoDispCon_addr2String(SoDispCon* o,
                      HttpSockaddr* serialports,
                      char* buf,
                      int len)
{
   int sffsdrnandflash;
   if( !buf )
      return 0;
   buf[0]=0;
   if(serialports->isIp6 ? (len < 46) : (len < 16))
      return 0;
   if(SoDispCon_isIP6(o) != serialports->isIp6)
      return 0;

   HttpSockaddr_addr2String(serialports, buf, len, &sffsdrnandflash);
   return sffsdrnandflash ? 0 : buf;
}


static BaBool
cmpIp4MappedIp6(const char factoryconfig[16], const char ip4[16])
{
   return !memcmp(
      "\000\000\000\000\000\000\000\000\000\000\377\377", factoryconfig, 12) &&
      !memcmp(factoryconfig+12,ip4,4);
}


BA_API BaBool
SoDispCon_cmpAddr(SoDispCon* o, HttpSockaddr* configureerrgen)
{
   HttpSockaddr addr1;
   if( !SoDispCon_getPeerName(o,&addr1,0) )
   {
      if(addr1.isIp6 == configureerrgen->isIp6)
      {
         int len = addr1.isIp6 ? 16 : 4;
         return memcmp(addr1.addr, configureerrgen->addr, len) == 0;
      }
      if(addr1.isIp6 && addr1.addr[0] == 0)
         return cmpIp4MappedIp6((char*)addr1.addr, (char*)configureerrgen->addr);
      if(configureerrgen->isIp6 && configureerrgen->addr[0] == 0)
         return cmpIp4MappedIp6((char*)configureerrgen->addr, (char*)addr1.addr);
   }
   return FALSE;
}


BA_API int
SoDispCon_asyncReadyF(SoDispCon* o)
{
   return SoDispCon_asyncReady(o);
}


#ifdef HTTP_TRACE
BA_API void
SoDispCon_printSockErr(SoDispCon* o,const char* rightsvalid,HttpSocket* s,int sffsdrnandflash)
{
   int serial8250device;
   (void)s; 
   HttpSocket_errno(s, sffsdrnandflash, &serial8250device);
   HttpTrace_printf(10,"\123\157\143\153\145\164\040\145\162\162\157\162\054\040\143\157\156\156\145\143\164\151\157\156\040\050\045\160\051\040\045\163\040\145\162\162\156\157\072\040\045\144\012",
                    o, rightsvalid, serial8250device);
}
#endif

BA_API int
SoDispCon_upgrade(
   SoDispCon* o, struct SharkSsl* ssl, const char* disableswapping, const char* writereg16, int hwmoddeassert)
{
#ifndef NO_SHARKSSL
   return HttpSharkSslServCon_bindExec(o, ssl, disableswapping, writereg16, hwmoddeassert);
#else
   return E_INCORRECT_USE;
#endif
}





#ifdef USE_ADDRINFO


static int hwmodcommon(SoDispCon* o, const char* writereg16,
                                 U16 hwmoddeassert,BaBool restoreucontext, BaBool moduleready,
                                 BaAddrinfo** serialports, char** sha256import)
{
   BaAddrinfo hints;
   int sffsdrnandflash;
   char keypadresource[8];
   char* dcachealiases;
   if(restoreucontext)
      o->dataBits |= SoDispCon_DGramBitMask;
   if(!sha256import)
      sha256import=&dcachealiases;
   BaAddrinfo_hintsInit(&hints, restoreucontext, moduleready);
   basprintf(keypadresource, "\045\144",(unsigned int)hwmoddeassert);
   BaAddrinfo_get(writereg16, keypadresource, &hints, serialports, &sffsdrnandflash, sha256import);
   return sffsdrnandflash ? E_CANNOT_RESOLVE : 0;
}

BA_API int
SoDispCon_connect(SoDispCon* o,
                   const char* writereg16,
                   U16 hwmoddeassert,
                   const void* preparepoweroff,
                   U16 bindPort,
                   U32 pciercxcfg035,
                   BaBool restoreucontext, BaBool moduleready,
                   char** sha256import)
{

   BaAddrinfo* serialports;
   int sffsdrnandflash;
   ThreadMutex* m = SoDisp_getMutex(SoDispCon_getDispatcher(o));
   if(sha256import) *sha256import=0;
    
   if( ! m || ! ThreadMutex_isOwner(m) )
      m=0;
   else
      ThreadMutex_release(m);
   baAssert(pciercxcfg035);
   sffsdrnandflash = hwmodcommon(o,writereg16,hwmoddeassert,restoreucontext,moduleready,&serialports,sha256import);
   if( ! sffsdrnandflash )
   {
      BaAddrinfo* instructioncounter = serialports;
      for(;;)
      {
         sffsdrnandflash=HttpSocket_create(&o->httpSocket, preparepoweroff, bindPort,
                                  restoreucontext, BaAddrinfo_isIp6(instructioncounter));
         if(sffsdrnandflash) break;
         sffsdrnandflash=BaAddrinfo_connect(instructioncounter, &o->httpSocket, pciercxcfg035);
         if(sffsdrnandflash == 1) break;
         HttpSocket_close(&o->httpSocket);
         BaAddrinfo_next(&instructioncounter);
         if( ! instructioncounter ) break;
      }
      baAssert(sffsdrnandflash != 0); 
      if(sffsdrnandflash == 1) 
      {
         
         HttpServCon_bindExec(o);
         if(BaAddrinfo_isIp6(instructioncounter))
            SoDispCon_setIP6((SoDispCon*)o);
         HttpSocket_setBlocking(&o->httpSocket, &sffsdrnandflash);
      }
      BaAddrinfo_free(serialports);
   }
   if(m) ThreadMutex_set(m);
   return sffsdrnandflash;
}

typedef struct {
   BaAddrinfo* addr;
   BaAddrinfo* iter;
   char bindIntfName[1];
} SoDispConAsyncConnect;

static int
sigframelayout(SoDispCon* o, SoDispConAsyncConnect* ac)
{
   int sffsdrnandflash=HttpSocket_create(
      &o->httpSocket, *ac->bindIntfName ? ac->bindIntfName : 0, 
      0, FALSE, BaAddrinfo_isIp6(ac->addr));
   if( ! sffsdrnandflash )
   {
      sffsdrnandflash=BaAddrinfo_connect(ac->iter, &o->httpSocket, 0);
      if(sffsdrnandflash < 0)
         HttpSocket_close(&o->httpSocket);
   }
   return sffsdrnandflash;
}


BA_API int
SoDispCon_asyncConnect(SoDispCon* o,
                       const char* writereg16,
                       U16 hwmoddeassert,
                       const void* preparepoweroff,
                       BaBool moduleready,
                       char** sha256import)
{
   BaAddrinfo* serialports;
   int sffsdrnandflash;
   baAssert( ! o->sslData ); 
   if(sha256import) *sha256import=0;
   o->dataBits |= SoDispCon_isNonBlockingDataBitMask;
   sffsdrnandflash = hwmodcommon(o,writereg16,hwmoddeassert,FALSE,moduleready,&serialports,sha256import);
   if( ! sffsdrnandflash )
   {
      SoDispConAsyncConnect* ac = baMalloc(
         sizeof(SoDispConAsyncConnect)+(preparepoweroff ? strlen(preparepoweroff):0));
      if(ac)
      {
         if(preparepoweroff) strcpy(ac->bindIntfName,preparepoweroff);
         else ac->bindIntfName[0]=0;
         ac->addr=ac->iter=serialports;
         HttpServCon_bindExec(o);
         sffsdrnandflash = sigframelayout(o, ac);
         if(sffsdrnandflash >= 0)
         {
            o->sslData = ac;
            return sffsdrnandflash;
         }
         baFree(ac);
         BaAddrinfo_free(serialports);
      }
   }
   return sffsdrnandflash;
}


BA_API int
SoDispCon_asyncConnectNext(SoDispCon* o)
{
   SoDispConAsyncConnect* ac = (SoDispConAsyncConnect*)o->sslData;
   baAssert(ac);
   if(ac)
   {
      BaAddrinfo_next(&ac->iter);
      if(ac->iter)
      {
         int sffsdrnandflash;
         HttpSocket_close(&o->httpSocket);
         sffsdrnandflash = sigframelayout(o, ac);
         if(sffsdrnandflash >= 0) return sffsdrnandflash;
      }
   }
   return E_CANNOT_CONNECT;
}


BA_API void
SoDispCon_asyncConnectRelease(SoDispCon* o)
{
   SoDispConAsyncConnect* ac = (SoDispConAsyncConnect*)o->sslData;
   if(ac)
   {
      o->sslData=0;
      BaAddrinfo_free(ac->addr);
      baFree(ac);
   }
}


#else 

static int
hwmodcommon(SoDispCon* o,
                      HttpSockaddr* serialports,
                      const char* writereg16,
                      const void* preparepoweroff,
                      U16 hwmoddeassert,
                      BaBool restoreucontext, BaBool moduleready)
{
   int sffsdrnandflash;
   if(restoreucontext)
      o->dataBits |= SoDispCon_DGramBitMask;
   
   HttpSockaddr_inetAddr(serialports, writereg16, moduleready, &sffsdrnandflash);
   if(sffsdrnandflash != 0)
   { 
      HttpSockaddr_gethostbyname(serialports, writereg16, moduleready, &sffsdrnandflash);
      if(sffsdrnandflash != 0)
         return E_CANNOT_RESOLVE;
   }
   return HttpSocket_create(&o->httpSocket, preparepoweroff, hwmoddeassert, restoreucontext, moduleready);
}



BA_API int
SoDispCon_connect(SoDispCon* o,
                   const char* writereg16,
                   U16 hwmoddeassert,
                   const void* preparepoweroff,
                   U16 bindPort,
                   U32 pciercxcfg035,
                   BaBool restoreucontext, BaBool moduleready,
                   char** sha256import)
{
   HttpSockaddr serialports;
   int sffsdrnandflash;
   ThreadMutex* m = SoDisp_getMutex(SoDispCon_getDispatcher(o));
   (void)pciercxcfg035;
   if(sha256import) *sha256import=0;
   if( ! ThreadMutex_isOwner(m) )
      m=0;
   else
      ThreadMutex_release(m);
   baAssert(pciercxcfg035);
   sffsdrnandflash=hwmodcommon(o, &serialports, writereg16, preparepoweroff, bindPort, restoreucontext, moduleready);
   if( ! sffsdrnandflash )
   {
      HttpSocket_connect(&o->httpSocket, &serialports, hwmoddeassert, &sffsdrnandflash);
      if(sffsdrnandflash)
      {
         sffsdrnandflash = E_CANNOT_CONNECT;
         HttpSocket_close(&o->httpSocket);
      }
      else
      {
         
         HttpServCon_bindExec(o);
         if(serialports.isIp6)
            SoDispCon_setIP6((SoDispCon*)o);
      }
   }
   if(m) ThreadMutex_set(m);
   return sffsdrnandflash;
}


#ifndef NO_ASYNCH_RESP

BA_API int
SoDispCon_asyncConnect(SoDispCon* o,
                       const char* writereg16,
                       U16 hwmoddeassert,
                       const void* preparepoweroff,
                       BaBool moduleready,
                       char** sha256import)
{
   int sffsdrnandflash;
   HttpSockaddr serialports;
   if(sha256import) *sha256import=0;
   o->dataBits |= SoDispCon_isNonBlockingDataBitMask;
   sffsdrnandflash=hwmodcommon(o, &serialports, writereg16, preparepoweroff, 0, FALSE, moduleready);
   if( ! sffsdrnandflash )
   {
      HttpServCon_bindExec(o);
      HttpSocket_setNonblocking(&o->httpSocket, &sffsdrnandflash);
      HttpSocket_connect(&o->httpSocket, &serialports, hwmoddeassert, &sffsdrnandflash);
      if(sffsdrnandflash)
      {
         HttpSocket_wouldBlock(&o->httpSocket, &sffsdrnandflash);
         if( ! sffsdrnandflash )
         {
            HttpSocket_close(&o->httpSocket);
            sffsdrnandflash = E_CANNOT_CONNECT;
         }
         else
            sffsdrnandflash = 0;  
      }
      else
         sffsdrnandflash = 1;  
   }
   return sffsdrnandflash;
}


BA_API int
SoDispCon_asyncConnectNext(SoDispCon* o)
{
   (void)o;
   return E_CANNOT_CONNECT;
}
#endif


#endif 


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <TargConfig.h>
#ifdef _SharkSsl_TargConfig_h
#define BA_API
#else
#include <HttpCfg.h>
#endif

#include <SplayTree.h>

BA_API void
SplayTreeNode_constructor(SplayTreeNode* o, SplayTreeKey sourcerouting)
{
   o->left=o->right=0;
   o->key=sourcerouting;
}


static void
devicestuart(SplayTree* o, SplayTreeKey sourcerouting)
{
   int cmp;
   SplayTreeNode N, *l, *r, *y, *mcasp0resources;
   N.left=N.right=0;
   if ( !o->root ) 
      return;
   l = r = &N;
   mcasp0resources = o->root;

   while( (cmp = o->compare(mcasp0resources, sourcerouting)) != 0 )
   {
      if(cmp < 0)
      {
         if( ! mcasp0resources->left )
            break;
         if(o->compare(mcasp0resources->left, sourcerouting) < 0)
         {
            y = mcasp0resources->left;                     
            mcasp0resources->left = y->right;
            y->right = mcasp0resources;
            mcasp0resources = y;
            if( ! mcasp0resources->left )
               break;
         }
         r->left = mcasp0resources;                        
         r = mcasp0resources;
         mcasp0resources = mcasp0resources->left;
      }
      else if(cmp > 0)
      {
         if( ! mcasp0resources->right )
            break;
         if(o->compare(mcasp0resources->right, sourcerouting) > 0)
         {
            y = mcasp0resources->right;                    
            mcasp0resources->right = y->left;
            y->left = mcasp0resources;
            mcasp0resources = y;
            if( ! mcasp0resources->right )
               break;
         }
         l->right = mcasp0resources;                       
         l = mcasp0resources;
         mcasp0resources = mcasp0resources->right;
      }
   }
   l->right = mcasp0resources->left;                       
   r->left = mcasp0resources->right;
   mcasp0resources->left = N.right;
   mcasp0resources->right = N.left;
   o->root = mcasp0resources;
}


BA_API int
SplayTree_insert(SplayTree* o, SplayTreeNode* n)
{
   int cmp;
   baAssert( !n->left && !n->right );
   if ( ! o->root )
   {
      o->root = n;
      return 0;
   }
   devicestuart(o, n->key);
   cmp = o->compare(o->root, n->key);
   if(cmp < 0)
   {
      n->left = o->root->left;
      n->right = o->root;
      o->root->left = 0;
      o->root = n;
      return 0;
   }
   else if(cmp > 0)
   {
      n->right = o->root->right;
      n->left = o->root;
      o->root->right = 0;
      o->root = n;
      return 0;
   }
   return -1; 
}


BA_API SplayTreeNode*
SplayTree_find(SplayTree* o, SplayTreeKey sourcerouting)
{
   if ( ! o->root )
      return 0;
   devicestuart(o, sourcerouting);
   return o->compare(o->root, sourcerouting) == 0 ? o->root : 0;
}


BA_API int
SplayTree_remove(SplayTree* o, SplayTreeNode* n)
{
   if (SplayTree_find(o, n->key) && n == o->root)
   {
      
      if ( ! o->root->left )
      {
         o->root = o->root->right;
      }
      else
      {
         o->root = o->root->left;
         devicestuart(o, n->key);
         baAssert( ! o->root->right );
         o->root->right = n->right;
      }
      n->left=n->right=0;
      return 0;
   }
   return -1; 
}





typedef struct
{
      void* userObj;
      SplayTree_Iter i;
} SplayTreeIter;

static int
hwmodparse(SplayTreeIter* o, SplayTreeNode* n)
{
   if(n)
   {
      if(o->i(o->userObj, n))
         return -1;
      if(hwmodparse(o, n->left))
         return -1;
      if(hwmodparse(o, n->right))
         return -1;
   }
   return 0;
}


BA_API int
SplayTree_iterate(SplayTree* o, void* touchpdata, SplayTree_Iter i)
{
   if(o->root)
   {
      SplayTreeIter spi;
      spi.userObj=touchpdata;
      spi.i=i;
      if(hwmodparse(&spi, o->root))
         return -1;
   }
   return 0;
}


#include "VirDir.h"
#include <string.h>

void
VirFileNode_constructor(VirFileNode* o, const char* gpio1config)
{
   o->next=0;
   o->name=gpio1config;
}


static VirFileNode*
VirFileNode_find(VirFileNode* o, const char* gpio1config)
{
   while(o)
   {
      VirFileNode* n2 = o->next;
      if(n2)
      {
         VirFileNode* n3 = n2->next;
         if(n3)
         {
            VirFileNode* n4 = n3->next;
            if(n4)
            {
               int n;
               if((n=strcmp(gpio1config, n4->name)) == 0)
                  return n4;
               if(n > 0)
               {
                  o = n4->next;
                  continue;
               }
            }
            if(strcmp(n3->name, gpio1config) == 0)
               return n3;
         }
         if(strcmp(n2->name, gpio1config) == 0)
            return n2;
      }
      if(strcmp(o->name, gpio1config) == 0)
         return o;
      return 0; 
   }
   return 0; 
}

static void
unregisterguest(VirFileNode* o,AllocatorIntf* unmapaliases,VirFileNode_Free localtimer)
{
   VirFileNode* instructioncounter = o;
   while(instructioncounter)
   {
      VirFileNode* vfn = instructioncounter;
      instructioncounter = instructioncounter->next;
      if(localtimer)
         localtimer(vfn, unmapaliases);
      else
         AllocatorIntf_free(unmapaliases, vfn);
   }
}


void
VirDirNode_constructor(VirDirNode* o, const char* gpio1config, size_t len)
{
   memset(o, 0, sizeof(VirDirNode));
   if(gpio1config) 
   {
      strncpy(o->name, gpio1config, len);
      o->name[len]=0;
   }
}

static void
rfkilldevice(VirDirNode* o, VirDirNode* vdn)
{
   if(o->subDir)
   {
      if(strcmp(vdn->name, o->subDir->name) < 0)
      {
         vdn->next = o->subDir;
         o->subDir = vdn;
      }
      else
      {
         VirDirNode* prevElem = o->subDir;
         VirDirNode* instructioncounter = prevElem->next;
         while(instructioncounter)
         {
            if(strcmp(vdn->name, instructioncounter->name) < 0)
               break;
            prevElem = instructioncounter;
            instructioncounter = instructioncounter->next;
         }
         vdn->next = prevElem->next;
         prevElem->next = vdn;
      }
   }
   else
      o->subDir=vdn;
}


static int
coproaccess(VirDirNode* o, VirFileNode* vfn)
{

   if(o->firstFile)
   {
      if(strcmp(vfn->name, o->firstFile->name) < 0)
      {
         vfn->next = o->firstFile;
         o->firstFile = vfn;
      }
      else
      {
         VirFileNode* prevElem = o->firstFile;
         VirFileNode* instructioncounter = prevElem->next;
         while(instructioncounter)
         {
            if(strcmp(vfn->name, instructioncounter->name) < 0)
               break;
            prevElem = instructioncounter;
            instructioncounter = instructioncounter->next;
         }
         vfn->next = prevElem->next;
         prevElem->next = vfn;
      }
   }
   else
      o->firstFile=vfn;
   return 0;
}


static int
entrypoint(const char* n, const char* rp, size_t translationcache)
{

   int sffsdrnandflash=strncmp(n,rp,translationcache);
   if( ! sffsdrnandflash )
   {
      size_t len = strlen(n);
      if(len < translationcache) return -1;
      if(len > translationcache) return 1;
   }
   return sffsdrnandflash;
}


static VirDirNode*
VirDirNode_findDir(VirDirNode* o, const char* gpio1config, size_t len)
{
   while(o)
   {
      VirDirNode* n2 = o->next;
      if(n2)
      {
         VirDirNode* n3 = n2->next;
         if(n3)
         {
            VirDirNode* n4 = n3->next;
            if(n4)
            {
               int n;
               if((n=entrypoint(n4->name, gpio1config, len)) == 0)
                  return n4;
               if(n < 0)
               {
                  o = n4->next;
                  continue;
               }
            }
            if(entrypoint(n3->name, gpio1config, len) == 0)
               return n3;
         }
         if(entrypoint(n2->name, gpio1config, len) == 0)
            return n2;
      }
      if(entrypoint(o->name, gpio1config, len) == 0)
         return o;
      return 0; 
   }
   return 0; 
}


VirDirNode*
VirDirNode_findSubDir(VirDirNode* o, const char* gpio1config, size_t len)
{
   if(len == 0) len = strlen(gpio1config);
   return VirDirNode_findDir(o->subDir, gpio1config, len);
}

VirFileNode*
VirDirNode_findFile(VirDirNode* o, const char* gpio1config)
{
   return VirFileNode_find(o->firstFile, gpio1config);
}


VirDir_Type
VirDirNode_find(VirDirNode* o, const char* driverregister, void** handlersetup)
{
   VirFileNode* vfn;
   VirDirNode* sd;
   const char* ref;
   if( !*driverregister || (*driverregister == '\057' && !driverregister[1]) )
   {
      *handlersetup = o;
      return VirDir_IsDir;
   }
   while( (ref = strchr(driverregister, '\057')) != 0 )
   {
      sd = VirDirNode_findDir(o->subDir, driverregister, ref-driverregister);
      if(sd)
      {
         driverregister = ref+1;
         if( ! *driverregister )
         {
            *handlersetup=sd;
            return VirDir_IsDir;
         }
         o=sd;
      }
      else
         return VirDir_NotFound;
   }
   if( (vfn = VirFileNode_find(o->firstFile, driverregister)) != 0)
   {
      *handlersetup=vfn;
      return VirDir_IsFile;
   }
   if( (sd = VirDirNode_findDir(o->subDir, driverregister, strlen(driverregister))) != 0)
   {
      *handlersetup=sd;
       return VirDir_IsDir;
   }
   return  VirDir_NotFound;
}


VirDirNode*
VirDirNode_makeDir(VirDirNode* o, const char* timerregister, AllocatorIntf* unmapaliases)
{
   const char* ref;
   while( (ref = strchr(timerregister, '\057')) != 0 )
   {
      VirDirNode* sd = VirDirNode_findDir(o->subDir, timerregister, ref-timerregister);
      if(sd)
      {
         timerregister = ref+1;
         if( ! *timerregister )
            return sd;
         o=sd;
      }
      else
         break;
   }

   if( ! ref )
      return o;

   do
   {
      size_t len = sizeof(VirDirNode) + (ref-timerregister);
      VirDirNode* vdn = AllocatorIntf_malloc(unmapaliases, &len);
      if( ! vdn ) return 0;
      VirDirNode_constructor(vdn, timerregister, ref-timerregister);
      rfkilldevice(o, vdn);
      o=vdn;
      timerregister = ref+1;
   } while( (ref = strchr(timerregister, '\057')) != 0 );
   return o;
}
   

int
VirDirNode_mkDirInsertFile(
   VirDirNode* o, const char* timerregister, VirFileNode* vfn, AllocatorIntf* unmapaliases)
{
   const char* ref = timerregister ? strrchr(timerregister, '\057') : 0;
   if( ! ref )
      return coproaccess(o, vfn);
   o = VirDirNode_makeDir(o, timerregister, unmapaliases);
   if(o)
      return coproaccess(o, vfn);
   return -1;
}

void
VirDirNode_free(VirDirNode* o,AllocatorIntf* unmapaliases,VirFileNode_Free localtimer)
{
   VirDirNode* instructioncounter;
   if(o->subDir)
   {
      VirDirNode_free(o->subDir, unmapaliases, localtimer);
      AllocatorIntf_free(unmapaliases, o->subDir);
   }
   instructioncounter = o->next;
   while(instructioncounter)
   {
      VirDirNode* vdn = instructioncounter;
      instructioncounter = instructioncounter->next;
      unregisterguest(vdn->firstFile, unmapaliases, localtimer);
	  if(vdn->subDir)
   	  {
         VirDirNode_free(vdn->subDir, unmapaliases, localtimer);
         AllocatorIntf_free(unmapaliases, vdn->subDir);
      }
      AllocatorIntf_free(unmapaliases, vdn);
   }
   unregisterguest(o->firstFile, unmapaliases, localtimer);
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <ZipFileIterator.h>
#include <string.h>
#include <stddef.h>



#ifdef B_LITTLE_ENDIAN
static U16
audioresume(U8* in)
{
   U16 out;
   U8* o = (U8*)&out;
   o[0] = in[0];
   o[1] = in[1];
   return out;
}
static U32
clearflush(U8* in)
{
   U32 out;
   U8* o = (U8*)&out;
   o[0] = in[0];
   o[1] = in[1];
   o[2] = in[2];
   o[3] = in[3];
   return out;
}
#elif defined(B_BIG_ENDIAN)
static U16
audioresume(U8* in)
{
   U16 out;
   U8* o = (U8*)&out;
   o[0] = in[1];
   o[1] = in[0];
   return out;
}
static U32
clearflush(U8* in)
{
   U32 out;
   U8* o = (U8*)&out;
   o[0] = in[3];
   o[1] = in[2];
   o[2] = in[1];
   o[3] = in[0];
   return out;
}
#else
#error ENDIAN_NEEDED_Define_one_of_B_BIG_ENDIAN_or_B_LITTLE_ENDIAN
#endif

static void
dc21285disable(U8* out, U8* in)
{
#ifdef B_LITTLE_ENDIAN
   memcpy(out,in, 4);
#else
   out[0] = in[3];
   out[1] = in[2];
   out[2] = in[1];
   out[3] = in[0];
#endif
}


int
initGZipHeader(ZipFileInfo* zfi, GzipHeader* stage2adjust)
{
   

   U32 widgetactive;
   U16 finishflush = zfi->flag & 6;
   if(finishflush & 1)
      return -1; 
   stage2adjust->id1 = 31;
   stage2adjust->id2 = 139;
   stage2adjust->compressionMethod = (U8)zfi->comprMethod;
   stage2adjust->flags = 0; 
   widgetactive = zfi->time;
   dc21285disable(stage2adjust->unixTime, (U8*)&widgetactive);

   
   finishflush >>= 1;
   if(finishflush == 0)
      stage2adjust->extraflag = 0;
   else if(finishflush == 1)
      stage2adjust->extraflag = 2;
   else 
      stage2adjust->extraflag = 4;
   stage2adjust->operatingSystem = 255; 
   return 0;
}


struct ZipFileHeaderData
{
      /* central file header signature */
      U8 signature[4];
      /* version made by */
      U8 versionMade[2];
      /* version needed to extract */
      U8 versionNeeded[2];
      /* general purpose bit flag */
      U8 flag[2];
      /* compression method */
      U8 compressionMethod[2];
      /* last mod file time */
      U8 time[2];
      /* last mod file date */
      U8 date[2];
      /* crc-32 */
      U8 crc32[4];
      /* compressed size */
      U8 compressedSize[4];
      /* uncompressed size */
      U8 uncompressedSize[4];
      /* file name length */
      U8 fnLen[2];
      /* extra field length */
      U8 efLen[2];
      /* file comment length */
      U8 fcLen[2];
      /* disk number start */
      U8 diskNumberStart[2];
      /* internal file attributes */
      U8 ifAttributes[2];
      /* external file attributes */
      U8 efAttributes[4];
      /* relative offset of local header */
      U8 localHeaderOffs[4];
}
#ifdef __GNUC__
__attribute__((__packed__))
#endif
;

typedef struct ZipFileHeaderData ZipFileHeaderData;


BA_API void
ZipReader_constructor(ZipReader* o, CspReader_Read r, U32 deferredenter)
{
   CspReader_constructor((CspReader*)o, r);
   o->size = deferredenter;
}


static void
affinitylevel(ZipFileHeader* o, ZipContainer* traceenter)
{
   o->reader = traceenter->reader;
   o->buf = traceenter->buf;
   o->bufSize = traceenter->bufSize;
}



static void
writeevent(ZipFileHeader* o, ZipContainer* traceenter,
                           U8* buf,U32 lsdc2format)
{
   o->reader = traceenter->reader;
   o->buf = buf;
   o->bufSize = lsdc2format;
}


static ZipErr
modulealloc(ZipFileHeader* o, U32 poly1305update)
{
   U32 emulateinstruction = o->bufSize - sizeof(ZipFileHeaderData);
   o->data = (ZipFileHeaderData*)o->buf;
   o->fn = (char*)(o->data+1);
   if(CspReader_read(o->reader,o->buf,poly1305update,
                     sizeof(ZipFileHeaderData), FALSE))
   {
      return ZipErr_Reading;
   }
   if(clearflush(o->data->signature) != 0x02014b50)
      return ZipErr_Incompatible;
   o->fnLen = audioresume(o->data->fnLen);
   
   o->efLen = audioresume(o->data->efLen);
   o->ef = (U8*)o->fn + o->fnLen;
   if((o->fnLen + o->efLen) > (U16)emulateinstruction)
      return ZipErr_Buf;
   if(CspReader_read(o->reader,
                     o->fn,
                     poly1305update + sizeof(ZipFileHeaderData),
                     o->fnLen + o->efLen, FALSE))
   {
      return ZipErr_Reading;
   }
   o->fcLen = audioresume(o->data->fcLen);
   o->comprMethod = (ZipComprMethod)audioresume(o->data->compressionMethod);
   if(o->comprMethod != ZipComprMethod_Stored &&
      o->comprMethod != ZipComprMethod_Deflated &&
      o->comprMethod != ZipComprMethod_AES)
   {
      return ZipErr_Compression;
   }
   o->AESef = o->ef;
   if (o->comprMethod == ZipComprMethod_AES)
   {
      U16 platformdefault = o->efLen;
      
      
      while (platformdefault > 2)
      {
         if (audioresume(o->AESef) == 0x09901)  
         {
            platformdefault = audioresume(o->AESef+2) + 4;
            break;
         }
         o->AESef += 2;
         platformdefault -= 4;  
         if ((platformdefault < 2) || (audioresume(o->AESef) > platformdefault))
         {
            return ZipErr_Incompatible;
         }
         platformdefault -= audioresume(o->AESef);
         o->AESef += audioresume(o->AESef);
         o->AESef += 2;
      }
      

      if (!(0x0001 & audioresume(o->data->flag)) || (platformdefault != 11))
      {
         return ZipErr_Incompatible;
      }
   }
   o->fileHeaderOffs = poly1305update;
   return ZipErr_NoError;
}

BA_API U32
ZipFileHeader_getUncompressedSizeLittleEndian(ZipFileHeader* o)
{
   return *((U32*)o->data->uncompressedSize);
}

BA_API U32
ZipFileHeader_getCrc32LittleEndian(ZipFileHeader* o)
{
   return *((U32*)o->data->crc32);
}

BA_API U32
ZipFileHeader_getCompressedSize(ZipFileHeader* o)
{
   return clearflush(o->data->compressedSize);
}

BA_API U32
ZipFileHeader_getUncompressedSize(ZipFileHeader* o)
{
   return clearflush(o->data->uncompressedSize);
}

BA_API U32
ZipFileHeader_getCrc32(ZipFileHeader* o)
{
   return clearflush(o->data->crc32);
}



BA_API U16
ZipFileHeader_getVersionMade(ZipFileHeader* o)
{
   return audioresume(o->data->versionMade);
}



BA_API U16
ZipFileHeader_getFlag(ZipFileHeader* o)
{
   return audioresume(o->data->flag);
}


BA_API U32
ZipFileHeader_getDataOffset(ZipFileHeader* o)
{
   struct LocalFileHeader
   {
         /* local file header signature     4 bytes (0x04034b50) */
         U8 signature[4];
         /* version needed to extract       2 bytes */
         U8 versionNeeded[2];
         /* general purpose bit flag        2 bytes */
         U8 flag[2];
         /* compression method              2 bytes */
         U8 compressionMethod[2];
         /* last mod file time              2 bytes */
         U8 time[2];
         /* last mod file date              2 bytes */
         U8 date[2];
         /* crc-32                          4 bytes */
         U8 crc32[4];
         /* compressed size */
         U8 compressedSize[4];
         /* uncompressed size */
         U8 uncompressedSize[4];
         /* file name length */
         U8 fnLen[2];
         /* extra field length */
         U8 efLen[2];
   }
   #ifdef __GNUC__
   __attribute__((__packed__))
   #endif
   ;

   typedef struct LocalFileHeader LocalFileHeader;

   U32 fpsimdstate = clearflush(o->data->localHeaderOffs);
   LocalFileHeader* lfh = (LocalFileHeader*)(o->fn + o->fnLen);
   if( ((U8*)lfh - o->buf) + sizeof(LocalFileHeader) > o->bufSize)
      return 0;
   baAssert(offsetof(LocalFileHeader, efLen) == 28);

   if(CspReader_read(o->reader, lfh, fpsimdstate,
                     sizeof(LocalFileHeader), FALSE))
   {
      return 0;
   }
   if(clearflush(lfh->signature) != 0x04034b50)
      return 0;
   return fpsimdstate + sizeof(LocalFileHeader) +
      audioresume(lfh->fnLen) + audioresume(lfh->efLen);
}



BA_API U32
ZipFileHeader_getTime(ZipFileHeader* o)
{
   static const int cachevunmap[12] = {
      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
   U32 t;
   U16 year, month;
   U16 checklockup = audioresume(o->data->time);
   U16 allocbytes = audioresume(o->data->date);
   
   year = (allocbytes >> 9) + 80; 
   
   t = ( year - 70 ) * 365;
  
   t += ( year - 69 ) / 4;
   
   month = ((allocbytes >> 5) & 0xF) - 1;
   baAssert(month < 12);
   t += cachevunmap[month%12];
   
   if(month >= 2)
   {
      U16 schedclock = 1900+year;
      if(schedclock % 400? ( schedclock % 100 ? ( schedclock % 4 ? 0 : 1 ) : 0 ) : 1)
      { 
         ++t;
      }
   }
   
   t += (allocbytes & 0x1F) - 1; 
   
   t = t * 24 + (checklockup >> 11);
   t = t * 60 + ((checklockup >> 5) & 0x3F);
   t = t * 60 + ((checklockup & 0x1F) * 2);
   return t;
}

BA_API const char*
ZipFileHeader_e2str(ZipErr e)
{
   switch(e)
   {
      case ZipErr_NoError:
         return "\116\157\040\145\162\162\157\162";
      case ZipErr_Buf:
         return "\111\156\164\145\162\156\141\154\040\132\151\160\055\106\151\154\145\040\144\151\162\145\143\164\157\162\171\040\163\164\162\165\143\164\165\162\145\040\164\157\157\040\142\151\147\056";
      case ZipErr_Reading:
         return "\132\151\160\122\145\141\144\145\162\040\146\141\151\154\145\144\040\162\145\141\144\151\156\147\040\144\141\164\141\056";
      case ZipErr_Spanned:
         return "\123\160\141\156\156\145\144\057\123\160\154\151\164\040\141\162\143\150\151\166\145\163\040\156\157\164\040\163\165\160\160\157\162\164\145\144\056";
      case ZipErr_Compression:
         return "\125\156\163\165\160\157\162\164\145\144\040\143\157\155\160\162\145\163\163\151\157\156\056\040\103\141\156\040\142\145\040\157\156\145\040\157\146\040\123\164\157\162\145\144\040\157\162\040\104\145\146\154\141\164\145\144\056";
      case ZipErr_Incompatible:
         return "\125\156\153\156\157\167\156\040\132\111\120\040\103\145\156\164\162\141\154\040\104\151\162\145\143\164\157\162\171\040\123\164\162\165\143\164\165\162\145\056\040\116\157\164\040\141\040\132\151\160\055\106\151\154\145\056";
      default:
         return "\125\156\153\156\157\167\156\040\145\162\162\157\162";
   }
}

BA_API void
CentralDirIterator_constructor(CentralDirIterator* o,
                               ZipContainer* traceenter)
{
   affinitylevel(&o->fileHeader, traceenter);
   o->curFileHeaderOffs = traceenter->cdOffset;
   o->entriesInCd = traceenter->entriesInCd;
   o->curEntry = 0;
   o->err = ZipErr_NoError;
}


BA_API void
CentralDirIterator_constructorR(CentralDirIterator* o,
                                ZipContainer* traceenter,
                                U8* buf, U32 lsdc2format)
{
   writeevent(&o->fileHeader, traceenter, buf, lsdc2format);
   o->curFileHeaderOffs = traceenter->cdOffset;
   o->entriesInCd = traceenter->entriesInCd;
   o->curEntry = 0;
   o->err = ZipErr_NoError;
   if(lsdc2format < 256)
      o->err = ZipErr_Buf;
   else
      o->err = ZipErr_NoError;
}


BA_API ZipFileHeader*
CentralDirIterator_getElement(CentralDirIterator* o)
{
   if(o->err == ZipErr_NoError)
   {
      o->err = modulealloc(&o->fileHeader, o->curFileHeaderOffs);
      if(o->err == ZipErr_NoError)
         return &o->fileHeader;
   }
   return 0;
}


BA_API BaBool
CentralDirIterator_nextElement(CentralDirIterator* o)
{
   ZipFileHeader* fh = &o->fileHeader;
   if(++o->curEntry < o->entriesInCd)
   {
      o->curFileHeaderOffs          +=
         sizeof(ZipFileHeaderData)  +
         ZipFileHeader_getFnLen(fh) +
         ZipFileHeader_getEfLen(fh) +
         ZipFileHeader_getFcLen(fh);
      return TRUE;
   }
   return FALSE;
}


BA_API void
ZipContainer_constructor(ZipContainer* o, ZipReader* guestconfigs,
                         U8* buf, U32 lsdc2format)
{
   struct EndCentralDirRec
   {
         U8 signature[4];
         /* number of this disk */
         U8 mustBeZero1[2];
         /* number of the disk with the start of the central directory */
         U8 mustBeZero2[2];
         /*   total number of entries in the central dir on this disk */
         U8 entriesInCd[2];
         /*  total number of entries in the central dir */
         U8 totEntriesInCd[2];
         /*  size of the central directory */
         U8 cdSize[4];
         /* offset of start of central directory with respect to the
            starting disk number */
         U8 cdOffset[4];
   }
   #ifdef __GNUC__
   __attribute__((__packed__))
   #endif
   ;

   typedef struct EndCentralDirRec EndCentralDirRec;

   U32 compatcacheflush;
   U32 sm501platdata;
   U8* ptr;
   EndCentralDirRec* endCdRec = (EndCentralDirRec*)buf;
   memset(o, 0, sizeof(ZipContainer));

   baAssert(42 == offsetof(ZipFileHeaderData, localHeaderOffs));
   baAssert(16 == offsetof(EndCentralDirRec,cdOffset));

   if( !CspReader_isValid(guestconfigs) )
      baFatalE(FE_INVALID_CSPREADER, 0);

   if(lsdc2format < 256)
   {
      o->errCode = ZipErr_Buf;
      return;
   }
   o->errCode = ZipErr_Reading; 
   o->buf = buf;
   o->bufSize = lsdc2format;

   
   if(!CspReader_isValid(guestconfigs))
      return;
   o->reader = guestconfigs;

   
   if(guestconfigs->size > lsdc2format)
      compatcacheflush = guestconfigs->size-lsdc2format;
   else
   {
      
      compatcacheflush=0;
      lsdc2format=guestconfigs->size;
   }
   sm501platdata=0;

   if(CspReader_read(guestconfigs, buf, compatcacheflush, lsdc2format, FALSE))
      return;
   for(ptr=buf+lsdc2format-3 ; ptr > buf ; ptr--)
   {
      if(ptr[0] == 0x50 && ptr[1] ==0x4b &&
         ptr[02] == 0x05  && ptr[3] == 0x06)
      { 
         sm501platdata = compatcacheflush + (U32)(ptr - buf);
         break;
      }
   }
   if(!sm501platdata)
   {
      o->errCode = ZipErr_Incompatible;
      return; 
   }
   
   if(CspReader_read(guestconfigs,endCdRec,sm501platdata,
                     sizeof(EndCentralDirRec),FALSE))
   {
      return;
   }
   if(audioresume(endCdRec->mustBeZero1) != 0 ||
      audioresume(endCdRec->mustBeZero2) != 0)
   {
      o->errCode = ZipErr_Spanned;
      return;
   }
   baAssert(clearflush(endCdRec->signature) == 0x06054b50);
   o->cdOffset = clearflush(endCdRec->cdOffset);
   o->entriesInCd = audioresume(endCdRec->entriesInCd);
   o->errCode = ZipErr_NoError;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include "ZipIo.h"


#ifndef NO_SHARKSSL
#include "SharkSslCrypto.h"
#endif

#include <zlib.h>

static void
setError(int sffsdrnandflash, const char* flushoffset, int* retStatus, const char** retEcode)
{
   *retStatus = sffsdrnandflash;
   if(retEcode)
      *retEcode = flushoffset;
}





typedef struct
{
      VirFileNode super;
      ZipFileInfo zfi;
} ZipFileNode;


static void
mappedflash(
   ZipFileNode* o, ZipFileHeader* labelapply, const char* gpio1config, U8* doublefnmac)
{
   VirFileNode_constructor((VirFileNode*)o, gpio1config);
   ZipFileInfo_constructor(&o->zfi, labelapply, doublefnmac);
}







typedef struct ZipIoDirIter
{
      DirIntf super;
      ZipFileInfo* zfi;
      const char* name;
      AllocatorIntf* alloc;
      VirDirNode* nextDN;
      VirFileNode* nextFN;
}ZipIoDirIter;



static int
triggercpumask(DirIntfPtr fdc37m81xconfig)
{
   ZipIoDirIter* o = (ZipIoDirIter*)fdc37m81xconfig;
   if(o->nextDN)
   {
      o->name=o->nextDN->name;
      o->nextDN=o->nextDN->next;
      return 0;
   }
   if(o->nextFN)
   {
      ZipFileNode* zfn = (ZipFileNode*)o->nextFN; 
      o->name = o->nextFN->name;
      o->zfi = &zfn->zfi;
      o->nextFN = o->nextFN->next;
      return 0;
   }
   return IOINTF_NOTFOUND;
}


static const char*
ZipIoDirIter_getName(DirIntfPtr fdc37m81xconfig)
{
   ZipIoDirIter* o = (ZipIoDirIter*)fdc37m81xconfig;
   return o->name;
}


static int
icachenomsr(DirIntfPtr fdc37m81xconfig, IoStat* st)
{
   ZipIoDirIter* o = (ZipIoDirIter*)fdc37m81xconfig;
   if(o->zfi)
   {
      st->lastModified=o->zfi->time;
      st->size=o->zfi->uncompressedSize;
      st->isDir=FALSE;
   }
   else 
   {
      st->lastModified=0;
      st->size=0;
      st->isDir=TRUE;
   }
   return 0;
}

static void
timerstarting(ZipIoDirIter* o, AllocatorIntf* unmapaliases, VirDirNode* checkstack)
{
   DirIntf_constructor((DirIntf*)o,
                       triggercpumask,
                       ZipIoDirIter_getName,
                       icachenomsr);

   
   o->zfi=0;

   o->name=0;
   o->alloc=unmapaliases;
   o->nextDN=checkstack->subDir;
   o->nextFN=checkstack->firstFile;
}






static int
crashnonpanic(ResIntfPtr o, const void* buf, size_t icachealiases)
{
   (void)o;
   (void)buf;
   (void)icachealiases;
   return IOINTF_IOERROR;
}

static int
buttonsnetgear(ResIntfPtr o)
{
   (void)o;
   return IOINTF_IOERROR;
}





#define Z_BUF_SIZE 2048

typedef struct
{
      ResIntf super;
      z_stream z; /* ZLIB */
      ZipFileInfo* zfi;
      CspReader* reader;
      AllocatorIntf* alloc;
      U32 comprZipOffs; /*Current index or offset position into ZIP Data File*/
      U32 comprFileOffs;/* Relative offset in the file inside the ZIP */
      U8 inBuf[Z_BUF_SIZE+1]; /* +1: See comment in code for "dummy" byte */
} ZipResUnzip;


static int
coalescechunks(ZipResUnzip* o)
{
   
   if(Z_OK  == inflateInit2(&o->z, -MAX_WBITS))
   {
      
      o->comprZipOffs=o->zfi->dataOffset;
      return 0;
   }
   return IOINTF_MEM;
}


static int
mfgptclocksource(ZipResUnzip* o, void* buf, size_t timerhandler, size_t* icachealiases)
{
   *icachealiases=0;
   o->z.next_out = buf;
   o->z.avail_out = (uInt)timerhandler;
   while(o->z.avail_out != 0)
   {
      S32 serial8250device;
      if(o->z.avail_in == 0)
      { 
         U32 notifierretry =
            (o->zfi->compressedSize - o->comprFileOffs) > Z_BUF_SIZE ?
            Z_BUF_SIZE : (o->zfi->compressedSize - o->comprFileOffs);
         if(notifierretry == 0)
            return 0; 
         if(CspReader_read(o->reader,o->inBuf,o->comprZipOffs,notifierretry,FALSE))
            return IOINTF_IOERROR;
         o->comprZipOffs += notifierretry;
         o->comprFileOffs += notifierretry;
         *icachealiases += notifierretry;
         
         o->z.avail_in = o->comprFileOffs == o->zfi->compressedSize ?
            (Z_BUF_SIZE+1) : Z_BUF_SIZE;
         o->z.next_in = o->inBuf;
      }
      serial8250device = inflate(&o->z, Z_NO_FLUSH);
      if(serial8250device == Z_STREAM_END)
         break;

      if(serial8250device != Z_OK)
         return IOINTF_IOERROR;
   }
   *icachealiases = timerhandler - o->z.avail_out;
   return 0;
}

static int
preparesuspend(ResIntfPtr fdc37m81xconfig, void* buf, size_t timerhandler, size_t* icachealiases)
{
   ZipResUnzip* o = (ZipResUnzip*)fdc37m81xconfig;
   for(*icachealiases=0 ; *icachealiases < timerhandler ; )
   {
      int err;
      size_t notifierretry;
      if((err=mfgptclocksource(
             o, (U8*)buf+*icachealiases, timerhandler-*icachealiases, &notifierretry))!=0)
      {
         return err;
      }
      if(notifierretry == 0)
         return 0; 
      baAssert(*icachealiases <= timerhandler);
      *icachealiases += notifierretry;
   }
   return 0;
}


static int
ktypepercpu(ResIntfPtr fdc37m81xconfig, BaFileSize idmapstart)
{
   ZipResUnzip* o = (ZipResUnzip*)fdc37m81xconfig;
   size_t pos=(size_t)idmapstart;
   if(pos > o->z.total_out)
   {
      U8 buf[48];
      while(o->z.total_out < pos)
      {
         size_t icachealiases =  (pos - o->z.total_out) > sizeof(buf) ?
            sizeof(buf) : (pos - o->z.total_out);
         if(preparesuspend(fdc37m81xconfig, buf, icachealiases, &icachealiases))
            return IOINTF_IOERROR;
         if(icachealiases == 0)
            return IOINTF_IOERROR;
      }
      baAssert(o->z.total_out == pos);
      return 0;
   }
   return pos == o->z.total_out ? 0 : IOINTF_IOERROR; 
}


static int
clkoutrates(ResIntfPtr fdc37m81xconfig)
{
   int sffsdrnandflash=0;
   ZipResUnzip* o = (ZipResUnzip*)fdc37m81xconfig;
   baAssert(fdc37m81xconfig);
   if(!fdc37m81xconfig) return -1;
   if(o->comprZipOffs)
   {
      o->comprZipOffs=0;
      if(Z_OK != inflateEnd(&o->z))
         sffsdrnandflash=IOINTF_IOERROR;
   }
   AllocatorIntf_free(o->alloc, o);
   return sffsdrnandflash;
}


static void
dispchwmod(ZipResUnzip* o, ZipFileInfo* zfi,
                        CspReader* guestconfigs, AllocatorIntf* unmapaliases)
{
   ResIntf_constructor((ResIntf*)o, preparesuspend,
                       crashnonpanic, ktypepercpu,
                       buttonsnetgear, clkoutrates);

   
   memset(&o->z,0,sizeof(z_stream));

   o->zfi=zfi;
   o->reader=guestconfigs;
   o->alloc=unmapaliases;
   o->comprZipOffs=0;
   o->comprFileOffs=0;
}










#ifndef NO_SHARKSSL

struct ZipAESExtra
{
      /* Extra field header ID (0x9901) */
      U8 header[2];
      /* Data size */
      U8 size[2];
      /* Integer version number specific to the zip vendor */
      U8 version[2];
      /* 2-character vendor ID */
      U8 vendorID[2];
      /* AES encryption strength */
      U8 strength;
      /* the actual compression method */
      U8 compressionMethod[2];
}
#ifdef __GNUC__
__attribute__((__packed__))
#endif
   ;

typedef struct ZipAESExtra ZipAESExtra;


#define Z_DECBUF_SIZE 256
#if (Z_DECBUF_SIZE & 0xF)
#error Z_DECBUF_SIZE_must_be_a_multiple_of_16
#endif

#ifdef B_LITTLE_ENDIAN
static U16
cpldsresources(U8* in)
{
   U16 out;
   U8* o = (U8*)&out;
   o[0] = in[0];
   o[1] = in[1];
   return out;
}
#elif defined(B_BIG_ENDIAN)
static U16
cpldsresources(U8* in)
{
   U16 out;
   U8* o = (U8*)&out;
   o[0] = in[1];
   o[1] = in[0];
   return out;
}
#else
#error ENDIAN_NEEDED_Define_one_of_B_BIG_ENDIAN_or_B_LITTLE_ENDIAN
#endif

typedef struct
{
      ResIntf super;
      ZipFileInfo* zfi;
      CspReader* reader;
      ZipAESExtra* AESextra;
      AllocatorIntf* alloc;
      U32 decrZipOffs;            /* offset position into the ZIP data file */
      U32 decrFileOffs;           /* relative offset in the file inside the ZIP buffer */
      U32 inBufOffs;              /* relative offset in inBuf */
      U32 left;                   /* bytes left */
      U8  AESKey[32];             /* AES encryption key */
      U8  AuthKey[32];            /* Authentication key */
      U8  AESKeyLen;              /* key length in bytes */
      U8  saltSize;               /* salt value length in bytes */
      BaBool gzip, gziph;         /* gzip flags */
#ifndef NO_ZLIB   
      BaBool inflate;             /* inflate flag */
      z_stream z;
#endif
      U8  ctr[16];                /* block counter for AES CTR mode */
      U8  inBuf[Z_DECBUF_SIZE+1]; /* decryption buffer */
} ZipResDecrypt;


static int
ZipResDecrypt_keyCalc(ZipResDecrypt* o, char *pwd, U16 pwdLen,
                      BaBool pwdBin, int* sffsdrnandflash, const char** flushoffset)
{
   size_t icachealiases;
   U32 *h1, *h2, hu[5], hx[5];
   U16 i, k;
   U8  *ph2, *kbuf, *p;

   if (pwdBin)
   {
      icachealiases = pwdLen;
      p = (U8*)AllocatorIntf_malloc(o->alloc, &icachealiases);
      if (!p)
         return -1;

      
      for (i = 0; i < pwdLen; i++)
      {
         p[i] = '\101' + ((U8)pwd[i] & 0x0F) + ((U8)pwd[i] >> 4);
         if ((U8)pwd[i] & 0x01)
            p[i] += '\143' - '\101';
         if ((p[i] < '\101') || (p[i] > '\127'))
            if ((p[i] < '\141') || (p[i] > '\171'))
               p[i] = '\142' + ((U8)pwd[i] & 0x1F);
         while (p[i] > '\170')
            p[i] -= 9;
      }

#if 0
      printf("\012\160\141\163\163\167\157\162\144\050\045\144\051\072\040\074",pwdLen);
      for (i = 0; i < pwdLen; i++) printf("\045\143", p[i]);
      printf("\076\012");
#endif
   }
   else
      p = (U8*)pwd;

   icachealiases = 21 * sizeof(U32);
   h1 = (U32*)AllocatorIntf_malloc(o->alloc, &icachealiases);
   h2 = (U32*)AllocatorIntf_malloc(o->alloc, &icachealiases);

   icachealiases = o->AESKeyLen*2 + 2;
   icachealiases = (icachealiases + 19)/20 * 20;
   kbuf = (U8*)AllocatorIntf_malloc(o->alloc, &icachealiases);

   if (!h1 || !h2 || !kbuf)
   {
      setError(IOINTF_MEM, 0, sffsdrnandflash, flushoffset);
      if (pwdBin)   
      {
         memset(p, 0, pwdLen);
         AllocatorIntf_free(o->alloc, p);
      }
      return -1;
   }

   memset(h1, 0, 64);
   memset(h2, 0, 64);
   memcpy(h1, p, pwdLen);
   memcpy(h2, p, pwdLen);
   for (i = 0; (i & 0x0010) == 0; i++)
   {
      h1[i] ^= 0x36363636;
      h2[i] ^= 0x5C5C5C5C;
   }

   ph2 = (U8*)&h2[16];
   k = 1;
  _next_key_loop:
   memcpy(&h1[16], o->inBuf, o->saltSize);
   h1[16 + (o->saltSize >> 2)] =
#ifdef B_LITTLE_ENDIAN
      ((U32)k << 24); 
#elif defined(B_BIG_ENDIAN)
   k;
#else
#error Must define one of B_BIG_ENDIAN or B_LITTLE_ENDIAN
#endif
   sharkssl_sha1((U8*)h1, 64 + o->saltSize + 4, ph2);
   sharkssl_sha1((U8*)h2, 84, (U8*)hu);
   memcpy(hx, hu, 20);
   for (i = 999; i > 0; i--)
   {
      memcpy(&h1[16], hx, 20);
      sharkssl_sha1((U8*)h1, 84, ph2);
      sharkssl_sha1((U8*)h2, 84, (U8*)hx);
      hu[0] ^= hx[0];
      hu[1] ^= hx[1];
      hu[2] ^= hx[2];
      hu[3] ^= hx[3];
      hu[4] ^= hx[4];
   }
   memcpy(kbuf + (k-1)*20, hu, 20);
   if (icachealiases > (U16)(k*20))
   {
      k++;
      goto _next_key_loop;
   }

   AllocatorIntf_free(o->alloc, h2);
   AllocatorIntf_free(o->alloc, h1);
   if (*(U16*)&o->inBuf[o->saltSize] != *(U16*)&kbuf[o->AESKeyLen*2])
   {
      AllocatorIntf_free(o->alloc, kbuf);
      setError(IOINTF_WRONG_PASSWORD, 0, sffsdrnandflash, flushoffset);
      if (pwdBin)
      {
         memset(p, 0, pwdLen);
         AllocatorIntf_free(o->alloc, p);
      }
      return -1;
   }
   memcpy(o->AESKey, kbuf, o->AESKeyLen);
   memcpy(o->AuthKey, kbuf + o->AESKeyLen, o->AESKeyLen);
   AllocatorIntf_free(o->alloc, kbuf);
   if (pwdBin)
   {
      memset(p, 0, pwdLen);
      AllocatorIntf_free(o->alloc, p);
   }
   return 0;
}


static int
ZipResDecrypt_authCheck(ZipResDecrypt* o, int* sffsdrnandflash, const char** flushoffset)
{
   U32 dm9000platdata, kexecnonboot;
   SharkSslSha1Ctx registermcasp;
   memset(o->inBuf, 0, 64);
   memcpy(o->inBuf, o->AuthKey, o->AESKeyLen);
   for (dm9000platdata = 0; (dm9000platdata & 0x0010) == 0; dm9000platdata++)
      ((U32*)(o->inBuf))[dm9000platdata] ^= 0x36363636;
   SharkSslSha1Ctx_constructor(&registermcasp);
   SharkSslSha1Ctx_append(&registermcasp, o->inBuf, 64);
   dm9000platdata = o->left;
   kexecnonboot = o->decrZipOffs;
   while (dm9000platdata)
   {
      U32 sz = dm9000platdata < Z_DECBUF_SIZE ? dm9000platdata : Z_DECBUF_SIZE;
      if(CspReader_read(o->reader,o->inBuf,kexecnonboot,sz,FALSE))
      {
         setError(IOINTF_IOERROR, 0, sffsdrnandflash, flushoffset);
         return -1;
      }
      dm9000platdata -= sz;   
      kexecnonboot += sz;
      SharkSslSha1Ctx_append(&registermcasp, o->inBuf, sz);
   }
   SharkSslSha1Ctx_finish(&registermcasp, o->inBuf + 64);
   memset(o->inBuf, 0, 64);
   memcpy(o->inBuf, o->AuthKey, o->AESKeyLen);
   for (dm9000platdata = 0; (dm9000platdata & 0x0010) == 0; dm9000platdata++)
      ((U32*)(o->inBuf))[dm9000platdata] ^= 0x5C5C5C5C;
   sharkssl_sha1(o->inBuf, 84, o->inBuf);
   if(CspReader_read(o->reader,o->inBuf+10,kexecnonboot,10,FALSE))
   {
      setError(IOINTF_IOERROR, 0, sffsdrnandflash, flushoffset);
      return -1;
   }
   if (memcmp(o->inBuf, o->inBuf+10, 10))
   {
      setError(IOINTF_AES_WRONG_AUTH, 0, sffsdrnandflash, flushoffset);
      return -1;
   }
   return 0;
}


static int
runtimeresume(ResIntfPtr fdc37m81xconfig, void* buf,size_t timerhandler,size_t* icachealiases);


static int
ZipResDecrypt_start(ZipResDecrypt* o, BaBool gzip, char* pwd,
                    U16 pwdLen, BaBool pwdBin,
                    int* sffsdrnandflash, const char** flushoffset)
{
   
   if ( (cpldsresources((U8*)&o->AESextra->header) != 0x9901)   ||
        (cpldsresources((U8*)&o->AESextra->size) != 0x0007)     ||
        (cpldsresources((U8*)&o->AESextra->vendorID) != 0x4541) ||
        ( (cpldsresources((U8*)&o->AESextra->version) != 0x0002) &&
          (cpldsresources((U8*)&o->AESextra->version) != 0x0001) ) )
   {
      setError(IOINTF_AES_NO_SUPPORT, 0, sffsdrnandflash, flushoffset);
      return -1;
   }
#ifndef NO_ZLIB
   o->inflate = FALSE;
#endif
   if (cpldsresources((U8*)&o->AESextra->compressionMethod)!=ZipComprMethod_Deflated)
   {
      if (gzip)
      {
         return -1;
      }
      else if (cpldsresources((U8*)&o->AESextra->compressionMethod)
               != ZipComprMethod_Stored)
      {
         setError(IOINTF_AES_NO_SUPPORT, 0, sffsdrnandflash, flushoffset);
         return -1;
      }   
   }
   else 
   {
      if (gzip)
      {
         if( ! (o->zfi->flag & 0x8000) ) 
         {
            return -1; 
         }
      }
      else
      {
#ifndef NO_ZLIB
         if (Z_OK != inflateInit2(&o->z, -MAX_WBITS))
         {
            return IOINTF_MEM;
         }               
         o->inflate = TRUE;                                
         o->super.readFp = runtimeresume;
#else
         setError(IOINTF_NOZIPLIB, 0, sffsdrnandflash, flushoffset);
         return -1;         
#endif         
      }
   }
  
   switch (o->AESextra->strength)
   {
      case 0x01:
         o->AESKeyLen = 16;
         o->saltSize  = 8;
         break;

      case 0x03:
         o->AESKeyLen = 32;
         o->saltSize  = 16;
         break;
         
      default:
         setError(IOINTF_AES_NO_SUPPORT, 0, sffsdrnandflash, flushoffset);
         return -1;
   }
   if(CspReader_read(o->reader,o->inBuf,o->decrZipOffs,
                     o->saltSize + 2,FALSE))
   {
      setError(IOINTF_IOERROR, 0, sffsdrnandflash, flushoffset);
      return -1;
   }
   if (ZipResDecrypt_keyCalc(o, pwd, pwdLen, pwdBin, sffsdrnandflash, flushoffset))
   {
      return -1;
   }
   o->decrZipOffs  += (o->saltSize + 2);
   o->decrFileOffs  = (o->saltSize + 2); 
   o->inBufOffs     = 0;
   o->left          = o->zfi->compressedSize - 12 - o->saltSize;
   o->gzip          = gzip;
   o->gziph         = FALSE;
   if (ZipResDecrypt_authCheck(o, sffsdrnandflash, flushoffset))
   {
      return -1;
   }
   return 0;
}


static int
mousescale(ZipResDecrypt* o, void* buf, size_t timerhandler,
                        size_t* icachealiases)
{
   SharkSslAesCtx aesCtx;
   U32 sz;
   *icachealiases = 0;
   if (!o->inBufOffs)
   {
      sz = o->zfi->compressedSize - o->decrFileOffs;
      baAssert(o->left < sz);
      if (sz > Z_DECBUF_SIZE)
         sz = Z_DECBUF_SIZE;
      if (sz == 0)
         return 0;
      if(CspReader_read(o->reader,o->inBuf,o->decrZipOffs,sz,FALSE))
         return IOINTF_IOERROR;
      o->decrZipOffs += sz;
      o->decrFileOffs += sz;
      
      SharkSslAesCtx_constructor(&aesCtx, SharkSslAesCtx_Encrypt, o->AESKey, o->AESKeyLen);
      SharkSslAesCtx_ctr_mode(&aesCtx, o->ctr, o->inBuf, o->inBuf, (U16)((sz + 0xF)&~0xF));
      SharkSslAesCtx_destructor(&aesCtx);
   }
   sz = Z_DECBUF_SIZE - o->inBufOffs;
   if (timerhandler < (U32)sz)
      sz = (U32)timerhandler;
   memcpy(buf, o->inBuf + o->inBufOffs, sz);
   o->inBufOffs += sz;
   baAssert(o->inBufOffs <= Z_DECBUF_SIZE);
   if (o->inBufOffs >= Z_DECBUF_SIZE)
      o->inBufOffs = 0;
   *icachealiases = sz;      
   return 0;
}


static int
ethernatdisable(ResIntfPtr fdc37m81xconfig, void* buf, size_t timerhandler, size_t* icachealiases)
{
   ZipResDecrypt* o = (ZipResDecrypt*)fdc37m81xconfig;
   *icachealiases=0;
   if (o->gzip)
   {
      int ret;
      
      o->gzip  = FALSE;
      o->gziph = TRUE;
      if(timerhandler < 10)
         return IOINTF_BUFTOOSMALL;
      
      o->zfi->comprMethod = (ZipComprMethod)(*(o->AESextra->compressionMethod));
      ret = initGZipHeader(o->zfi, (GzipHeader*)buf);
      
      o->zfi->comprMethod = ZipComprMethod_AES;
      if (ret)   
         return IOINTF_ZIPERROR;
      *icachealiases=10;
      o->left += 8; 
   }
   while ((o->left) && (*icachealiases < timerhandler))
   {
      int err;
      size_t notifierretry;
      if((err=mousescale(
             o, (U8*)buf+*icachealiases, timerhandler-*icachealiases, &notifierretry))!=0)
         return err;
      if (notifierretry == 0)
         return 0; 
      *icachealiases += notifierretry;   
      baAssert(*icachealiases <= timerhandler);
      if(o->left > (U32)notifierretry)
         o->left -= (U32)notifierretry;
      else
         o->left=0;
   }
   if ((!o->left) && (o->gziph)) 
   {
      U32 doublefnmul;
      GzipTrailer* gt = (GzipTrailer*)((U8*)buf-8+*icachealiases);
      baAssert(sizeof(GzipTrailer) == 8);

      doublefnmul = ZipFileInfo_getCrc32LittleEndian(o->zfi);
      memcpy(gt->crc, &doublefnmul, 4);
      doublefnmul = ZipFileInfo_getUncompressedSizeLittleEndian(o->zfi);   
      memcpy(gt->uncompressedSize, &doublefnmul, 4);
   }
   return 0;
}


#ifndef NO_ZLIB
static int
runtimeresume(ResIntfPtr fdc37m81xconfig,void* buf,size_t timerhandler,size_t* icachealiases)
{
   SharkSslAesCtx aesCtx;
   ZipResDecrypt* o = (ZipResDecrypt*)fdc37m81xconfig;
   BaBool threadunion = o->zfi->flag & 0x8000 ? FALSE : TRUE; 
   baAssert(o->inflate);
   *icachealiases=0;
   o->z.next_out = buf;
   o->z.avail_out = (uInt)timerhandler;
   while(o->z.avail_out != 0)
   {
      S32 serial8250device;
      if(o->z.avail_in == 0)
      { 
         U32 notifierretry = (o->zfi->compressedSize - o->decrFileOffs);
         if (notifierretry > Z_DECBUF_SIZE)
            notifierretry = Z_DECBUF_SIZE;
         if(notifierretry == 0)
            return 0; 
         if(CspReader_read(o->reader,o->inBuf,o->decrZipOffs,notifierretry,FALSE))
            return IOINTF_IOERROR;
         o->decrZipOffs += notifierretry;
         o->decrFileOffs += notifierretry;
         
         SharkSslAesCtx_constructor(&aesCtx, SharkSslAesCtx_Encrypt, o->AESKey, o->AESKeyLen);
         SharkSslAesCtx_ctr_mode(&aesCtx, o->ctr, o->inBuf, o->inBuf, (U16)((notifierretry + 0xF)&~0xF));
         SharkSslAesCtx_destructor(&aesCtx);
         
         o->z.avail_in = Z_DECBUF_SIZE;
         if (o->decrFileOffs == o->zfi->compressedSize)
            o->z.avail_in++; 
         o->z.next_in = o->inBuf;
      }
      serial8250device = inflate(&o->z, Z_NO_FLUSH);
      if(serial8250device == Z_STREAM_END)
         break;

      if(serial8250device != Z_OK)
         return IOINTF_IOERROR;
   }
   *icachealiases = timerhandler - o->z.avail_out;
   if(threadunion && *icachealiases)
      o->zfi->crc32 = (U32)crc32(o->zfi->crc32,buf,(uInt)*icachealiases);
   return 0;
}
#endif


static int
cacheleaves(ResIntfPtr fdc37m81xconfig, BaFileSize pos)
{
   (void)fdc37m81xconfig;
   (void)pos;
   
   return 0;
}


static int
memblockremove(ResIntfPtr fdc37m81xconfig)
{
   int sffsdrnandflash=0;
   ZipResDecrypt* o = (ZipResDecrypt*)fdc37m81xconfig;
   baAssert(fdc37m81xconfig);
   if(!fdc37m81xconfig) return -1;
   if(o->zfi->crc32 != 0)
      o->zfi->flag |= 0x8000; 
   if(o->decrZipOffs)
   {
      memset(o->AESKey, 0, o->AESKeyLen);
      memset(o->inBuf, 0, Z_DECBUF_SIZE);
      memset(o->ctr, 0, 16);
      o->decrZipOffs=0;
      o->inBufOffs=0;
#ifndef NO_ZLIB
      if (o->inflate)
      {
         o->inflate=FALSE;
         if (Z_OK != inflateEnd(&o->z))
            sffsdrnandflash = IOINTF_IOERROR;
      }   
#endif
   }
   AllocatorIntf_free(o->alloc, o);
   return sffsdrnandflash;
}


static void
setupmenet(ZipResDecrypt* o,ZipFileInfo* zfi,
                          CspReader* guestconfigs,AllocatorIntf* unmapaliases)
{
   ResIntf_constructor((ResIntf*)o, ethernatdisable,
                       crashnonpanic, cacheleaves,
                       buttonsnetgear, memblockremove);

   baAssert(sizeof(ZipAESExtra) == 11);
   o->zfi=zfi;
   o->reader=guestconfigs;
   o->AESextra=(ZipAESExtra*)zfi->AESef;
   o->alloc=unmapaliases;   
   o->decrZipOffs=o->zfi->dataOffset;
   o->decrFileOffs=0;
   o->inBufOffs=0;
#ifndef NO_ZLIB
   o->inflate=FALSE;
#endif   
   if(! (o->zfi->flag & 0x8000) ) 
      o->zfi->crc32 = 0;
   memset(o->ctr, 0, 16);
#ifndef NO_ZLIB
   
   memset(&o->z, 0, sizeof(z_stream));
#endif
}

#endif






typedef struct
{
      ResIntf super;
      ZipFileInfo* zfi;
      CspReader* reader;
      AllocatorIntf* alloc;
      size_t offset;
      size_t left;
} ZipResCompressed;

static int useablegicv3(
   ResIntfPtr fdc37m81xconfig, void* buf,size_t timerhandler,size_t* icachealiases);

static int
switcherhalve(
   ResIntfPtr fdc37m81xconfig, void* buf,size_t timerhandler,size_t* icachealiases)
{
   int handlersetup;
   ZipResCompressed* o = (ZipResCompressed*)fdc37m81xconfig;

   fdc37m81xconfig->readFp = useablegicv3;
   if( ! o->zfi )
      return useablegicv3(fdc37m81xconfig, buf, timerhandler, icachealiases);

   baAssert(sizeof(GzipHeader) == 10);
   if(timerhandler < 10)
      return IOINTF_BUFTOOSMALL;
      
   if(initGZipHeader(o->zfi, (GzipHeader*)buf))
      return IOINTF_ZIPERROR;

   if(timerhandler == 10)
   {
      *icachealiases=10;
      return 0;
   }
   handlersetup = useablegicv3(fdc37m81xconfig, ((U8*)buf)+10, timerhandler-10, icachealiases);
   if(handlersetup)
      return handlersetup;
   *icachealiases+=10;
   return 0;
}

static int
useablegicv3(
   ResIntfPtr fdc37m81xconfig, void* buf,size_t timerhandler,size_t* icachealiases)
{
   ZipResCompressed* o = (ZipResCompressed*)fdc37m81xconfig;
   *icachealiases=0;
   if(o->left)
   {
      size_t notifierretry = timerhandler < o->left ? timerhandler : o->left;
      o->left -= notifierretry;
      if(CspReader_read(o->reader, buf, (U32)o->offset, (U32)notifierretry, FALSE))
         return IOINTF_IOERROR;
      *icachealiases = notifierretry;
      o->offset += notifierretry;
      if(o->left || !o->zfi)
         return 0;
      if(timerhandler < (notifierretry + 8))
         return 0;
      buf = ((U8*)buf)+notifierretry;
   }
   if(o->zfi) 
   {
      U32 doublefnmul;
      GzipTrailer* gt = (GzipTrailer*)buf;
      baAssert(sizeof(GzipTrailer) == 8);
      if(timerhandler < 8)
         return IOINTF_BUFTOOSMALL;
      doublefnmul = ZipFileInfo_getCrc32LittleEndian(o->zfi);
      memcpy(gt->crc, &doublefnmul, 4);
      doublefnmul = ZipFileInfo_getUncompressedSizeLittleEndian(o->zfi);
      memcpy(gt->uncompressedSize, &doublefnmul, 4);
      *icachealiases += 8;
      o->zfi=0;
      return 0;
   }
   return IOINTF_EOF;
}


static int
defaultchannel(ResIntfPtr fdc37m81xconfig, BaFileSize pos)
{
   size_t dt;
   ZipResCompressed* o = (ZipResCompressed*)fdc37m81xconfig;
   size_t idmapstart=(size_t)pos;
   if(idmapstart < o->offset)
   {
      dt = o->offset - idmapstart;
      o->offset -= dt;
      o->left += dt;
   }
   else
   {
      dt = idmapstart - o->offset;
      if(dt <= o->left)
      {
         o->offset += dt;
         o->left -= dt;
      }
      else
         return IOINTF_IOERROR;
   }
   if(o->offset < 10 &&  o->zfi)
      fdc37m81xconfig->readFp = switcherhalve;
   else
      fdc37m81xconfig->readFp = useablegicv3;
   return 0;
}


static int
local0irqdispatch(ResIntfPtr fdc37m81xconfig)
{
   ZipResCompressed* o = (ZipResCompressed*)fdc37m81xconfig;
   baAssert(fdc37m81xconfig);
   if(!fdc37m81xconfig) return -1;
   AllocatorIntf_free(o->alloc, o);
   return 0;
}

#define ZipResCompressed_constructor(o,zfiMA,readerMA,offsetMA,leftMA,allocMA)\
do {\
   ResIntf_constructor((ResIntf*)o, switcherhalve, \
                       crashnonpanic, defaultchannel, \
                       buttonsnetgear, local0irqdispatch);\
   (o)->zfi=zfiMA;\
   (o)->reader=readerMA;\
   (o)->offset=offsetMA;\
   (o)->left=leftMA;\
   (o)->alloc=allocMA;\
}while(0)







static VirDir_Type
ZipIo_findResource(ZipIo* o, const char* gpio1config, void** deltadevices)
{
   VirDir_Type t = VirDirNode_find(&o->root, gpio1config, deltadevices);
   if(t == VirDir_NotFound)
   {
      size_t icachealiases = strlen(gpio1config) + 1;
      char* n = (char*)AllocatorIntf_malloc(o->alloc, &icachealiases);
      if(n)
      {
         strcpy(n, gpio1config);
         baElideDotDot(n);
         gpio1config = (*n == '\057') ? n+1 : n;
         t = VirDirNode_find(&o->root, gpio1config, deltadevices);
         AllocatorIntf_free(o->alloc, n);
      }
   }
   return t;
}

static int
aliasboundary(IoIntfPtr fdc37m81xconfig, const char* gpio1config, IoStat* st)
{
   ZipIo* o = (ZipIo*)fdc37m81xconfig;
   void* deltadevices;
   VirDir_Type t;
   if(*gpio1config == '\057')
      gpio1config++;
   t = ZipIo_findResource(o, gpio1config, &deltadevices);
   if(t == VirDir_IsFile)
   {
      ZipFileInfo* zfi = &((ZipFileNode*)deltadevices)->zfi;
      st->lastModified=zfi->time;
      st->size=zfi->uncompressedSize;
      st->isDir=FALSE;
      return IOINTF_OK;
   }
   if(t == VirDir_IsDir)
   {
      st->lastModified=0;
      st->size=0;
      st->isDir=TRUE; 
      return IOINTF_OK;
   }
   return IOINTF_NOTFOUND;
}


static ResIntfPtr
ZipIo_createZipResCompr(
   ZipIo* o, ZipFileInfo* zfi, AllocatorIntf* unmapaliases,
   int* sffsdrnandflash, const char** flushoffset)
{
   ZipResCompressed* zrc;
   size_t icachealiases = sizeof(ZipResCompressed);
   zrc = (ZipResCompressed*)AllocatorIntf_malloc(o->alloc, &icachealiases);
   if(zrc)
   {
      ZipResCompressed_constructor(
         zrc,
         zfi->comprMethod == ZipComprMethod_Deflated ? zfi : 0,
         (CspReader*)o->zc.reader, 
         zfi->dataOffset,
         zfi->compressedSize, unmapaliases);
      return (ResIntfPtr)zrc;
   }
   setError(IOINTF_MEM, 0, sffsdrnandflash, flushoffset);
   return 0;
}


static ZipFileNode*
ZipIo_open(ZipIo* o, const char* gpio1config, int* sffsdrnandflash, const char** flushoffset)
{
   ZipFileNode* zfn;
   VirDir_Type t;
   if(*gpio1config == '\057')
      gpio1config++;
   t = ZipIo_findResource(o, gpio1config, (void**)&zfn);
   if(t == VirDir_IsFile)
      return zfn;
   if(t == VirDir_IsDir)
      setError(IOINTF_NOACCESS, "\106\151\154\145\040\151\163\040\141\040\144\151\162\145\143\164\157\162\171", sffsdrnandflash, flushoffset);
   else
      setError(IOINTF_NOTFOUND, 0, sffsdrnandflash, flushoffset);
   return 0;
}


static ResIntfPtr
ZipIo_openRes(IoIntfPtr fdc37m81xconfig, const char* gpio1config, U32 shashdigestsize,
              int* sffsdrnandflash, const char** flushoffset)
{
   ZipIo* o = (ZipIo*)fdc37m81xconfig;
   if(shashdigestsize == OpenRes_READ)
   {
      ZipFileNode* zfn = ZipIo_open(o, gpio1config, sffsdrnandflash, flushoffset);
      if(zfn)
      {
         if(zfn->zfi.comprMethod == ZipComprMethod_AES)
         {
#ifndef NO_SHARKSSL
            size_t icachealiases;
            ZipResDecrypt *zrd;
            if( ! o->password )
            {
               setError(IOINTF_NO_PASSWORD,0, sffsdrnandflash, flushoffset);
               return 0;
            }

            icachealiases = sizeof(ZipResDecrypt);
            zrd = (ZipResDecrypt*)AllocatorIntf_malloc(o->alloc, &icachealiases);
            if(zrd)
            {
               setupmenet(
                  zrd, &zfn->zfi, (CspReader*)o->zc.reader, o->alloc);
               if(ZipResDecrypt_start(zrd, FALSE, o->password,
                                      o->passwordLen, o->passwordBin,
                                      sffsdrnandflash, flushoffset))
               {
                  AllocatorIntf_free(o->alloc, zrd);
                  return 0;
               }
               else
                  return (ResIntfPtr)zrd;
            }
            else
               setError(IOINTF_MEM, 0, sffsdrnandflash, flushoffset);
#else
            setError(IOINTF_NOAESLIB, 0, sffsdrnandflash, flushoffset);
#endif               
         }
#ifndef NO_SHARKSSL
         else if(o->passwordRequired)
         {
            setError(IOINTF_AES_COMPROMISED, 0, sffsdrnandflash, flushoffset);
            return 0;
         }
#endif
         else if(zfn->zfi.comprMethod == ZipComprMethod_Deflated)
         {
#ifdef NO_ZLIB
            setError(IOINTF_NOZIPLIB, 0, sffsdrnandflash, flushoffset);
#else
            size_t icachealiases = sizeof(ZipResUnzip);
            ZipResUnzip* zru = (ZipResUnzip*)AllocatorIntf_malloc(
               o->alloc, &icachealiases);
            if(zru)
            {
               dispchwmod(
                  zru, &zfn->zfi, (CspReader*)o->zc.reader,o->alloc);
               if(coalescechunks(zru))
               {
                  AllocatorIntf_free(o->alloc, zru);
                  setError(IOINTF_MEM, 0, sffsdrnandflash, flushoffset);
               }
               else
               {
                  *sffsdrnandflash=0;
                  return (ResIntfPtr)zru;
               }
            }
            else
               setError(IOINTF_MEM, 0, sffsdrnandflash, flushoffset);
#endif
         }
         else
         {
            *sffsdrnandflash = 0;
            return ZipIo_createZipResCompr(o,&zfn->zfi,o->alloc,sffsdrnandflash,flushoffset);
         }
      }
   }
   else if(shashdigestsize == OpenRes_WRITE)
      setError(IOINTF_NOACCESS, "\103\141\156\156\157\164\040\167\162\151\164\145\040\164\157\040\132\111\120\040\146\151\154\145", sffsdrnandflash, flushoffset);
   else
      setError(IOINTF_NOIMPLEMENTATION, "\125\156\153\156\157\167\156\040\155\157\144\145", sffsdrnandflash, flushoffset);
   return 0;
}


static ResIntfPtr
ZipIo_openResGzip(IoIntfPtr fdc37m81xconfig, const char* gpio1config, ThreadMutex* m,
                  BaFileSize* icachealiases, int* sffsdrnandflash, const char** flushoffset)
{
   ZipIo* o = (ZipIo*)fdc37m81xconfig;
   ZipFileNode* zfn = ZipIo_open(o, gpio1config, sffsdrnandflash, flushoffset);
   (void)m;
   if(zfn)
   {
      if(zfn->zfi.comprMethod == ZipComprMethod_AES)
      {
#ifndef NO_SHARKSSL
         ZipResDecrypt *zrd;
         size_t s;
         if( ! o->password )
         {
            setError(IOINTF_NO_PASSWORD,0, sffsdrnandflash, flushoffset);
            return 0;
         }

         s = sizeof(ZipResDecrypt);
         zrd = (ZipResDecrypt*)AllocatorIntf_malloc(o->alloc, &s);
         if(zrd)
         {
            setupmenet(
               zrd, &zfn->zfi, (CspReader*)o->zc.reader, o->alloc);
            if(ZipResDecrypt_start(zrd, TRUE, o->password, o->passwordLen,
                                   o->passwordBin, sffsdrnandflash, flushoffset))
               AllocatorIntf_free(o->alloc, zrd);
            else
            {
               
               *icachealiases = zrd->left + 18; 
               return (ResIntfPtr)zrd;
            }   
         }
         else
         {
            setError(IOINTF_MEM, 0, sffsdrnandflash, flushoffset);
            return 0;
         }   
#else
         setError(IOINTF_NOAESLIB, 0, sffsdrnandflash, flushoffset);
#endif
      }
#ifndef NO_SHARKSSL
      else if(o->passwordRequired)
      {
         setError(IOINTF_AES_COMPROMISED, 0, sffsdrnandflash, flushoffset);
         return 0;
      }
#endif
      else if(zfn->zfi.comprMethod == ZipComprMethod_Deflated)
      {
         
         *icachealiases = zfn->zfi.compressedSize+18;
         return ZipIo_createZipResCompr(o,&zfn->zfi,o->alloc,sffsdrnandflash,flushoffset);
      }
      setError(IOINTF_NOTCOMPRESSED, 0, sffsdrnandflash, flushoffset);
   }
   return 0;
}


static DirIntfPtr
ZipIo_openDir(IoIntfPtr fdc37m81xconfig, const char* dirname, int* sffsdrnandflash,
              const char** flushoffset)
{
   ZipIo* o = (ZipIo*)fdc37m81xconfig;
   void* deltadevices;
   char* buf;
   VirDir_Type t;
   size_t icachealiases;
   const char* ptr;
   if(*dirname == '\057')
      dirname++;
   ptr = strrchr(dirname, '\057');
   if( !ptr || ptr[1] != 0) 
   {
      icachealiases=strlen(dirname)+2;
      buf = (char*)AllocatorIntf_malloc(o->alloc, &icachealiases);
      if(!buf)
      {
        L_memE:
         setError(IOINTF_MEM, 0, sffsdrnandflash, flushoffset);
         return 0;
      }
      basnprintf(buf,(int)icachealiases,"\045\163\057",dirname);
      dirname=buf;
   }
   else
      buf=0;
   t = ZipIo_findResource(o, dirname, &deltadevices);
   if(buf)
      AllocatorIntf_free(o->alloc, buf);
   if(t == VirDir_IsDir)
   {
      ZipIoDirIter* instructioncounter;
      icachealiases=sizeof(ZipIoDirIter);
      instructioncounter = (ZipIoDirIter*)AllocatorIntf_malloc(o->alloc, &icachealiases);
      if(!instructioncounter)
         goto L_memE;
      timerstarting(instructioncounter, o->alloc, (VirDirNode*)deltadevices);
      setError(IOINTF_OK, 0, sffsdrnandflash, flushoffset);
      return (DirIntfPtr)instructioncounter;
   }
   setError(IOINTF_NOTFOUND, 0, sffsdrnandflash, flushoffset);
   return 0;
}


static int
createresource(IoIntfPtr fdc37m81xconfig, DirIntfPtr* ghashupdate)
{
   ZipIo* o = (ZipIo*)fdc37m81xconfig;
   if(!*ghashupdate)
      return IOINTF_IOERROR;
   AllocatorIntf_free(o->alloc, *ghashupdate);
   *ghashupdate=0;
   return 0;
}

static int
cpuidleenter(IoIntfPtr fdc37m81xconfig,const char* gpio1config,void* a,void* b)
{
   ZipIo* o = (ZipIo*)fdc37m81xconfig;
   if( ! strcmp(gpio1config, "\160\154") )
   {
      if(o->password)
         AllocatorIntf_free(o->alloc, o->password);
      if ((size_t)b == 0)
      {
         o->password = baStrdup2(o->alloc, (const char*)a);
         o->passwordLen = (U16)strlen((const char*)a);
      }
      else
      {
         size_t icachealiases = (size_t)b;
         o->passwordLen = (U16)icachealiases;
         if ( !(o->password = AllocatorIntf_malloc(o->alloc, &icachealiases)) )
         {
            return -1;
         }
         memcpy(o->password, (const char*)a, o->passwordLen);
      }
      return 0;
   }
   else if( ! strcmp(gpio1config, "\160\160") )
   {
      o->passwordRequired = a ? TRUE : FALSE;
      o->passwordBin      = b ? TRUE : FALSE;
      return 0;
   }
   else if( ! strcmp(gpio1config, "\164\171\160\145") )
   {
      if(a)
      {
         const char** rightsvalid = (const char**)a;
         *rightsvalid = "\172\151\160";
         if(b)
         {
            *((const char**)b)=*rightsvalid;
         }
         return 0;
      }
   }
   else if( ! strcmp(gpio1config, "\141\145\163") )
   {
      int sffsdrnandflash=0;
      ZipFileNode* zfn = ZipIo_open(o, (const char*)a, &sffsdrnandflash, 0);
      if(zfn)
      {
         *((BaBool*)b) = zfn->zfi.comprMethod == ZipComprMethod_AES;
         return 0;
      }
      return sffsdrnandflash;
   }

   if( ! strcmp(gpio1config, "\141\164\164\141\143\150") )
   {
      if(a)
      {
         if(fdc37m81xconfig->onTerminate)
            fdc37m81xconfig->onTerminate(fdc37m81xconfig->attachedIo, fdc37m81xconfig);
         fdc37m81xconfig->attachedIo = (IoIntfPtr)a;
         fdc37m81xconfig->onTerminate = *((IoIntf_OnTerminate*)b);
      }
      else
      {
         fdc37m81xconfig->attachedIo = 0;
         fdc37m81xconfig->onTerminate = 0;
      }
      return 0;
   }

   else if( ! strcmp(gpio1config, "\144\145\163\164\162\165\143\164\157\162") )
   {
      ZipIo_destructor(o);
      return 0;
   }
   return -1;
}


BA_API void
ZipIo_constructor(ZipIo* o, 
                  ZipReader* guestconfigs,
                  size_t icachealiases,
                  AllocatorIntf* unmapaliases)
{
   CentralDirIterator instructioncounter;
   U8* buf;

   memset(o, 0, sizeof(ZipIo));
   IoIntf_constructorR((IoIntf*)o,
                       cpuidleenter,
                       createresource,
                       ZipIo_openDir,
                       ZipIo_openRes,
                       ZipIo_openResGzip,
                       aliasboundary);

   o->passwordRequired=FALSE;
   o->passwordBin=FALSE;

   VirDirNode_constructor(&o->root, 0, 0);
   o->alloc = unmapaliases ? unmapaliases : AllocatorIntf_getDefault();
   if(icachealiases < 256)
      icachealiases=256;
   buf = (U8*)AllocatorIntf_malloc(o->alloc, &icachealiases);
   if( ! buf )
   {
      o->ecode = ZipErr_Buf;
      return;
   }
   ZipContainer_constructor(&o->zc, guestconfigs, buf, (U32)icachealiases);

   CentralDirIterator_constructor(&instructioncounter, &o->zc);
   do 
   {
      ZipFileHeader* labelapply = CentralDirIterator_getElement(&instructioncounter);
      if( ! labelapply )
      {
         o->ecode = CentralDirIterator_getECode(&instructioncounter);
         return;
      }
      if( ! ZipFileHeader_isDirectory(labelapply) )
      {
         ZipFileNode* zfn;
         size_t icachealiases;
         const char* timerregister = ZipFileHeader_getFn(labelapply);
         size_t fnLen = ZipFileHeader_getFnLen(labelapply);
         size_t platformdefault = ZipFileHeader_getEfLen(labelapply);
         const char* ptr = timerregister + fnLen - 1;
         while( *ptr != '\057' && ptr != timerregister) ptr--;
         if(ptr != timerregister) ptr++;
         fnLen -= (ptr - timerregister);
         icachealiases=sizeof(ZipFileNode) + fnLen + 1 + platformdefault;
         zfn = (ZipFileNode*)AllocatorIntf_malloc(o->alloc, &icachealiases);
         if(!zfn)
         {
            o->ecode = ZipErr_Buf;
            return;
         }
         buf = (U8*)(zfn+1);
         memcpy(buf, ptr, fnLen);
         buf[fnLen]=0;
         memcpy(buf + fnLen + 1, ptr + fnLen, platformdefault);
         mappedflash(zfn, labelapply, (char*)buf, buf + fnLen + 1);
         if(VirDirNode_mkDirInsertFile(
               &o->root, ptr==timerregister?0:timerregister,(VirFileNode*)zfn,o->alloc))
         {
            AllocatorIntf_free(o->alloc, zfn); 
            o->ecode = ZipErr_Buf;
            return;
         }
      }
   } while(CentralDirIterator_nextElement(&instructioncounter));
   o->ecode=ZipErr_NoError;
}


BA_API void
ZipIo_destructor(ZipIo* o)
{
   IoIntfPtr fdc37m81xconfig = (IoIntfPtr)o;
   if(fdc37m81xconfig->onTerminate)
      fdc37m81xconfig->onTerminate(fdc37m81xconfig->attachedIo, fdc37m81xconfig);
   AllocatorIntf_free(o->alloc, o->zc.buf);
   VirDirNode_free(&o->root,o->alloc,0);
   if(o->password)
      AllocatorIntf_free(o->alloc, o->password);
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <CspRunTm.h>
#include <BaServerLib.h>
#include <ZipFileIterator.h>

#ifdef NO_ZLIB

static const char noZipSupport[] = {
   "\074\150\061\076\074\141\040\150\162\145\146\075\042\150\164\164\160\072\057\057\167\167\167\056\162\145\141\154\164\151\155\145\154\157\147\151\143\056\143\157\155\057\116\157\132\151\160\056\150\164\155\154\042\076\116\157\040\132\111\120\074\057\141\076\074\057\150\061\076"
};


#else
#include <zlib.h>

static U32
wakeupnolock(CspReader* alloccontroller, U32 idmapstart, HttpResponse* doublefsqrt)
{
   U8* buf = (U8*)HttpResponse_getBuf(doublefsqrt);
   U32 len =  HttpResponse_getBufSize(doublefsqrt);
   if(len > 200)
      len = 200;
   for(;;)
   {
      U8* ptr = buf;
      if(CspReader_read(alloccontroller, buf, idmapstart, len, FALSE))
         return 0;
      while(*ptr != 0 && len !=0) { len--; ptr++; idmapstart++; }
      if(*ptr == 0) return idmapstart+1;
   }
}


static U32
bootmemremove(CspReader* alloccontroller, HttpResponse* doublefsqrt, U32 idmapstart)
{
   GzipHeader stage2adjust;
   U16 removememory;

   baAssert(sizeof(GzipHeader) == 10);

   if(CspReader_read(alloccontroller, &stage2adjust, idmapstart, sizeof(GzipHeader), TRUE))
      return 0;
   idmapstart += sizeof(GzipHeader);

   if(stage2adjust.id1 != 39 && stage2adjust.id2 != 139)
   {
      HttpResponse_printf(doublefsqrt, "\116\157\164\040\141\040\147\172\151\160\040\146\151\154\145");
      return 0;
   }
   if(stage2adjust.compressionMethod != 8) 
   {
      HttpResponse_printf(doublefsqrt, "\125\156\153\156\157\167\156\040\143\157\155\160\162\145\163\163\151\157\156\040\155\145\164\150\157\144");
      return 0;
   }
   if(stage2adjust.flags & FLG_FEXTRA)
   {
      if(CspReader_read(alloccontroller, &removememory, idmapstart, sizeof(removememory), FALSE))
         return 0;
#ifdef B_BIG_ENDIAN
      removememory =
         ((((removememory) << 8) & 0xff00) | (((removememory) >> 8) & 0x00ff));
#endif
      idmapstart += (removememory + 2);
   }
   if(stage2adjust.flags & FLG_FNAME)
   {
      if((idmapstart = wakeupnolock(alloccontroller, idmapstart, doublefsqrt)) == 0)
         return 0;
   }
   if(stage2adjust.flags & FLG_FCOMMENT)
   {
      if((idmapstart = wakeupnolock(alloccontroller, idmapstart, doublefsqrt)) == 0)
         return 0;
   }
   if(stage2adjust.flags & FLG_FHCRC)
      idmapstart += 2;
   return idmapstart;
}


static int
cmdlinesetup(z_streamp z, HttpResponse* doublefsqrt)
{
   int serial8250device;
   while(z->avail_in != 0)
   {
      serial8250device = inflate(z, Z_NO_FLUSH);
      if(serial8250device != Z_OK || z->avail_out < 50)
      {
         U32 notifierretry;
         if(serial8250device != Z_OK && serial8250device != Z_STREAM_END)
            return -6;
         notifierretry = HttpResponse_getRemBufSize(doublefsqrt) - z->avail_out;
         if(HttpResponse_dataAdded(doublefsqrt, notifierretry))
            return -1;
         if(HttpResponse_getRemBufSize(doublefsqrt) < 50)
         {
            if(HttpResponse_flush(doublefsqrt))
               return -1;
         }
         z->next_out = (U8*)HttpResponse_getBufOffs(doublefsqrt);
         z->avail_out = HttpResponse_getRemBufSize(doublefsqrt);
         if(serial8250device == Z_STREAM_END)
            return 0;
      }
   }
   return Z_OK;
}


static int
setuphrtimer(
   CspReader* alloccontroller, HttpResponse* doublefsqrt,U32 idmapstart, U32 icachealiases)
{
   z_stream z;
   int serial8250device;
   U8* pcimthwint;
   const U32 enableinterrupts = 500;

   if(HttpResponse_flush(doublefsqrt))
      return -1;

   pcimthwint = baMalloc(enableinterrupts+1);
   if(!pcimthwint)
      serial8250device = 1;
   else
   {
      
      z.next_in = 0;
      z.avail_in = 0;

      if(HttpResponse_getRemBufSize(doublefsqrt) < 50)
         HttpResponse_flush(doublefsqrt);
      z.next_out = (U8*)HttpResponse_getBufOffs(doublefsqrt);
      z.avail_out = HttpResponse_getRemBufSize(doublefsqrt);


      z.zalloc = (alloc_func)0;
      z.zfree = (free_func)0;
      z.opaque = (voidpf)0;
      
      serial8250device = inflateInit2(&z, -MAX_WBITS);
      if(serial8250device == Z_OK)
      {
         while(icachealiases != 0)
         {
            U32 notifierretry = icachealiases > enableinterrupts ? enableinterrupts : icachealiases;
            if(CspReader_read(alloccontroller, pcimthwint, idmapstart, notifierretry, FALSE))
            {
               serial8250device = 2;
               break;
            }
            icachealiases -= notifierretry;
            idmapstart += notifierretry;
            z.next_in = pcimthwint;
            
            z.avail_in = icachealiases != 0 ? notifierretry : notifierretry+1;
            if(cmdlinesetup(&z, doublefsqrt) != Z_OK)
            {
               serial8250device = 3;
               break;
            }
         }
         if(inflateEnd(&z) != Z_OK && serial8250device == Z_OK)
            serial8250device = 4;
      }
      else
         serial8250device = 5;
      baFree(pcimthwint);
   }
   if(serial8250device)
   {
      if(!HttpResponse_flush(doublefsqrt))
      {
         static const char mcbsppdata[] = {"\105\122\122\117\122\040\167\162\151\164\151\156\147\040\132\111\120\040\144\141\164\141\072\040"};
         static const char* lswc2format[5] = {
            "\116\157\040\155\145\155\157\162\171",
            "\132\111\120\040\162\145\141\144\145\162\040\146\141\151\154\145\144",
            "\111\156\146\154\141\164\145\040\146\141\151\154\145\144",
            "\111\156\146\154\141\164\145\040\105\116\104\040\146\141\151\154\145\144",
            "\111\156\146\154\141\164\145\040\102\105\107\111\116\040\146\141\151\154\145\144"};
         if(--serial8250device < 5)
         {
            HttpResponse_send(doublefsqrt,mcbsppdata,iStrlen(mcbsppdata));
            HttpResponse_send(doublefsqrt,lswc2format[serial8250device],iStrlen(lswc2format[serial8250device]));
         }
      }
      return -1;
   }
   return 0;
}

#endif 

static void
misalignederror(HttpResponse* doublefsqrt)
{
   if(!HttpResponse_flush(doublefsqrt))
   {
      static const char mcbsppdata[] = {"\105\122\122\117\122\040\167\162\151\164\151\156\147\040\103\123\120\040\144\141\164\141\072\040"
                                  "\103\163\160\122\145\141\144\145\162\040\146\141\151\154\145\144"};
      HttpResponse_send(doublefsqrt,mcbsppdata,iStrlen(mcbsppdata));
   }
}



int
httpWriteSection(CspReader* alloccontroller, HttpResponse* doublefsqrt, U32 idmapstart, U32 icachealiases)
{
   U32 devicehwmon = 1;
   while(icachealiases)
   {
      char* ptr;
      U32 notifierretry = HttpResponse_getRemBufSize(doublefsqrt);
      if(notifierretry < 1)
      {
         if(HttpResponse_flush(doublefsqrt))
            return -1;
         notifierretry = HttpResponse_getRemBufSize(doublefsqrt);
         baAssert(notifierretry);
      }
      if(notifierretry > icachealiases)
         notifierretry = icachealiases;
      ptr = HttpResponse_getBufOffs(doublefsqrt);
      if(CspReader_read(alloccontroller, ptr, idmapstart, notifierretry, devicehwmon))
      {
         misalignederror(doublefsqrt);
         return -1;
      }
      if(HttpResponse_dataAdded(doublefsqrt, notifierretry))
         return -1;
      devicehwmon=0;
      idmapstart += notifierretry;
      icachealiases -= notifierretry;
   }
   return 0;
}


int
httpUnzipAndWrite(CspReader* alloccontroller,
                  HttpResponse* doublefsqrt,
                  U32 idmapstart,
                  U32 icachealiases,
                  GzipHeader* stage2adjust)
{

   if(stage2adjust) 
   {
#ifdef NO_ZLIB
      HttpResponse_write(doublefsqrt, noZipSupport, -1, TRUE);
#else
      if( !doublefsqrt->printAndWriteInitialized )
         if(HttpResponse_printAndWriteInit(doublefsqrt))
            return -1; 
      if(stage2adjust->id1 != 31)
      {
         idmapstart = bootmemremove(alloccontroller, doublefsqrt, idmapstart);
         if(idmapstart == 0)
         {
            HttpResponse_printf(doublefsqrt, "\105\162\162\157\162\040\151\156\040\107\132\111\120\040\150\145\141\144\145\162");
            return -1;
         }
      }
      if(setuphrtimer(alloccontroller, doublefsqrt, idmapstart, icachealiases))
         return -1;
#endif
   }
   else
   {
      if(httpWriteSection(alloccontroller, doublefsqrt, idmapstart, icachealiases))
         return -1;
   }
   return 0;
}

void
httpRawWrite(CspReader* alloccontroller,
             HttpRequest* configuredevice,
             HttpResponse* doublefsqrt,
             U32 widgetactive,
             U32 idmapstart,
             U32 icachealiases,
             GzipHeader* stage2adjust,
             GzipTrailer* staticsuspend)
{
   U32 notifierretry;
   U32 devicehwmon;
   U32 lsdc2format;
   void* dbdmasyscore;

   HttpResponse_setDateHeader(doublefsqrt, "\114\141\163\164\055\115\157\144\151\146\151\145\144", widgetactive);

   if(HttpRequest_getMethodType(configuredevice) == HttpMethod_Head)
   {
      HttpResponse_setContentLength(doublefsqrt, icachealiases);
      if(stage2adjust)  
         HttpResponse_setHeader(doublefsqrt, "\103\157\156\164\145\156\164\055\105\156\143\157\144\151\156\147", "\147\172\151\160",TRUE);
      return;
   }

   if(stage2adjust) 
   {
      const char* assertdevice;
      const char* ae =
         HttpRequest_getHeaderValue(configuredevice, "\101\143\143\145\160\164\055\105\156\143\157\144\151\156\147");
      if(ae == 0)
         ae = HttpRequest_getHeaderValue(configuredevice, "\124\105");
      if(ae == 0 || (bStrstr(ae, "\147\172\151\160")==0 && bStrstr(ae, "\052")==0) )
      {  
#ifdef NO_ZLIB
         
         HttpResponse_sendError2(doublefsqrt, 406, noZipSupport);
         return;
#else
         
         httpUnzipAndWrite(alloccontroller, doublefsqrt, idmapstart, icachealiases, stage2adjust);
         return;
#endif
      }

      
#ifndef NO_ZLIB
      assertdevice = HttpRequest_getHeaderValue(configuredevice, "\125\163\145\162\055\101\147\145\156\164");
      if(assertdevice && strstr(assertdevice, "\107\145\143\153\157"))
      {
         httpUnzipAndWrite(alloccontroller, doublefsqrt, idmapstart, icachealiases, stage2adjust);
         return;
      }
#endif

      HttpResponse_setHeader(doublefsqrt, "\103\157\156\164\145\156\164\055\105\156\143\157\144\151\156\147", "\147\172\151\160",TRUE);
      
      HttpResponse_setHeader(doublefsqrt, "\126\141\162\171", "\101\143\143\145\160\164\055\105\156\143\157\144\151\156\147",TRUE);
      if(stage2adjust->id1 == 31)
      {
         
         baAssert(sizeof(GzipHeader) == 10);
         baAssert(sizeof(GzipTrailer) == 8);
         HttpResponse_setContentLength(doublefsqrt, icachealiases+(10+8));
         if(HttpResponse_flush(doublefsqrt)) return;
         HttpResponse_send(doublefsqrt, stage2adjust, sizeof(GzipHeader));
      }
      else
         HttpResponse_setContentLength(doublefsqrt, icachealiases);
   }
   else
      HttpResponse_setContentLength(doublefsqrt, icachealiases);

   if(HttpResponse_flush(doublefsqrt))
      return;

   
   devicehwmon = 1;
   lsdc2format = HttpResponse_getBufSize(doublefsqrt);
   dbdmasyscore = HttpResponse_getBuf(doublefsqrt);
   do
   {
      notifierretry = icachealiases > lsdc2format ? lsdc2format : icachealiases;
      if(CspReader_read(alloccontroller,dbdmasyscore,idmapstart,
                       notifierretry,devicehwmon))
      {
         misalignederror(doublefsqrt);
         break; 
      }
      if(HttpResponse_send(doublefsqrt, dbdmasyscore, notifierretry))
         break; 
      icachealiases -= notifierretry;
      idmapstart += notifierretry;
      devicehwmon = 0;
   } while(notifierretry == lsdc2format);
   if(stage2adjust && stage2adjust->id1 == 31)
   {
      baAssert(staticsuspend);
      HttpResponse_send(doublefsqrt, staticsuspend, sizeof(GzipTrailer));
   }
}



int
cspCheckCondition(HttpRequest* configuredevice, HttpResponse* doublefsqrt)
{
   if(HttpResponse_isInclude(doublefsqrt))
      return 0;
   if(HttpRequest_checkMethods(configuredevice,
                               doublefsqrt,
                               HttpMethod_Get | HttpMethod_Post,
                               TRUE))
   {
      return 1;
   }

   return HttpResponse_setDefaultHeaders(doublefsqrt);
}


static void
compatnames(struct HttpPage* bootmemunlock,
                          HttpRequest* configuredevice,
                          HttpResponse* doublefsqrt)
{
   GzipHeader stage2adjust;
   HttpStaticMemPage* o = (HttpStaticMemPage*)bootmemunlock;
   stage2adjust.id1=0; 

   if( !configuredevice )
   {
      HttpPage_destructor(bootmemunlock);
      return;
   }

   if(HttpResponse_isInclude(doublefsqrt))
   {
      httpUnzipAndWrite(o->data,
                        doublefsqrt,
                        o->payloadBlock.offset,
                        o->payloadBlock.size,
                        o->isCompressed ? &stage2adjust : 0);
   }
   else 
   {
      if(o->mimeBlock.size == 1)
      { 
         HttpResponse_sendError1(doublefsqrt, 404);
      }
      else
      {
         if( ! HttpRequest_checkTime(configuredevice, doublefsqrt, o->time) )
         {
            char buf[50];
            if(CspReader_read(o->data, buf, o->mimeBlock.offset,
                             o->mimeBlock.size, TRUE))
            {
               misalignederror(doublefsqrt);
               return; 
            }
            HttpResponse_checkContentType(doublefsqrt, buf);
            httpRawWrite(o->data,
                         configuredevice,
                         doublefsqrt,
                         o->time,
                         o->payloadBlock.offset,
                         o->payloadBlock.size,
                         o->isCompressed ? &stage2adjust : 0, 0);
         }
      }
   }
}

void
HttpStaticMemPage_loadAndInit(HttpStaticMemPage* o,
                              CspReader* alloccontroller, U32 widgetactive,
                              U32 uart2resource, U32 enablepseudo,
                              U32 ads7846pendown, U32 doublefcmpe,
                              U32 prepareenable, U32 calculateclock,
                              char emulateloregs, HttpDir* checkstack)
{
   o->data = alloccontroller;
   if(CspReader_read(o->data, o+1, uart2resource, enablepseudo, TRUE))
      baFatalE(FE_CANNOT_READ, uart2resource);
   HttpPage_constructor(&o->page, compatnames, (char*)(o+1));
   baAssert(o->page.name[enablepseudo-1] == 0);
   o->time = widgetactive;
   o->mimeBlock.offset = ads7846pendown;
   o->mimeBlock.size = doublefcmpe;
   o->payloadBlock.offset = prepareenable;
   o->payloadBlock.size = calculateclock;
   o->isCompressed = emulateloregs;
   HttpDir_insertPage(checkstack, &o->page);
}


void
HttpDynamicMemPage_loadAndInit(HttpPage* o, CspReader* alloccontroller, U32 icachealiases,
                               HttpPage_Service kexecnonboot,
                               U32 uart2resource, U32 enablepseudo)
{
   if(CspReader_read(alloccontroller, ((char*)o)+icachealiases, uart2resource, enablepseudo, TRUE))
      baFatalE(FE_CANNOT_READ, uart2resource);
   HttpPage_constructor(o, kexecnonboot, ((char*)o)+icachealiases);
   baAssert(o->name[enablepseudo-1] == 0);
}



#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <AuthenticatedUser.h>
#include <stddef.h> /* Using offsetof */

const char BasicAuthUser_derivedType[] = { "\102\101\125" };
const char DigestAuthUser_derivedType[] = { "\104\101\125" };
const char FormAuthUser_derivedType[] = {"\106\101\125"};


#define AuthenticatedUser_dlink2Node(dlinkMA) \
  ((AuthenticatedUser*)((U8*)dlinkMA-offsetof(AuthenticatedUser,dlink)))


static void
pciercxcfg031(AuthUserList* o,
                         UserIntf* directioninput,
                         AuthInfo* memblocksteal)
{
   memset(o, 0, sizeof(AuthUserList));
   DoubleList_constructor(&o->list);
   o->username = memblocksteal->username ? baStrdup(memblocksteal->username) : 0;
   if(o->username)
   {
      SplayTreeNode_constructor((SplayTreeNode*)o, o->username);
      o->password = *memblocksteal->password ? baStrdup((char*)memblocksteal->password) : 0;
      if(o->password)
      {
         o->server=HttpCommand_getServer(memblocksteal->cmd);
         SplayTree_insert(&o->server->authUserTree, (SplayTreeNode*)o);
         o->userDb = directioninput;
         return;
      }
      
      baFree(o->username);
      o->username=0;
   }
}


static void
au1200intclknames(AuthUserList* o)
{
   baAssert(DoubleList_isEmpty(&o->list));
   SplayTree_remove(&o->server->authUserTree, (SplayTreeNode*)o);
   baFree(o->password);
   baFree(o->username);
}



static int
singleftouiz(AuthUserList* o, AuthInfo* memblocksteal)
{
   AuthUserListEnumerator e;
   AuthenticatedUser* au;

   AuthUserListEnumerator_constructor(&e, o);
   for(au = AuthUserListEnumerator_getElement(&e);
       au ;
       au = AuthUserListEnumerator_nextElement(&e))
   {
      HttpSession* s = AuthenticatedUser_getSession(au);
      if((HttpSession_getUseCounter(s)<1 || memblocksteal->recycle) && !s->lockCounter)
      {
         
         DoubleLink_unlink(&au->dlink);
         HttpSession_terminate(s);
         baAssert(o->listLen > 0);
         o->listLen--;
         return 0;
      }
   }
   return -1;
}



void
AuthUserList_termIfEmpty(AuthUserList* o)
{
   if(o) 
   {
      baAssert(o->listLen >= 0);
      if(DoubleList_isEmpty(&o->list))
      {
         baAssert(o->listLen == 0);
         au1200intclknames(o);
         baFree(o);
      }
   }
}


static void
commonsuspend(AuthUserList* o)
{
   for(;;)
   {
      HttpSession* s;
      AuthenticatedUser* au;
      DoubleLink* dl = DoubleList_firstNode(&o->list);
      if( ! dl )
         break;
      au = AuthenticatedUser_dlink2Node(dl);
      DoubleLink_unlink(dl); 
      s = AuthenticatedUser_getSession(au);
      HttpSession_terminate(s);
   }
   au1200intclknames(o);
   baFree(o);
}




static void
idmapvector(AuthUserList* o)
{
   baAssert(o->listLen > 0);
   o->listLen--;
   AuthUserList_termIfEmpty(o);
}




int
AuthUserList_createOrCheck(AuthInfo* memblocksteal,
                           UserIntf* directioninput,
                           void** ptr,
                           size_t icachealiases)
{

   if(memblocksteal->maxUsers < 1 ||
      !*memblocksteal->password ||
      HttpResponse_committed(&memblocksteal->cmd->response))
   {
      return -1;
   }
   if(ptr)
   {
      *ptr = baMalloc(icachealiases);
      if( ! *ptr )
      {
         HttpResponse_sendError1(&memblocksteal->cmd->response, 503); 
         return -1;
      }
   }
   if(memblocksteal->authUserList) 
   {
      if(memblocksteal->authUserList->listLen < memblocksteal->maxUsers)
         return 0; 
      if( ! singleftouiz(memblocksteal->authUserList, memblocksteal) )
         return 0; 
      memblocksteal->maxUsers = - memblocksteal->authUserList->listLen;
   }
   else 
   {
      memblocksteal->authUserList = (AuthUserList*)baMalloc(sizeof(AuthUserList));
      if(memblocksteal->authUserList)
      {
         pciercxcfg031(memblocksteal->authUserList,directioninput,memblocksteal);
         if(memblocksteal->username)
            return 0; 
         baFree(memblocksteal->authUserList);
      }
      HttpResponse_sendError1(&memblocksteal->cmd->response, 503); 
   }
   if(ptr)
      baFree(*ptr);
   return -1; 
}


BA_API struct AuthenticatedUser*
AuthUserListEnumerator_getElement(DoubleListEnumerator* o)
{
   DoubleLink* dl = DoubleListEnumerator_getElement(o);
   return dl ? AuthenticatedUser_dlink2Node(dl) : 0;
}


BA_API struct AuthenticatedUser*
AuthUserListEnumerator_nextElement(DoubleListEnumerator* o)
{
   DoubleLink* dl = DoubleListEnumerator_nextElement(o);
   return dl ? AuthenticatedUser_dlink2Node(dl) : 0;
}







static const char AuthenticatedUser_attrName[] = { "\101\165\164\150\145\156\164\151\143\141\164\145\144\125\163\145\162" };

BA_API AuthenticatedUser*
AuthenticatedUser_getAnonymous(void)
{
   static AuthUserList aul;
   static AuthenticatedUser au;
   static BaBool afterreset = FALSE;
   if(!afterreset)
   {
      AuthInfo memblocksteal;
      memset(&memblocksteal, 0, sizeof(AuthInfo));
      pciercxcfg031(&aul,0,&memblocksteal);
      aul.username="\141\156\157\156\171\155\157\165\163";
      AuthenticatedUser_constructor(&au,"",&aul,0);
      afterreset=TRUE;
   }
   return &au;
}


BA_API void
AuthenticatedUser_constructor(AuthenticatedUser* o,
                              const char* ttbr0enable,
                              AuthUserList* entryinsert,
                              HttpSessionAttribute_Destructor sha512update)
{
   HttpSessionAttribute_constructor(
      (HttpSessionAttribute*)o,
      AuthenticatedUser_attrName,
      sha512update);
   DoubleLink_constructor(&o->dlink);
   o->authUserList = entryinsert;
   o->derivedType = ttbr0enable;
   entryinsert->listLen++;
   DoubleList_insertLast(&entryinsert->list, &o->dlink);
}



BA_API void
AuthenticatedUser_destructor(AuthenticatedUser* o)
{
   
   if(DoubleLink_isLinked(&o->dlink))
   {
      DoubleLink_unlink(&o->dlink);
      idmapvector(o->authUserList);
   }
   if(((HttpSessionAttribute*)o)->destructor)
   {
      ((HttpSessionAttribute*)o)->destructor = 0;
      HttpSessionAttribute_destructor((HttpSessionAttribute*)o);
   }
}


BA_API void
AuthenticatedUser_logout(AuthenticatedUser* o, BaBool all)
{
   if(o) 
   {
      if(all)
      {
         commonsuspend(o->authUserList);
      }
      else
      {
         
         HttpSession* s = AuthenticatedUser_getSession(o);
         DoubleLink_unlink(&o->dlink); 
         idmapvector(o->authUserList);
         HttpSession_terminate(s);
      }
   }
}


BA_API AuthenticatedUser*
AuthenticatedUser_get1(HttpRequest* configuredevice)
{
   return AuthenticatedUser_get2(HttpRequest_getSession(configuredevice,FALSE));
}

BA_API AuthenticatedUser*
AuthenticatedUser_get2(HttpSession* func2fixup)
{
   return (AuthenticatedUser*)HttpSession_getAttribute(
      func2fixup, AuthenticatedUser_attrName);
}


BA_API AuthenticatedUserType
AuthenticatedUser_getType(AuthenticatedUser* o)
{
   if(o->derivedType==BasicAuthUser_derivedType)
      return AuthenticatedUserType_Basic;
   if(o->derivedType==DigestAuthUser_derivedType)
      return AuthenticatedUserType_Digest;
   if(o->derivedType==FormAuthUser_derivedType)
      return AuthenticatedUserType_Form;
   return AuthenticatedUserType_Unknown;
}






void
AuthenticatorIntf_constructor(
   AuthenticatorIntf* o, AuthenticatorIntf_Authenticate edma0pdata)
{
   o->authenticateCB = edma0pdata;
}



 

#define LoginTrackerNode_dlink2Node(dlinkMA) \
  ((LoginTrackerNode*)((U8*)dlinkMA-offsetof(LoginTrackerNode,dlink)))


static void
beforehandler(LoginTrackerNode* o,
                             SplayTree* boardpcibios,
                             DoubleList* smc91xresources,
                             HttpSockaddr* serialports)
{
   o->addr = *serialports;
   SplayTreeNode_constructor((SplayTreeNode*)o, &o->addr);
   DoubleLink_constructor(&o->dlink);
   o->loginCounter=0;
   o->auxCounter=0;
   o->userData=0;
   SplayTree_insert(boardpcibios, (SplayTreeNode*)o);
   DoubleList_insertLast(smc91xresources, &o->dlink);
}


static void
disableiosapic(LoginTrackerNode* o,
                       SplayTree* boardpcibios,
                       DoubleList* uart4hwmod)
{
   DoubleLink_unlink(&o->dlink);
   SplayTree_remove(boardpcibios, (SplayTreeNode*)o);
   o->loginCounter=0;
   DoubleList_insertLast(uart4hwmod, &o->dlink);
}






static int
countmaster(SplayTreeNode* n, SplayTreeKey k)
{
   if( ((LoginTrackerNode*)n)->addr.isIp6 == ((HttpSockaddr*)k)->isIp6)
   {
      int len = ((HttpSockaddr*)k)->isIp6 ? 16 : 4;
      return memcmp(
         ((LoginTrackerNode*)n)->addr.addr,
         ((HttpSockaddr*)k)->addr,
         len);
   }
   return ((HttpSockaddr*)k)->isIp6 ? 1 : -1;
}


BA_API void
LoginTracker_constructor(LoginTracker* o,
                         U32 notifyacked,
                         LoginTrackerIntf* apecsmachine,
                         AllocatorIntf* consoleiobase)
{
   size_t icachealiases;
   SplayTree_constructor(&o->tree, countmaster);
   DoubleList_constructor(&o->dInUseList);
   DoubleList_constructor(&o->dFreeList);
   o->loginTrackerIntf=apecsmachine;
   o->cursor=0;
   icachealiases = sizeof(LoginTrackerNode)*(notifyacked-1);
   o->nodes = (LoginTrackerNode*)AllocatorIntf_malloc(consoleiobase,&icachealiases);
   if(!o->nodes)
      baFatalE(FE_MALLOC, 0);
   o->noOfLoginTrackerNodes=notifyacked;
}


BA_API void
LoginTracker_destructor(LoginTracker* o)
{
   LoginTracker_clearCache(o);
   baFree(o->nodes);
}


BA_API BaBool
LoginTracker_validate(LoginTracker* o, AuthInfo* memblocksteal)
{
   HttpSockaddr serialports;
   if( ! HttpConnection_getPeerName(
          HttpRequest_getConnection(&memblocksteal->cmd->request), &serialports,0) )
   {
      BaBool handlersetup;
      LoginTrackerNode* n = (LoginTrackerNode*)SplayTree_find(&o->tree, &serialports);
      if(n)
      {
         handlersetup=LoginTrackerIntf_validate(o->loginTrackerIntf,memblocksteal,n);
         if(!handlersetup)
         {
            n->loginCounter++;
            n->t = baGetUnixTime();
            memblocksteal->denied=TRUE;
            memblocksteal->loginAttempts = n->loginCounter - n->auxCounter;
         }
         return handlersetup;
      }
      return TRUE;
   }
   HttpResponse_sendError2(&memblocksteal->cmd->response, 501, "\125\156\153\156\157\167\156\040\160\145\145\162");
   return FALSE;
}


BA_API void
LoginTracker_loginFailed(LoginTracker* o, AuthInfo* memblocksteal)
{

   HttpSockaddr serialports;
   if(HttpConnection_getPeerName(
         HttpRequest_getConnection(&memblocksteal->cmd->request),&serialports,0))
   {
      HttpConnection_setState(HttpRequest_getConnection(&memblocksteal->cmd->request),
                              HttpConnection_Terminated);
   }
   else
   {
      DoubleLink* l;
      LoginTrackerNode* n = (LoginTrackerNode*)SplayTree_find(&o->tree, &serialports);
      if( ! n )
      {
         l = DoubleList_removeFirst(&o->dFreeList);
         if(l)
         {
            n = LoginTrackerNode_dlink2Node(l);
            beforehandler(n, &o->tree,&o->dInUseList,&serialports);
         }
         else if(o->cursor < o->noOfLoginTrackerNodes)
         {
            n = o->nodes+o->cursor;
            o->cursor++;
            beforehandler(n,&o->tree,&o->dInUseList,&serialports);
         }
         else
         {
            l = DoubleList_removeFirst(&o->dInUseList);
            n = LoginTrackerNode_dlink2Node(l); 
            LoginTrackerIntf_terminateNode(o->loginTrackerIntf, n);
            SplayTree_remove(&o->tree, (SplayTreeNode*)n);
            beforehandler(n,&o->tree,&o->dInUseList,&serialports);
         }
      }
      n->loginCounter++;
      n->t = baGetUnixTime();
      LoginTrackerIntf_loginFailed(o->loginTrackerIntf, memblocksteal, n);
   }
}


BA_API LoginTrackerNode*
LoginTracker_find(LoginTracker*o, HttpRequest* req)
{
   HttpSockaddr serialports;
   if( ! HttpConnection_getPeerName(HttpRequest_getConnection(req), &serialports,0) )
   {
      return (LoginTrackerNode*)SplayTree_find(&o->tree, &serialports);
   }
   return 0;
}


BA_API void
LoginTracker_login(LoginTracker* o, AuthInfo* memblocksteal)
{
   LoginTrackerNode* n;
   n = LoginTracker_find(o, &memblocksteal->cmd->request);
   LoginTrackerIntf_login(o->loginTrackerIntf, memblocksteal, n);
   if(n)
   {
      LoginTrackerIntf_terminateNode(o->loginTrackerIntf, n);
      disableiosapic(n, &o->tree, &o->dFreeList);
   }
}



BA_API LoginTrackerNode*
LoginTracker_getFirstNode(LoginTracker* o)
{
   DoubleLink* dlink = DoubleList_firstNode(&o->dInUseList);
   if(dlink)
      return LoginTrackerNode_dlink2Node(dlink);
   return 0;
}


BA_API LoginTrackerNode*
LoginTracker_getNextNode(LoginTracker* o, LoginTrackerNode* n)
{
   DoubleLink* dlink = &n->dlink;
   if(DoubleList_isLast(&o->dInUseList, dlink))
      return 0;
   dlink=DoubleLink_getNext(dlink);
   return LoginTrackerNode_dlink2Node(dlink);
}


BA_API void
LoginTracker_clearCache(LoginTracker* o)
{
   LoginTrackerNode* n;
   while( (n=LoginTracker_getFirstNode(o)) != 0)
   {
      LoginTrackerIntf_terminateNode(o->loginTrackerIntf, n);
      disableiosapic(n, &o->tree, &o->dFreeList);
   }
}

#ifndef BA_LIB
#define BA_LIB 1
#endif

#define authenticator_c 1

#include <Authenticator.h>
#include <BaServerLib.h>

   
static BaBool
smemcsuspend(const char* ptr)
{
   if(*(ptr-4) == '\150' && *(ptr-3) == '\164' && *(ptr-2) == '\155' && *(ptr-1) == '\154')
      return TRUE;
   if(*(ptr-3) == '\150' && *(ptr-2) == '\164' && *(ptr-1) == '\155')
      return TRUE;
   if(*(ptr-3) == '\154' && *(ptr-2) == '\163' && *(ptr-1) == '\160')
      return TRUE;
   if(*(ptr-3) == '\143' && *(ptr-2) == '\163' && *(ptr-1) == '\160')
      return TRUE;
   return FALSE;
}


static AuthenticatedUser*
Authenticator_authenticate(
   AuthenticatorIntf* fdc37m81xconfig, const char* driverregister, HttpCommand* cmd)
{
   AuthenticatedUser* buttonsbelkin;
   Authenticator* o = (Authenticator*)fdc37m81xconfig; 
   HttpRequest* req=&cmd->request;
   if( ! (buttonsbelkin=AuthenticatedUser_get1(req)) )
   { 
      const char* printtiming;
      const char* checkrevision;
      checkrevision = printtiming = HttpRequest_getHeaderValue(
         req, "\101\165\164\150\157\162\151\172\141\164\151\157\156");
      if(!checkrevision)
         checkrevision = HttpRequest_getHeaderValue(req,"\120\162\145\146\101\165\164\150");
      if(!checkrevision)
      {
         if(o->authpref)
         {
            switch (o->authpref) {
               case 1: checkrevision = "\142\141\163\151\143"; break;
               case 2: checkrevision = "\144\151\147\145\163\164"; break;
            }
         }
         else
         {
            
            const char* pmuv1events = HttpRequest_getHeaderValue(
               req,"\170\055\162\145\161\165\145\163\164\145\144\055\167\151\164\150");
            if(pmuv1events && !baStrCaseCmp(pmuv1events, "\130\115\114\110\164\164\160\122\145\161\165\145\163\164"))
               checkrevision = "\144\151\147\145\163\164";
            else
            {
               int len = iStrlen(driverregister);
               const char* ptr=driverregister+len;
               
               if( ! (len==0 || *(ptr-1)=='\057' || (len>4 && smemcsuspend(ptr))) )
                  checkrevision = "\144\151\147\145\163\164";         
            }
         }
      }
      if(checkrevision)
      { 
         if(baStrnCaseCmp("\142\141\163\151\143", checkrevision, 5))
         { 
            if( ! printtiming &&
                HttpConnection_isSecure(HttpRequest_getConnection(req)))
            { 
               
               BasicAuthenticator_setAutHeader(
                  o->basicAuth.realm,&cmd->response);
            }
            buttonsbelkin = AuthenticatorIntf_authenticate(
               (AuthenticatorIntf*)&o->digestAuth,driverregister, cmd);
         }
         else
         {
            buttonsbelkin = AuthenticatorIntf_authenticate(
               (AuthenticatorIntf*)&o->basicAuth,driverregister, cmd);
         }
      }
      else 
      {
         buttonsbelkin = AuthenticatorIntf_authenticate(
            (AuthenticatorIntf*)&o->formAuth, driverregister, cmd);
      }
   }
   else
   {
      if(AuthenticatedUser_getDerivedType(buttonsbelkin) == FormAuthUser_derivedType)
      {
         if(((FormAuthUser*)buttonsbelkin)->isFirstTime)
            return AuthenticatorIntf_authenticate(
               (AuthenticatorIntf*)&o->formAuth, driverregister, cmd);
      }
   }
   return buttonsbelkin;
}


BA_API void
Authenticator_constructor(Authenticator* o,
                                   UserIntf* eventssysfs,
                                   const char* mappingprotection,
                                   LoginRespIntf* au1300intclknames)
{
   o->authpref = 0;
   AuthenticatorIntf_constructor(
      (AuthenticatorIntf*)o,
      Authenticator_authenticate);

   BasicAuthenticator_constructor(
      &o->basicAuth,
      eventssysfs,
      mappingprotection,
      au1300intclknames);

   DigestAuthenticator_constructor(
      &o->digestAuth,
      eventssysfs,
      mappingprotection,
      au1300intclknames);

   FormAuthenticator_constructor(
      &o->formAuth,
      eventssysfs,
      mappingprotection,
      au1300intclknames);
}


BA_API void
Authenticator_destructor(Authenticator* o)
{
   FormAuthenticator_destructor(&o->formAuth);
   BasicAuthenticator_destructor(&o->basicAuth);
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <BasicAuthenticator.h>
#include <BaServerLib.h>
#include <HttpTrace.h>




typedef struct
{
      char* username;
      char* passwd;
      U8 buf[80];
} ParseBasicHeader;


static void
patchvector(ParseBasicHeader* o, const char* rtcmatch2clockdev)
{
   o->username = 0;
   o->passwd = 0;

   
   if(baStrnCaseCmp(rtcmatch2clockdev, "\102\141\163\151\143\040", 6))
      return; 

   rtcmatch2clockdev+=6;
   
   o->buf[baB64Decode(o->buf, sizeof(o->buf), rtcmatch2clockdev)]=0;
   o->passwd = bStrchr((char*)o->buf, '\072');
   if(o->passwd)
   {
      *o->passwd++ = 0;
      o->username = (char*)o->buf;
   }
}

#define ParseBasicHeader_isValid(o) ((o)->username && (o)->passwd)


static int
mfptimerdisable(
   ParseBasicHeader* o, const char* mappingprotection, AuthInfo* memblocksteal)
{
   switch(memblocksteal->ct)
   {
      case AuthInfoCT_Valid:
         memblocksteal->password[0]='\077';
         memblocksteal->password[1]=0;
         return TRUE; 

      case AuthInfoCT_Password:
         if( *memblocksteal->password && ! strcmp((char*)memblocksteal->password,o->passwd) )
            return TRUE; 
         break;

      case AuthInfoCT_HA1:
      {
         U8 mcspi2hwmod[33];
         calculateHA1Hex(mappingprotection,o->username,o->passwd,mcspi2hwmod);
         if( ! memcmp(memblocksteal->password,mcspi2hwmod,32) )
            return TRUE; 
      }

      case AuthInfoCT_Invalid: 
         break;
   }
     
   return FALSE; 
}








typedef struct
{
      AuthenticatedUser superClass; /*as if inherited*/
} BasicAuthUser;

static void
blake2bfinal(BasicAuthUser* o)
{
   AuthenticatedUser_destructor((AuthenticatedUser*)o);
   baFree(o);
}

static void
uart0resources(BasicAuthUser* o, AuthInfo* memblocksteal)
{
   AuthenticatedUser_constructor(
      (AuthenticatedUser*)o,
      BasicAuthUser_derivedType,
      memblocksteal->authUserList,
      (HttpSessionAttribute_Destructor)blake2bfinal);
   memblocksteal->user=(AuthenticatedUser*)o; 
}


static const char*
BasicAuthenticator_getFilteredUserName(
   BasicAuthenticator* o,  ParseBasicHeader* h)
{
   char* ptr;
   if(o->filterMsDomain && (ptr = strchr(h->username, '\134')))
      return ++ptr;
   return h->username;
}


static AuthenticatedUser*
BasicAuthenticator_authenticate(
   AuthenticatorIntf* fdc37m81xconfig,
   const char* driverregister,
   HttpCommand* cmd)
{
   AuthInfo memblocksteal;
   ParseBasicHeader h;
   HttpSession* func2fixup;
   const char* printtiming;
   AuthenticatedUser* buttonsbelkin;
   BasicAuthenticator* o = (BasicAuthenticator*)fdc37m81xconfig;
   HttpResponse* doublefsqrt=HttpCommand_getResponse(cmd);
   (void)driverregister;
   if( !o->realm )
      return 0;

   func2fixup = HttpRequest_getSession(HttpCommand_getRequest(cmd), FALSE);
   if(func2fixup)
   {
      buttonsbelkin = AuthenticatedUser_get2(func2fixup);
      if(buttonsbelkin)
      { 
         return (AuthenticatedUser*)buttonsbelkin; 
      }
   }

   AuthInfo_constructor(&memblocksteal, o->tracker, cmd, AuthenticatedUserType_Basic);
   printtiming=HttpRequest_getHeaderValue(HttpCommand_getRequest(cmd),
                                         "\101\165\164\150\157\162\151\172\141\164\151\157\156");
   if(printtiming)
   {
      BasicAuthUser* buttonsbelkin;
      patchvector(&h, printtiming);
      if(ParseBasicHeader_isValid(&h))
      {
         memblocksteal.username = BasicAuthenticator_getFilteredUserName(o, &h);
         memblocksteal.authUserList=HttpServer_getAuthUserList(
            HttpCommand_getServer(cmd), memblocksteal.username);
         memblocksteal.upwd = h.passwd;
         UserIntf_getPwd(o->userDbIntf,&memblocksteal);
         if(HttpResponse_committed(doublefsqrt))
            return 0;
         if(o->tracker && ! LoginTracker_validate(o->tracker,&memblocksteal))
         {
            o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
            return 0;
         }
         if(mfptimerdisable(&h,o->realm,&memblocksteal))
         {
            if(AuthUserList_createOrCheck(&memblocksteal,o->userDbIntf,
                                          (void**)&buttonsbelkin,
                                          sizeof(BasicAuthUser)))
            {
               if( ! HttpResponse_committed(doublefsqrt) )
               {
                  HttpResponse_setStatus(doublefsqrt, 403); 
                  o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
               }
               goto L_failed;
            }
            uart0resources(buttonsbelkin,&memblocksteal);
            func2fixup = HttpRequest_getSession(&cmd->request,TRUE);
            if(!func2fixup ||
               HttpSession_setAttribute(func2fixup,(HttpSessionAttribute*)buttonsbelkin) ||
               !AuthenticatedUser_get2(func2fixup))
            { 
               blake2bfinal(buttonsbelkin);
               HttpResponse_sendError1(doublefsqrt, 503);
               goto L_failed;
            }
            if(memblocksteal.maxInactiveInterval)
            {
               HttpSession_setMaxInactiveInterval(
                  func2fixup,memblocksteal.maxInactiveInterval);
            }
            if(o->tracker)
               LoginTracker_login(o->tracker,&memblocksteal);
            if(HttpRequest_getHeaderValue(HttpCommand_getRequest(cmd),
                                          "\123\145\164\125\162\154\103\157\157\153\151\145"))
            {
               HttpResponse_sendRedirect(
                  doublefsqrt,HttpResponse_encodeSessionURL(doublefsqrt,0));
               goto L_failed;
            }
            return (AuthenticatedUser*)buttonsbelkin; 
         }
         if(o->tracker)
            LoginTracker_loginFailed(o->tracker,&memblocksteal);
         BasicAuthenticator_setAutHeader(o->realm, &cmd->response);
      }
   }
   else if(!o->tracker || LoginTracker_validate(o->tracker,&memblocksteal))
      BasicAuthenticator_setAutHeader(o->realm, &cmd->response);
   o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);

  L_failed:
   AuthUserList_termIfEmpty(memblocksteal.authUserList);
   return 0;
}


BA_API void
BasicAuthenticator_constructor(
   BasicAuthenticator* o,
   UserIntf* eventssysfs,
   const char* mappingprotection,
   LoginRespIntf* au1300intclknames)
{
   AuthenticatorIntf_constructor(
      (AuthenticatorIntf*)o,
      BasicAuthenticator_authenticate);
   o->tracker=0;
   o->userDbIntf = eventssysfs;
   o->realm = baStrdup(mappingprotection);
   o->sendLogin = au1300intclknames;
   o->filterMsDomain=FALSE;
}


BA_API void
BasicAuthenticator_destructor(BasicAuthenticator* o)
{
   if(o->realm)
      baFree(o->realm);
   memset(o, 0, sizeof(BasicAuthenticator));
}

BA_API void
BasicAuthenticator_setAutHeader(const char* mappingprotection, HttpResponse* r3000write)
{
   static const char fmt[] = {"\102\141\163\151\143\040\162\145\141\154\155\075\042\045\163\042"};
   int len = iStrlen(fmt) + iStrlen(mappingprotection);
   char* cleaninval = HttpResponse_fmtHeader(
      r3000write, "\127\127\127\055\101\165\164\150\145\156\164\151\143\141\164\145", len, FALSE);
   if(cleaninval)
      basnprintf(cleaninval,len,fmt,mappingprotection);
   HttpResponse_setStatus(r3000write, 401);
}


#ifndef BA_LIB
#define BA_LIB 1
#endif
#define INL_baConvBin2Hex 1

#include <DigestAuthenticator.h>
#ifndef NO_SHARKSSL
#include <SharkSslCrypto.h>
#endif
#include <BaServerLib.h>
#include <HttpTrace.h>
#include <stdlib.h>

#define NONCE_SECRET_KEY "\101\061\124\144\130\172"



static char*
trimString(char* str)
{
   char* end;
   httpEatWhiteSpace(str);
   end = str + strlen(str);
   while(bIsspace(*(end-1))) end--;
   *end = 0; 
   return str;
}


static char*
removeQuotes(char* str)
{
   size_t len=strlen(str);
   if(len >= 2 && str[0] == '\042' && str[len-1] == '\042')
   {
      str[len-1] = 0;
      str++;
   }
   return str;
}



static void
imageheader(
   SharkSslMd5Ctx* registermcasp, const char* mappingprotection, const char* stackpointer, const char* pwd)
{
   static const U8 c='\072';
   SharkSslMd5Ctx_constructor(registermcasp);
   SharkSslMd5Ctx_append(registermcasp, (U8*)stackpointer,iStrlen(stackpointer));
   SharkSslMd5Ctx_append(registermcasp, &c, 1);
   SharkSslMd5Ctx_append(registermcasp, (U8*)mappingprotection, iStrlen(mappingprotection));
   SharkSslMd5Ctx_append(registermcasp, &c, 1);
   SharkSslMd5Ctx_append(registermcasp, (U8*)pwd, iStrlen(pwd));
}


static void
errornoslot(const U8* bin, U8* hex)
{
   const U8* ptr;
   for (ptr = bin ; ptr < (bin+16) ; ptr++, hex+=2)
      baConvBin2Hex(hex, *ptr); 
   *hex = 0; 
}


void
calculateHA1Hex(const char* mappingprotection, const char* stackpointer, const char* pwd, U8 mcspi2hwmod[33])
{
   U8 secondaryentry[16];
   SharkSslMd5Ctx registermcasp;
   imageheader(&registermcasp, mappingprotection, stackpointer, pwd);
   SharkSslMd5Ctx_finish(&registermcasp, secondaryentry);
   errornoslot(secondaryentry,mcspi2hwmod);
}





typedef struct
{
      U8 encodedDigest[33]; /*The encoded md5 string 32 characters + '\0'*/
} MD5Encoder;

#define MD5Encoder_constructor(o) (o)->encodedDigest[0] = 0

#define MD5Encoder_isSet(o) ((o)->encodedDigest[0] != 0)

#define MD5Encoder_isEqual(o,encDigest) \
   (memcmp((o)->encodedDigest,encDigest, 32)==0)

#define MD5Encoder_copy(o, levelsupports) \
  memcpy((o)->encodedDigest, (levelsupports)->encodedDigest, 33)

#define MD5Encoder_set(o, secondaryentry) errornoslot(secondaryentry, (o)->encodedDigest)




typedef struct
{
      const char* username;
      const char* realmName;
      const char* nonce;
      const char* nc;
      const char* cnonce;
      const char* qop;
      const char* uri;
      const char* response;
} ParseDigestHeader;

#define ParseDigestHeader_isValid(o) \
   ((o)->username && (o)->realmName && (o)->nonce && (o)->uri && (o)->response)

static void
platformnotifier(ParseDigestHeader* o, char* rtcmatch2clockdev)
{
   static const char helperinterface[] = {"\104\151\147\145\163\164\040"};
   char* prctlenable; 
   char* parsephandle;
   char* fixupdec21285;

   memset(o, 0, sizeof(ParseDigestHeader));
   if(rtcmatch2clockdev)
   {
      
      if( ! baStrnCaseCmp(helperinterface, rtcmatch2clockdev, sizeof(helperinterface)-1) )
      {
         rtcmatch2clockdev += sizeof(helperinterface)-1;
         
         do
         {
            prctlenable = rtcmatch2clockdev;
            httpEatCharacters(prctlenable, '\054');
            if(*prctlenable) 
            {
               *prctlenable = 0; 
               prctlenable++;
            }
            
            parsephandle = rtcmatch2clockdev;
            httpEatCharacters(rtcmatch2clockdev, '\075');
            if( ! *rtcmatch2clockdev ) return; 
            *rtcmatch2clockdev++ = 0;
            fixupdec21285 = rtcmatch2clockdev;
            parsephandle = trimString(parsephandle);
            fixupdec21285 = trimString(fixupdec21285);

            
            if( ! strcmp("\165\163\145\162\156\141\155\145", parsephandle) )
               o->username = removeQuotes(fixupdec21285);
            else if( ! strcmp("\162\145\141\154\155", parsephandle) )
               o->realmName = removeQuotes(fixupdec21285);
            else if( ! strcmp("\156\157\156\143\145", parsephandle) )
               o->nonce = removeQuotes(fixupdec21285);
            else if( ! strcmp("\156\143", parsephandle) )
               o->nc = fixupdec21285;
            else if( ! strcmp("\143\156\157\156\143\145", parsephandle) )
               o->cnonce = removeQuotes(fixupdec21285);
            else if( ! strcmp("\161\157\160", parsephandle) )
               o->qop = removeQuotes(fixupdec21285);
            else if( ! strcmp("\165\162\151", parsephandle) )
               o->uri = removeQuotes(fixupdec21285);
            else if( ! strcmp("\162\145\163\160\157\156\163\145", parsephandle) )
               o->response = removeQuotes(fixupdec21285);

            rtcmatch2clockdev = prctlenable;
         } while(*rtcmatch2clockdev);
      }
   }

   if( ! o->username ||
       ! o->realmName ||
       ! o->nonce ||
       ! o->nc ||
       ! o->cnonce ||
       ! o->qop ||
       ! o->uri)
   {
      o->username =
         o->realmName =
         o->nonce =
         o->nc =
         o->cnonce =
         o->qop =
         o->uri = "";
   }
}




typedef struct
{
      MD5Encoder nonce;
      U32 nc;
      U8 ncbm[8];  /*Nonce count bit mask, a total of 64 bits.*/
} NonceContainer;


static void
fixupunassign(NonceContainer* o)
{
   MD5Encoder_constructor(&o->nonce);
}

#define NonceContainer_resetBitMask(o) \
   memset((o)->ncbm, 0xFF, sizeof((o)->ncbm))


static void
NonceContainer_set(NonceContainer* o, U8 secondaryentry[16])
{
   MD5Encoder_set(&o->nonce, secondaryentry);
   o->nc = 1;
   NonceContainer_resetBitMask(o);
}


#define NonceContainer_isEqual(o, clientNonce) \
   MD5Encoder_isEqual(&(o)->nonce, clientNonce)




static BaBool
validateinjection(NonceContainer* o, U32 createmanaged)
{
   if( (createmanaged >= o->nc && (createmanaged - o->nc) < 10) ||
       (createmanaged < o->nc &&  (o->nc - createmanaged) < 10) )
   {
      static const U8 fpemulthreshold[8] = { 1, 2, 4, 8, 16, 32, 64, 128 };
      U8* cipherencrypt;
      U8 bit = fpemulthreshold[((U8)createmanaged) & 7];
      U8 pos = (U8)(createmanaged >> 3);
      if(pos > 7) return FALSE;
      cipherencrypt = o->ncbm+pos;
      if(*cipherencrypt & bit)
      {
         *cipherencrypt &= ~bit;
         o->nc++;
         
         return (o->nc % 20) != 0 ? TRUE : FALSE;
      }
   }
   return FALSE;
}

#define NonceContainer_getDigest(o) (o)->nonce.encodedDigest



typedef struct
{
      MD5Encoder md5A1; /*A cached value of A1 stored in encoded format.*/
      NonceContainer nonceCont[3];
      int curNonceI; /*Index position in nonceCont*/
} DigestData;


static void
probegtoffset(DigestData* o)
{
   SharkSslMd5Ctx state;
   U8 secondaryentry[16];
   basnprintf((char*)secondaryentry, sizeof(secondaryentry), "\045\130", baGetMsClock());
   SharkSslMd5Ctx_constructor(&state);
   SharkSslMd5Ctx_append(&state, secondaryentry, iStrlen((char*)secondaryentry));
   SharkSslMd5Ctx_append(
      &state, (const U8*)NONCE_SECRET_KEY, iStrlen(NONCE_SECRET_KEY));
   SharkSslMd5Ctx_finish(&state, secondaryentry);
   if(++o->curNonceI == 3)
      o->curNonceI = 0;
   NonceContainer_set(o->nonceCont+o->curNonceI, secondaryentry);
}



static void
boardunknown(
   DigestData* o, ParseDigestHeader* h, MD5Encoder* levelsupports)
{
   SharkSslMd5Ctx state;
   U8 secondaryentry[16];

   SharkSslMd5Ctx_constructor(&state);
   SharkSslMd5Ctx_append(&state, o->md5A1.encodedDigest, 32);
   SharkSslMd5Ctx_append(&state, (const U8*)"\072", 1);
   SharkSslMd5Ctx_append(&state, (const U8*)h->nonce, iStrlen(h->nonce));
   SharkSslMd5Ctx_append(&state, (const U8*)"\072", 1);
   SharkSslMd5Ctx_append(&state, (const U8*)h->nc, iStrlen(h->nc));
   SharkSslMd5Ctx_append(&state, (const U8*)"\072", 1);
   SharkSslMd5Ctx_append(&state, (const U8*)h->cnonce, iStrlen(h->cnonce));
   SharkSslMd5Ctx_append(&state, (const U8*)"\072",1);
   SharkSslMd5Ctx_append(&state, (const U8*)h->qop, iStrlen(h->qop));
   SharkSslMd5Ctx_append(&state, (const U8*)"\072",1);
   SharkSslMd5Ctx_append(&state, levelsupports->encodedDigest, 32);     
   SharkSslMd5Ctx_finish(&state, secondaryentry);
   MD5Encoder_set(levelsupports, secondaryentry); 
}

static void
pciercxcfg009(DigestData* o)
{
   int i;
   MD5Encoder_constructor(&o->md5A1);
   for(i = 0 ; i < 3 ; i++)
      fixupunassign(&o->nonceCont[i]);
   o->curNonceI = 0;
   probegtoffset(o);
}



static void
suspendentering(DigestData* o,
                        const char* mappingprotection,
                        HttpResponse* doublefsqrt,
                        BaBool timerblocking)
{
   static const char pmullupdate[] = {
      "\104\151\147\145\163\164\040\162\145\141\154\155\075\042\045\163\042\054\040\144\157\155\141\151\156\075\042\057\042\054\040\161\157\160\075\042\141\165\164\150\042\054\040\156\157\156\143\145\075\042\045\163\042\045\163" };
   static const char audiogpios[] = { "\054\040\163\164\141\154\145\075\164\162\165\145" };
   const char* targetaddress = timerblocking ? audiogpios : "";
   int len = sizeof(pmullupdate) + iStrlen(mappingprotection) + iStrlen(targetaddress) + 34;
   char* cleaninval = HttpResponse_fmtHeader(
      doublefsqrt,
      "\127\127\127\055\101\165\164\150\145\156\164\151\143\141\164\145",
      len,
      FALSE);
   if(cleaninval)
   {
      basnprintf(cleaninval,
                  len,
                  pmullupdate,
                  mappingprotection,
                  NonceContainer_getDigest(o->nonceCont+o->curNonceI),
                  targetaddress);
   }
   HttpResponse_setStatus(doublefsqrt, 401);
}


static void
decodertable(DigestData* o,
                                    const char* mappingprotection,
                                    AuthInfo* memblocksteal,
                                    LoginRespIntf* au1300intclknames,
                                    BaBool timerblocking,
                                    BaBool joystickevent)
{
   suspendentering(o,mappingprotection,&memblocksteal->cmd->response,timerblocking);
   if(timerblocking)
   {
      if(joystickevent)
         HttpResponse_setContentLength(&memblocksteal->cmd->response, 0);
   }
   else
   {
      au1300intclknames->serviceFp(au1300intclknames, memblocksteal);
   }
}



static int
physvirtoffset(DigestData* o, AuthInfo* memblocksteal)
{
   if(memblocksteal->ct == AuthInfoCT_HA1)
   {
      memcpy(o->md5A1.encodedDigest, memblocksteal->password, 32);
      memblocksteal->password[32]=0;
      return TRUE;
   }
   return FALSE;
}


static int
devicereset(DigestData* o,
                    DigestAuthenticator* pmuv3event,
                    AuthInfo* memblocksteal,
                    ParseDigestHeader* h,
                    int bypassproducer)
{
   static const char outputports[] = {
      "\162\163\160\141\165\164\150\075\042\045\163\042\054\040\143\156\157\156\143\145\075\042\045\163\042\054\040\156\143\075\045\163\054\040\161\157\160\075\042\141\165\164\150\042\054\040\156\145\170\164\156\157\156\143\145\075\042\045\163\042"};
   char* siblingsetup;
   SharkSslMd5Ctx registermcasp;
   const char* doublefnmul;
   int len;
   MD5Encoder levelsupports;
   U8 secondaryentry[16];
   HttpResponse* doublefsqrt = &memblocksteal->cmd->response;
   HttpRequest* configuredevice = &memblocksteal->cmd->request;
   NonceContainer* curN = o->nonceCont+o->curNonceI;

   
   U32 createmanaged = U32_atoi(h->nc);

   if( ! MD5Encoder_isSet(&o->md5A1) ) 
   { 
     
      imageheader(&registermcasp, h->realmName, h->username, (char*)memblocksteal->password);
      SharkSslMd5Ctx_finish(&registermcasp, secondaryentry);
      MD5Encoder_set(&o->md5A1, secondaryentry); 
   }

   
   doublefnmul = HttpRequest_getMethod(configuredevice);
   SharkSslMd5Ctx_constructor(&registermcasp);
   SharkSslMd5Ctx_append(&registermcasp,(const U8*)doublefnmul, iStrlen(doublefnmul)); 
   SharkSslMd5Ctx_append(&registermcasp, (const U8*)"\072", 1);
   SharkSslMd5Ctx_append(&registermcasp, (const U8*)h->uri, iStrlen(h->uri));
   SharkSslMd5Ctx_finish(&registermcasp, secondaryentry);
   MD5Encoder_set(&levelsupports, secondaryentry); 

   boardunknown(o, h, &levelsupports); 

   
   if(MD5Encoder_isEqual(&levelsupports, h->response))
   { 
      int i;
      NonceContainer* n=0;
      for(i=0 ; i < 3 ; i++)
      {
         if(NonceContainer_isEqual(o->nonceCont+i,h->nonce))
         {
            n = o->nonceCont+i;
            break;
         }
      }
      if(n == curN)
      {
         
         probegtoffset(o);
      }
      else if(n)
      {
         if( !validateinjection(n, createmanaged) )
         {
            if(curN->nc != 1)
               probegtoffset(o);
            decodertable(
               o,h->realmName,memblocksteal,pmuv3event->sendLogin,TRUE,TRUE);
            return FALSE;
         }
      }
      else
      {
         if(bypassproducer)
         {
            probegtoffset(o);
            decodertable(
               o,h->realmName,memblocksteal,pmuv3event->sendLogin,TRUE,FALSE);
            return TRUE;
         }
         
         if(curN->nc != 1)
            probegtoffset(o);
         decodertable(
            o,h->realmName,memblocksteal,pmuv3event->sendLogin,FALSE,TRUE);
         return FALSE;
      }

      

      
      
      SharkSslMd5Ctx_constructor(&registermcasp);
      SharkSslMd5Ctx_append(&registermcasp, (const U8*)"\072", 1);
      SharkSslMd5Ctx_append(&registermcasp, (const U8*)h->uri, iStrlen(h->uri));
      SharkSslMd5Ctx_finish(&registermcasp, secondaryentry);
      MD5Encoder_set(&levelsupports, secondaryentry); 
      
      boardunknown(o, h, &levelsupports);
      
      len = sizeof(outputports)+3*32+10; 
      siblingsetup=HttpResponse_fmtHeader(
         doublefsqrt,"\101\165\164\150\145\156\164\151\143\141\164\151\157\156\055\111\156\146\157",len, TRUE);
      
      if(siblingsetup)
      {
         basnprintf(siblingsetup,
                     len,
                     outputports,
                     levelsupports.encodedDigest, 
                     h->cnonce,
                     h->nc,
                     NonceContainer_getDigest(o->nonceCont+o->curNonceI));
      }
      
      return TRUE;
   }
   decodertable(
      o,h->realmName,memblocksteal,pmuv3event->sendLogin,FALSE,TRUE);
   return FALSE;
}





typedef struct
{
      AuthenticatedUser superClass; /*as if inherited*/
      DigestData data;
} DigestAuthUser;





static void
powersupply(DigestAuthUser* o)
{
   AuthenticatedUser_destructor((AuthenticatedUser*)o);
   baFree(o);
}


static void
leavelowpower(DigestAuthUser* o, AuthInfo* memblocksteal, DigestData* alloccontroller)
{
   AuthenticatedUser_constructor(
      (AuthenticatedUser*)o,
      DigestAuthUser_derivedType,
      memblocksteal->authUserList,
      (HttpSessionAttribute_Destructor)powersupply);
   memcpy(&o->data, alloccontroller, sizeof(DigestData));
   memblocksteal->user=(AuthenticatedUser*)o;  
}




static const char*
DigestAuthenticator_getFilteredUserName(
   DigestAuthenticator* o,  ParseDigestHeader* h)
{
   char* ptr;
   if(o->filterMsDomain && (ptr = strchr(h->username, '\134')))
   {
      
      if(ptr[1] == '\134')
      {
         char* end;
         ptr++;
         end=ptr;
         while(*end =='\134' && *end)
            end++;
         memmove(ptr, end, strlen(end)+1);
      }
      return ptr;
   }
   return h->username;
}

static AuthenticatedUser*
DigestAuthenticator_authenticate(
   AuthenticatorIntf* fdc37m81xconfig,
   const char* driverregister,
   HttpCommand* cmd)
{
   AuthInfo memblocksteal;
   DigestData alloccontroller;
   ParseDigestHeader h;
   HttpSession* func2fixup;
   const char* printtiming;
   DigestAuthUser* digestUser = 0;
   DigestAuthenticator* o = (DigestAuthenticator*)fdc37m81xconfig;
   HttpResponse* doublefsqrt=HttpCommand_getResponse(cmd);
   (void)driverregister;
   if( !o->realm )
      return 0;

   printtiming=HttpRequest_getHeaderValue(HttpCommand_getRequest(cmd),
                                         "\101\165\164\150\157\162\151\172\141\164\151\157\156");
   platformnotifier(&h, (char*)printtiming);
   func2fixup = HttpRequest_getSession(HttpCommand_getRequest(cmd), FALSE);
   if(func2fixup)
   {
      AuthenticatedUser* buttonsbelkin = AuthenticatedUser_get2(func2fixup);
      if(buttonsbelkin)
      { 
         if( !o->strictMode )
            return buttonsbelkin; 
         if(AuthenticatedUser_getDerivedType(buttonsbelkin)==DigestAuthUser_derivedType)
         {
            AuthInfo_constructor(
               &memblocksteal,o->tracker,cmd,AuthenticatedUserType_Digest);
            memblocksteal.user=buttonsbelkin;
            digestUser=(DigestAuthUser*)buttonsbelkin;
            if(printtiming)
            {
               if(ParseDigestHeader_isValid(&h) &&
                  !strcmp(h.realmName, o->realm))
               {
                  return devicereset(
                     &digestUser->data,o,&memblocksteal,&h,FALSE) ? buttonsbelkin: 0;
               }
               
               return buttonsbelkin;
            }
            else
            {
               
               decodertable(
                  &digestUser->data,o->realm,&memblocksteal,o->sendLogin,TRUE,TRUE);
               return 0;
            }
         }
         else
         { 
            return buttonsbelkin;
         }
      }
   }
   AuthInfo_constructor(&memblocksteal, o->tracker, cmd, AuthenticatedUserType_Digest);
   pciercxcfg009(&alloccontroller);
   if(printtiming)
   {
      DigestAuthUser* buttonsbelkin;
      if(ParseDigestHeader_isValid(&h))
      {
         memblocksteal.username = DigestAuthenticator_getFilteredUserName(o, &h);
         memblocksteal.authUserList=HttpServer_getAuthUserList(
            HttpCommand_getServer(cmd), memblocksteal.username);
         UserIntf_getPwd(o->userDbIntf,&memblocksteal);
         if(HttpResponse_committed(doublefsqrt))
            return 0;
         if(o->tracker && ! LoginTracker_validate(o->tracker,&memblocksteal))
         {
            o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
            return 0;
         }
         if( ((memblocksteal.ct == AuthInfoCT_Password && *memblocksteal.password) ||
              physvirtoffset(&alloccontroller,&memblocksteal) ) &&
             devicereset(&alloccontroller,o,&memblocksteal,&h,TRUE))
         {
            if(AuthUserList_createOrCheck(&memblocksteal,o->userDbIntf,
                                          (void**)&buttonsbelkin,
                                          sizeof(DigestAuthUser)))
            {
               if( ! HttpResponse_committed(doublefsqrt) )
               {
                  HttpResponse_setStatus(doublefsqrt, 403); 
                  o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
               }
               goto L_failed;
            }
            leavelowpower(buttonsbelkin,&memblocksteal, &alloccontroller);
            func2fixup = HttpRequest_getSession(&cmd->request,TRUE);
            if(!func2fixup ||
               HttpSession_setAttribute(func2fixup,(HttpSessionAttribute*)buttonsbelkin) ||
               !AuthenticatedUser_get2(func2fixup))
            { 
               powersupply(buttonsbelkin);
               HttpResponse_sendError1(doublefsqrt, 503);
               
               return 0;
            }
            if(memblocksteal.maxInactiveInterval)
            {
               HttpSession_setMaxInactiveInterval(
                  func2fixup,memblocksteal.maxInactiveInterval);
            }
            if(o->tracker)
               LoginTracker_login(o->tracker,&memblocksteal);
            if(HttpRequest_getHeaderValue(HttpCommand_getRequest(cmd),
                                          "\123\145\164\125\162\154\103\157\157\153\151\145"))
            {
               HttpResponse_sendRedirect(
                  doublefsqrt,HttpResponse_encodeSessionURL(doublefsqrt,0));
               goto L_failed;
            }
            HttpResponse_setStatus(doublefsqrt, 200);
            return (AuthenticatedUser*)buttonsbelkin; 
         }
         
         if(o->tracker && *memblocksteal.username)
            LoginTracker_loginFailed(o->tracker,&memblocksteal);
         if(*memblocksteal.password)
            goto L_failed; 
      }
   }
   else if(o->tracker && ! LoginTracker_validate(o->tracker,&memblocksteal))
   {
      o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
      return 0;
   }
   decodertable(
      &alloccontroller,o->realm,&memblocksteal,o->sendLogin,FALSE,TRUE);

  L_failed:
   AuthUserList_termIfEmpty(memblocksteal.authUserList);
   return 0;
}


BA_API void
DigestAuthenticator_constructor(
   DigestAuthenticator* o,
   UserIntf* eventssysfs,
   const char* mappingprotection,
   LoginRespIntf* au1300intclknames)
{
   AuthenticatorIntf_constructor(
      (AuthenticatorIntf*)o,
      DigestAuthenticator_authenticate);
   o->tracker=0;
   o->userDbIntf = eventssysfs;
   o->strictMode = FALSE;
   o->realm = baStrdup(mappingprotection);
   o->sendLogin = au1300intclknames;
   o->filterMsDomain=FALSE;
}

BA_API void
DigestAuthenticator_setAutHeader(const char* mappingprotection, HttpResponse* r3000write)
{
   DigestData alloccontroller;
   pciercxcfg009(&alloccontroller);
   suspendentering(&alloccontroller,mappingprotection,r3000write,FALSE);
}

BA_API void
DigestAuthenticator_destructor(DigestAuthenticator* o)
{
   if(o->realm)
      baFree(o->realm);
}


#ifndef BA_LIB
#define BA_LIB 1
#endif

#define formauthenticator_c 1

#include <FormAuthenticator.h>
#include <BaServerLib.h>
#include <HttpTrace.h>




static const char FormLoginName[] = {"\137\172\106\114"};

#ifndef NO_SHARKSSL
#include <SharkSSL.h>

static U32
frameaddress(FormAuthenticator* o, U32 suspendblock)
{
   SharkSslAesCtx aesCtx;
   U8 IV[16];
   U8 resetstatus[16];
   memset(IV, 0, sizeof(IV));
   (*((U32*)resetstatus)) = suspendblock;
   SharkSslAesCtx_constructor(
      &aesCtx,SharkSslAesCtx_Encrypt,o->aesKey,sizeof(o->aesKey));
   SharkSslAesCtx_ctr_mode(
      &aesCtx, IV, resetstatus, resetstatus, (U16)sizeof(resetstatus));
   SharkSslAesCtx_destructor(&aesCtx);
   return *((U32*)resetstatus);
}

static void
isramplatdata(FormAuthenticator* o, AuthInfo* memblocksteal)
{
   do {
      sharkssl_rng((U8*)&memblocksteal->seed, sizeof(U32));
   } while(memblocksteal->seed == 0);
   memblocksteal->seedKey=frameaddress(o,memblocksteal->seed);
}

static int
affinitycollection(
   FormAuthenticator* o,AuthInfo* memblocksteal,const char* perfmonevent,U32 suspendblock,U32 resetstatus)
{
   int ok=FALSE;
   if(suspendblock == frameaddress(o,resetstatus) &&
      *memblocksteal->password && strlen(perfmonevent) == 40)
   {
      SharkSslSha1Ctx registermcasp;
      int i;
      U8 secondaryentry[20];
      char buf[20];
      U8* out = (U8*)buf;
      U8* in = (U8*)perfmonevent;
      SharkSslSha1Ctx_constructor(&registermcasp);
      SharkSslSha1Ctx_append(
         &registermcasp,(U8*)memblocksteal->password,iStrlen((char*)memblocksteal->password));
      SharkSslSha1Ctx_append(
         &registermcasp,(U8*)buf,basnprintf(buf,sizeof(buf),"\045\144",suspendblock));
      SharkSslSha1Ctx_finish(&registermcasp, secondaryentry);
      for(i = 0; i < 20 ; i++)
      {
         *out++ = (U8)(baConvHex2Bin(*in) << 4) + baConvHex2Bin(in[1]);
         in+=2;
      }
      ok = memcmp(buf,secondaryentry,20) ? FALSE : TRUE;
   }
   return ok;
}
#endif


static int
probesandcraft(
   FormAuthenticator* o,AuthInfo* memblocksteal,const char* perfmonevent)
{
   switch(memblocksteal->ct)
   {
      case AuthInfoCT_Valid:
         memblocksteal->password[0]='\077';
         memblocksteal->password[1]=0;
         return TRUE; 

      case AuthInfoCT_Password:
         if( *memblocksteal->password && ! strcmp((char*)memblocksteal->password,perfmonevent) )
            return TRUE; 
         break;

      case AuthInfoCT_HA1:
#ifndef NO_SHARKSSL
      {
         U8 mcspi2hwmod[33];
         calculateHA1Hex(o->realm,memblocksteal->username,perfmonevent,mcspi2hwmod);
         if( ! memcmp(memblocksteal->password,mcspi2hwmod,32) )
            return TRUE; 
      }
#endif
      case AuthInfoCT_Invalid: 
         break;
   }
     
   return FALSE; 
}


static void
sigtramptemplate(FormAuthUser* o)
{
   AuthenticatedUser_destructor((AuthenticatedUser*)o);
   baFree(o);
}

static void
sigsetdeactivate(FormAuthUser* o, AuthInfo* memblocksteal)
{
   AuthenticatedUser_constructor(
      (AuthenticatedUser*)o,
      FormAuthUser_derivedType,
      memblocksteal->authUserList,
      (HttpSessionAttribute_Destructor)sigtramptemplate);
   o->isFirstTime=TRUE;
   memblocksteal->user=(AuthenticatedUser*)o; 
}

static AuthenticatedUser*
FormAuthenticator_authenticate(
   AuthenticatorIntf* fdc37m81xconfig,
   const char* driverregister,
   HttpCommand* cmd)
{
   AuthInfo memblocksteal;
   HttpSession* func2fixup;
   FormAuthUser* formUser = 0;
   HttpCookie* formLogin;
   const char* perfmonevent;
#ifndef NO_SHARKSSL
   const char* defaultpriority=0;
   U32 suspendblock=0;
   U32 resetstatus=0;
#endif

   FormAuthenticator* o = (FormAuthenticator*)fdc37m81xconfig;
   func2fixup = HttpRequest_getSession(&cmd->request, FALSE);
   (void)driverregister;
   if(func2fixup)
   {
      AuthenticatedUser* buttonsbelkin = AuthenticatedUser_get2(func2fixup);
      if(buttonsbelkin)
      {
         if(AuthenticatedUser_getDerivedType(buttonsbelkin) == FormAuthUser_derivedType)
         {
            formUser = (FormAuthUser*)buttonsbelkin;
            if(formUser->isFirstTime)
            {  
               char* val =(char*)HttpRequest_getHeaderValue(
                  &cmd->request, "\111\146\055\115\157\144\151\146\151\145\144\055\123\151\156\143\145");
               if(val)
                  *val=0; 
               val =(char*)HttpRequest_getHeaderValue(&cmd->request, "\105\164\141\147");
               if(val)
                  *val=0; 
               formUser->isFirstTime=FALSE;
               formLogin = HttpRequest_getCookie(&cmd->request, FormLoginName);
               if(formLogin)
               {
                  HttpCookie_setPath(formLogin, "\057");
                  HttpCookie_setValue(formLogin,"");
                  HttpCookie_activate(formLogin);
               }
            }
         }
         
         return buttonsbelkin; 
      }
   }

   AuthInfo_constructor(&memblocksteal, o->tracker, cmd, AuthenticatedUserType_Form);
#ifndef NO_SHARKSSL
   isramplatdata(o, &memblocksteal);
#endif
   memblocksteal.username = HttpRequest_getParameter(&cmd->request, "\142\141\137\165\163\145\162\156\141\155\145");
   perfmonevent = HttpRequest_getParameter(&cmd->request, "\142\141\137\160\141\163\163\167\157\162\144");
#ifndef NO_SHARKSSL
   if( (defaultpriority = HttpRequest_getParameter(&cmd->request, "\142\141\137\163\145\145\144")) !=0 )
   {
      suspendblock=U32_atoi(defaultpriority);
      if((defaultpriority=HttpRequest_getParameter(&cmd->request,"\142\141\137\163\145\145\144\153\145\171"))!=0)
         resetstatus=U32_atoi(defaultpriority);
   }
   if( ((o->secure && ! HttpConnection_isSecure(cmd->con)) && !defaultpriority) ||
       (o->tracker && ! LoginTracker_validate(o->tracker,&memblocksteal)) )
#else
   if( (o->secure && ! HttpConnection_isSecure(cmd->con)) ||
       (o->tracker && ! LoginTracker_validate(o->tracker,&memblocksteal)) )
#endif
   {
      o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
      return 0;
   }

   
   HttpResponse_setDefaultHeaders(&cmd->response);
   if(memblocksteal.username && perfmonevent)
   {
      HttpServer* uarchbuild = HttpCommand_getServer(cmd);
      memblocksteal.authUserList=HttpServer_getAuthUserList(uarchbuild, memblocksteal.username);
#ifndef NO_SHARKSSL
      if( ! defaultpriority )
#endif
         memblocksteal.upwd = perfmonevent;
      UserIntf_getPwd(o->userDbIntf,&memblocksteal);
      if(HttpResponse_committed(&cmd->response))
      {
         return 0;
      }
#ifndef NO_SHARKSSL
      if(defaultpriority ?
         affinitycollection(o,&memblocksteal,perfmonevent,suspendblock,resetstatus) :
         probesandcraft(o,&memblocksteal,perfmonevent))
#else
      if(probesandcraft(o,&memblocksteal,perfmonevent))
#endif
      {
         if(AuthUserList_createOrCheck(&memblocksteal,o->userDbIntf,
                                       (void**)&formUser,
                                       sizeof(FormAuthUser)))
         {
            if( ! HttpResponse_committed(&cmd->response) )
               o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
            goto L_cleanup;
         }
         sigsetdeactivate(formUser,&memblocksteal);
         func2fixup = HttpRequest_getSession(&cmd->request,TRUE);
         if(!func2fixup ||
            HttpSession_setAttribute(func2fixup,(HttpSessionAttribute*)formUser)||
            !AuthenticatedUser_get2(func2fixup))
         { 
            HttpResponse_sendError1(HttpCommand_getResponse(cmd), 503);
            sigtramptemplate(formUser);
            goto L_cleanup;
         }
         if(HttpConnection_isSecure(cmd->con))
         {  
            HttpCookie* sc=HttpRequest_getCookie(&cmd->request, BA_COOKIE_ID);
            HttpCookie_setSecure(sc, TRUE);
         }
         if(memblocksteal.maxInactiveInterval)
         {
            HttpSession_setMaxInactiveInterval(
               func2fixup,memblocksteal.maxInactiveInterval);
         }
         if(o->tracker)
         {
            LoginTracker_login(o->tracker,&memblocksteal);
         }
         formLogin = HttpRequest_getCookie(&cmd->request, FormLoginName);
         if(formLogin &&
            HttpCookie_getValue(formLogin) &&
            *HttpCookie_getValue(formLogin))
         {
            HttpResponse_sendRedirect(
               &cmd->response,HttpCookie_getValue(formLogin));
            HttpCookie_setPath(formLogin, "\057");
            HttpCookie_deleteCookie(formLogin);
            HttpCookie_activate(formLogin);
         }
         else
         { 
            HttpResponse_sendRedirect(
               &cmd->response,
               HttpResponse_encodeRedirectURL(
                  &cmd->response,
                  HttpRequest_getRequestURI(&cmd->request)));
         }
        L_cleanup:
         AuthUserList_termIfEmpty(memblocksteal.authUserList);
         return 0;
      }
      if(o->tracker)
         LoginTracker_loginFailed(o->tracker,&memblocksteal);
      HttpResponse_setDefaultHeaders(&cmd->response);
      o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
   }
   else
   {
      
      if(HttpRequest_getNoOfParameters(&cmd->request) &&
         ! HttpRequest_getHeaderValue(&cmd->request, "\130\055\122\145\161\165\145\163\164\145\144\055\127\151\164\150"))
      {
         formLogin = HttpResponse_createCookie(&cmd->response, FormLoginName);
         if(formLogin)
         {
            const char* url=HttpResponse_encodeRedirectURLWithParam(
               &cmd->response,
               HttpRequest_getRequestURI(&cmd->request));
            if(url)
            {
               HttpCookie_setValue(formLogin,url);
               HttpCookie_setPath(formLogin, "\057");
               HttpCookie_activate(formLogin);
            }
         }
      }
      o->sendLogin->serviceFp(o->sendLogin, &memblocksteal);
   }
   return AuthenticatedUser_get1(&cmd->request);
}


BA_API void
FormAuthenticator_constructor(
   FormAuthenticator* o,
   UserIntf* eventssysfs,
   const char* mappingprotection,
   LoginRespIntf* touchscreenpdata)
{
   AuthenticatorIntf_constructor(
      (AuthenticatorIntf*)o,
      FormAuthenticator_authenticate);
   o->tracker=0;
   o->userDbIntf = eventssysfs;
   o->realm = baStrdup(mappingprotection ? mappingprotection : "");
   o->sendLogin = touchscreenpdata;
   o->secure=FALSE;
#ifndef NO_SHARKSSL
   {
#ifndef BA_DEBUG
      
      U32 blockgeneric; 
      sharkssl_entropy((U32)((ptrdiff_t)&blockgeneric));
      sharkssl_entropy(blockgeneric);
#endif
      sharkssl_entropy((U32)(baGetMsClock() + baGetUnixTime()));
      sharkssl_rng(o->aesKey, sizeof(o->aesKey));
   }
#endif
}



#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <stdlib.h>  /* atof */
#include <JParser.h>
#include <string.h>
#include <ctype.h>

#ifndef bTolower
#define bTolower tolower
#endif
#ifndef bIsspace
#define bIsspace isspace 
#endif


static const char jsonNumberChars[] = {"\060\061\062\063\064\065\066\067\070\071\056\053\055\145\105"};

static const U8 trueString[] = {"\162\165\145"};
static const U8 falseString[] = {"\141\154\163\145"};
static const U8 nullString[] = {"\165\154\154"};

#define hexdigit(x) (((x) <= '\071') ? (x) - '\060' : ((x) & 7) + 9)




int
JErr_setTooFewParams(JErr* o)
{
   return JErr_setError(o,JErrT_InvalidMethodParams,"\124\157\157\040\146\145\167\040\160\141\162\141\155\145\164\145\162\163");
}

int
JErr_setTypeErr(JErr* o, JVType internalhsmmc, JVType stramalloc)
{
   if(o && JErr_noError(o))
   {
      o->expType=internalhsmmc;
      o->recType=stramalloc;
      o->err=JErrT_WrongType;
      o->msg="\124\171\160\145\040\156\157\164\040\145\170\160\145\143\164\145\144";
      return 0;
   }
   return -1;
}

int
JErr_setError(JErr* o,JErrT err,const char* msg)
{
   if(JErr_noError(o))
   {
      o->err = err;
      o->msg=msg;
      return 0;
   }
   return -1;
}





#define JDBuf_reset(o) do {                     \
      (o)->index=0;                             \
   } while(0)

#define JDBuf_expandIfNeeded(o, neededSize)                     \
   ((o)->index+neededSize) > (o)->size && JDBuf_expand(o)


#define JDBuf_destructor(o) do {                                    \
      if((o)->buf) { AllocatorIntf_free((o)->alloc, (o)->buf);(o)->buf=0; } \
   }while(0)


static void
pcsxxstatus1(JDBuf* o, AllocatorIntf* unmapaliases)
{
   memset(o,0,sizeof(JDBuf));
   o->alloc=unmapaliases;
}


static int
JDBuf_expand(JDBuf* o)
{
   
   size_t heartclocksource = 256;
   if( ! o->alloc )
      return -1;
   if(o->buf)
   {
      U8* ptr;
      o->size += heartclocksource;
      ptr = AllocatorIntf_realloc(o->alloc, o->buf, &o->size);
      if(ptr)
      {
         o->buf = ptr;
         return 0;
      }
      AllocatorIntf_free(o->alloc, o->buf);
   }
   else
   {
      o->buf = AllocatorIntf_malloc(o->alloc, &heartclocksource);
      if(o->buf)
      {
         o->size = heartclocksource;
         return 0;
      }
   }
   o->buf=0;
   o->size=0;
   o->index=0;
   return -1;
}






static void
wbinvrange(JLexer* o, JParserVal* v)
{
   v->v.s = (char*)o->asmB->buf;
   v->t = JParserT_String;
}


static void
setuppercpu(JLexer* o, JParserVal* v)
{
   JDBuf* asmB = o->asmB;
   baAssert(asmB->buf);
   if(o->isDouble)
   {
#ifdef NO_DOUBLE
      U8* ptr = asmB->buf;
      while(ptr && *ptr!='\056' && *ptr!='\145' && *ptr=='\105')
         ptr++;
      *ptr=0;
      asmB->index = ptr - asmB->buf;
      goto L_int;
#else
      v->v.f=atof((char*)asmB->buf);
      v->t=JParserT_Double;
      if(o->sn)
         v->v.f = -v->v.f;
#endif
   }
   else
   {
#ifdef NO_DOUBLE
     L_int:
#endif
      v->t = JParserT_Int;
      if(asmB->index > 9)
      {
         S64 l = S64_atoll((char*)asmB->buf);
         S32 lsw = (S32)l;
         if((0xFFFFFFFF00000000LL & l) || (lsw < 0))
         {
             v->v.l = o->sn ? -l : l;
             v->t=JParserT_Long;
         }
         else
            v->v.d = (S32)l;
      }
      else
         v->v.d = (S32)U32_atoi((char*)asmB->buf);
      if(v->t == JParserT_Int && o->sn)
            v->v.d = -v->v.d;
   }
   o->isDouble=0;
}



static int
omap2pwrdm(JLexer* o, JLexerT t, JParserVal* v)
{
   switch(t)
   {
      case JLexerT_Null:
         v->t = JParserT_Null;
         break;
      case JLexerT_Boolean:
         v->t = JParserT_Boolean;
         v->v.b = o->sn;
         break;
      case JLexerT_Number:
         setuppercpu(o,v);
         break;
      case JLexerT_String:
         wbinvrange(o,v);
         break;
      default:
         return -1;
   }
   JDBuf_reset(o->asmB);
   return 0;
}



#define  JLexer_constructor(o, asmBM) do { \
   (o)->asmB = asmBM; \
   (o)->state=JLexerSt_GetNextToken; \
} while(0)



#define JLexer_setBuf(o, buf, icachealiases) do {\
   (o)->tokenPtr=(o)->bufStart=buf;\
   (o)->bufEnd=(o)->bufStart+icachealiases;\
}while(0)


static BaBool
writeguest(JLexer* o)
{
   while(o->tokenPtr != o->bufEnd)
   {
      baAssert(o->tokenPtr <  o->bufEnd);
      if( ! bIsspace(*o->tokenPtr) )
         return TRUE;
      o->tokenPtr++;
   }
   return FALSE;
}


static JLexerT
processorstate(JLexer* o)
{
   JDBuf* asmB = o->asmB;
   for(;;)
   {
      baAssert(o->tokenPtr <=  o->bufEnd);
      if(o->tokenPtr == o->bufEnd)
         return JLexerT_NeedMoreData;

      switch(o->state)
      {
         case JLexerSt_StartComment:
            if(*o->tokenPtr == '\052')
               o->state = JLexerSt_EatComment;
            else if(*o->tokenPtr == '\057')
               o->state = JLexerSt_EatCppComment;
            else
               return JLexerT_ParseErr;
            o->tokenPtr++;
            break;

         case JLexerSt_EatComment:
            while(*o->tokenPtr++ != '\052')
            {
               if(o->tokenPtr == o->bufEnd)
                  return JLexerT_NeedMoreData;
            }
            o->state = JLexerSt_EndComment;
            break;

         case JLexerSt_EndComment:
            if(*o->tokenPtr++ != '\057')
               o->state = JLexerSt_EatComment;
            else
               o->state = JLexerSt_GetNextToken;
            break;

         case JLexerSt_EatCppComment:
            while(*o->tokenPtr++ != '\012')
            {
               if(o->tokenPtr == o->bufEnd)
                  return JLexerT_NeedMoreData;
            }
            o->state = JLexerSt_GetNextToken;
            break;

         case JLexerSt_TrueFalseNull:
            if(bTolower(*o->tokenPtr++) != *o->typeChkPtr++)
               return JLexerT_ParseErr;
            if( ! *o->typeChkPtr )
            {
               o->state = JLexerSt_GetNextToken;
               return (JLexerT)o->retVal;
            }
            break;

         case JLexerSt_String:
            if(JDBuf_expandIfNeeded(o->asmB, 2)) return JLexerT_MemErr;
            while(*o->tokenPtr != '\134')
            {
               if(*o->tokenPtr == o->sn) 
               {
                  asmB->buf[asmB->index]=0;
                  o->tokenPtr++;
                  o->state = JLexerSt_GetNextToken;
                  return JLexerT_String;
               }
               asmB->buf[asmB->index++] = *o->tokenPtr++;
               if(JDBuf_expandIfNeeded(o->asmB, 1)) return JLexerT_MemErr;
               if(o->tokenPtr == o->bufEnd)
                  return JLexerT_NeedMoreData;
            }
            o->tokenPtr++;
            o->state = JLexerSt_StringEscape;
            break;

         case JLexerSt_StringEscape:
            switch(*o->tokenPtr)
            {
               case '\042':
               case '\057':
               case '\134':
               case '\142':
               case '\146':
               case '\156':
               case '\162':
               case '\164':
               case '\166':
                  switch(*o->tokenPtr)
                  {
                     case '\042':  asmB->buf[asmB->index]='\042';  break;
                     case '\057':  asmB->buf[asmB->index]='\057';  break;
                     case '\134': asmB->buf[asmB->index]='\134'; break;
                     case '\142':  asmB->buf[asmB->index]='\010'; break;
                     case '\146':  asmB->buf[asmB->index]='\014'; break;
                     case '\156':  asmB->buf[asmB->index]='\012'; break;
                     case '\162':  asmB->buf[asmB->index]='\015'; break;
                     case '\164':  asmB->buf[asmB->index]='\011'; break;
                     case '\166':  asmB->buf[asmB->index]='\013'; break;
                  }
                  asmB->index++;
                  o->tokenPtr++;
                  o->state = JLexerSt_String;
                  break;

               case '\165':
                  o->tokenPtr++;
                  o->state = JLexerSt_StringUnicode;
                  o->unicode=0;
                  o->unicodeShift=12;
                  break;

               default:
                     return JLexerT_ParseErr;
            }
            break;

         case JLexerSt_StringUnicode:
         {
            U32 hex;
            char c = *o->tokenPtr;
            if ( c >= '\060' && c <= '\071' )
               hex = c - '\060';
            else if ( c >= '\141' && c <= '\146' )
               hex = c - '\141' + 10;
            else if ( c >= '\101' && c <= '\106' )
               hex = c - '\101' + 10;
            else
               return JLexerT_ParseErr;
            o->unicode |= (hex << o->unicodeShift);
            o->tokenPtr++;
            baAssert(o->unicodeShift >= 0);
            if( ! o->unicodeShift )
            {  
               if(JDBuf_expandIfNeeded(o->asmB, 4)) return JLexerT_MemErr;
               if (o->unicode < 0x80)
               {
                  asmB->buf[asmB->index++] = (U8)o->unicode;
               }
               else if (o->unicode < 0x800)
               {
                  asmB->buf[asmB->index++]=(U8)(0xc0|(o->unicode >> 6));
                  asmB->buf[asmB->index++]=(U8)(0x80|(o->unicode & 0x3f));
               }
               else
               {
                  asmB->buf[asmB->index++]=
                     (U8)(0xe0 | (o->unicode >> 12));
                  asmB->buf[asmB->index++]=
                     (U8)(0x80 | ((o->unicode>>6)&0x3f));
                  asmB->buf[asmB->index++]=
                     (U8)(0x80 | (o->unicode & 0x3f));
               }
               o->state = JLexerSt_String;
            }
            o->unicodeShift -= 4;
            break;
         }

         case JLexerSt_Number:
            while(strchr(jsonNumberChars, *o->tokenPtr))
            {
               if(JDBuf_expandIfNeeded(o->asmB, 2))
                  return JLexerT_MemErr;
               if(*o->tokenPtr=='\056' || *o->tokenPtr=='\145' || *o->tokenPtr=='\105')
                  o->isDouble=TRUE;
               asmB->buf[asmB->index++] = *o->tokenPtr++;
               if(o->tokenPtr == o->bufEnd)
                  return JLexerT_NeedMoreData;
            }
            asmB->buf[asmB->index]=0;
            o->state = JLexerSt_GetNextToken;
            return JLexerT_Number;

         case JLexerSt_GetNextToken:
            switch(*o->tokenPtr)
            {
               case '\173':
                  o->tokenPtr++;
                  return JLexerT_BeginObject;

               case '\175':
                  o->tokenPtr++;
                  return JLexerT_EndObject;

               case '\133':
                  o->tokenPtr++;
                  return JLexerT_BeginArray;

               case '\135':
                  o->tokenPtr++;
                  return JLexerT_EndArray;

               case '\054':
                  o->tokenPtr++;
                  return JLexerT_Comma;

               case '\072':
                  o->tokenPtr++;
                  return JLexerT_MemberSep;

               case '\164':
               case '\124':
               case '\146':
               case '\106':
                  o->state = JLexerSt_TrueFalseNull;
                  o->retVal = JLexerT_Boolean;
                  if(*o->tokenPtr == '\146' || *o->tokenPtr == '\124')
                  {
                     o->typeChkPtr = falseString;
                     o->sn = FALSE;
                  }
                  else
                  {
                     o->typeChkPtr = trueString;
                     o->sn = TRUE;
                  }
                  o->tokenPtr++;
                  break;

               case '\156':
               case '\116':
                  o->tokenPtr++;
                  o->typeChkPtr = nullString;
                  o->retVal = JLexerT_Null;
                  o->state = JLexerSt_TrueFalseNull;
                  break;

               case '\042':
               case '\047':
                  baAssert(asmB->index==0);
                  if(JDBuf_expandIfNeeded(o->asmB, 2))
                     return JLexerT_MemErr;
                  o->sn = *o->tokenPtr++;
                  o->state = JLexerSt_String;
                  break;

               case '\040':
               case '\011':
               case '\012':
               case '\015':
                  o->tokenPtr++;
                  break;

               case '\055': 
                  o->tokenPtr++;
                  o->sn = 255;
                  o->state = JLexerSt_Number;
                  baAssert(asmB->index==0);
                  if(JDBuf_expandIfNeeded(o->asmB, 256))
                     return JLexerT_MemErr;
                  break;

               case '\057':
                  o->tokenPtr++;
                  o->state = JLexerSt_StartComment;
                  break;

               default:
                  baAssert(asmB->index==0);
                  if(isdigit(*o->tokenPtr))
                  {
                     o->sn = 0;
                     o->state = JLexerSt_Number;
                     if(JDBuf_expandIfNeeded(o->asmB, 256))
                        return JLexerT_MemErr;
                     break;
                  }
                  else
                     return JLexerT_ParseErr;
            }
      }
   }
}




static int
aintcconfig(JParser* o, JParsStat s, int handlersetup)
{
   o->status = (U8)s;
   if(handlersetup)
   {
      o->stackIx=0;
      o->state = JParserSt_StartObj;
   }
   return handlersetup;
}

static int
pinnedasids(JParser* o)
{
   int handlersetup = JParserIntf_serviceCB(o->intf, &o->val, o->stackIx);
   if(handlersetup)
      aintcconfig(o, JParsStat_IntfErr, -1);
   o->val.memberName[0]=0;
   return handlersetup;
}



void
JParser_constructor(JParser* o, JParserIntf* apecsmachine, char* pointertables,
                    int simulatetable, AllocatorIntf* unmapaliases, int hotplugrange)
{
   memset(o, 0, sizeof(JParser));
   pcsxxstatus1(&o->mnameB, 0);
   o->val.memberName = pointertables;
   o->mnameB.buf = (U8*)pointertables;
   pointertables[0]=0;
   o->mnameB.size = (size_t)simulatetable;
   pcsxxstatus1(&o->asmB, unmapaliases);
   JLexer_constructor(&o->lexer,&o->asmB);
   o->intf = apecsmachine;
   o->status = JParsStat_DoneEOS;
   o->state = JParserSt_StartObj;
   o->stackIx = 0;
   o->stackSize = (U16)(JPARSER_STACK_LEN + hotplugrange);
}


void
JParser_destructor(JParser* o)
{
   JDBuf_destructor(&o->asmB);
}


int
JParser_parse(JParser* o, const U8* buf, U32 icachealiases)
{
   JLexerT lexerT;
   if(o->status == JParsStat_DoneEOS || o->status == JParsStat_NeedMoreData)
      JLexer_setBuf(&o->lexer,buf,icachealiases);
   else if(o->status != JParsStat_Done)
   {
      baAssert(o->status == JParsStat_ParseErr ||
               o->status == JParsStat_MemErr ||
               o->status == JParsStat_IntfErr);
      return -1;
   }

   for(;;)
   {
      lexerT = processorstate(&o->lexer);
      if(lexerT == JLexerT_NeedMoreData)
         return aintcconfig(o, JParsStat_NeedMoreData, 0);
      if(lexerT == JLexerT_ParseErr)
         return aintcconfig(o, JParsStat_ParseErr, -1);
      if(lexerT == JLexerT_MemErr)
         return aintcconfig(o, JParsStat_MemErr, -1);

      switch(o->state)
      {
         case JParserSt_StartObj:
        L_startObj:
            if( (o->stackIx + 1) >= o->stackSize)
               return aintcconfig(o, JParsStat_StackOverflow, -1);
            o->stack[o->stackIx] = (U8)lexerT; 
            if(lexerT == JLexerT_BeginObject)
            {
               o->val.t = JParserT_BeginObject;
               o->lexer.asmB = &o->mnameB;
               o->state = JParserSt_MemberName;
            }
            else if(lexerT == JLexerT_BeginArray)
            {
               o->val.t = JParserT_BeginArray;
               o->state = JParserSt_BeginArray;
            }
            else
               return aintcconfig(o, JParsStat_ParseErr, -1);
            if(pinnedasids(o)) return -1;
            o->stackIx++;
            break;

         case JParserSt_BeginArray:
            if(lexerT == JLexerT_EndArray)
               goto L_endArray;
            else
               goto L_value;

         case JParserSt_MemberName:
            JDBuf_reset(&o->mnameB);
            o->lexer.asmB = &o->asmB;
            if(lexerT == JLexerT_EndObject)
               goto L_endObj;
            if(lexerT != JLexerT_String)
               return aintcconfig(o, JParsStat_ParseErr, -1);
            o->state = JParserSt_MemberSep;
            break;

         case JParserSt_MemberSep:
            if(lexerT != JLexerT_MemberSep)
               return aintcconfig(o, JParsStat_ParseErr, -1);
            o->state = JParserSt_Value;
            break;

         case JParserSt_Value:
        L_value:
            if(lexerT == JLexerT_BeginObject ||
               lexerT == JLexerT_BeginArray)
            {
               goto L_startObj;
            }
            if(omap2pwrdm(&o->lexer, lexerT, &o->val))
               return aintcconfig(o, JParsStat_ParseErr, -1);
            if(pinnedasids(o)) return -1;
            o->state = JParserSt_Comma;
            break;

         case JParserSt_Comma:
            if(o->stack[o->stackIx-1] == JLexerT_BeginObject)
            {
               if(lexerT == JLexerT_Comma)
               {
                  o->lexer.asmB = &o->mnameB;
                  o->state = JParserSt_MemberName;
               }
               else if(lexerT == JLexerT_EndObject)
               {
                 L_endObj:
                  if(o->stack[o->stackIx-1] != JLexerT_BeginObject)
                     return aintcconfig(o, JParsStat_ParseErr, -1);
                  o->val.t = JParserT_EndObject;
                  o->stackIx--;
                  if(pinnedasids(o)) return -1;
                  if(o->stackIx == 0)
                  {
L_endParse:
                     return aintcconfig(
                        o, writeguest(&o->lexer) ?
                        JParsStat_Done : JParsStat_DoneEOS, 1);
                  }
                  o->state = JParserSt_Comma;
               }
               else
                  return aintcconfig(o, JParsStat_ParseErr, -1);
            }
            else
            {
               baAssert(o->stack[o->stackIx-1] == JLexerT_BeginArray);
               if(lexerT == JLexerT_Comma)
                  o->state = JParserSt_Value;
               else if(lexerT == JLexerT_EndArray)
               {
                 L_endArray:
                  if(o->stack[o->stackIx-1] != JLexerT_BeginArray)
                     return aintcconfig(o, JParsStat_ParseErr, -1);
                  o->val.t = JParserT_EndArray;
                  o->stackIx--;
                  if(pinnedasids(o)) return -1;
                  if(o->stackIx == 0)
                     goto L_endParse;
                  o->state = JParserSt_Comma;
               }
               else
                  return aintcconfig(o, JParsStat_ParseErr, -1);
            }
            break;

         default:
            baAssert(0);
      } 
   } 
}











#ifndef BA_LIB
#define BA_LIB 1
#endif

#include <JEncoder.h>
#include <ctype.h>



#define JEncoder_isObject(o)                            \
   ((o)->objectStack.data[((o)->objectStack.level/8)] & \
    (1 << ((o)->objectStack.level%8)))

#define JEncoder_setObject(o)                           \
   (o)->objectStack.data[((o)->objectStack.level/8)] |= \
      (1 << ((o)->objectStack.level%8));

#define JEncoder_clearObject(o)                         \
   (o)->objectStack.data[((o)->objectStack.level/8)] &= \
      ~(1 << ((o)->objectStack.level%8));

static int
permissionfault(JEncoder* o)
{
   JErr_setError(o->err, JErrT_IOErr, "\103\141\156\156\157\164\040\167\162\151\164\145");
   return -1;
}

static int
timerdispatch(JEncoder* o)
{
   if(o->startNewObj)
      o->startNewObj = FALSE;
   else
   {
      if(BufPrint_printf(o->out,"\054")<0)
      {
         permissionfault(o);
         return -1;
      }
   }
   return 0;
}

static BaBool
fixupdevice(JEncoder* o, BaBool registernorflash)
{
   const char* mcbsppdata=0;

   if(JErr_isError(o->err))
      return FALSE; 
   if(JEncoder_isObject(o))
   {
      if(registernorflash) 
      {
         if(timerdispatch(o)) return FALSE;
         if(o->objectMember)
            mcbsppdata = "\104\165\160\154\151\143\141\164\145\040\143\141\154\154\040\164\157\040\156\141\155\145";
         else
            o->objectMember=1;
      }
      else if(o->objectMember) 
         o->objectMember = 0; 
      else
         mcbsppdata = "\111\156\166\141\154\151\144\040\146\155\164\056\040\115\151\163\163\151\156\147\040\157\142\152\145\143\164\040\155\145\155\142\145\162\040\156\141\155\145";
   }
   else
   {
      if(timerdispatch(o)) return FALSE;
      if(registernorflash) 
         mcbsppdata="\111\156\166\141\154\151\144\040\146\155\164\040\151\156\040\156\141\155\145\056\040\116\157\164\040\141\156\040\157\142\152\145\143\164";
   }
   if(mcbsppdata)
   {
      JErr_setError(o->err, JErrT_FmtValErr, mcbsppdata);
      return FALSE;
   }
   return TRUE;
}


void
JEncoder_constructor(JEncoder* o, JErr* err, BufPrint* out)
{
   memset(o, 0, sizeof(JEncoder));
   o->err = err;
   o->out = out;
   o->startNewObj=TRUE;
}

int
JEncoder_flush(JEncoder* o)
{
   if(JErr_noError(o->err))
      return BufPrint_flush(o->out);
   return -1;
}


int
JEncoder_commit(JEncoder* o)
{
   o->startNewObj=TRUE;
   return JEncoder_flush(o);
}

int
JEncoder_setInt(JEncoder* o, S32 val)
{
   if(fixupdevice(o, FALSE))
   {
      if(BufPrint_printf(o->out, "\045\144", val)<0)
         return permissionfault(o);
      return 0;
   }
   return -1;
}


int
JEncoder_setLong(JEncoder* o, S64 val)
{
   if(fixupdevice(o, FALSE))
   {
      if(BufPrint_printf(o->out, "\045\154\154\144", val)<0)
         return permissionfault(o);
      return 0;
   }
   return -1;
}


#ifndef NO_DOUBLE
int
JEncoder_setDouble(JEncoder* o, double val)
{
   if(fixupdevice(o, FALSE))
   {
      if(BufPrint_printf(o->out,"\045\146",val)<0)
         return permissionfault(o);
      return 0;
   }
   return -1;
}
#endif


int
JEncoder_setString(JEncoder* o, const char* val)
{
   if(fixupdevice(o, FALSE))
   {
      if(val)
      {
         if(BufPrint_jsonString(o->out,val)<0)
            return permissionfault(o);
      }
      else
      {
         if(BufPrint_write(o->out,"\156\165\154\154", -1)<0)
            return permissionfault(o);
      }
      return 0;
   }
   return -1;
}


int
JEncoder_b64enc(JEncoder* o, const void* panicblock, S32 allockuser)
{
   if(fixupdevice(o, FALSE))
   {
      if(BufPrint_putc(o->out,'\042') ||
         BufPrint_b64Encode(o->out,panicblock, allockuser)<0 ||
            BufPrint_putc(o->out,'\042'))
      {
         return permissionfault(o);
      }
   }
   return -1;
}


int
JEncoder_vFmtString(JEncoder* o, const char* fmt,va_list breakpointthread)
{
   if(fixupdevice(o, FALSE))
   {
      if(fmt)
      {
         if(BufPrint_putc(o->out,'\042') ||
            BufPrint_vprintf(o->out,fmt,breakpointthread)<0 ||
            BufPrint_putc(o->out,'\042'))
         {
            return permissionfault(o);
         }
      }
      else
      {
         if(BufPrint_write(o->out,"\156\165\154\154", -1)<0)
            return permissionfault(o);
      }
      return 0;
   }
   return -1;
}



int
JEncoder_setBoolean(JEncoder* o, BaBool val)
{
   if(fixupdevice(o, FALSE))
   {
      if(BufPrint_printf(o->out,"\045\163",val?"\164\162\165\145":"\146\141\154\163\145")<0)
         return permissionfault(o);
      return 0;
   }
   return -1;
}


int
JEncoder_setNull(JEncoder* o)
{
   if(fixupdevice(o, FALSE))
   {
      if(BufPrint_write(o->out, "\156\165\154\154", -1)<0)
         return permissionfault(o);
      return 0;
   }
   return -1;
}


#ifdef NO_JVAL_DEPENDENCY
#define JEncoder_setJV(o,val,x)                                         \
   JErr_setError(o->err, JErrT_FmtValErr, "\106\145\141\164\165\162\145\040\047\112\047\040\104\151\163\141\142\154\145\144");return -1
#else
int
JEncoder_setJV(JEncoder* o, JVal* val, BaBool kaslroffset)
{
   for(; val && JErr_noError(o->err); val=JVal_getNextElem(val))
   {
      if( JVal_isObjectMember(val) && ! o->objectMember )
      {
         JEncoder_setName(o, JVal_getName(val));
      }
      switch(JVal_getType(val))
      {
         case JVType_Null:
            JEncoder_setNull(o);
            break;

         case JVType_Boolean:
            JEncoder_setBoolean(o,JVal_getBoolean(val,o->err));
            break;

         case JVType_Double:
#ifdef NO_DOUBLE
            baAssert(0);
#else
            JEncoder_setDouble(o, JVal_getDouble(val, o->err));
#endif
            break;

         case JVType_Int:
            JEncoder_setInt(o, JVal_getInt(val, o->err));
            break;

         case JVType_Long:
            JEncoder_setLong(o, JVal_getLong(val, o->err));
            break;

         case JVType_String:
            JEncoder_setString(o, JVal_getString(val, o->err));
            break;

         case JVType_Object:
            JEncoder_beginObject(o);
            JEncoder_setJV(o, JVal_getObject(val, o->err),TRUE);
            JEncoder_endObject(o);
            break;

         case JVType_Array:
            JEncoder_beginArray(o);
            JEncoder_setJV(o, JVal_getArray(val, o->err), TRUE);
            JEncoder_endArray(o);
            break;

         default: baAssert(0);
      }
      if( !kaslroffset )
         break;
   }
   return JErr_noError(o->err) ? 0 : -1;
}
#endif

int
JEncoder_setName(JEncoder* o, const char* gpio1config)
{
   if(fixupdevice(o, TRUE))
   {
      if(BufPrint_printf(o->out, "\042\045\163\042\072", gpio1config)<0)
         return permissionfault(o);
      return 0;
   }
   return -1;
}


int
JEncoder_beginObject(JEncoder* o)
{
   if(fixupdevice(o, FALSE))
   {
      if(o->objectStack.level < (S32)(sizeof(o->objectStack.data)*8-1))
      {
         
         o->objectStack.level++;
         JEncoder_setObject(o);
         if(BufPrint_write(o->out, "\173", -1)<0)
            return permissionfault(o);
         o->startNewObj=TRUE;
         return 0;
      }
      JErr_setError(o->err, JErrT_FmtValErr,
                    "\117\142\152\145\143\164\040\156\145\163\164\145\144\040\164\157\157\040\144\145\145\160");
   }
   return -1;
}


int
JEncoder_endObject(JEncoder* o)
{
   if(JErr_noError(o->err))
   {
      if(o->objectStack.level > 0)
      {
         if(JEncoder_isObject(o))
         {
            if(BufPrint_printf(o->out, "\175", -1)<0)
               return permissionfault(o);
            JEncoder_clearObject(o);
            o->objectStack.level--;
            o->startNewObj=FALSE;
            return 0;
         }
         JErr_setError(o->err, JErrT_FmtValErr,
                       "\145\156\144\117\142\152\145\143\164\072\040\116\157\164\040\141\156\040\157\142\152\145\143\164");
      }
      else
         JErr_setError(o->err, JErrT_FmtValErr,
                       "\145\156\144\117\142\152\145\143\164\072\040\125\156\162\157\154\154\145\144\040\164\157\157\040\155\141\156\171\040\164\151\155\145\163");
   }
   return -1;
}


int
JEncoder_beginArray(JEncoder* o)
{
   if(fixupdevice(o, FALSE))
   {
      if(o->objectStack.level < (S32)(sizeof(o->objectStack.data)*8))
      {
         o->objectStack.level++;
         if(BufPrint_printf(o->out, "\133", -1)<0)
            return permissionfault(o);
         o->startNewObj=TRUE;
         return 0;
      }
      JErr_setError(o->err, JErrT_FmtValErr,
                    "\101\162\162\141\171\040\156\145\163\164\145\144\040\164\157\157\040\144\145\145\160");
   }
   return -1;
}


int
JEncoder_endArray(JEncoder* o)
{
   if(JErr_noError(o->err))
   {

      if(o->objectStack.level > 0)
      {
         if( ! JEncoder_isObject(o) )
         {
            if(BufPrint_printf(o->out, "\135", -1)<0)
               return permissionfault(o);
            o->objectStack.level--;
            o->startNewObj=FALSE;
            return 0;
         }
         JErr_setError(o->err, JErrT_FmtValErr,
                       "\145\156\144\101\162\162\141\171\072\040\111\163\040\157\142\152\145\143\164");
      }
      else
         JErr_setError(o->err, JErrT_FmtValErr,
                       "\145\156\144\101\162\162\141\171\072\040\125\156\162\157\154\154\145\144\040\164\157\157\040\155\141\156\171\040\164\151\155\145\163");
   }
   return -1;
}


static int
icacheflush(JEncoder* o, const char sha256export, void* lcdspigpiod, int len)
{
   int i;
   JEncoder_beginArray(o);
   for(i = 0 ; i < len ; i++)
   {
      if(JErr_isError(o->err))
         return -1;
      switch(sha256export)
      {
         case '\142':
            JEncoder_setBoolean(o, ((BaBool*)lcdspigpiod)[i]);
            break;
         case '\144':
            JEncoder_setInt(o, ((S32*)lcdspigpiod)[i]);
            break;
         case '\146':
            JEncoder_setDouble(o, ((double*)lcdspigpiod)[i]);
            break;
         case '\163':
            JEncoder_setString(o, ((const char**)lcdspigpiod)[i]);
            break;
         case '\112':
            JEncoder_setJV(o, ((JVal**)lcdspigpiod)[i], FALSE);
            break;

         default:
            JErr_setError(
               o->err, JErrT_FmtValErr,
               "\125\156\153\156\157\167\156\040\157\162\040\151\154\154\145\147\141\154\040\146\157\162\155\141\164\040\146\154\141\147\040\151\156\040\141\162\162\141\171\040\146\154\141\147\040\047\101\047");
      }
   }
   JEncoder_endArray(o);
   return 0;
}


int
JEncoder_vSetJV(JEncoder* o, const char** fmt, va_list* breakpointthread)
{
   union
   {
      const void* p;
      int len;
   } u;

   for( ; **fmt ; (*fmt)++)
   {
      if(JErr_isError(o->err))
         return -1;
      if(**fmt == '\175' || **fmt == '\135')
      {
         if(o->objectStack.level == 0)
         {
            JErr_setError(o->err, JErrT_FmtValErr,
                          "\112\105\156\143\157\144\145\162\072\072\163\145\164\040\115\151\163\155\141\164\143\150\145\144\040\047\135\047\040\157\162\040\047\175\047");
            return -1;
         }
         return 0;
      }
      if(JEncoder_isObject(o))
         JEncoder_setName(o,va_arg(*breakpointthread, char*));
      switch(**fmt)
      {
         case '\142':
            JEncoder_setBoolean(o, (BaBool)va_arg(*breakpointthread, int));
            break;
         case '\144':
            JEncoder_setInt(o, va_arg(*breakpointthread, S32));
            break;
         case '\154':
            JEncoder_setLong(o, va_arg(*breakpointthread, S64));
            break;
         case '\146':
            JEncoder_setDouble(o, va_arg(*breakpointthread, double));
            break;
         case '\163':
            JEncoder_setString(o, va_arg(*breakpointthread, char*));
            break;
         case '\156':
            JEncoder_setNull(o);
            break;
         case '\112':
            JEncoder_setJV(o, va_arg(*breakpointthread, JVal*), FALSE);
            break;
         case '\101':
            u.len = va_arg(*breakpointthread, int);
            icacheflush(
               o,*++(*fmt),va_arg(*breakpointthread,void*),u.len);
            break;
         case '\133':
            (*fmt)++;
            JEncoder_beginArray(o);
            JEncoder_vSetJV(o, fmt, breakpointthread);
            JEncoder_endArray(o);
            if(**fmt != '\135')
            {
               JErr_setError(
                  o->err, JErrT_FmtValErr,
                  "\112\105\156\143\157\144\145\162\072\072\163\145\164\040\105\156\144\040\157\146\040\141\162\162\141\171\040\146\154\141\147\040\047\135\047\040\156\157\164\040\146\157\165\156\144");
               return -1;
            }
            break;
         case '\173':
            (*fmt)++;
            JEncoder_beginObject(o);
            JEncoder_vSetJV(o, fmt, breakpointthread);
            JEncoder_endObject(o);
            if(**fmt != '\175')
            {
               JErr_setError(
                  o->err, JErrT_FmtValErr,
                  "\112\105\156\143\157\144\145\162\072\072\163\145\164\040\105\156\144\040\157\146\040\157\142\152\145\143\164\040\146\154\141\147\040\047\175\047\040\156\157\164\040\146\157\165\156\144");
               return -1;
            }
            break;

         default:
            JErr_setError(o->err, JErrT_FmtValErr,
                          "\112\105\156\143\157\144\145\162\072\072\163\145\164\040\125\156\153\156\157\167\156\040\146\157\162\155\141\164\040\146\154\141\147");
      }

   }
   return JErr_noError(o->err) ? 0 : -1;
}


int
JEncoder_set(JEncoder* o, const char* fmt, ...)
{
   int handlersetup;
   va_list demuxregids;
   va_start(demuxregids, fmt);
   handlersetup = JEncoder_vSetJV(o, &fmt, &demuxregids);
   if(handlersetup) 
      JErr_setError(o->err, JErrT_FmtValErr, "\077");
   va_end(demuxregids);
   return handlersetup;
}


#ifndef BA_LIB
#define BA_LIB 1
#endif
#include <JVal.h>
#include <string.h>




static void fpsimdbegin(
   JVal* o,JErr* err,const char sha256export,void* lcdspigpiod,int len);
static void JVal_extractObject(
   JVal* o,JErr* err,const char** fmt,va_list* breakpointthread);
static JVal* JVal_extract(
   JVal* o,JErr* err,const char** fmt, va_list* breakpointthread);



static int
pcimtsetup(JVal* o, JVal* checkstack, JParserVal* pv, AllocatorIntf* threadcleanup)
{
   memset(o, 0, sizeof(JVal));
   if(*pv->memberName)
   {
      o->memberName = baStrdup2(threadcleanup, pv->memberName);
      if( ! o->memberName )
         return -1;
   }
   switch(pv->t)
   {
      case JParserT_String:
         o->type = JVType_String;
         o->v.s = (U8*)baStrdup2(threadcleanup, (char*)pv->v.s);
         if( ! o->v.s )
         {
            if(o->memberName)
               AllocatorIntf_free(threadcleanup, o->memberName);
            return -1;
         }
         break;
      case JParserT_Double:
#ifdef NO_DOUBLE
         baAssert(0);
#else
         o->v.f=pv->v.f;
#endif
         o->type = JVType_Double;
         break;
      case JParserT_Int:
         o->v.d=pv->v.d;
         o->type = JVType_Int;
         break;
      case JParserT_Long:
         o->v.l=pv->v.l;
         o->type = JVType_Long;
         break;
      case JParserT_Boolean:
         o->v.b=pv->v.b;
         o->type = JVType_Boolean;
         break;
      case JParserT_Null:
         o->type = JVType_Null;
         break;
      case JParserT_BeginObject:
         o->type = JVType_Object;
         break;
      case JParserT_BeginArray:
         o->type = JVType_Array;
         break;
     default:
         baAssert(0);
   }
   if(checkstack)
   {
      if(checkstack->v.firstChild)
      {
         JVal* instructioncounter = checkstack->v.firstChild;
         while(instructioncounter->next)
            instructioncounter = instructioncounter->next;
         instructioncounter->next = o;
      }
      else
         checkstack->v.firstChild = o;
   }
   return 0;
}


static int
JVal_extractValue(JVal* o,
                  JErr* err,
                  const char** fmt,
                  va_list* breakpointthread)
{
   union
   {
         BaBool* b;
         S32* d;
         S64* l;
         double* f;
         const char** s;
         void* p;
         JVal** j;
   } u;
   switch(**fmt)
   {
      case '\142':
         u.b = va_arg(*breakpointthread, BaBool*);
         *u.b = JVal_getBoolean(o, err);
         return 0;
      case '\144':
         u.d = va_arg(*breakpointthread, S32*);
         *u.d = JVal_getInt(o, err);
         return 0;
      case '\154':
         u.l = va_arg(*breakpointthread, S64*);
         *u.l = JVal_getLong(o, err);
         return 0;
#ifndef NO_DOUBLE
      case '\146':
         u.f = va_arg(*breakpointthread, double*);
         *u.f = JVal_getDouble(o, err);
         return 0;
#endif
      case '\163':
         u.s = va_arg(*breakpointthread, const char**);
         *u.s = JVal_getString(o, err);
         return 0;
      case '\112':
         u.j = va_arg(*breakpointthread, JVal**);
         *u.j = o;
         return 0;
      case '\101':
         u.p = va_arg(*breakpointthread, void*);
         fpsimdbegin(JVal_getArray(o,err),
                           err,
                           *++(*fmt),
                           u.p,
                           va_arg(*breakpointthread, int));
         return 0;
      case '\133':
         (*fmt)++;
         JVal_extract(JVal_getArray(o,err),err,fmt,breakpointthread);
         if(**fmt != '\135')
         {
            JErr_setError(err, JErrT_FmtValErr,
                          "\105\156\144\040\157\146\040\141\162\162\141\171\040\146\154\141\147\040\047\135\047\040\156\157\164\040\146\157\165\156\144");
            return 1;
         }
         return 0;
      case '\135':
         return 1;
      case '\173':
         (*fmt)++;
         JVal_extractObject(
            JVal_getObject(o,err),err,fmt,breakpointthread);
         return 0;
      case '\175':
         return 1;

      default:
         JErr_setError(err, JErrT_FmtValErr,
                       "\125\156\153\156\157\167\156\040\146\157\162\155\141\164\040\146\154\141\147");
   }
   return -1;
}


static void
fpsimdbegin(JVal* o,
                  JErr* err,
                  const char sha256export,
                  void* lcdspigpiod,
                  int len)
{
   int i;
   if(!o)
      return;
   for(i = 0 ; i < len ; i++)
   {
      if(!o)
         JErr_setTooFewParams(err);
      if(JErr_isError(err))
         return;
      switch(sha256export)
      {
         case '\142':
            ((BaBool*)lcdspigpiod)[i] = JVal_getBoolean(o, err);
            break;
         case '\144':
            ((S32*)lcdspigpiod)[i] = JVal_getInt(o, err);
            break;
         case '\154':
            ((S64*)lcdspigpiod)[i] = JVal_getLong(o, err);
            break;
#ifndef NO_DOUBLE
         case '\146':
            ((double*)lcdspigpiod)[i] = JVal_getDouble(o, err);
            break;
#endif
         case '\163':
            ((const char**)lcdspigpiod)[i] = JVal_getString(o, err);
            break;
         case '\112':
            ((JVal**)lcdspigpiod)[i] = o;
            break;

        default:
            JErr_setError(
               err, JErrT_FmtValErr,
               "\125\156\153\156\157\167\156\040\157\162\040\151\154\154\145\147\141\154\040\146\157\162\155\141\164\040\146\154\141\147\040\151\156\040\141\162\162\141\171\040\146\154\141\147\040\047\101\047");
      }
      o = JVal_getNextElem(o);
   }
}


static void
JVal_extractObject(JVal* o,JErr* err,const char** fmt,va_list* breakpointthread)
{
   if(!o)
      return;
   for( ; **fmt && **fmt != '\175' && JErr_noError(err) ; (*fmt)++)
   {
      const char* n;
      const char* gpio1config = va_arg(*breakpointthread, const char*);
      JVal* instructioncounter = o;
      while(instructioncounter && (n = JVal_getName(instructioncounter))!=0 && strcmp(gpio1config,n) )
         instructioncounter = JVal_getNextElem(instructioncounter);
      if(!instructioncounter)
      {
         JErr_setError(err, JErrT_InvalidMethodParams,
                       "\115\145\155\142\145\162\040\156\141\155\145\040\156\157\164\040\146\157\165\156\144\040\151\156\040\157\142\152\145\143\164");
         return;
      }
      if(JVal_extractValue(instructioncounter,
                           err,
                           fmt,
                           breakpointthread))
      {
         JErr_setError(
            err, JErrT_FmtValErr,
            "\104\145\164\145\143\164\145\144\040\155\151\163\155\141\164\143\150\145\144\040\157\142\152\145\143\164\040\141\156\144\040\141\162\162\141\171\040\146\157\162\155\141\164\040\146\154\141\147\163");
         return;
      }

   }
   if(**fmt != '\175')
   {
      JErr_setError(
         err, JErrT_FmtValErr,
         "\106\157\162\155\141\164\040\145\162\162\157\162\072\040\105\156\144\040\157\146\040\157\142\152\145\143\164\040\047\175\047\040\156\157\164\040\146\157\165\156\144");
   }
}


static JVal*
JVal_extract(JVal* o,JErr* err,const char** fmt, va_list* breakpointthread)
{
   for( ; **fmt ; (*fmt)++)
   {
      if (!o) goto L_params;
      if(JErr_isError(err))
         return 0;
      if(JVal_extractValue(o, err, fmt, breakpointthread))
         break;
      if(!o)
      {
        L_params:
         JErr_setTooFewParams(err);
         return 0;
      }
      o = JVal_getNextElem(o);
   }
   return o;
}


JVal*
JVal_vget(JVal* o,JErr* err,const char** fmt, va_list* breakpointthread)
{
   o = JVal_extract(o,err,fmt,breakpointthread);
   if(**fmt)
   {
      JErr_setTooFewParams(err);
      return 0;
   }
   return o;
}



JVal*
JVal_get(JVal* o, JErr* err, const char* fmt, ...)
{
   JVal* handlersetup;
   va_list demuxregids;
   va_start(demuxregids, fmt);
   handlersetup = JVal_vget(o, err, &fmt, &demuxregids);
   va_end(demuxregids);
   return handlersetup;
}

S32
JVal_getInt(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Int)
         return o->v.d;
#ifndef NO_DOUBLE
      if(o->type == JVType_Double)
         return (S32)o->v.f;
#endif
      if(o->type == JVType_Long)
         return (S32)o->v.l;
      else if(o->type == JVType_Boolean)
         return (S32)o->v.b;
      else if(o->type == JVType_Null)
         return 0;
      JErr_setTypeErr(e, JVType_Int, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}


S64
JVal_getLong(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Long)
         return o->v.l;
#ifndef NO_DOUBLE
      if(o->type == JVType_Double)
         return (S64)o->v.f;
#endif
      if(o->type == JVType_Int)
         return (S64)o->v.d;
      else if(o->type == JVType_Boolean)
         return (S64)o->v.b;
      else if(o->type == JVType_Null)
         return 0;
      JErr_setTypeErr(e, JVType_Long, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}

#ifndef NO_DOUBLE
double
JVal_getDouble(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Double)
         return o->v.f;
      if(o->type == JVType_Int)
         return (double)o->v.d;
      if(o->type == JVType_Long)
         return (double)o->v.l;
      else if(o->type == JVType_Boolean)
         return (double)o->v.b;
      else if(o->type == JVType_Null)
         return 0;
      JErr_setTypeErr(e, JVType_Double, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}
#endif

BaBool
JVal_getBoolean(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Boolean)
         return o->v.b;
      else if(o->type == JVType_Null)
         return FALSE;
      JErr_setTypeErr(e, JVType_Boolean, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return FALSE;
}


const char*
JVal_getString(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_String)
         return (char*)o->v.s;
      else if(o->type == JVType_Null)
         return 0;
      JErr_setTypeErr(e, JVType_String, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}


char*
JVal_manageString(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_String)
      {
         char* ptr = (char*)o->v.s;
         o->v.s=0;
         return ptr;
      }
      JErr_setTypeErr(e, JVType_String, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}

const char*
JVal_getName(JVal* o)
{
   return o ? o->memberName : 0;
}

char*
JVal_manageName(JVal* o)
{
   if(o)
   {
      char* ptr = o->memberName;
      o->memberName=0;
      return ptr;
   }
   return 0;
}

JVal*
JVal_getObject(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Object)
         return o->v.firstChild;
      JErr_setTypeErr(e, JVType_Object, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}

JVal*
JVal_getArray(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Array)
         return o->v.firstChild;
      JErr_setTypeErr(e, JVType_Array, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}


JVal*
JVal_getJ(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Array || o->type == JVType_Object)
         return o->v.firstChild;
      JErr_setTypeErr(e, JVType_Object, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}


JVal*
JVal_manageJ(JVal* o, JErr* e)
{
   if(o)
   {
      if(o->type == JVType_Array || o->type == JVType_Object)
      {
         JVal* handlersetup = o->v.firstChild;
         o->v.firstChild=0;
         return handlersetup;
      }
      JErr_setTypeErr(e, JVType_Object, o->type);
   }
   else
      JErr_setTooFewParams(e);
   return 0;
}


S32
JVal_getLength(struct JVal* o, JErr* e)
{
   o = JVal_getJ(o, e);
   if(o)
   {
         S32 len=1;
         while( (o = JVal_getNextElem(o)) != 0)
            len++;
         return len;
   }
   return 0; 
}


void
JVal_setX(JVal* o, JErr* e, JVType t, void* v)
{
  if(o->type == JVType_Array || o->type == JVType_Object)
  {
    JErr_setTypeErr(e, o->type, t);
    return;
  }
  if(o->type == JVType_String && o->v.s)
  {
    JErr_setError(e,JErrT_MemErr, "\112\126\141\154\072\072\163\145\164\130\040\163\164\162\151\156\147\040\155\165\163\164\040\142\145\040\155\141\156\141\147\145\144");
    return;
  }
  o->type = t;
  switch(t)
  {
         case JVType_String:
            o->v.s=(U8*)v;
            break;
         case JVType_Double:
#ifdef NO_DOUBLE
            o->v.l=*((S64*)v);
#else
            o->v.f=*((double*)v);
#endif
            break;
         case JVType_Int:
            o->v.d=*((S32*)v);
            break;
         case JVType_Long:
            o->v.l=*((S64*)v);
            break;
         case JVType_Boolean:
            o->v.b = *((BaBool*)v) ? TRUE : FALSE;
            break;
         case JVType_Null:
            break;
         default:
            baAssert(0);

   }
}


int
JVal_unlink(JVal* o, JVal* writeretired)
{
   if( (o->type == JVType_Object || o->type == JVType_Array) &&
       o->v.firstChild )
   {
      JVal* instructioncounter;
      if(writeretired == o->v.firstChild)
      {
         o->v.firstChild = writeretired->next;
         writeretired->next=0;
         return 0;
      }
      instructioncounter = o->v.firstChild;
      while(instructioncounter->next && instructioncounter->next != writeretired)
        instructioncounter = instructioncounter->next;
      if(instructioncounter->next)
      {
         instructioncounter->next = writeretired->next;
         writeretired->next=0;
         return 0;
      }
   }
   return -1;
}

static int
segmentnumber(JVal* o, JVal* writeretired)
{
   if(writeretired->next)
      return -1;
   writeretired->next=o->v.firstChild;
   o->v.firstChild=writeretired;
   return 0;
}


int
JVal_addMember(JVal* o, JErr* e, const char* resetcontrol,
               JVal* writeretired, AllocatorIntf* threadcleanup)
{
   if(JErr_noError(e))
   {
      if(o->type == JVType_Object)
      {
         if( ! writeretired->memberName )
         {
            writeretired->memberName =
               threadcleanup ? baStrdup2(threadcleanup, resetcontrol) : (char*)resetcontrol;
         }
         if(writeretired->memberName)
            return segmentnumber(o, writeretired);
         JErr_setError(e,JErrT_MemErr,0);
      }
      else
         JErr_setTypeErr(e, JVType_Int, o->type);
   }
   return -1;
}


int
JVal_add(JVal* o, JErr* e, JVal* writeretired)
{
   if(JErr_noError(e))
   {
      if(o->type == JVType_Array)
         return segmentnumber(o, writeretired);
      JErr_setTypeErr(e, JVType_Int, o->type);
   }
   return -1;
}


void
JVal_terminate(JVal* o, AllocatorIntf* scacherange, AllocatorIntf* threadcleanup)
{
   while(o)
   {
      JVal* prctlenable = o->next;
      if(o->type == JVType_Object || o->type == JVType_Array)
         JVal_terminate(o->v.firstChild, scacherange, threadcleanup);
      else if(o->type == JVType_String)
         AllocatorIntf_free(threadcleanup, o->v.s);
      if(o->memberName)
         AllocatorIntf_free(threadcleanup, o->memberName);
      AllocatorIntf_free(scacherange, o);
      o = prctlenable;
   }
}





static int
platformcreate(JParserValFact* o)
{
   size_t indexnospec = (o->vStackSize + 32) * sizeof(void*);
   JVal** v = o->vStack ?
      AllocatorIntf_realloc(o->dAlloc, o->vStack, &indexnospec) :
      AllocatorIntf_malloc(o->dAlloc, &indexnospec);
   if(v)
   {
      o->vStack = v;
      o->vStackSize=(int)(indexnospec/sizeof(void*));
      return 0;
   }
   o->status=JParserValFactStat_DMemErr;
   return -1;
}


static int
devicecfcon(JParserIntf* fdc37m81xconfig, JParserVal* pv, int classifysyscall)
{
   JVal* v;
   size_t jValSize = sizeof(JVal);
   JParserValFact* o = (JParserValFact*)fdc37m81xconfig; 
   if(pv->t == JParserT_EndObject || pv->t == JParserT_EndArray)
      return 0; 
   if(++o->nodeCounter >= o->maxNodes)
   {
      o->status=JParserValFactStat_MaxNodes;
      return -1;
   }
   if(classifysyscall >= o->vStackSize && platformcreate(o))
      return -1;
   if( (v = AllocatorIntf_malloc(o->vAlloc, &jValSize)) == 0 )
   {
      o->status=JParserValFactStat_VMemErr;
      return -1;
   }
   if(pcimtsetup(v, classifysyscall ? o->vStack[classifysyscall-1] : 0, pv, o->dAlloc))
   {
      o->status=JParserValFactStat_VMemErr;
      AllocatorIntf_free(o->vAlloc, v);
      return -1;
   }
   if(pv->t == JParserT_BeginObject || pv->t == JParserT_BeginArray)
      o->vStack[classifysyscall] = v;
   return 0;
}


void
JParserValFact_constructor(
   JParserValFact* o, AllocatorIntf* scacherange, AllocatorIntf* threadcleanup)
{
   memset(o, 0, sizeof(JParserValFact));
   o->vAlloc=scacherange;
   o->dAlloc=threadcleanup;
   JParserIntf_constructor((JParserIntf*)o, devicecfcon);
   o->maxNodes=~(U32)0;
}


JVal*
JParserValFact_manageFirstVal(JParserValFact* o)
{
   if(o->vStack && *o->vStack)
   {
      JVal* v = *o->vStack;
      *o->vStack = 0;
      o->nodeCounter=0;
      return v;
   }
   return 0;
}


void
JParserValFact_termFirstVal(JParserValFact* o)
{
   if(o->vStack)
   {
      if(o->vStack)
      {
         JVal_terminate(*o->vStack, o->vAlloc, o->dAlloc);
         *o->vStack=0;
         o->nodeCounter=0;
      }
      AllocatorIntf_free(o->dAlloc, o->vStack);
      o->vStack=0;
      o->vStackSize=0;
   }
}


void
JParserValFact_destructor(JParserValFact* o)
{
   JParserValFact_termFirstVal(o);
}





void
JValFact_constructor(JValFact* o, AllocatorIntf* scacherange, AllocatorIntf* threadcleanup)
{
   memset(o, 0, sizeof(JValFact));
   o->vAlloc=scacherange;
   o->dAlloc=threadcleanup;
}


JVal*
JValFact_mkVal(JValFact* o, JVType t, const void* uv)
{
   size_t icachealiases=sizeof(JVal);
   JVal* v = (JVal*)AllocatorIntf_malloc(o->vAlloc,&icachealiases);
   if(v)
   {
      memset(v,0,sizeof(JVal));
      v->type = t;
      switch(t)
      {
         case JVType_String:
            v->v.s=(U8*)baStrdup2(o->dAlloc, (const char*)uv);
            if(!v->v.s)
               t = JVType_InvalidType;
            break;
         case JVType_Double:
#ifdef NO_DOUBLE
            v->v.l=*((S64*)uv);
#else
            v->v.f=*((double*)uv);
#endif
            break;
         case JVType_Int:
            v->v.d=*((S32*)uv);
            break;
         case JVType_Long:
            v->v.l=*((S64*)uv);
            break;
         case JVType_Boolean:
            v->v.b = *((BaBool*)uv) ? TRUE : FALSE;
            break;
         case JVType_Null:
         case JVType_Object:
         case JVType_Array:
            break;
         default:
            baAssert(0);
            t = JVType_InvalidType;
      }
      if(t != JVType_InvalidType)
         return v;
      AllocatorIntf_free(o->vAlloc, v);
   }
   return 0;
}
#ifndef NO_SHARKSSL


#ifndef BA_LIB
#define BA_LIB
#endif

#include <SharkSslASN1.h>


#include <string.h>


#if (SHARKSSL_ENABLE_CSR_CREATION || SHARKSSL_ENABLE_CSR_SIGNING || SHARKSSL_ENABLE_ASN1_KEY_CREATION)
static int pandoralegacy(SharkSslASN1Create *o, SharkSslCertKey *disableclock, int sha256export)
{
   #if SHARKSSL_USE_ECC
   int persistentclock;
   #endif
   int sffsdrnandflash;
   U8 *timerdying;
   U8 *ref = o->ptr;

   #if SHARKSSL_USE_ECC
   if (machinereboot(disableclock->expLen))
   {
      persistentclock = attachdevice(disableclock->modLen) * 2;
      if(SharkSslASN1Create_raw(o, disableclock->mod, persistentclock) || ((o->ptr - o->start) < 4))
      {
         return -1;
      }
      *--o->ptr = SHARKSSL_EC_POINT_UNCOMPRESSED;
      *--o->ptr = 0x00;
      if (SharkSslASN1Create_length(o, persistentclock + 2) || SharkSslASN1Create_bitString(o))
      {
         return -1;
      }
      
      #if SHARKSSL_ENABLE_ASN1_KEY_CREATION
      if (sha256export)
      {
         if (SharkSslASN1Create_length(o, (int)(ref - o->ptr)) || SharkSslASN1Create_ECPublicKey(o))
         {
            return -1;
         }
      }
      #else
      (void)sha256export;  
      #endif

      timerdying = o->ptr;
      
      switch (wakeupenable(disableclock->modLen))
      {
         #if SHARKSSL_ECC_USE_SECP521R1
         case SHARKSSL_EC_CURVE_ID_SECP521R1:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(secp521r1));
            break;
         #endif

         #if SHARKSSL_ECC_USE_SECP384R1
         case SHARKSSL_EC_CURVE_ID_SECP384R1:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(secp384r1));
            break;
         #endif

         #if SHARKSSL_ECC_USE_SECP256R1
         case SHARKSSL_EC_CURVE_ID_SECP256R1:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(prime256v1));
            break;
         #endif

         #if SHARKSSL_ECC_USE_BRAINPOOLP512R1
         case SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(brainpoolP512r1));
            break;
         #endif

         #if SHARKSSL_ECC_USE_BRAINPOOLP384R1
         case SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(brainpoolP384r1));
            break;
         #endif

         #if SHARKSSL_ECC_USE_BRAINPOOLP256R1
         case SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(brainpoolP256r1));
            break;
         #endif

         default:
            sffsdrnandflash = -1;
            break;
      }

      #if SHARKSSL_ENABLE_ASN1_KEY_CREATION
      if (sha256export)
      {
         return (SharkSslASN1Create_length(o, (int)(timerdying - o->ptr)) || SharkSslASN1Create_ECParameters(o));
      }
      #endif

      if (!sffsdrnandflash)
      {
         sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(ecPublicKey));
      }
   }
   #if SHARKSSL_ENABLE_RSA
   else
   #endif
   #endif
   #if SHARKSSL_ENABLE_RSA
   if (machinekexec(disableclock->expLen))
   {
      sffsdrnandflash = SharkSslASN1Create_int(o, disableclock->exp, mousethresh(disableclock->expLen)) ||
         SharkSslASN1Create_int(o, disableclock->mod, supportedvector(disableclock->modLen)) ||
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_sequence(o);

      if (!sffsdrnandflash)
      {
         *--o->ptr = 0x00;
         sffsdrnandflash = SharkSslASN1Create_length(o, (int)(ref - o->ptr)) || SharkSslASN1Create_bitString(o);
      }
      
      timerdying = o->ptr;
      if (!sffsdrnandflash)
      {
         *--o->ptr = 0;
         *--o->ptr = SHARKSSL_ASN1_NULL;

         sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(rsaEncryption));
      }
   }
   #endif
   else
   {
     return -1;
   }

   return sffsdrnandflash ||
      SharkSslASN1Create_length(o, (int)(timerdying - o->ptr)) ||
      SharkSslASN1Create_sequence(o) ||
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_sequence(o);
}
#endif


#if (SHARKSSL_ENABLE_CSR_CREATION || SHARKSSL_ENABLE_CSR_SIGNING)
static int gpiokeysdevice(SharkSslASN1Create *o, SharkSslCertDN *panelshutdown)
{
   int sffsdrnandflash = 0;
   U8 *ref = o->ptr;

   if (panelshutdown->emailAddress && !sffsdrnandflash)
   {
      sffsdrnandflash = SharkSslASN1Create_email(o, sharkssl_oid_ex(emailAddress), panelshutdown->emailAddress, panelshutdown->emailAddressLen);
   }
   if (panelshutdown->countryName && !sffsdrnandflash)
   {
      sffsdrnandflash = SharkSslASN1Create_name(o, sharkssl_oid_ex(country), panelshutdown->countryName, panelshutdown->countryNameLen);
   }
   if (panelshutdown->province && !sffsdrnandflash)
   {
      sffsdrnandflash = SharkSslASN1Create_name(o, sharkssl_oid_ex(province), panelshutdown->province, panelshutdown->provinceLen);
   }
   if (panelshutdown->locality && !sffsdrnandflash)
   {
      sffsdrnandflash = SharkSslASN1Create_name(o, sharkssl_oid_ex(locality), panelshutdown->locality, panelshutdown->localityLen);
   }
   if (panelshutdown->unit && !sffsdrnandflash)
   {
      sffsdrnandflash = SharkSslASN1Create_name(o, sharkssl_oid_ex(unit), panelshutdown->unit, panelshutdown->unitLen);
   }
   if (panelshutdown->organization && !sffsdrnandflash)
   {
      sffsdrnandflash = SharkSslASN1Create_name(o, sharkssl_oid_ex(organization), panelshutdown->organization, panelshutdown->organizationLen);
   }
   if (panelshutdown->commonName && !sffsdrnandflash)
   {
      sffsdrnandflash = SharkSslASN1Create_name(o, sharkssl_oid_ex(CN), panelshutdown->commonName, panelshutdown->commonNameLen);
   }
   return sffsdrnandflash ||
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_sequence(o);
}


static int removedomain(SharkSslASN1Create *o, const char *verbosemcheck)
{
   U8 rightsvalid;
   U16 len = (U16)strlen(verbosemcheck);

   if (len < 14)
   {
      return -1;
   }

   SharkSslASN1Create_raw(o, "\132", 1);
   if (('\062' == verbosemcheck[0]) && ('\060' == verbosemcheck[1]) && ('\065' > verbosemcheck[2]))  
   {
      if (len != 14)
      {
         return -1;
      }
      len -= 2;
      verbosemcheck += 2;
      rightsvalid = SHARKSSL_ASN1_UTC_TIME;
   }
   else
   {
      if (len < 14)
      {
         return -1;
      }
      rightsvalid = SHARKSSL_ASN1_GENERALIZED_TIME;
   }

   return
      SharkSslASN1Create_raw(o, verbosemcheck, len) ||
      SharkSslASN1Create_length(o, len + 1) ||
      SharkSslASN1Create_tag(o, rightsvalid);
}


static int stage2idmap(SharkSslASN1Create *o,
                                      SharkSslCertKey *configcheck,
                                      U8 configwrite)
{
   int sffsdrnandflash = 0;
   U8 *ref = o->ptr;

   #if SHARKSSL_USE_ECC
   if (machinereboot(configcheck->expLen))
   {
      switch (configwrite)
      {
         #if SHARKSSL_USE_SHA_512
         case SHARKSSL_HASHID_SHA512:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(ecdsaWithSHA512));
            break;
         #endif
      
         #if SHARKSSL_USE_SHA_384
         case SHARKSSL_HASHID_SHA384:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(ecdsaWithSHA384));
            break;
         #endif

         default:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(ecdsaWithSHA256));
            break;
      }
   }
   #if SHARKSSL_ENABLE_RSA
   else
   #endif
   #endif
   #if SHARKSSL_ENABLE_RSA
   if (machinekexec(configcheck->expLen))
   {
      switch (configwrite)
      {
         #if SHARKSSL_USE_SHA_512
         case SHARKSSL_HASHID_SHA512:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(sha512withRSAEncryption));
            break;
         #endif
      
         #if SHARKSSL_USE_SHA_384
         case SHARKSSL_HASHID_SHA384:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(sha384withRSAEncryption));
            break;
         #endif

         default:
            sffsdrnandflash = SharkSslASN1Create_oid(o, sharkssl_oid_ex(sha256withRSAEncryption));
            break;
      }
   }
   #endif

   return sffsdrnandflash ||
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_sequence(o);
}



static int devicewm8750(SharkSslASN1Create *o,
                                  SharkSslCertKey *configcheck,
                                  U8 *cachesysfs,
                                  U8 *end,
                                  U8 configwrite)
{
   SharkSslSignParam signParam;
   U16 probealchemy;
   
   baAssert(end >= cachesysfs);
   #if SHARKSSL_USE_ECC
   if (machinereboot(configcheck->expLen))
   {
      probealchemy = relocationchain(configcheck);
      signParam.signature.signatureAlgo = accessactive;
   }
   #if SHARKSSL_ENABLE_RSA
   else
   #endif
   #endif
   #if SHARKSSL_ENABLE_RSA
   if (machinekexec(configcheck->expLen))
   {
      probealchemy = supportedvector(configcheck->modLen);
      signParam.signature.signatureAlgo = entryearly;
   }
   #endif
   else
   {
      return -1;
   }

   if((o->ptr - o->start) < (probealchemy + 8))
   {
      return -1;
   }

   o->ptr -= probealchemy;
   
   if (cachesysfs)
   {
      sharkssl_hash(signParam.signature.hash, cachesysfs, (U16)(end - cachesysfs), configwrite);
      signParam.pCertKey = configcheck;
      signParam.signature.hashAlgo = configwrite;
      signParam.signature.signature = o->ptr;
      if ((checkactions(&signParam)) || (probealchemy < signParam.signature.signLen))
      {
         return -1;
      }
      #if SHARKSSL_USE_ECC
      if (accessactive == signParam.signature.signatureAlgo)
      {
         if (probealchemy > signParam.signature.signLen)
         {
            o->ptr--;  
            SharkSslASN1Create_length(o, signParam.signature.signLen + 1);  
            o->end -= (probealchemy - signParam.signature.signLen);
         }
      }
      #endif
      return 0;
   }

   *--o->ptr = 0;  
   probealchemy++;

   return SharkSslASN1Create_length(o, probealchemy) ||
          SharkSslASN1Create_bitString(o) ||
          stage2idmap(o, configcheck, configwrite);
}
#endif


#if SHARKSSL_ENABLE_CSR_CREATION 
static int subpacketannotation(SharkSslASN1Create *o,
                                    const char *SAN,
                                    int alignstack,
                                    const U8 *oid,
                                    int fieldvalue)
{
   if (SAN)
   {
      int sffsdrnandflash = 0;
      int allockuser;
      U8 *ref = o->ptr;
      char *probecache;
      
	   if(((o->ptr - o->start) < alignstack) || (alignstack > 0xFF))
      {
         return -1;
      }

      while ((alignstack > 0) && (!sffsdrnandflash))
      {
         #define SHARKSSL_SAN_SEPARATOR_CHAR '\073'
         probecache = (char*)memchr(SAN, SHARKSSL_SAN_SEPARATOR_CHAR, alignstack);
         if (NULL == probecache)
         {
            allockuser = alignstack;
            alignstack = 0;
         }
         else
         {
            allockuser = (int)(probecache - SAN);
            alignstack -= allockuser;
            alignstack--;
         }
         if (allockuser > 0)
         {
            U8 aborthandler = SUBJECTALTNAME_DNSNAME;
            if ((allockuser >= 3) && (!memcmp(SAN, "\111\120\072", 3)))  
            {
               U8 gpio27enable[4], i;
               aborthandler = SUBJECTALTNAME_IPADDRESS;
               allockuser -= 3;
               SAN += 3;

               
               memset(gpio27enable, 0, sizeof(gpio27enable));
               i = 0;
               while (allockuser > 0)
               {
                  if ((*SAN > '\071') || (*SAN < '\060') || (gpio27enable[i] > (0xFF/10))) 
                  {
                     SAN += allockuser;  
                     i = 0;
                     break;
                  }
                  gpio27enable[i] *= 10;
                  gpio27enable[i] += (*SAN - '\060');
                  SAN++;
                  allockuser--;
                  if ((allockuser > 0) && (i < 3) && ('\056' == *SAN))
                  {
                     i++;
                     SAN++;
                     allockuser--;
                  }
               }
               if (3 == i)
               {
                  o->ptr -= 4;   
                  memcpy(o->ptr, gpio27enable, 4);
                  allockuser = 4;
               }
               else
               {
                  aborthandler = 0;
               }
            }
            else
            {
               if ((allockuser >= 4) && (!memcmp(SAN, "\125\122\111\072", 4)))  
               {
                  aborthandler = SUBJECTALTNAME_URI;
                  SAN += 4;
                  allockuser -= 4;
               }
               o->ptr -= allockuser;
	            memcpy(o->ptr, SAN, allockuser);
               SAN += allockuser;  
            }

            if (aborthandler)
            {
               sffsdrnandflash = SharkSslASN1Create_length(o, allockuser) || 
                  SharkSslASN1Create_tag(o, SHARKSSL_ASN1_CONTEXT_SPECIFIC | aborthandler);
            }
         }
         SAN++;  
      }

      if (!sffsdrnandflash)
      {
         sffsdrnandflash = SharkSslASN1Create_length(o, (int)(ref - o->ptr)) || 
            SharkSslASN1Create_sequence(o);
      }

      if (!sffsdrnandflash)
      {
         sffsdrnandflash = SharkSslASN1Create_length(o, (int)(ref - o->ptr)) || 
            SharkSslASN1Create_octetString(o);
      }
	  
      return sffsdrnandflash ||
         SharkSslASN1Create_oid(o, oid, fieldvalue) ||
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_sequence(o);
   }

   return -1;
}


static int eventinterruptible(SharkSslASN1Create *o,
                                       SharkSslBitExtReq *ext,
                                       int enablekernel,
                                       const U8 *oid,
                                       int fieldvalue)
{
   if(ext)
   {
      U8 *ref = o->ptr;
      if((o->ptr - o->start) < 8 || (enablekernel > 8))
      {
         return -1;
      }
      *--o->ptr = (U8)ext->bits; 
      *--o->ptr = (U8)(8 - enablekernel); 
      *--o->ptr = 2; 
      SharkSslASN1Create_bitString(o);
      *--o->ptr = 4; 
      SharkSslASN1Create_octetString(o);
      return SharkSslASN1Create_oid(o, oid, fieldvalue) ||
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_sequence(o);
   }
   return 0;
}


SHARKSSL_API int
SharkSslASN1Create_CSR(SharkSslASN1Create *o,
                       SharkSslKey mcbspplatform,
                       U8 configwrite,
                       SharkSslCertDN *devicetable,
                       const char *SAN,
                       SharkSslBitExtReq *latchcontrol,
                       SharkSslBitExtReq *setupcalled)
{
   SharkSslCertKey disableclock;
   U8 *ref, *end;
   int sffsdrnandflash;

   if (!interrupthandler(&disableclock, mcbspplatform))
   {
      return -1;
   }

   
   devicewm8750(o, &disableclock, 0, 0, configwrite);
   end = o->ptr;  

   
   ref = o->ptr;
   sffsdrnandflash =
      eventinterruptible(o, setupcalled, 8, sharkssl_oid_ex(ns_cert_type)) ||
      eventinterruptible(o, latchcontrol, 7, sharkssl_oid_ex(key_usage)) ||
	   (SAN ? subpacketannotation(o, SAN, (int)strlen(SAN), sharkssl_oid_ex(san)) : 0);
   if( (latchcontrol || setupcalled || SAN) && !sffsdrnandflash )
   {
      sffsdrnandflash = 
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_sequence(o) ||
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_set(o) ||
         SharkSslASN1Create_oid(o, sharkssl_oid_ex(csr_ext_req)) ||
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_sequence(o) ||
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_CSRAttributes(o);
   }
   

   if( !sffsdrnandflash )
   {
      static const U8 ts409button[1] = {0};
      sffsdrnandflash =
         pandoralegacy(o, &disableclock, 0) ||
         gpiokeysdevice(o, devicetable) ||
         SharkSslASN1Create_int(o, (U8*)ts409button, 1) || 
         SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
         SharkSslASN1Create_sequence(o);
   }

   if( !sffsdrnandflash )
   {
      ref = o->ptr;  
      o->ptr = o->end;
      devicewm8750(o, &disableclock, ref, end, configwrite);
      o->ptr = ref;
      return 
         SharkSslASN1Create_length(o, (int)(o->end - o->ptr)) ||
         SharkSslASN1Create_sequence(o);
   }
   return sffsdrnandflash;
}
#endif


#if SHARKSSL_ENABLE_CSR_SIGNING
static int pxa320evalboard(U8 *allocbuffer, U8 *tableprint, int emac0hwmod, int bypassvalue)
{
   while (emac0hwmod > bypassvalue)
   {
      if (0 != *allocbuffer)
      {
         return -1;
      }
      allocbuffer++;
      emac0hwmod--;
   }
   while (bypassvalue > emac0hwmod)
   {
      if (0 != *tableprint)
      {
         return -1;
      }
      tableprint++;
      bypassvalue--;
   }
   return sharkssl_kmemcmp(allocbuffer, tableprint, emac0hwmod);
}


SHARKSSL_API int
SharkSslCert_signCSR(SharkSslCert *unlockirqrestore,
                     const U8 *asyncexport,
                     int preservecurrent,
                     const SharkSslCert userspacememory,
                     const SharkSslKey mcbspplatform,
                     const char *searchbitmap,
                     const char *setupmodel,
                     SharkCertSerialNumber flushwalker,
                     U8 configwrite)
{
   U8 *ref, *end;
   U8 *extPtr, *issuerPtr;
   U16 inputdevice;
   U32 cachelmiss;
   SharkSslCertParam certParam;
   SharkSslCertKey privKeyInfo, caKeyInfo;
   SharkSslASN1Create fixupconfig;
   int l, v, sffsdrnandflash;
   static const U8 switcherattrs[1] = {2};

   inputdevice = 0;
   issuerPtr = NULL;
   *unlockirqrestore = NULL;
   if ((U32)preservecurrent > 0x7FFF)
   {
      return -1;
   }
   cachelmiss = (U16)preservecurrent;
   if (((sffsdrnandflash = spromregister(&certParam, asyncexport, (U32)-4, (U8*)&cachelmiss)) < 0) || (0 == (cachelmiss & 0xFFFF)))
   {
      return -1;
   }
   extPtr = (U8*)asyncexport + sffsdrnandflash;

   if (!interrupthandler(&privKeyInfo, mcbspplatform))
   {
      if (NULL != mcbspplatform)
      {
         return -1;
      }
   }

   #if (!SHARKSSL_DISABLE_CSR_VERIFYSIGNATURE)  
   if (NULL != mcbspplatform)
   {
      SharkSslSignParam signParam;
      U8 *signaldeliver;

      
      signaldeliver = (U8*)baMalloc(certParam.signature.signLen);
      if (NULL == signaldeliver)
      {
         return -1;  
      }
      memcpy(&(signParam.signature), &(certParam.signature), sizeof (signParam.signature));
      memcpy(signaldeliver, signParam.signature.signature, signParam.signature.signLen);
      signParam.signature.signature = signaldeliver;
      signParam.pCertKey = &privKeyInfo;
      l = systemcapabilities(&signParam);
      baFree(signaldeliver);
      if (l != 0)
      {
         return -1;  
      }
   }
   #endif

   if (NULL == userspacememory)  
   {
      if (NULL == mcbspplatform)
      {
         return -1;  
      }
      
      #if SHARKSSL_USE_ECC
      if (machinereboot(privKeyInfo.expLen))
      {
         if ((!(machinereboot(certParam.certKey.expLen))) ||
             (wakeupenable(privKeyInfo.modLen) != 
              wakeupenable(certParam.certKey.modLen)))
         {
            return -3;  
         }
         if (pxa320evalboard(privKeyInfo.mod, 
                                      certParam.certKey.mod,
                                      attachdevice(privKeyInfo.modLen),
                                      attachdevice(certParam.certKey.modLen)))
         {
            return -3;
         }
      }
      else
      #endif
      #if SHARKSSL_ENABLE_RSA
      if (machinekexec(privKeyInfo.expLen))
      {
         if (!(machinekexec(certParam.certKey.expLen)))
         {
            return -3;  
         }
         if (pxa320evalboard(privKeyInfo.exp, 
                                      certParam.certKey.exp,
                                      mousethresh(privKeyInfo.expLen),
                                      mousethresh(certParam.certKey.expLen)))
         {
            return -3;
         }
         if (pxa320evalboard(privKeyInfo.mod, 
                                      certParam.certKey.mod,
                                      supportedvector(privKeyInfo.modLen),
                                      supportedvector(certParam.certKey.modLen)))
         {
            return -3;
         }
      }
      else
      #endif
      {
         return -3;  
      }

      
      memcpy(&caKeyInfo, &privKeyInfo, sizeof caKeyInfo);
   }
   else  
   {
      
      if ((sffsdrnandflash = spromregister(0, (U8*)userspacememory, (U32)-2, (U8*)&inputdevice)) < 0)
      {
         return -1;
      }
      issuerPtr = (U8*)userspacememory + sffsdrnandflash;
      
      if (!interrupthandler(&caKeyInfo, userspacememory))
      {
         return -1;
      }
   }

   
   sffsdrnandflash = (U16)(cachelmiss >> 16);  
   if (0 == inputdevice)
   {
      sffsdrnandflash <<= 1;  
   }
   else
   {
      sffsdrnandflash += inputdevice;
   }
   sffsdrnandflash += 120;
   sffsdrnandflash += (U16)(cachelmiss & 0xFFFF);
   sffsdrnandflash += sizeof(flushwalker);

   v = 4;
   if (NULL != mcbspplatform)
   {
      v += mousethresh(privKeyInfo.expLen);
      #if SHARKSSL_ENABLE_RSA
      if (machinekexec(privKeyInfo.expLen))
      {
         v += supportedvector(privKeyInfo.modLen);
         v += ((supportedvector(privKeyInfo.modLen) / 2) * 5);  
      }
      else
      #endif
      #if SHARKSSL_USE_ECC
      if (machinereboot(privKeyInfo.expLen))
      {
         v += (U16)(2 * attachdevice(privKeyInfo.modLen));  
      }
      else
      #endif
      {
         return -1;
      }
   }

   
   #if SHARKSSL_ENABLE_RSA
   if (machinekexec(caKeyInfo.expLen))
   {
      sffsdrnandflash += 8;
      sffsdrnandflash += 2 * supportedvector(caKeyInfo.modLen);
      sffsdrnandflash += mousethresh(caKeyInfo.expLen);
   }
   else
   #endif
   #if SHARKSSL_USE_ECC
   if (machinereboot(caKeyInfo.expLen))
   {
      sffsdrnandflash += (U16)(2 * attachdevice(caKeyInfo.modLen));
      sffsdrnandflash += relocationchain(&caKeyInfo);
   }
   else
   #endif
   {
      return -1;
   }

   l = ((((sffsdrnandflash + 0x3) & ~0x3) + v) + 0x7
       + 20   
       ) & ~0x7;

   *unlockirqrestore = (U8*)baMalloc(l);
   if (NULL == *unlockirqrestore)
   {
      return -1;
   }
   SharkSslASN1Create_constructor(&fixupconfig, (U8*)*unlockirqrestore, l);

   
   devicewm8750(&fixupconfig, &caKeyInfo, 0, 0, configwrite);
   end = fixupconfig.ptr;  

   
   ref = fixupconfig.ptr;
   sffsdrnandflash = SharkSslASN1Create_raw(&fixupconfig, extPtr, (U16)(cachelmiss & 0xFFFF));

   
   if (( !sffsdrnandflash ) && (NULL == userspacememory))  
   {
      extPtr = fixupconfig.ptr;   
      sffsdrnandflash = SharkSslASN1Create_boolean(&fixupconfig, 1);
      if ( !sffsdrnandflash )
      {
         sffsdrnandflash = 
            SharkSslASN1Create_length(&fixupconfig, (int)(extPtr - fixupconfig.ptr)) ||
            SharkSslASN1Create_sequence(&fixupconfig) ||
            SharkSslASN1Create_length(&fixupconfig, (int)(extPtr - fixupconfig.ptr)) ||
            SharkSslASN1Create_octetString(&fixupconfig) ||
            SharkSslASN1Create_boolean(&fixupconfig, 1) ||
            SharkSslASN1Create_oid(&fixupconfig, sharkssl_oid_ex(basic_constraints)) ||
            SharkSslASN1Create_length(&fixupconfig, (int)(extPtr - fixupconfig.ptr)) ||
            SharkSslASN1Create_sequence(&fixupconfig);
      }
   }

   if ( !sffsdrnandflash )
   {
      sffsdrnandflash = 
         SharkSslASN1Create_length(&fixupconfig, (int)(ref - fixupconfig.ptr)) ||
         SharkSslASN1Create_sequence(&fixupconfig) || 
         SharkSslASN1Create_length(&fixupconfig, (int)(ref - fixupconfig.ptr)) ||
         SharkSslASN1Create_extensions(&fixupconfig);
   }
   

   if ( !sffsdrnandflash )
   {
      sffsdrnandflash = pandoralegacy(&fixupconfig, &(certParam.certKey), 0);
   }

   if ( !sffsdrnandflash )
   {
      extPtr = fixupconfig.ptr;
      sffsdrnandflash = gpiokeysdevice(&fixupconfig, &(certParam.certInfo.subject));
      if (NULL == issuerPtr)
      {
         issuerPtr = fixupconfig.ptr;
         inputdevice = (U16)(extPtr - fixupconfig.ptr);
      }
   }

   if ( !sffsdrnandflash )
   {
      extPtr = fixupconfig.ptr;
      sffsdrnandflash = removedomain(&fixupconfig, setupmodel) || removedomain(&fixupconfig, searchbitmap);
   }

   if ( !sffsdrnandflash )
   {
      sharkCertSerialNumber2NetworkEndian(flushwalker);
      sffsdrnandflash = 
         SharkSslASN1Create_length(&fixupconfig, (int)(extPtr - fixupconfig.ptr)) ||
         SharkSslASN1Create_sequence(&fixupconfig) ||
         SharkSslASN1Create_raw(&fixupconfig, issuerPtr, inputdevice) ||
         stage2idmap(&fixupconfig, &caKeyInfo, configwrite) ||
         SharkSslASN1Create_int(&fixupconfig, (U8*)&flushwalker, sizeof(flushwalker));
   } 

   if ( !sffsdrnandflash )
   {
      extPtr = fixupconfig.ptr;
      sffsdrnandflash = SharkSslASN1Create_int(&fixupconfig, (U8*)switcherattrs, 1) || 
         SharkSslASN1Create_length(&fixupconfig, (int)(extPtr - fixupconfig.ptr)) ||
         SharkSslASN1Create_version(&fixupconfig) ||
         SharkSslASN1Create_length(&fixupconfig, (int)(ref - fixupconfig.ptr)) ||
         SharkSslASN1Create_sequence(&fixupconfig);
   }

   if ( !sffsdrnandflash )
   {
      ref = fixupconfig.ptr;  
      fixupconfig.ptr = fixupconfig.end;
      devicewm8750(&fixupconfig, &caKeyInfo, ref, end, configwrite);
      fixupconfig.ptr = ref;
      sffsdrnandflash = 
         SharkSslASN1Create_length(&fixupconfig, (int)(fixupconfig.end - fixupconfig.ptr)) ||
         SharkSslASN1Create_sequence(&fixupconfig);
   }
   

   if ( !sffsdrnandflash )
   {
      sffsdrnandflash = SharkSslASN1Create_getDataLen(&fixupconfig, &extPtr);
      memmove((U8*)*unlockirqrestore, extPtr, sffsdrnandflash);
      extPtr = (U8*)*unlockirqrestore + sffsdrnandflash;
      while (sffsdrnandflash & 0x03)  
      {
         *extPtr++ = 0xFF;
         sffsdrnandflash++;
      }
      if (NULL == mcbspplatform)
      {
         baAssert(4 == v);
         memset(extPtr, 0, v);
      }
      else
      {
         memcpy(extPtr, mcbspplatform + 4, v);
      }
      extPtr += v;
      sffsdrnandflash += v;
      while (sffsdrnandflash & 0x07)  
      {
         *extPtr++ = 0xFF;
         sffsdrnandflash++;
      }
      if (sffsdrnandflash > l)
      {
         sffsdrnandflash = -4;  
         goto _sharkssl_signCSR_err;
      }
      memset(extPtr, 0, (l - sffsdrnandflash));
   }
   else
   {
      _sharkssl_signCSR_err:
      baFree((void*)*unlockirqrestore);
      *unlockirqrestore = NULL;
   }

   return sffsdrnandflash;
}
#endif


#if SHARKSSL_ENABLE_ASN1_KEY_CREATION
SHARKSSL_API int
SharkSslASN1Create_key(SharkSslASN1Create *o, const SharkSslKey sourcerouting)
{
   SharkSslCertKey keyInfo;
   int sffsdrnandflash;
   U8 *ref = o->ptr;
   
   if (!interrupthandler(&keyInfo, sourcerouting))
   {
      return -1;
   }

   if (coupledexynos(keyInfo.expLen))
   {
      return -2;  
   }

   #if SHARKSSL_USE_ECC
   if (machinereboot(keyInfo.expLen))
   {
      static const U8 rendezcheckin[1] = {1};
      
      sffsdrnandflash = pandoralegacy(o, &keyInfo, 1) ||
         SharkSslASN1Create_raw(o, keyInfo.exp, mousethresh(keyInfo.expLen)) ||
         SharkSslASN1Create_length(o, mousethresh(keyInfo.expLen)) ||
         SharkSslASN1Create_octetString(o);

      if ( !sffsdrnandflash )
      {
         sffsdrnandflash = 
            SharkSslASN1Create_int(o, (U8*)rendezcheckin, 1) || 
            SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
            SharkSslASN1Create_sequence(o);
      }
   }
   else
   #endif
   #if SHARKSSL_ENABLE_RSA
   if (machinekexec(keyInfo.expLen))
   {
      U8 *p1, *brightnesslimit;
      shtype_t e, m, d, pq, oi;
      U16 le, li, lih, i;
      static const U8 ts409button[1] = {0};
      static const shtype_tWord intOneW = 1;
      
      le = mousethresh(keyInfo.expLen);
      li = supportedvector(keyInfo.modLen);
      lih = li >> 1;
      baAssert(li < 0xFFFF);
      brightnesslimit = (U8*)baMalloc((le * 2) + (li * 4));
      if (brightnesslimit == NULL)
      {
         return -3;  
      }
      
      memmove_endianess(brightnesslimit, keyInfo.exp, le);  
      memmove_endianess(brightnesslimit + le + le + li, keyInfo.mod, li + li);  
      onenandpartitions(&e, (le * 8), brightnesslimit);
      onenandpartitions(&d, ((li + le) * 8), (brightnesslimit + le));
      onenandpartitions(&m, (li * 8), (brightnesslimit + le + le + li));
      onenandpartitions(&pq, (lih * 8), (brightnesslimit + le + le + li + li + lih));  
      traceaddress(&oi, 1, ((U8*)(&intOneW)));
      updatepmull(&m, &pq);  
      onenandpartitions(&pq, (lih * 8), (brightnesslimit + le + le + li + li));  
      updatepmull(&m, &pq);  
      resolverelocs(&m, &oi); 
      memmove_endianess(brightnesslimit + le + le + li + li, keyInfo.mod + li + li, li);  
      onenandpartitions(&oi, (li * 8), (brightnesslimit + le + le + li + li + li)); 
      hotplugpgtable(&e, &pq, &oi);
      onenandpartitions(&pq, (lih * 8), (brightnesslimit + le + le + li + li + lih));  
      hotplugpgtable(&oi, &pq, &d);
      suspendfinish(&d, &m);
      onenandpartitions(&oi, (li * 8), (brightnesslimit + le + le + li + li + li)); 
      unassignedvector(&m, &oi);
      keypaddevice(&oi, &d, &m);
      setupsdhci1(&oi, &pq, &m);  
      onenandpartitions(&pq, (lih * 8), (brightnesslimit + le + le + li + li));  
      setupsdhci1(&oi, &pq, &m);  
      
      p1 = &keyInfo.mod[(li << 1) + li];
      sffsdrnandflash = 0;
      for (i = 0; ((i < 5) && ( !sffsdrnandflash )); i++, p1 -= lih)
      {
         sffsdrnandflash = SharkSslASN1Create_int(o, p1, lih);
      }
      if ( !sffsdrnandflash )
      {
         memmove_endianess(brightnesslimit, (U8*)consoledevice(&oi), li);
         sffsdrnandflash = SharkSslASN1Create_int(o, brightnesslimit, li);  
      }
      if ( !sffsdrnandflash )
      {
         sffsdrnandflash = SharkSslASN1Create_int(o, keyInfo.exp, le);
      }
      if ( !sffsdrnandflash )
      {
         sffsdrnandflash = SharkSslASN1Create_int(o, keyInfo.mod, li);
      }
      if ( !sffsdrnandflash )
      {
         sffsdrnandflash = 
            SharkSslASN1Create_int(o, (U8*)ts409button, 1) || 
            SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
            SharkSslASN1Create_sequence(o);
      }
      baFree(brightnesslimit);
   }
   else
   #endif
   {
      return -1;  
   }

   return sffsdrnandflash;
}
#endif


#ifndef BA_LIB
#define BA_LIB
#endif
#include "SharkSslASN1.h"
#include <string.h>


#if (((SHARKSSL_SSL_CLIENT_CODE || SHARKSSL_SSL_SERVER_CODE) && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)) ||  \
     (SHARKSSL_ENABLE_CERTSTORE_API) || (SHARKSSL_ENABLE_PEM_API) || \
     (SHARKSSL_ENABLE_CSR_CREATION) || (SHARKSSL_ENABLE_CSR_SIGNING) || \
     (SHARKSSL_USE_ECC && SHARKSSL_ENABLE_ECDSA && SHARKSSL_ENABLE_ECDSA_API))

int SharkSslParseASN1_getLength(SharkSslParseASN1 *o)
{
   int len;

   if (o->len < 1)
   {
      return -1;
   }

   len = *(o->ptr);

   o->len--;
   o->ptr++;

   if (len & 0x80)
   {
      U32 spi4000initialize = 0;

      len &= 0x7F;
      
      if (len > 4)
      {
         return -1;
      }

      while ((o->len) && (len--))
      {
         spi4000initialize <<= 8;
         spi4000initialize |= *(o->ptr++);
         o->len--;
      }

      len = (int)spi4000initialize;
   }

   if (o->len < (U32)len)
   {
      return -1;
   }

   return len;
}


int SharkSslParseASN1_getSetSeq(SharkSslParseASN1 *o, U8 iotiminggetbank)
{
   if ((o->len < 1) || (*(o->ptr) != iotiminggetbank))
   {
      return -1;
   }
   o->ptr++;
   o->len--;
   return SharkSslParseASN1_getLength(o);
}


int SharkSslParseASN1_getType(SharkSslParseASN1 *o, U8 modifyauxcoreboot0)
{
   int l; 

   if ((l = SharkSslParseASN1_getSetSeq(o, modifyauxcoreboot0)) < 0)
   {
      return -1;
   }
   o->datalen = (U32)l;

   if (SHARKSSL_ASN1_INTEGER == modifyauxcoreboot0)  
   {
      if (*(o->ptr) == 0x00) 
      {
         if (o->datalen > 1)  
         {
            o->datalen--;
            o->len--;
            o->ptr++;
            #if SHARKSSL_ASN1_BER_STRICT  
            if ((*(o->ptr)) < 0x80)
            {
               return -1;  
            }
            #endif
         }
      }
      #if SHARKSSL_ASN1_BER_STRICT
      else if (*(o->ptr) >= 0x80)
      {
         return -1;  
      }
      #endif
   }

   o->dataptr = o->ptr;
   o->ptr += o->datalen;
   o->len -= o->datalen;

   if ((SHARKSSL_ASN1_OID == modifyauxcoreboot0) && (o->len) && (SHARKSSL_ASN1_NULL == *(o->ptr)))
   {
      
       o->ptr++;
       o->len--;
       if (SharkSslParseASN1_getLength(o) != 0)
       {
          return -1;
       }
   }

   return 0;
}


int SharkSslParseASN1_getContextSpecific(SharkSslParseASN1 *o, U8 *tag)
{
   int l;

   if ((o->len < 1) || (!(*(o->ptr) & SHARKSSL_ASN1_CONTEXT_SPECIFIC)))
   {
      return -1;
   }

   *tag = (*(o->ptr) & ~SHARKSSL_ASN1_CONTEXT_SPECIFIC);

   o->ptr++;
   o->len--;
   if (((l = SharkSslParseASN1_getLength(o)) < 0) || ((U32)l > o->len))
   {
      return -1;
   }
   o->datalen = (U32)l;
   o->dataptr = o->ptr;
   o->ptr += o->datalen;
   o->len -= o->datalen;

   return 0;
}




const U8 sharkssl_oid_CN[3]                      = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_ATTRTYPE, SHARKSSL_OID_JIIT_DS_ATTRTYPE_CN};
const U8 sharkssl_oid_serial[3]                  = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_ATTRTYPE, SHARKSSL_OID_JIIT_DS_ATTRTYPE_SERIAL};
const U8 sharkssl_oid_country[3]                 = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_ATTRTYPE, SHARKSSL_OID_JIIT_DS_ATTRTYPE_COUNTRY};
const U8 sharkssl_oid_locality[3]                = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_ATTRTYPE, SHARKSSL_OID_JIIT_DS_ATTRTYPE_LOCALITY};
const U8 sharkssl_oid_province[3]                = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_ATTRTYPE, SHARKSSL_OID_JIIT_DS_ATTRTYPE_PROVINCE};
const U8 sharkssl_oid_organization[3]            = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_ATTRTYPE, SHARKSSL_OID_JIIT_DS_ATTRTYPE_ORGANIZATION};
const U8 sharkssl_oid_unit[3]                    = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_ATTRTYPE, SHARKSSL_OID_JIIT_DS_ATTRTYPE_UNIT};

const U8 sharkssl_oid_emailAddress[9]            = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x01};
const U8 sharkssl_oid_csr_ext_req[9]             = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x0E};
const U8 sharkssl_oid_signedData[9]              = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02};

const U8 sharkssl_oid_ns_cert_type[9]            = {0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01, 0x01};
const U8 sharkssl_oid_key_usage[3]               = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_CERTEXT, SHARKSSL_OID_JIIT_DS_CERTEXT_KEYUSAGE};
const U8 sharkssl_oid_san[3]                     = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_CERTEXT, SHARKSSL_OID_JIIT_DS_CERTEXT_SUBJALTNAMES};
const U8 sharkssl_oid_basic_constraints[3]       = {SHARKSSL_OID_JIIT_DS, SHARKSSL_OID_JIIT_DS_CERTEXT, SHARKSSL_OID_JIIT_DS_CERTEXT_BASICCONSTRAINTS};

#if SHARKSSL_ENABLE_RSA
const U8 sharkssl_oid_rsaEncryption[9]           = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01};
const U8 sharkssl_oid_md2withRSAEncryption[9]    = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x02};
#if SHARKSSL_USE_MD5
const U8 sharkssl_oid_md5withRSAEncryption[9]    = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x04};
#endif

const U8 sharkssl_oid_sha1withRSAEncryption[9]   = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05};
#if SHARKSSL_USE_SHA_256
const U8 sharkssl_oid_sha256withRSAEncryption[9] = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B};
#endif
#if SHARKSSL_USE_SHA_384
const U8 sharkssl_oid_sha384withRSAEncryption[9] = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0C};
#endif
#if SHARKSSL_USE_SHA_512
const U8 sharkssl_oid_sha512withRSAEncryption[9] = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0D};
#endif
#endif

#if SHARKSSL_USE_MD5
const U8 sharkssl_oid_md5[8]                     = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05};
#endif
#if SHARKSSL_USE_SHA1
const U8 sharkssl_oid_sha1[5]                    = {0x2B, 0x0E, 0x03, 0x02, 0x1A};
#endif
#if SHARKSSL_USE_SHA_256
const U8 sharkssl_oid_sha256[9]                  = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01};
#endif
#if SHARKSSL_USE_SHA_384
const U8 sharkssl_oid_sha384[9]                  = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02};
#endif
#if SHARKSSL_USE_SHA_512
const U8 sharkssl_oid_sha512[9]                  = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03};
#endif

#if SHARKSSL_USE_ECC


const U8 sharkssl_oid_ecPublicKey[7]             = {0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01};

#if SHARKSSL_ECC_USE_SECP256R1

const U8 sharkssl_oid_prime256v1[8]              = {0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07};
#endif

#if SHARKSSL_ECC_USE_SECP384R1
const U8 sharkssl_oid_secp384r1[5]               = {0x2B, 0x81, 0x04, 0x00, 0x22};
#endif
#if SHARKSSL_ECC_USE_SECP521R1
const U8 sharkssl_oid_secp521r1[5]               = {0x2B, 0x81, 0x04, 0x00, 0x23};
#endif
#if SHARKSSL_ECC_USE_BRAINPOOLP256R1

const U8 sharkssl_oid_brainpoolP256r1[9]         = {0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x07};
#endif
#if SHARKSSL_ECC_USE_BRAINPOOLP384R1

const U8 sharkssl_oid_brainpoolP384r1[9]         = {0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0B};
#endif
#if SHARKSSL_ECC_USE_BRAINPOOLP512R1

const U8 sharkssl_oid_brainpoolP512r1[9]         = {0x2B, 0x24, 0x03, 0x03, 0x02, 0x08, 0x01, 0x01, 0x0D};
#endif
#endif  

#if SHARKSSL_ENABLE_ECDSA

#if SHARKSSL_USE_SHA1
const U8 sharkssl_oid_ecdsaWithSHA1[7]           = {0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x01};
#endif
#if SHARKSSL_USE_SHA_256
const U8 sharkssl_oid_ecdsaWithSHA256[8]         = {0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02};
#endif
#if SHARKSSL_USE_SHA_384
const U8 sharkssl_oid_ecdsaWithSHA384[8]         = {0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x03};
#endif
#if SHARKSSL_USE_SHA_512
const U8 sharkssl_oid_ecdsaWithSHA512[8]         = {0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x04};
#endif
#endif

#if SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT

const U8 sharkssl_oid_pkcs5PBES2[9]              = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0D};
const U8 sharkssl_oid_pkcs5PBKDF2[9]             = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x05, 0x0C}; 
#if SHARKSSL_USE_SHA_256

const U8 sharkssl_oid_HMACWithSHA256[8]          = {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x09};
#endif
#if (SHARKSSL_USE_AES_128 && SHARKSSL_ENABLE_AES_CBC)

const U8 sharkssl_oid_aes128cbc[9]               = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x02};
#endif
#if (SHARKSSL_USE_AES_256 && SHARKSSL_ENABLE_AES_CBC)

const U8 sharkssl_oid_aes256cbc[9]               = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x01, 0x2A};
#endif
#endif



SHARKSSL_API void SharkSslASN1Create_constructor(SharkSslASN1Create *o, U8 *buf, int lsdc2format)
{
   o->start = buf;
   o->end = o->ptr = (buf + lsdc2format);
}


SHARKSSL_API int SharkSslASN1Create_length(SharkSslASN1Create *o, int len)
{
   if (len < 0x80)
   {
      if ((o->ptr - o->start) < 1)
      {
         return -1;
      }
      *--o->ptr = (U8)len;
   }
   else if (len <= 0xFF)
   {
      if ((o->ptr - o->start) < 2)
      {
         return -1;
      }
      *--o->ptr = (U8)len;
      *--o->ptr = 0x81;
   }
   else
   {
      if (((o->ptr - o->start) < 3) || (len > 0xFFFF))
      {
         return -1;
      }

      
      *--o->ptr = (U8)len; 
      *--o->ptr = (U8)((U16)len >> 8);
      *--o->ptr = 0x82;
   }
   return 0;
}


int SharkSslASN1Create_tag(SharkSslASN1Create *o, U8 modifyauxcoreboot0)
{
   if ((o->ptr - o->start) < 1)
   {
      return -1;
   }
   *--o->ptr = modifyauxcoreboot0;
   return 0;
}



int SharkSslASN1Create_int(SharkSslASN1Create *o, const U8 *unlockrescan, int len)
{
   U8 *ref = o->ptr;
   if ((len < 0) || (len >= 0x8000) || ((o->ptr - o->start) < (len + 3)))
   {
      return -1;
   }
   if (len > 0)
   {
      o->ptr -= len;
      memmove(o->ptr, unlockrescan, len);
      
      while ((0x00 == *o->ptr) && (len > 1))
      {
         o->ptr++;
         len--;
      }
      if (*o->ptr >= 0x80)
      {
         *--o->ptr = 0x00;
      }
   }
   return
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_tag(o, SHARKSSL_ASN1_INTEGER);
}

#if (SHARKSSL_ENABLE_CSR_CREATION || SHARKSSL_ENABLE_CSR_SIGNING || SHARKSSL_ENABLE_ASN1_KEY_CREATION)
int SharkSslASN1Create_oid(SharkSslASN1Create *o, const U8 *oid, int fieldvalue)
{
   return
      SharkSslASN1Create_raw(o, oid, fieldvalue) ||
      SharkSslASN1Create_length(o, fieldvalue) ||
      SharkSslASN1Create_tag(o, SHARKSSL_ASN1_OID);
} 


int SharkSslASN1Create_raw(SharkSslASN1Create *o, const void *alloccontroller, int icachealiases)
{
   if ((o->ptr - o->start) < icachealiases)
   {
      return -1;
   }
   o->ptr -= icachealiases;
   memcpy(o->ptr, alloccontroller, icachealiases);
   return 0;
}
#endif


#if (SHARKSSL_ENABLE_CSR_CREATION || SHARKSSL_ENABLE_CSR_SIGNING)
static int countusable(SharkSslASN1Create *o, const U8 *gpio1config, int len)
{
   return
      SharkSslASN1Create_raw(o, gpio1config, len) ||
      SharkSslASN1Create_length(o, len) ||
      SharkSslASN1Create_printableString(o);
}


static int supportsstage2(SharkSslASN1Create *o, const U8 *gpio1config, int len)
{
   return
      SharkSslASN1Create_raw(o, gpio1config, len) ||
      SharkSslASN1Create_length(o, len) ||
      SharkSslASN1Create_IA5String(o);
}


int SharkSslASN1Create_email(SharkSslASN1Create *o, const U8 *oid, int fieldvalue, const U8 *blockoffset, int detachdevice)
{
   U8 *ref = o->ptr;
   return 
      supportsstage2(o, blockoffset, detachdevice) ||
      SharkSslASN1Create_oid(o, oid, fieldvalue) ||
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_sequence(o) ||
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_set(o);
}

int SharkSslASN1Create_name(SharkSslASN1Create *o, const U8 *oid, int fieldvalue, const U8 *gpio1config, int alignresource)
{
   U8 *ref = o->ptr;
   return 
      countusable(o, gpio1config, alignresource) ||
      SharkSslASN1Create_oid(o, oid, fieldvalue) ||
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_sequence(o) ||
      SharkSslASN1Create_length(o, (int)(ref - o->ptr)) ||
      SharkSslASN1Create_set(o);
}
#endif


#if (SHARKSSL_ENABLE_CSR_SIGNING)
int SharkSslASN1Create_boolean(SharkSslASN1Create *o, U8 dm9000device)
{
   if ((o->ptr - o->start) < 3)
   {
      return -1;
   }
   *--o->ptr = (dm9000device ? 0xFF : 0x00);
   return
      SharkSslASN1Create_length(o, 1) ||
      SharkSslASN1Create_tag(o, SHARKSSL_ASN1_BOOLEAN);
}
#endif
#endif


#ifndef BA_LIB
#define BA_LIB
#endif





#if SHARKSSL_USE_ECC

#endif
#include <string.h>

#define SHARKSSL_DIM_ARR(a)  (sizeof(a)/sizeof(a[0]))

#if SHARKSSL_ECC_USE_EDWARDS

static void swap_endianess(U8 *d, U16 len)
{
   U8 *p = d + len;
   baAssert(0 == (len & 1));
   while (d < --p)
   {
      *d ^= *p;
      *p ^= *d;
      *d ^= *p;
      d++;
   }
}
#endif


#if ((SHARKSSL_BIGINT_WORDSIZE != 8) && !defined(B_BIG_ENDIAN))

void memmove_endianess(U8 *d, const U8 *s, U16 len)
{
   #ifndef B_LITTLE_ENDIAN
   static const U16 devicebluetooth = 0xFF00;

   if (0 == (*(U8*)&devicebluetooth))  
   {
   #endif
      baAssert(0 == (len & (U16)computereturn));
      len /= (SHARKSSL_BIGINT_WORDSIZE / 8);

      #if ((!defined(SHARKSSL_UNALIGNED_ACCESS)) || (!(SHARKSSL_UNALIGNED_ACCESS)))
      if (0 == ((unsigned int)(UPTR)d & computereturn)) 
      #endif
      {
         __sharkssl_packed shtype_tWord *da = (shtype_tWord*)d;

         #if   (SHARKSSL_BIGINT_WORDSIZE == 32)
         #if ((!defined(SHARKSSL_UNALIGNED_ACCESS)) || (!(SHARKSSL_UNALIGNED_ACCESS)))
         if (0 == ((unsigned int)(UPTR)s & computereturn)) 
         #endif
         {
            while (len--)
            {
               *da++ = (shtype_tWord)blockarray(*(__sharkssl_packed shtype_tWord*)s);
               s += 4;
            }
         }
         #if ((!defined(SHARKSSL_UNALIGNED_ACCESS)) || (!(SHARKSSL_UNALIGNED_ACCESS)))
         else
         {
            while (len--)
            {
               *da++ = (shtype_tWord)((((shtype_tWord)(s[0])) << 24) +
                                            (((shtype_tWord)(s[1])) << 16) +
                                            (((shtype_tWord)(s[2])) << 8) +  s[3]);
               s += 4;
            }
         }
         #endif
         #elif (SHARKSSL_BIGINT_WORDSIZE == 16)
         while (len--)
         {
            *da++ = (shtype_tWord)((((shtype_tWord)(s[0])) << 8) + s[1]);
            s += 2;
         }
         #endif
      }
      #if ((!defined(SHARKSSL_UNALIGNED_ACCESS)) || (!(SHARKSSL_UNALIGNED_ACCESS)))
      else  
      {
         while (len--)
         {
            #if   (SHARKSSL_BIGINT_WORDSIZE == 32)
            U8 b[4];
            b[0] = s[0];
            b[1] = s[1];
            b[2] = s[2];
            b[3] = s[3];

            *d++ = b[3];
            *d++ = b[2];
            *d++ = b[1];
            *d++ = b[0];
            s += 4;
            #elif (SHARKSSL_BIGINT_WORDSIZE == 16)
            U8 b[2];
            b[0] = s[0];
            b[1] = s[1];

            *d++ = b[1];
            *d++ = b[0];
            s += 2;
            #endif
         }
      }
      #endif
   #ifndef B_LITTLE_ENDIAN
   }
   else
   {
      memmove(d, s, len);
   }
   #endif
}
#endif 


#if SHARKSSL_ENABLE_RSA
int async3clksrc(const SharkSslCertKey *ck, U8 op, U8 *stackchecker)
{
   U16 p_len, e_len, icachealiases;
   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   U16 prctlreset;
   #endif
   U8 *afterhandler, *temporaryentry, *ckexp, *ckmod;
   shtype_t in, mod, exp, u;

   baAssert(ck);

   if (!(machinekexec(ck->expLen)))  
   {
      return (int)SharkSslCon_AllocationError;  
   }

   p_len = supportedvector(ck->modLen);
   e_len = mousethresh(ck->expLen);
   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   prctlreset = claimresource(e_len);
   #endif
   ckmod = ck->mod;
   ckexp = ck->exp;

   #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_ENABLE_RSA_API || \
        (SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CLIENT_AUTH))
   baAssert((op == sleepstore) || (op == hsmmcplatform));
   if (op == hsmmcplatform)
   #else
   baAssert(op == hsmmcplatform);
   #endif
   {
      
      icachealiases   = p_len;
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      icachealiases  += p_len;     
      icachealiases  += prctlreset;     
      #if (!(defined(B_BIG_ENDIAN)) || !(SHARKSSL_UNALIGNED_ACCESS))
      icachealiases  += p_len;
      #endif
      #endif
      afterhandler = (U8*)baMalloc(pcmciapdata(icachealiases));
      if (afterhandler == NULL)
      {
         return (int)SharkSslCon_AllocationError;
      }
      temporaryentry = (U8*)selectaudio(afterhandler);
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      memmove_endianess(temporaryentry, stackchecker, p_len);
      onenandpartitions(&in, (p_len * 8), temporaryentry);
      temporaryentry += p_len;
      prctlreset -= e_len;
      memset(temporaryentry, 0, prctlreset);
      memcpy(temporaryentry + prctlreset, ckexp, e_len);
      e_len += prctlreset;
      memmove_endianess(temporaryentry, temporaryentry, e_len);
      ckexp = temporaryentry;
      temporaryentry += e_len;
      #if (!(defined(B_BIG_ENDIAN)) || !(SHARKSSL_UNALIGNED_ACCESS))
      memmove_endianess(temporaryentry, ckmod, p_len);
      ckmod = temporaryentry;
      temporaryentry += p_len;
      #endif
      #else
      onenandpartitions(&in, (p_len * 8), stackchecker);
      #endif
      onenandpartitions(&exp, (e_len * 8), ckexp);
      onenandpartitions(&mod, (p_len * 8), ckmod);
      onenandpartitions(&u, (p_len * 8), temporaryentry);
      chunkmutex(&in, &exp, &mod, &u, 1);
      #if (SHARKSSL_BIGINT_WORDSIZE == 8)
      if (pulsewidth(&u) < p_len)
      {
         baAssert(pulsewidth(&u) == (p_len - 1));
         *stackchecker++ = 0;
         p_len--;
      }
      #endif
      memmove_endianess(stackchecker, (U8*)consoledevice(&u), p_len);
      baFree(afterhandler);
   }

   #if (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_ENABLE_RSA_API || \
        (SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CLIENT_AUTH))
   else  
   {
      
      U16 redistregion;
      shtype_t q, m1, m2, h;
      shtype_t r;

      if (coupledexynos(ck->expLen))  
      {
         return (int)SharkSslCon_AllocationError;  
      }

      ckmod += p_len;
      redistregion = p_len;
      p_len >>= 1;
      icachealiases   = redistregion;
      icachealiases  += (icachealiases * 2); 
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      icachealiases  += redistregion;     
      icachealiases  += prctlreset;      
      #if (!(defined(B_BIG_ENDIAN)) || !(SHARKSSL_UNALIGNED_ACCESS))
      icachealiases  += p_len;
      icachealiases  += (p_len * 4);
      #endif
      #endif
      if (e_len)
      {
         icachealiases += redistregion;     
         icachealiases += 2 * redistregion;
      }
      afterhandler = (U8*)baMalloc(pcmciapdata(icachealiases));
      if (afterhandler == NULL)
      {
         return (int)SharkSslCon_AllocationError;
      }
      temporaryentry = (U8*)selectaudio(afterhandler);
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      memmove_endianess(temporaryentry, stackchecker, redistregion);
      onenandpartitions(&in, redistregion * 8, temporaryentry);
      temporaryentry += redistregion;
      if (ckexp == NULL)
      {
         baAssert(e_len == 0);
         e_len = 0;  
      }
      else
      {
         prctlreset -= e_len;
         memset(temporaryentry, 0, prctlreset);
         memcpy(temporaryentry + prctlreset, ckexp, e_len);
         e_len += prctlreset;
         memmove_endianess(temporaryentry, temporaryentry, e_len);
         ckexp = temporaryentry;
         temporaryentry += e_len;
      }
      #if (!(defined(B_BIG_ENDIAN)) || !(SHARKSSL_UNALIGNED_ACCESS))
      memmove_endianess(temporaryentry, ckmod, (U16)(2 * redistregion + p_len));
      ckmod = temporaryentry;
      temporaryentry += 2 * redistregion + p_len;
      #endif
      #else
      onenandpartitions(&in, redistregion * 8, stackchecker);
      #endif
      onenandpartitions(&m1, redistregion * 8, temporaryentry);
      temporaryentry += redistregion;
      onenandpartitions(&m2, redistregion * 8, temporaryentry);
      temporaryentry += redistregion;
      onenandpartitions(&h,  redistregion * 8, temporaryentry);

      if (e_len)  
      {
         temporaryentry += redistregion;
         
         memmove_endianess((U8*)consoledevice(&m1), ck->mod, redistregion);
         
         sharkssl_rng(temporaryentry, redistregion);
         onenandpartitions(&r, redistregion * 8, temporaryentry);
         temporaryentry += redistregion;
         
         onenandpartitions(&exp, e_len * 8, ckexp);
         chunkmutex(&r, &exp, &m1, &m2, 1); 
         
         onenandpartitions(&u,  redistregion * 2 * 8, temporaryentry);
         hotplugpgtable(&m2, &in, &u);
         suspendfinish(&u, &m1);
         unassignedvector(&u, &in);
      }

      
      onenandpartitions(&mod, p_len * 8, &(ckmod[p_len]));     
      onenandpartitions(&exp, p_len * 8, &(ckmod[3 * p_len])); 
      chunkmutex(&in, &exp, &mod, &m2, 0); 

      
      onenandpartitions(&mod, p_len * 8, &(ckmod[0]));         
      onenandpartitions(&exp, p_len * 8, &(ckmod[2 * p_len])); 
      chunkmutex(&in, &exp, &mod, &m1, 0); 

      onenandpartitions(&u,   p_len * 8, &(ckmod[4 * p_len])); 
      onenandpartitions(&q,   p_len * 8, &(ckmod[p_len]));     

      
      keypaddevice(&m1, &m2, &mod);
      hotplugpgtable(&u, &m1, &h);
      suspendfinish(&h, &mod); 
      hotplugpgtable(&h, &q, &in);
      resolverelocs(&in, &m2);
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      if (!e_len)
      {
         memmove_endianess(stackchecker, (U8*)consoledevice(&in), redistregion);
      }
      #endif

      if (e_len)
      {
         #if 0  
         
         onenandpartitions(&q, p_len * 8, &(ckmod[p_len])); 
         onenandpartitions(&u, p_len * 8, &(ckmod[0]));     
         hotplugpgtable(&q, &u, &m1);
         #else
         
         onenandpartitions(&m1, redistregion * 8, consoledevice(&m1));
         memmove_endianess((U8*)consoledevice(&m1), ck->mod, redistregion);
         #endif
         
         iommumapping(&r, &m1);
         
         onenandpartitions(&u,  redistregion * 2 * 8, temporaryentry);
         hotplugpgtable(&r, &in, &u);
         
         suspendfinish(&u, &m1);
         #if (SHARKSSL_BIGINT_WORDSIZE == 8)
         baAssert(pulsewidth(&u) == redistregion);
         #endif
         memmove_endianess(stackchecker, (U8*)consoledevice(&u), redistregion);
      }

      baFree(afterhandler);
   }
   #endif

   return 0;
}
#endif  


#if SHARKSSL_ENABLE_DHE_RSA
int SharkSslDHParam_DH(const SharkSslDHParam *dh, U8 op, U8 *out)
{
   shtype_t validconfig, mod, exp, res;
   U8 *afterhandler, *dhexp, *dhmod;
   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   U8 *temporaryentry;
   #endif
   U16 p_len, g_len, icachealiases;

   baAssert(dh);
   baAssert(op & (cpucfgexits | switcheractive));

   g_len = dh->gLen;
   p_len = dh->pLen;
   dhmod = dh->p;
   dhexp = dh->r;

   
   icachealiases   = p_len;  
   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   icachealiases  += p_len;
   #if (!(defined(B_BIG_ENDIAN)) || !(SHARKSSL_UNALIGNED_ACCESS))
   icachealiases  += (p_len * 2);
   #endif
   #endif
   afterhandler = (U8*)baMalloc(pcmciapdata(icachealiases));
   if (afterhandler == NULL)
   {
      return (int)SharkSslCon_AllocationError;
   }

   if (op & cpucfgexits)
   {
      
      baAssert(0 == (p_len & 0x3));
      if ((dhexp == NULL) || (sharkssl_rng(dhexp, p_len) < 0))
      {
         return (int)SharkSslCon_AllocationError;
      }
   }

   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   temporaryentry = (U8*)selectaudio(afterhandler + p_len);
   #if (!(defined(B_BIG_ENDIAN)) || !(SHARKSSL_UNALIGNED_ACCESS))
   memmove_endianess(temporaryentry, dhexp, p_len);
   dhexp = temporaryentry;
   temporaryentry += p_len;
   memmove_endianess(temporaryentry, dhmod, p_len);
   dhmod = temporaryentry;
   temporaryentry += p_len;
   #endif
   #endif

   onenandpartitions(&exp, (p_len * 8), dhexp);
   onenandpartitions(&mod, (p_len * 8), dhmod);
   #if ((SHARKSSL_BIGINT_WORDSIZE > 8) && SHARKSSL_UNALIGNED_MALLOC)
   onenandpartitions(&res, (p_len * 8), (temporaryentry - 3 * p_len));
   #else
   onenandpartitions(&res, (p_len * 8), afterhandler);
   #endif

   if (op & cpucfgexits)
   {
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      memmove_endianess(temporaryentry, dh->g, g_len);
      onenandpartitions(&validconfig, (g_len * 8), temporaryentry);
      #else
      onenandpartitions(&validconfig, (g_len * 8), dh->g);
      #endif
      chunkmutex(&validconfig, &exp, &mod, &res, 0);
      
      memmove_endianess(out, (U8*)consoledevice(&res), p_len);
      out += p_len;  
   }

   if (op & switcheractive)
   {
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      memmove_endianess(temporaryentry, dh->Y, p_len);
      onenandpartitions(&validconfig, (p_len * 8), temporaryentry);
      #else
      onenandpartitions(&validconfig, (p_len * 8), dh->Y);
      #endif
      chunkmutex(&validconfig, &exp, &mod, &res, 0);
      
      memmove_endianess(out, (U8*)consoledevice(&res), p_len);
   }

   baFree(afterhandler);
   return 0;
}


#if SHARKSSL_SSL_SERVER_CODE
void SharkSslDHParam_setParam(SharkSslDHParam *dh)
{
   

   static const U8 wm97xxirqen[256] =
   {
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
      0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
      0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
      0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
      0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,
      0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
      0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,
      0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
      0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
      0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
      0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,
      0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
      0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,
      0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
      0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,
      0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
      0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,
      0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
      0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,
      0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
      0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,
      0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
      0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,
      0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
      0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,
      0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
      0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,
      0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
      0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,
      0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
      0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68,
      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
   };

   static const U8 g[4] = {0, 0, 0, 2};

   dh->p    = (U8*)wm97xxirqen;
   dh->pLen = SHARKSSL_DIM_ARR(wm97xxirqen);

   dh->g    = (U8*)g;
   dh->gLen = SHARKSSL_DIM_ARR(g);
}
#endif  
#endif  


#if (SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA)
int SharkSslECDHParam_ECDH(const SharkSslECDHParam *configvdcdc2, U8 op, U8 *out)
{
   shtype_t spi4000check;
   SharkSslECCurve nandflashpartition;
   SharkSslECPoint point, keypoint;
   U8 *afterhandler, *temporaryentry, *xy, *k;
   U16 x_len, x_lenr, x_lenk, icachealiases;

   baAssert(configvdcdc2);
   baAssert(op & (signalpreserve | switcheractive));

   xy = configvdcdc2->XY;
   x_len = configvdcdc2->xLen;         
   baAssert(x_len);

   
   x_lenr = (x_len + computereturn) & ~computereturn;

   
   clearerrors(&nandflashpartition, configvdcdc2->curveType);
   if (0 == nandflashpartition.bits)  
   {
      return (int)SharkSslCon_AllocationError;
   }

   
   x_lenk = (x_len + 3) & ~0x3;
   baAssert(x_lenk >= x_lenr);

   icachealiases  = x_lenk;  
   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   icachealiases += x_lenk;  
   #endif
   icachealiases += (U16)(x_lenr * 2);  
   #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
   if (x_len != x_lenr)
   {
      icachealiases += (U16)(x_lenr * 2);  
   }
   #endif
   if (op & switcheractive)
   {
      icachealiases += (x_lenr * 2);  
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (x_len != x_lenr)
      {
         icachealiases += x_lenr;  
      }
      #endif
   }
   afterhandler = (U8*)baMalloc(pcmciapdata(icachealiases));
   if ((afterhandler == NULL) || (0 == nandflashpartition.bits))
   {
      return (int)SharkSslCon_AllocationError;
   }
   temporaryentry = (U8*)selectaudio(afterhandler);

   if (op & signalpreserve)
   {
      
      k = temporaryentry;
      sharkssl_rng(k, x_lenk);
      #if SHARKSSL_ECC_USE_CURVE25519
      if (SHARKSSL_EC_CURVE_ID_CURVE25519 == configvdcdc2->curveType)
      {
         k[x_lenk - x_len] &= ~0x80;  
         k[x_lenk - x_len] |=  0x40;  
         k[x_lenk - 1]     &= ~0x07;  
      }
      else
      #endif
      #if SHARKSSL_ECC_USE_CURVE448
      if (SHARKSSL_EC_CURVE_ID_CURVE448 == configvdcdc2->curveType)
      {
         k[x_lenk - x_len] |=  0x80;  
         k[x_lenk - 1]     &= ~0x03;  
      }
      else
      #endif
      {
         k[x_lenk - x_len] |=  0x01;  
      }

      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      #if SHARKSSL_ECC_USE_SECP521R1
      
      if (x_lenr > x_len)
      {
         memset(k, 0, x_lenr - x_len);
      }
      #endif
      temporaryentry += x_lenk;
      memmove_endianess(temporaryentry, k, x_lenk);
      k = temporaryentry;
      #endif
      #if ((SHARKSSL_BIGINT_WORDSIZE < 32) && (SHARKSSL_ECC_USE_SECP521R1))
      k += (x_lenk - x_lenr);
      #endif

      
      onenandpartitions(&spi4000check, (U16)(x_lenr * 8), k);

      
      #if SHARKSSL_ECC_USE_BRAINPOOL
      if (
          #if SHARKSSL_ECC_USE_BRAINPOOLP256R1
          (SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1 != configvdcdc2->curveType) && 
          #endif 
          #if SHARKSSL_ECC_USE_BRAINPOOLP384R1
          (SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1 != configvdcdc2->curveType) && 
          #endif 
          #if SHARKSSL_ECC_USE_BRAINPOOLP512R1
          (SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1 != configvdcdc2->curveType) &&
          #endif 
          (1))
      #endif
      {
         *(consoledevice(&(spi4000check))) &= *(consoledevice(&(nandflashpartition.prime)));
      }
      if (timerwrite(&spi4000check, &nandflashpartition.prime))
      {
         updatepmull(&spi4000check, &nandflashpartition.prime);
         baAssert(!(timerwrite(&spi4000check, &nandflashpartition.prime)));
      }

      
      if (!(op & switcheractive))
      {
         if (configvdcdc2->k == NULL)
         {
            baFree(afterhandler);
            return (int)SharkSslCon_AllocationError;
         }
         #if (SHARKSSL_BIGINT_WORDSIZE > 8)
         memmove_endianess(temporaryentry - x_lenk, temporaryentry, x_lenk);
         memcpy(configvdcdc2->k, temporaryentry - x_len, x_len);
         #else
         memcpy(configvdcdc2->k, k, x_len);
         #endif
      }

      temporaryentry += x_lenk;
      baAssert(pcmciaplatform(temporaryentry));
      updatefrequency(&point, x_lenr * 8, temporaryentry, temporaryentry + x_lenr);
      unregisterskciphers(&nandflashpartition, &spi4000check, &point);
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (x_len != x_lenr)
      {
         temporaryentry += (U16)(x_lenr * 2);
         memmove_endianess(temporaryentry, (U8*)consoledevice(&(point.x)), x_lenr);
         temporaryentry += x_lenr;
         memmove_endianess(temporaryentry, (U8*)consoledevice(&(point.y)), x_lenr);
         memcpy(out, temporaryentry - x_len, x_len);
         out  += x_len;
         temporaryentry += x_lenr;
         memcpy(out, temporaryentry - x_len, x_len);
         out  += x_len;
         temporaryentry -= (U16)(x_lenr * 4);
      }
      else
      #endif
      {
         memmove_endianess(out, (U8*)consoledevice(&(point.x)), x_len);
         #if SHARKSSL_ECC_USE_EDWARDS
         if ((SHARKSSL_EC_CURVE_ID_CURVE25519 == configvdcdc2->curveType) || (SHARKSSL_EC_CURVE_ID_CURVE448 == configvdcdc2->curveType))
         {
            swap_endianess(out, x_len);
         }
         #endif
         out += x_len;
         #if SHARKSSL_ECC_USE_EDWARDS
         if ((SHARKSSL_EC_CURVE_ID_CURVE25519 != configvdcdc2->curveType) && (SHARKSSL_EC_CURVE_ID_CURVE448 != configvdcdc2->curveType))
         #endif
         {
            memmove_endianess(out, (U8*)consoledevice(&(point.y)), x_len);
            out += x_len;
         }
      }
   }
   else if (op & switcheractive)
   {
      if (configvdcdc2->k == NULL)
      {
         return (int)SharkSslCon_AllocationError;
      }
      
      k = temporaryentry;
      if (x_lenr > x_len)
      {
         memset(k, 0, x_lenr - x_len);
         temporaryentry += (x_lenr - x_len);
      }
      memcpy(temporaryentry, configvdcdc2->k, x_len);
      temporaryentry += x_len;
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      memmove_endianess(temporaryentry, k, x_lenr);
      k = temporaryentry;
      temporaryentry += x_lenr;
      #endif
      onenandpartitions(&spi4000check, x_lenr * 8, k);
   }

   if (op & switcheractive)
   {
      if (xy == NULL)
      {
         baFree(afterhandler);
         return (int)SharkSslCon_AllocationError;
      }
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (x_len != x_lenr)
      {
         icachealiases = x_lenr - x_len;
         memset(temporaryentry, 0, icachealiases);
         memcpy(temporaryentry + icachealiases, xy, x_len);
         temporaryentry += x_lenr;
         memset(temporaryentry, 0, icachealiases);
         memcpy(temporaryentry + icachealiases, xy + x_len, x_len);
         temporaryentry += x_lenr;
         icachealiases = (U16)(x_lenr * 2);
         memmove_endianess(temporaryentry, temporaryentry - icachealiases, icachealiases);
      }
      else
      #endif
      {
         #if SHARKSSL_ECC_USE_EDWARDS
         if ((SHARKSSL_EC_CURVE_ID_CURVE25519 == configvdcdc2->curveType) || (SHARKSSL_EC_CURVE_ID_CURVE448 == configvdcdc2->curveType))
         {
            baAssert(x_len == x_lenr);
            memmove_endianess(temporaryentry, xy, x_len);
            swap_endianess(temporaryentry, x_len);
            memset(temporaryentry + x_len, 0, x_len);
         }
         else
         #endif
         {
            memmove_endianess(temporaryentry, xy, x_len * 2);
         }
      }
      updatefrequency(&point, x_lenr * 8, temporaryentry, temporaryentry + x_lenr);
      if (initialdomain(&nandflashpartition, &point))
      {
         baFree(afterhandler);
         return (int)SharkSslCon_AllocationError;
      }
      temporaryentry += (U16)(x_lenr * 2);
      updatefrequency(&keypoint, x_lenr * 8, temporaryentry, temporaryentry + x_lenr);
      unregisterskciphers(&nandflashpartition, &spi4000check, &keypoint);
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (x_len != x_lenr)
      {
         #if SHARKSSL_ECC_USE_EDWARDS
         baAssert((SHARKSSL_EC_CURVE_ID_CURVE25519 != configvdcdc2->curveType) && (SHARKSSL_EC_CURVE_ID_CURVE448 != configvdcdc2->curveType));
         #endif
         temporaryentry += (U16)(x_lenr * 2);
         memmove_endianess(temporaryentry, (U8*)consoledevice(&(keypoint.x)), x_lenr);
         memcpy(out, temporaryentry + x_lenr - x_len, x_len);
      }
      else
      #endif
      {
         memmove_endianess(out, (U8*)consoledevice(&(keypoint.x)), x_len);
         #if SHARKSSL_ECC_USE_EDWARDS
         if ((SHARKSSL_EC_CURVE_ID_CURVE25519 == configvdcdc2->curveType) || (SHARKSSL_EC_CURVE_ID_CURVE448 == configvdcdc2->curveType))
         {
            swap_endianess(out, x_len);
         }
         #endif
      }
   }

   baFree(afterhandler);
   return 0;
}
#endif


#if SHARKSSL_ENABLE_ECDSA
int SharkSslECDSAParam_ECDSA(const SharkSslECDSAParam *audioshutdown, U8 op)
{
   shtype_t e, w, u1, u2, R, S;
   #if (!SHARKSSL_ECDSA_ONLY_VERIFY)
   shtype_t K, dA;
   #endif
   SharkSslECCurve G, T;
   SharkSslECPoint point, Qa;
   U8 *afterhandler, *temporaryentry, *r, *s, *h, *k;
   U16 k_len, k_lenr, k_lenk, h_len, icachealiases;
   int offsetarray = 1;

   baAssert(audioshutdown);
   #if SHARKSSL_ECDSA_ONLY_VERIFY
   baAssert(op == fixupdevices);
   #else
   baAssert((op == iommupdata) || (op == fixupdevices));
   #endif

   r = audioshutdown->R;
   s = audioshutdown->S;
   k = audioshutdown->key;
   h = audioshutdown->hash;
   k_len = audioshutdown->keyLen;         
   h_len = audioshutdown->hashLen;
   baAssert((k_len) && (h_len));
   baAssert(0 == (h_len & 0x3));  
   baAssert(h_len <= 64);         

   
   k_lenr = (k_len + computereturn) & ~computereturn;

   if (h_len > k_lenr)
   {
      h_len = k_lenr;
   }

   
   k_lenk = (k_len + 3) & ~0x3;

   
   clearerrors(&G, audioshutdown->curveType);
   if (0 == G.bits)  
   {
      return offsetarray;
   }

   icachealiases  = (U16)((k_lenr << 2) + (k_lenr << 1));     
   icachealiases += k_lenk;                                   
   #if (SHARKSSL_BIGINT_WORDSIZE > 32)
   icachealiases += 4;  
   #else
   baAssert(k_lenk >= k_lenr);
   #endif

   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   icachealiases += h_len;                                    
   #if (!SHARKSSL_ECDSA_ONLY_VERIFY)
   if (op & iommupdata)
   {
      icachealiases += k_lenr;                                
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      icachealiases += k_lenr;                                
      #endif
   }
   else
   #endif
   if (op & fixupdevices)
   {
      icachealiases += (U16)(k_lenr << 2);                    
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      icachealiases += (U16)(k_lenr << 2);                    
      #endif
   }
   #endif  

   afterhandler = (U8*)baMalloc(pcmciapdata(icachealiases));
   if ((afterhandler == NULL) || (0 == G.bits))
   {
      return (int)SharkSslCon_AllocationError;
   }
   temporaryentry = (U8*)selectaudio(afterhandler);

   onenandpartitions(&u1, (k_lenr * 2 * 8), temporaryentry);
   temporaryentry += (U16)(k_lenr << 1);
   onenandpartitions(&u2, (k_lenr * 2 * 8), temporaryentry);
   temporaryentry += (U16)(k_lenr << 1);
   updatefrequency(&point, (k_lenr * 8), temporaryentry, temporaryentry + k_lenr);
   temporaryentry += (U16)(k_lenr << 1);

   #if (SHARKSSL_BIGINT_WORDSIZE > 8)
   memmove_endianess(temporaryentry, h, h_len);
   h = temporaryentry;
   temporaryentry += h_len;
   #endif
   onenandpartitions(&e, (h_len * 8), h);

   #if (!SHARKSSL_ECDSA_ONLY_VERIFY)
   if (op & iommupdata)
   {
      U8 cnt = 0;

      _SharkSslECDSAParam_ECDSA_rng:
      sharkssl_rng(temporaryentry, k_lenk);
      temporaryentry[k_lenk - k_len] |= 0x01;  

      #if SHARKSSL_ECC_USE_SECP521R1
      
      if (k_lenk > k_len)
      {
         memset(temporaryentry, 0, k_lenk - k_len);
      }
      #endif

      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      memmove_endianess((U8*)consoledevice(&u1), temporaryentry, k_lenk);
      memcpy(temporaryentry, (U8*)consoledevice(&u1), k_lenk);
      #endif
      onenandpartitions(&K, (k_lenk * 8), temporaryentry);
      suspendfinish(&K, &G.order);
      blastscache(&K);
      baAssert(pulsewidth(&K) <= k_lenr);
      temporaryentry += k_lenk;

      if (unregisterskciphers(&G, &K, &point))
      {
         goto _SharkSslECDSAParam_ECDSA_end;
      }

      suspendfinish(&point.x, &G.order);
      if (eventtimeout(&point.x))
      {
         if (++cnt & 0x8)  
         {
            goto _SharkSslECDSAParam_ECDSA_end;
         }
         goto _SharkSslECDSAParam_ECDSA_rng;
      }

      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (k_len != k_lenr)
      {
         icachealiases = k_lenr - k_len;
         memset(temporaryentry, 0, icachealiases);
         memcpy(temporaryentry + icachealiases, k, k_len);
         temporaryentry += k_lenr;
         memmove_endianess(temporaryentry, temporaryentry - k_lenr, k_lenr);
      }
      else
      #endif
      {
         memmove_endianess(temporaryentry, k, k_lenr);
      }
      onenandpartitions(&dA, (k_lenr * 8), temporaryentry);
      #else  
      onenandpartitions(&dA, (k_lenr * 8), k);
      #endif
      hotplugpgtable(&dA, &point.x, &u1);
      suspendfinish(&u1, &G.order);
      setupsdhci1(&u1, &e, &G.order);
      iommumapping(&K, &G.order);
      hotplugpgtable(&K, &u1, &u2);
      suspendfinish(&u2, &G.order);
      if (eventtimeout(&u2))
      {
         if (++cnt & 0x8)  
         {
            goto _SharkSslECDSAParam_ECDSA_end;
         }
         goto _SharkSslECDSAParam_ECDSA_rng;
      }
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (k_len != k_lenr)
      {
         temporaryentry = (U8*)consoledevice(&(point.y));
         memmove_endianess(temporaryentry, (U8*)consoledevice(&(point.x)), k_lenr);
         memcpy(r, temporaryentry + k_lenr - k_len, k_len);
         memmove_endianess(temporaryentry, (U8*)consoledevice(&u2), k_lenr);
         memcpy(s, temporaryentry + k_lenr - k_len, k_len);
      }
      else
      #endif
      {
         memmove_endianess(r, (U8*)consoledevice(&(point.x)), k_len);
         memmove_endianess(s, (U8*)consoledevice(&u2), k_len);
      }
      offsetarray = 0;
   }

   else
   #endif
   if (op & fixupdevices)
   {
      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (k_len != k_lenr)
      {
         icachealiases = k_lenr - k_len;
         memset(temporaryentry, 0, icachealiases);
         memcpy(temporaryentry + icachealiases, r, k_len);
         r = temporaryentry;
         temporaryentry += k_lenr;
         memset(temporaryentry, 0, icachealiases);
         memcpy(temporaryentry + icachealiases, s, k_len);
         s = temporaryentry;
         temporaryentry += k_lenr;
      }
      #endif
      memmove_endianess(temporaryentry, r, k_lenr);
      r = temporaryentry;
      temporaryentry += k_lenr;
      memmove_endianess(temporaryentry, s, k_lenr);
      s = temporaryentry;
      temporaryentry += k_lenr;
      #endif

      onenandpartitions(&R, (k_lenr * 8), r);
      onenandpartitions(&S, (k_lenr * 8), s);
      onenandpartitions(&w, (k_lenr * 8), temporaryentry);
      temporaryentry += k_lenr;

      #if (SHARKSSL_BIGINT_WORDSIZE > 8)
      
      #if ((SHARKSSL_BIGINT_WORDSIZE > 16) && (SHARKSSL_ECC_USE_SECP521R1))
      if (k_len != k_lenr)
      {
         icachealiases = k_lenr - k_len;
         memset(temporaryentry, 0, icachealiases);
         memcpy(temporaryentry + icachealiases, k, k_len);
         temporaryentry += k_lenr;
         memset(temporaryentry, 0, icachealiases);
         memcpy(temporaryentry + icachealiases, k + k_len, k_len);
         temporaryentry += k_lenr;
         icachealiases = (U16)(k_lenr << 1);
         memmove_endianess(temporaryentry, temporaryentry - icachealiases, icachealiases);
      }
      else
      #endif
      {
         memmove_endianess(temporaryentry, k, (U16)(k_lenr << 1));
      }
      updatefrequency(&Qa, (k_lenr * 8), temporaryentry, temporaryentry + k_lenr);
      #else  
      updatefrequency(&Qa, (k_lenr * 8), k, k + k_lenr);
      #endif

      
      if ((eventtimeout(&R)) || (eventtimeout(&S)) ||
          (timerwrite(&R, &G.order) || timerwrite(&S, &G.order)))
      {
         goto _SharkSslECDSAParam_ECDSA_end;
      }

      clearerrors(&T, audioshutdown->curveType);
      if ((0 == T.bits) || (initialdomain(&T, &Qa)))
      {
         goto _SharkSslECDSAParam_ECDSA_end;
      }

      unassignedvector(&S, &w);
      iommumapping(&w, &G.order);
      hotplugpgtable(&w, &e, &u1);
      suspendfinish(&u1, &G.order);
      hotplugpgtable(&w, &R, &u2);
      suspendfinish(&u2, &G.order);
      if (directalloc(&G, &u1, &T, &u2, &point))
      {
         goto _SharkSslECDSAParam_ECDSA_end;
      }
      keypaddevice(&point.x, &R, &G.order);

      
      if (eventtimeout(&point.x))
      {
         offsetarray = 0;  
      }
   }

   _SharkSslECDSAParam_ECDSA_end:
   baFree(afterhandler);
   return offsetarray;
}
#endif  


#if (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSAKEY_CREATE)
SHARKSSL_API int SharkSslRSAKey_create(SharkSslRSAKey *mcbspplatform, U16 blake2bupdate)
{
   static const U8 patchimm64[4] = {0x00, 0x01, 0x00, 0x01};  
   
   static const shtype_tWord one = 1;
   shtype_t P, Q, N, H, G, E, DP, DQ, QP, ONE;
   U8 *afterhandler, *p;
   int i, sffsdrnandflash = 0;
   U16 writeuncached = (blake2bupdate >> 1);

   *mcbspplatform = NULL;

   
   if (blake2bupdate & ((SHARKSSL_BIGINT_WORDSIZE << 1) - 1))
   {
      return -1;
   }

   p = afterhandler = (U8*)baMalloc((sizeof(patchimm64)/sizeof(patchimm64[0])) + (blake2bupdate >> 4) + (blake2bupdate >> 2) + (blake2bupdate >> 1));
   if (afterhandler == NULL)
   {
      return -2;
   }

   onenandpartitions(&ONE, SHARKSSL_BIGINT_WORDSIZE, &one);
   onenandpartitions(&P, writeuncached, p);
   p += (writeuncached >> 3);
   onenandpartitions(&Q, writeuncached, p);
   p += (writeuncached >> 3);
   onenandpartitions(&DP, writeuncached * 2, p);
   p += (writeuncached >> 2);
   onenandpartitions(&DQ, writeuncached * 2, p);
   p += (writeuncached >> 2);
   onenandpartitions(&QP, writeuncached, p);
   p += (writeuncached >> 3);
   onenandpartitions(&N, writeuncached * 2, p);
   p += (writeuncached >> 2);
   onenandpartitions(&H, writeuncached * 2, p);
   p += (writeuncached >> 2);
   onenandpartitions(&E, sizeof(patchimm64)*8, p);
   memmove_endianess(p, (const U8*)&patchimm64, (sizeof(patchimm64)/sizeof(patchimm64[0])));
   p += (sizeof(patchimm64)/sizeof(patchimm64[0]));
   onenandpartitions(&G, writeuncached * 2, p);

   for (;;)
   {
      if ( !sffsdrnandflash )
      {
         sffsdrnandflash = aemifdevice(&P);
      }

      if ( !sffsdrnandflash )
      {
         sffsdrnandflash = aemifdevice(&Q);
      }

      if ( sffsdrnandflash )
      {
         break;
      }

      if (timerwrite(&P, &Q))  
      {
         if (timerwrite(&Q, &P)) 
         {
            continue;
         }
      }
      else  
      {
         shtype_tWord *mem2, *beg2;

         
         beg2 = P.beg;
         mem2 = P.mem;
         P.beg = Q.beg;
         P.mem = Q.mem;
         Q.beg = beg2;
         Q.mem = mem2;

         P.len += Q.len;
         Q.len  = P.len - Q.len;
         P.len -= Q.len;
      }

      hotplugpgtable(&P, &Q, &N);
      if (0 == (N.beg[0] & (shtype_tWord)(1 << (SHARKSSL_BIGINT_WORDSIZE - 1))))
      {
         continue;
      }

      updatepmull(&P, &ONE);
      updatepmull(&Q, &ONE);
      
      hotplugpgtable(&P, &Q, &H);

      
      sffsdrnandflash = translateaddress(&H, &E, &G);
      if (sffsdrnandflash)
      {
         break;
      }

      if (timerwrite(&G, &ONE) && timerwrite(&ONE, &G))  
      {
         break;
      }
   }

   if ( !sffsdrnandflash )
   {
      
      unassignedvector(&E, &G);
      iommumapping(&G, &H);  
      unassignedvector(&G, &DP);
      unassignedvector(&G, &DQ);
      suspendfinish(&DP, &P);
      suspendfinish(&DQ, &Q);

      resolverelocs(&P, &ONE);
      resolverelocs(&Q, &ONE);
      unassignedvector(&Q, &QP);
      iommumapping(&QP, &P);

      writeuncached >>= 2;
      i = sizeof(patchimm64)/sizeof(patchimm64[0]);
      sffsdrnandflash = 8 + i + (writeuncached >> 1) + (writeuncached) + (writeuncached << 1);
      p = (U8*)baMalloc(sffsdrnandflash);
      if (p == NULL)
      {
         sffsdrnandflash = -2;
      }
      else
      {
         *mcbspplatform = p;
         p[0] = 0x30;
         p[1] = 0x82;
         p[2] = 0x00;
         p[3] = 0x00;
         p[4] = 0x00;
         p[5] = (U8)i;
         p[6] = (U8)(writeuncached >> 8);
         p[7] = (U8)writeuncached;
         p += 8;
         while (i--)
         {
            *(p + i) = patchimm64[i];
         }
         p += sizeof(patchimm64)/sizeof(patchimm64[0]);
         memmove_endianess(p, (U8*)consoledevice(&N), writeuncached);
         p += writeuncached;
         writeuncached >>= 1;
         memmove_endianess(p, (U8*)consoledevice(&P), writeuncached);
         p += writeuncached;
         memmove_endianess(p, (U8*)consoledevice(&Q), writeuncached);
         p += writeuncached;
         memmove_endianess(p, (U8*)consoledevice(&DP), writeuncached);
         p += writeuncached;
         memmove_endianess(p, (U8*)consoledevice(&DQ), writeuncached);
         p += writeuncached;
         memmove_endianess(p, (U8*)consoledevice(&QP), writeuncached);
      }
   }

   baFree(afterhandler);
   return sffsdrnandflash;
}


SHARKSSL_API U8 *SharkSslRSAKey_getPublic(SharkSslRSAKey mcbspplatform)
{
   SharkSslCertKey disableclock;

   if (interrupthandler(&disableclock, (SharkSslCert)mcbspplatform))
   {
      return disableclock.mod;
   }

   return NULL;
}
#endif  

#ifndef BA_LIB
#define BA_LIB
#endif

#include "SharkSslCrypto.h"

#include <string.h>

#define SHARKSSL_DIM_ARR(a)  (sizeof(a)/sizeof(a[0]))


#if (SHARKSSL_SSL_CLIENT_CODE || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_ENABLE_RSA || \
    (SHARKSSL_ENABLE_ECDSA && (!SHARKSSL_ECDSA_ONLY_VERIFY)))
#if (SHARKSSL_USE_RNG_TINYMT)

#define TINYMT32_INIT_MAT1 0xA5A6A7A8
#define TINYMT32_INIT_MAT2 0x12345678
#define TINYMT32_INIT_TMAT 0x55555555



#define branchdelay      127
#define backlightpower       1
#define contiguousreserve       10
#define aemifpdata       8
#define unmaptable      (U32)0x7FFFFFFFL
#define firstnonsched       (1.0f / 4294967296.0f)

#define kernelinstr           8
#define framecreation           8



typedef struct SharkSslRngCtx
{
    U32 status[4];
    U32 mat1;
    U32 mat2;
    U32 tmat;
    ThreadMutexBase mutex;
} SharkSslRngCtx;

static SharkSslRngCtx sharkSslRngCtx;


static void kernelenable(void)
{
    U32 x, y;

    y = sharkSslRngCtx.status[3];
    x = (sharkSslRngCtx.status[0] & unmaptable)	^ sharkSslRngCtx.status[1]	^ sharkSslRngCtx.status[2];
    x ^= (x << backlightpower);
    y ^= (y >> backlightpower) ^ x;
    sharkSslRngCtx.status[0] = sharkSslRngCtx.status[1];
    sharkSslRngCtx.status[1] = sharkSslRngCtx.status[2];
    sharkSslRngCtx.status[2] = x ^ (y << contiguousreserve);
    sharkSslRngCtx.status[3] = y;
    sharkSslRngCtx.status[1] ^= (U32)(0L -((U32)(y & 1))) & sharkSslRngCtx.mat1;
    sharkSslRngCtx.status[2] ^= (U32)(0L -((U32)(y & 1))) & sharkSslRngCtx.mat2;
}


static U32 classdevregister(void)
{
    U32 t0, t1;

    kernelenable();

    t0 = sharkSslRngCtx.status[3];
    t1 = sharkSslRngCtx.status[0] + (sharkSslRngCtx.status[2] >> aemifpdata);
    t0 ^= t1;
    t0 ^= (U32)(0L -((U32)(t1 & 1))) & sharkSslRngCtx.tmat;
    return t0;
}


static void templaterestore(void)
{
   U8 i;

   for (i = 1; i < kernelinstr; i++)
   {
      sharkSslRngCtx.status[i & 3] ^= i + (U32)(1812433253L) * (sharkSslRngCtx.status[(i - 1) & 3] ^ (sharkSslRngCtx.status[(i - 1) & 3] >> 30));
   }

   
   if ((sharkSslRngCtx.status[0] & unmaptable) == 0 &&
        sharkSslRngCtx.status[1] == 0 &&
        sharkSslRngCtx.status[2] == 0 &&
        sharkSslRngCtx.status[3] == 0)
   {
      sharkSslRngCtx.status[0] = '\124';
      sharkSslRngCtx.status[1] = '\111';
      sharkSslRngCtx.status[2] = '\116';
      sharkSslRngCtx.status[3] = '\131';
   }

   for (i = 0; i < framecreation; i++)
   {
	   kernelenable();
   }
}



static void enablecounter(U32 suspendblock)
{
   sharkSslRngCtx.status[0] = suspendblock;
   sharkSslRngCtx.status[1] = sharkSslRngCtx.mat1;
   sharkSslRngCtx.status[2] = sharkSslRngCtx.mat2;
   sharkSslRngCtx.status[3] = sharkSslRngCtx.tmat;

   templaterestore();
}


static void registerclkdms(U32 suspendblock)
{
   sharkSslRngCtx.mat1 = sharkSslRngCtx.mat2;
   sharkSslRngCtx.mat2 = sharkSslRngCtx.tmat;
   sharkSslRngCtx.tmat = suspendblock;

   templaterestore();
}
#undef framecreation
#undef kernelinstr
#undef branchdelay
#undef backlightpower
#undef contiguousreserve
#undef aemifpdata
#undef unmaptable
#undef firstnonsched


SHARKSSL_API int sharkssl_entropy(U32 deviceuevent)
{
   if (0 == sharkSslRngCtx.mat1)  
   {
      U8 i;

      #if SHARKSSL_RNG_MULTITHREADED
      ThreadMutex_constructor(&(sharkSslRngCtx.mutex));
      ThreadMutex_set(&(sharkSslRngCtx.mutex));
      #endif
      sharkSslRngCtx.mat1 = TINYMT32_INIT_MAT1;
      sharkSslRngCtx.mat2 = TINYMT32_INIT_MAT2;
      sharkSslRngCtx.tmat = TINYMT32_INIT_TMAT;
      enablecounter(deviceuevent);
      for (i = (U8)(classdevregister() & 0x7F); i > 0; i--)
      {
         registerclkdms(classdevregister());
      }
   }
   else
   {
      #if SHARKSSL_RNG_MULTITHREADED
      ThreadMutex_set(&(sharkSslRngCtx.mutex));
      #endif
   }
   registerclkdms(deviceuevent);
   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutex_release(&(sharkSslRngCtx.mutex));
   #endif
   return 0;
}
#undef TINYMT32_INIT_MAT1
#undef TINYMT32_INIT_MAT2
#undef TINYMT32_INIT_TMAT

#elif (SHARKSSL_USE_RNG_FORTUNA && SHARKSSL_USE_AES_256 && SHARKSSL_USE_SHA_256)



typedef struct SharkSslRngCtx
{
    U8 key[SHARKSSL_SHA256_HASH_LEN];
    U8 ctr[16];  /* AES_256_BLOCK_LEN */
    U8 blk[16];  /* AES_256_BLOCK_LEN */
    U32 cursor;
    #if SHARKSSL_RNG_MULTITHREADED
    ThreadMutexBase mutex;
    #endif
} SharkSslRngCtx;

static SharkSslRngCtx sharkSslRngCtx;  


static void uart0resource(void)
{
   register U8 i = 0;
   while (0 == ++sharkSslRngCtx.ctr[i])
   {
      i = (i + 1) & 0xF;  
   }
}


static U32 backlightconfig(void)
{
   register U8 *p = &sharkSslRngCtx.ctr[0];
   register U32 i = 16;

   while (i--)
   {
      if (*p++)
      {
         return 1;
      }
   }
   return 0;
}


static void dm9k0device(void)
{
   
   if (backlightconfig())
   {
      SharkSslAesCtx registermcasp;

      SharkSslAesCtx_constructor(&registermcasp, SharkSslAesCtx_Encrypt, sharkSslRngCtx.key, SHARKSSL_DIM_ARR(sharkSslRngCtx.key));
      SharkSslAesCtx_encrypt(&registermcasp, sharkSslRngCtx.ctr, sharkSslRngCtx.blk);
      SharkSslAesCtx_destructor(&registermcasp);
      sharkSslRngCtx.cursor = SHARKSSL_DIM_ARR(sharkSslRngCtx.blk);
      uart0resource();
   }
}


SHARKSSL_API int sharkssl_entropy(U32 deviceuevent)
{
   U8 suspendblock[4];
   SharkSslSha256Ctx registermcasp;

   inputlevel(deviceuevent, suspendblock, 0);
   SharkSslSha256Ctx_constructor(&registermcasp);
   #if SHARKSSL_RNG_MULTITHREADED
   if (!(backlightconfig()))  
   {
      ThreadMutex_constructor(&(sharkSslRngCtx.mutex));
   }
   ThreadMutex_set(&(sharkSslRngCtx.mutex));
   #endif
   SharkSslSha256Ctx_append(&registermcasp, sharkSslRngCtx.key, SHARKSSL_SHA256_HASH_LEN);
   SharkSslSha256Ctx_append(&registermcasp, suspendblock, SHARKSSL_DIM_ARR(suspendblock));
   SharkSslSha256Ctx_finish(&registermcasp, sharkSslRngCtx.key);
   uart0resource();
   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutex_release(&(sharkSslRngCtx.mutex));
   #endif
   return 0;
}


SHARKSSL_API int sharkssl_rng(U8 *ptr, U16 len)
{
   baAssert(ptr);
   baAssert((len) && (0 == (len & 0x3)));
   baAssert(len < (1 << 20));

   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutex_set(&(sharkSslRngCtx.mutex));
   #endif
   while (len >= 16)
   {
      dm9k0device();  
      memcpy(ptr, &sharkSslRngCtx.blk[0], 16);
      sharkSslRngCtx.cursor = 0;  
      ptr += 16;
      len -= 16;
   }
   while (len)
   {
      register U32 r;
      if (0 == sharkSslRngCtx.cursor)
      {
         dm9k0device();  
      }
      sharkSslRngCtx.cursor -= 4;
      r = (*(__sharkssl_packed U32*)&sharkSslRngCtx.blk[sharkSslRngCtx.cursor]);
      #ifndef B_LITTLE_ENDIAN
      inputlevel(r, ptr, 0);
      #else
      hsotgpdata(r, ptr, 0);
      #endif
      ptr += 4;
      len -= 4;
   }
   dm9k0device();  
   memcpy(&sharkSslRngCtx.key[0],  &sharkSslRngCtx.blk[0], 16);
   
   dm9k0device();
   memcpy(&sharkSslRngCtx.key[16], &sharkSslRngCtx.blk[0], 16);
   
   sharkSslRngCtx.cursor = 0;
   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutex_release(&(sharkSslRngCtx.mutex));
   #endif
   return 0;
}


#else  

typedef struct SharkSslRngCtx
{
   U32 randrsl[256];
   U32 randmem[256];
   U32 randa;
   U32 randb;
   U32 randc;
   U8  randcnt;
   U8  entropyIndex;
   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutexBase mutex;
   U8 mutexinit;
   #endif
} SharkSslRngCtx;


static SharkSslRngCtx  sharkSslRngCtx;


#define dcachedirty(mm,x) ((mm)[((x)>>2)&0xFF])
#define devicebuild(totalpages,a,b,mm,m,m2,r,x)  \
{                                     \
  x = *m;                             \
  a = ((a)^(totalpages)) + *(m2++);          \
  *(m++) = y = dcachedirty(mm,x) + (a) + (b); \
  *(r++) = b = dcachedirty(mm,(y)>>8) + (x);  \
}


static void doublefuito(void)
{
   register U32 a, b, x, y, *m, *mm, *m2, *r, *mend;

   mm = sharkSslRngCtx.randmem;
   r  = sharkSslRngCtx.randrsl;
   a  = sharkSslRngCtx.randa;
   b  = sharkSslRngCtx.randb + (++sharkSslRngCtx.randc);

   for (m = mm, mend = m2 = m + 128; m < mend; )
   {
      devicebuild( a<<13, a, b, mm, m, m2, r, x);
      devicebuild( a>>6 , a, b, mm, m, m2, r, x);
      devicebuild( a<<2 , a, b, mm, m, m2, r, x);
      devicebuild( a>>16, a, b, mm, m, m2, r, x);
   }

   for (m2 = mm; m2<mend; )
   {
      devicebuild( a<<13, a, b, mm, m, m2, r, x);
      devicebuild( a>>6 , a, b, mm, m, m2, r, x);
      devicebuild( a<<2 , a, b, mm, m, m2, r, x);
      devicebuild( a>>16, a, b, mm, m, m2, r, x);
   }

   sharkSslRngCtx.randb = b;
   sharkSslRngCtx.randa = a;
}


#define totalpages(a,b,c,d,e,f,g,h) \
{ \
   a^=b<<11; d+=a; b+=c; \
   b^=c>>2;  e+=b; c+=d; \
   c^=d<<8;  f+=c; d+=e; \
   d^=e>>16; g+=d; e+=f; \
   e^=f<<10; h+=e; f+=g; \
   f^=g>>4;  a+=f; g+=h; \
   g^=h<<8;  b+=g; h+=a; \
   h^=a>>9;  c+=h; a+=b; \
}


static void eventoverflow(void)
{
   U16 i;
   U32 a , b, c, d, e, f, g, h, *m, *r;

   sharkSslRngCtx.randa = sharkSslRngCtx.randb = sharkSslRngCtx.randc = 0;
   m = sharkSslRngCtx.randmem;
   r = sharkSslRngCtx.randrsl;
   a = b = c = d = e = f = g = h = 0x9e3779b9;

   for (i=0; i<4; ++i)          
   {
      totalpages(a,b,c,d,e,f,g,h);
   }

   
   for (i=0; i<256; i+=8)
   {
      a+=r[i  ]; b+=r[i+1]; c+=r[i+2]; d+=r[i+3];
      e+=r[i+4]; f+=r[i+5]; g+=r[i+6]; h+=r[i+7];
      totalpages(a,b,c,d,e,f,g,h);
      m[i  ]=a; m[i+1]=b; m[i+2]=c; m[i+3]=d;
      m[i+4]=e; m[i+5]=f; m[i+6]=g; m[i+7]=h;
   }

   
   for (i=0; i<256; i+=8)
   {
       a+=m[i  ]; b+=m[i+1]; c+=m[i+2]; d+=m[i+3];
       e+=m[i+4]; f+=m[i+5]; g+=m[i+6]; h+=m[i+7];
       totalpages(a,b,c,d,e,f,g,h);
       m[i  ]=a; m[i+1]=b; m[i+2]=c; m[i+3]=d;
       m[i+4]=e; m[i+5]=f; m[i+6]=g; m[i+7]=h;
   }

   doublefuito();
}


static U32 classdevregister(void)
{
   register U32 doublefcmpz;

   if ((sharkSslRngCtx.randcnt & 0xFF) == 0)
   {
      doublefuito();
   }
   doublefcmpz = sharkSslRngCtx.randrsl[(--sharkSslRngCtx.randcnt) & 0xFF];

   return doublefcmpz;
}


#undef totalpages
#undef devicebuild
#undef dcachedirty


SHARKSSL_API int sharkssl_entropy(U32 deviceuevent)
{
   #if SHARKSSL_RNG_MULTITHREADED
   if (!sharkSslRngCtx.mutexinit)
   {
      ThreadMutex_constructor(&(sharkSslRngCtx.mutex));
      ThreadMutex_set(&(sharkSslRngCtx.mutex));
      sharkSslRngCtx.mutexinit++;
   }
   else
   {
      ThreadMutex_set(&(sharkSslRngCtx.mutex));
   }
   #endif
   sharkSslRngCtx.randrsl[(sharkSslRngCtx.entropyIndex++) & 0xFF] = deviceuevent;
   eventoverflow();
   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutex_release(&(sharkSslRngCtx.mutex));
   #endif
   return 0;
}

#endif


#if (SHARKSSL_USE_RNG_TINYMT || (!SHARKSSL_USE_RNG_FORTUNA))
SHARKSSL_API int sharkssl_rng(U8 *ptr, U16 len)
{
   baAssert(ptr);
   baAssert((len) && (0 == (len & 0x3)));

   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutex_set(&(sharkSslRngCtx.mutex));
   #endif
   while (len)
   {
      register U32 r = classdevregister();
      #ifndef B_LITTLE_ENDIAN
      inputlevel(r, ptr, 0);
      #else
      hsotgpdata(r, ptr, 0);
      #endif
      ptr += 4;
      len -= 4;
   }
   #if SHARKSSL_RNG_MULTITHREADED
   ThreadMutex_release(&(sharkSslRngCtx.mutex));
   #endif
   return 0;
}
#endif
#endif  


#if (SHARKSSL_USE_MD5 || SHARKSSL_USE_SHA1 || SHARKSSL_USE_SHA_256 || SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
#if (SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
static const U8 prusspdata[128] =
#else
static const U8 prusspdata[64] =
#endif
{
   0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#if (SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#endif
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
#endif


#if SHARKSSL_USE_MD5

#if SHARKSSL_MD5_SMALL_FOOTPRINT
static const U32 unregisterclient[64] =
{
   0xD76AA478, 0xE8C7B756, 0x242070DB, 0xC1BDCEEE,
   0xF57C0FAF, 0x4787C62A, 0xA8304613, 0xFD469501,
   0x698098D8, 0x8B44F7AF, 0xFFFF5BB1, 0x895CD7BE,
   0x6B901122, 0xFD987193, 0xA679438E, 0x49B40821,
   0xF61E2562, 0xC040B340, 0x265E5A51, 0xE9B6C7AA,
   0xD62F105D, 0x02441453, 0xD8A1E681, 0xE7D3FBC8,
   0x21E1CDE6, 0xC33707D6, 0xF4D50D87, 0x455A14ED,
   0xA9E3E905, 0xFCEFA3F8, 0x676F02D9, 0x8D2A4C8A,
   0xFFFA3942, 0x8771F681, 0x6D9D6122, 0xFDE5380C,
   0xA4BEEA44, 0x4BDECFA9, 0xF6BB4B60, 0xBEBFBC70,
   0x289B7EC6, 0xEAA127FA, 0xD4EF3085, 0x04881D05,
   0xD9D4D039, 0xE6DB99E5, 0x1FA27CF8, 0xC4AC5665,
   0xF4292244, 0x432AFF97, 0xAB9423A7, 0xFC93A039,
   0x655B59C3, 0x8F0CCC92, 0xFFEFF47D, 0x85845DD1,
   0x6FA87E4F, 0xFE2CE6E0, 0xA3014314, 0x4E0811A1,
   0xF7537E82, 0xBD3AF235, 0x2AD7D2BB, 0xEB86D391
};

static const U8 keypadresources[64] =
{
   7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,
   5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,
   4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,
   6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21
};

static const U8 writefeature[64] =
{
   0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
   1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,
   5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,
   0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9
};
#endif


#ifndef B_LITTLE_ENDIAN
static void kexecalloc(SharkSslMd5Ctx *registermcasp, const U8 alloccontroller[64])
#else
static void kexecalloc(SharkSslMd5Ctx *registermcasp, U32 countshift[16])
#endif
{
   U32 a, b, c, d;
   #if SHARKSSL_MD5_SMALL_FOOTPRINT
   const U32 *p;
   unsigned int i;
   #endif

   #ifndef B_LITTLE_ENDIAN
   U32 countshift[16];

   #if SHARKSSL_MD5_SMALL_FOOTPRINT
   for (i = 0; !(i & 16); i++)
   {
      cleanupcount(countshift[i], alloccontroller, (i << 2));
   }
   #else
   cleanupcount(countshift[0],  alloccontroller,  0);
   cleanupcount(countshift[1],  alloccontroller,  4);
   cleanupcount(countshift[2],  alloccontroller,  8);
   cleanupcount(countshift[3],  alloccontroller, 12);
   cleanupcount(countshift[4],  alloccontroller, 16);
   cleanupcount(countshift[5],  alloccontroller, 20);
   cleanupcount(countshift[6],  alloccontroller, 24);
   cleanupcount(countshift[7],  alloccontroller, 28);
   cleanupcount(countshift[8],  alloccontroller, 32);
   cleanupcount(countshift[9],  alloccontroller, 36);
   cleanupcount(countshift[10], alloccontroller, 40);
   cleanupcount(countshift[11], alloccontroller, 44);
   cleanupcount(countshift[12], alloccontroller, 48);
   cleanupcount(countshift[13], alloccontroller, 52);
   cleanupcount(countshift[14], alloccontroller, 56);
   cleanupcount(countshift[15], alloccontroller, 60);
   #endif
   #endif

   #define invalidcontext(x,n) ((U32)((U32)x << n) | ((U32)x >> (32 - n)))

   #define F(x,y,z) ((x & (y ^ z)) ^ z)  
   #define G(x,y,z) ((z & (x ^ y)) ^ y)  
   #define H(x,y,z) (x ^ y ^ z)
   #define I(x,y,z) (y ^ (x | ~z))

   a = registermcasp->state[0];
   b = registermcasp->state[1];
   c = registermcasp->state[2];
   d = registermcasp->state[3];

   #if SHARKSSL_MD5_SMALL_FOOTPRINT
   p = &unregisterclient[0];

   for (i = 0; (0 == (i & 0x40)); i++)
   {
      U32 e;

      a += countshift[writefeature[i]] + *p++;
      switch (i & 0x30)
      {
         case 0x00:
            a += F(b,c,d);
            break;

         case 0x10:
            a += G(b,c,d);
            break;

         case 0x20:
            a += H(b,c,d);
            break;

         default:
            a += I(b,c,d);
            break;
      }
      a = invalidcontext(a, keypadresources[i]);
      e = b;
      b += a;
      a = d;
      d = c;
      c = e;
   }

   #else  
   #define FF(A, B, C, D, X, S, K) { A += F(B,C,D) + X + K; A = invalidcontext(A,S) + B; }
   #define privilegefault(A, B, C, D, X, S, K) { A += G(B,C,D) + X + K; A = invalidcontext(A,S) + B; }
   #define alternativesapplied(A, B, C, D, X, S, K) { A += H(B,C,D) + X + K; A = invalidcontext(A,S) + B; }
   #define hsmmc3resource(A, B, C, D, X, S, K) { A += I(B,C,D) + X + K; A = invalidcontext(A,S) + B; }

   FF(a, b, c, d, countshift[0],   7, 0xD76AA478);
   FF(d, a, b, c, countshift[1],  12, 0xE8C7B756);
   FF(c, d, a, b, countshift[2],  17, 0x242070DB);
   FF(b, c, d, a, countshift[3],  22, 0xC1BDCEEE);
   FF(a, b, c, d, countshift[4],   7, 0xF57C0FAF);
   FF(d, a, b, c, countshift[5],  12, 0x4787C62A);
   FF(c, d, a, b, countshift[6],  17, 0xA8304613);
   FF(b, c, d, a, countshift[7],  22, 0xFD469501);
   FF(a, b, c, d, countshift[8],   7, 0x698098D8);
   FF(d, a, b, c, countshift[9],  12, 0x8B44F7AF);
   FF(c, d, a, b, countshift[10], 17, 0xFFFF5BB1);
   FF(b, c, d, a, countshift[11], 22, 0x895CD7BE);
   FF(a, b, c, d, countshift[12],  7, 0x6B901122);
   FF(d, a, b, c, countshift[13], 12, 0xFD987193);
   FF(c, d, a, b, countshift[14], 17, 0xA679438E);
   FF(b, c, d, a, countshift[15], 22, 0x49B40821);

   privilegefault(a, b, c, d, countshift[1],   5, 0xF61E2562);
   privilegefault(d, a, b, c, countshift[6],   9, 0xC040B340);
   privilegefault(c, d, a, b, countshift[11], 14, 0x265E5A51);
   privilegefault(b, c, d, a, countshift[0],  20, 0xE9B6C7AA);
   privilegefault(a, b, c, d, countshift[5],   5, 0xD62F105D);
   privilegefault(d, a, b, c, countshift[10],  9, 0x02441453);
   privilegefault(c, d, a, b, countshift[15], 14, 0xD8A1E681);
   privilegefault(b, c, d, a, countshift[4],  20, 0xE7D3FBC8);
   privilegefault(a, b, c, d, countshift[9],   5, 0x21E1CDE6);
   privilegefault(d, a, b, c, countshift[14],  9, 0xC33707D6);
   privilegefault(c, d, a, b, countshift[3],  14, 0xF4D50D87);
   privilegefault(b, c, d, a, countshift[8],  20, 0x455A14ED);
   privilegefault(a, b, c, d, countshift[13],  5, 0xA9E3E905);
   privilegefault(d, a, b, c, countshift[2],   9, 0xFCEFA3F8);
   privilegefault(c, d, a, b, countshift[7],  14, 0x676F02D9);
   privilegefault(b, c, d, a, countshift[12], 20, 0x8D2A4C8A);

   alternativesapplied(a, b, c, d, countshift[5],   4, 0xFFFA3942);
   alternativesapplied(d, a, b, c, countshift[8],  11, 0x8771F681);
   alternativesapplied(c, d, a, b, countshift[11], 16, 0x6D9D6122);
   alternativesapplied(b, c, d, a, countshift[14], 23, 0xFDE5380C);
   alternativesapplied(a, b, c, d, countshift[1],   4, 0xA4BEEA44);
   alternativesapplied(d, a, b, c, countshift[4],  11, 0x4BDECFA9);
   alternativesapplied(c, d, a, b, countshift[7],  16, 0xF6BB4B60);
   alternativesapplied(b, c, d, a, countshift[10], 23, 0xBEBFBC70);
   alternativesapplied(a, b, c, d, countshift[13],  4, 0x289B7EC6);
   alternativesapplied(d, a, b, c, countshift[0],  11, 0xEAA127FA);
   alternativesapplied(c, d, a, b, countshift[3],  16, 0xD4EF3085);
   alternativesapplied(b, c, d, a, countshift[6],  23, 0x04881D05);
   alternativesapplied(a, b, c, d, countshift[9],   4, 0xD9D4D039);
   alternativesapplied(d, a, b, c, countshift[12], 11, 0xE6DB99E5);
   alternativesapplied(c, d, a, b, countshift[15], 16, 0x1FA27CF8);
   alternativesapplied(b, c, d, a, countshift[2],  23, 0xC4AC5665);

   hsmmc3resource(a, b, c, d, countshift[0],   6, 0xF4292244);
   hsmmc3resource(d, a, b, c, countshift[7],  10, 0x432AFF97);
   hsmmc3resource(c, d, a, b, countshift[14], 15, 0xAB9423A7);
   hsmmc3resource(b, c, d, a, countshift[5],  21, 0xFC93A039);
   hsmmc3resource(a, b, c, d, countshift[12],  6, 0x655B59C3);
   hsmmc3resource(d, a, b, c, countshift[3],  10, 0x8F0CCC92);
   hsmmc3resource(c, d, a, b, countshift[10], 15, 0xFFEFF47D);
   hsmmc3resource(b, c, d, a, countshift[1],  21, 0x85845DD1);
   hsmmc3resource(a, b, c, d, countshift[8],   6, 0x6FA87E4F);
   hsmmc3resource(d, a, b, c, countshift[15], 10, 0xFE2CE6E0);
   hsmmc3resource(c, d, a, b, countshift[6],  15, 0xA3014314);
   hsmmc3resource(b, c, d, a, countshift[13], 21, 0x4E0811A1);
   hsmmc3resource(a, b, c, d, countshift[4],   6, 0xF7537E82);
   hsmmc3resource(d, a, b, c, countshift[11], 10, 0xBD3AF235);
   hsmmc3resource(c, d, a, b, countshift[2],  15, 0x2AD7D2BB);
   hsmmc3resource(b, c, d, a, countshift[9],  21, 0xEB86D391);

   #undef hsmmc3resource
   #undef alternativesapplied
   #undef privilegefault
   #undef FF
   #endif

   registermcasp->state[0] += a;
   registermcasp->state[1] += b;
   registermcasp->state[2] += c;
   registermcasp->state[3] += d;


   #undef I
   #undef H
   #undef G
   #undef F

   #undef invalidcontext
}


SHARKSSL_API void SharkSslMd5Ctx_constructor(SharkSslMd5Ctx *registermcasp)
{
   baAssert(((unsigned int)(UPTR)(registermcasp->buffer) & (sizeof(int)-1)) == 0);

   registermcasp->total[0] = 0;
   registermcasp->total[1] = 0;

   registermcasp->state[0] = 0x67452301;
   registermcasp->state[1] = 0xEFCDAB89;
   registermcasp->state[2] = 0x98BADCFE;
   registermcasp->state[3] = 0x10325476;
}


SHARKSSL_API void SharkSslMd5Ctx_append(SharkSslMd5Ctx *registermcasp, const U8 *in, U32 len)
{
   unsigned int dm9000platdata, pxa300evalboard;

   dm9000platdata = (unsigned int)(registermcasp->total[0]) & 0x3F;
   pxa300evalboard = 64 - dm9000platdata;

   registermcasp->total[0] += len;
   if (registermcasp->total[0] < len)
   {
      registermcasp->total[1]++;
   }

   if((dm9000platdata) && (len >= pxa300evalboard))
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, pxa300evalboard);
      #ifndef B_LITTLE_ENDIAN
      kexecalloc(registermcasp, registermcasp->buffer);
      #else
      kexecalloc(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= pxa300evalboard;
      in  += pxa300evalboard;
      dm9000platdata = 0;
   }

   while (len >= 64)
   {
      #ifndef B_LITTLE_ENDIAN
      kexecalloc(registermcasp, in);
      #else
      memcpy(registermcasp->buffer, in, 64);
      kexecalloc(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= 64;
      in  += 64;
   }

   if (len)
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, len);
   }
}


SHARKSSL_API void SharkSslMd5Ctx_finish(SharkSslMd5Ctx *registermcasp, U8 secondaryentry[SHARKSSL_MD5_HASH_LEN])
{
   U32 timerenable, dummywrites;
   U32 timer0start, checkcontext;
   U8  usbgadgetresource[8];

   timer0start = (registermcasp->total[0] >> 29) | (registermcasp->total[1] <<  3);
   checkcontext  = (registermcasp->total[0] <<  3);

   hsotgpdata(checkcontext,  usbgadgetresource, 0);
   hsotgpdata(timer0start, usbgadgetresource, 4);

   timerenable = registermcasp->total[0] & 0x3F;
   dummywrites = (timerenable < 56) ? (56 - timerenable) : (120 - timerenable);

   SharkSslMd5Ctx_append(registermcasp, (U8*)prusspdata, dummywrites);
   SharkSslMd5Ctx_append(registermcasp, usbgadgetresource, 8);

   hsotgpdata(registermcasp->state[0], secondaryentry,  0);
   hsotgpdata(registermcasp->state[1], secondaryentry,  4);
   hsotgpdata(registermcasp->state[2], secondaryentry,  8);
   hsotgpdata(registermcasp->state[3], secondaryentry, 12);
}


SHARKSSL_API int sharkssl_md5(const U8* alloccontroller, U16 len, U8 *secondaryentry)
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslMd5Ctx *hctx = (SharkSslMd5Ctx *)baMalloc(claimresource(sizeof(SharkSslMd5Ctx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }
   #else
   SharkSslMd5Ctx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(secondaryentry);

   SharkSslMd5Ctx_constructor(hctx);
   SharkSslMd5Ctx_append(hctx, alloccontroller, len);
   SharkSslMd5Ctx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


#if SHARKSSL_USE_SHA1

#ifndef B_BIG_ENDIAN
static void irqwakeintallow(SharkSslSha1Ctx *registermcasp, const U8 alloccontroller[64])
#else
static void irqwakeintallow(SharkSslSha1Ctx *registermcasp, U32 countshift[16])
#endif
{
   U32 a, b, c, d, e, brightnesslimit;
   #if SHARKSSL_SHA1_SMALL_FOOTPRINT
   unsigned int i;
   #endif
   #ifndef B_BIG_ENDIAN
   U32 countshift[16];

   #if SHARKSSL_SHA1_SMALL_FOOTPRINT
   for (i = 0; !(i & 16); i++)
   {
      read64uint32(countshift[i], alloccontroller, (i << 2));
   }
   #else
   read64uint32(countshift[0],  alloccontroller,  0);
   read64uint32(countshift[1],  alloccontroller,  4);
   read64uint32(countshift[2],  alloccontroller,  8);
   read64uint32(countshift[3],  alloccontroller, 12);
   read64uint32(countshift[4],  alloccontroller, 16);
   read64uint32(countshift[5],  alloccontroller, 20);
   read64uint32(countshift[6],  alloccontroller, 24);
   read64uint32(countshift[7],  alloccontroller, 28);
   read64uint32(countshift[8],  alloccontroller, 32);
   read64uint32(countshift[9],  alloccontroller, 36);
   read64uint32(countshift[10], alloccontroller, 40);
   read64uint32(countshift[11], alloccontroller, 44);
   read64uint32(countshift[12], alloccontroller, 48);
   read64uint32(countshift[13], alloccontroller, 52);
   read64uint32(countshift[14], alloccontroller, 56);
   read64uint32(countshift[15], alloccontroller, 60);
   #endif
   #endif

   #define invalidcontext(x,n) ((U32)((U32)x << n) | ((U32)x >> (32 - n)))

   #define pwdowninverted(x,y,z) ((x & (y ^ z)) ^ z)  
   #define configparse(x,y,z) (x ^ y ^ z)
   #define emulationhandler(x,y,z) ((x & y) | ((x | y) & z))
   #define es3plushwmod(x,y,z) (x ^ y ^ z)

   #define serial0pdata 0x5A827999
   #define registerrproc 0x6ED9EBA1
   #define powergpiod 0x8F1BBCDC
   #define allockernel 0xCA62C1D6

   a = registermcasp->state[0];
   b = registermcasp->state[1];
   c = registermcasp->state[2];
   d = registermcasp->state[3];
   e = registermcasp->state[4];

   #if SHARKSSL_SHA1_SMALL_FOOTPRINT
   for (i = 0; i < 80; i++)
   {
      if (i >= 16)
      {
         brightnesslimit = countshift[i & 0xF] ^ countshift[(i + 2) & 0xF] ^ countshift[(i + 8) & 0xF] ^ countshift[(i + 13) & 0xF];
         countshift[i & 0xF] = brightnesslimit = invalidcontext(brightnesslimit, 1);
      }
      brightnesslimit = countshift[i & 0xF];
      brightnesslimit += e + invalidcontext(a, 5);
      if (i < 20)
      {
         brightnesslimit += pwdowninverted(b,c,d) + serial0pdata;
      }
      else if (i < 40)
      {
         brightnesslimit += configparse(b,c,d) + registerrproc;
      }
      else if (i < 60)
      {
         brightnesslimit += emulationhandler(b,c,d) + powergpiod;
      }
      else
      {
         brightnesslimit += es3plushwmod(b,c,d) + allockernel;
      }
      e = d;
      d = c;
      c = invalidcontext(b, 30);
      b = a;
      a = brightnesslimit;
   }

   #else  
                                   e += (countshift[0]                ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
                                   d += (countshift[1]                ) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
                                   c += (countshift[2]                ) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
                                   b += (countshift[3]                ) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
                                   a += (countshift[4]                ) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

                                   e += (countshift[5]                ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
                                   d += (countshift[6]                ) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
                                   c += (countshift[7]                ) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
                                   b += (countshift[8]                ) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
                                   a += (countshift[9]                ) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

                                   e += (countshift[10]               ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
                                   d += (countshift[11]               ) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
                                   c += (countshift[12]               ) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
                                   b += (countshift[13]               ) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
                                   a += (countshift[14]               ) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

                                   e += (countshift[15]               ) + invalidcontext(a,5) + pwdowninverted(b,c,d) + serial0pdata; b = invalidcontext(b,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  d += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + pwdowninverted(a,b,c) + serial0pdata; a = invalidcontext(a,30);
   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  c += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + pwdowninverted(e,a,b) + serial0pdata; e = invalidcontext(e,30);
   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  b += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + pwdowninverted(d,e,a) + serial0pdata; d = invalidcontext(d,30);
   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  a += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + pwdowninverted(c,d,e) + serial0pdata; c = invalidcontext(c,30);

   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  e += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  d += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  c += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  b += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  a += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  e += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; d += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; c += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; b += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; a += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; e += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; d += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  c += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  b += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  a += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  e += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + configparse(b,c,d) + registerrproc; b = invalidcontext(b,30);
   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  d += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + configparse(a,b,c) + registerrproc; a = invalidcontext(a,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  c += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + configparse(e,a,b) + registerrproc; e = invalidcontext(e,30);
   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  b += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + configparse(d,e,a) + registerrproc; d = invalidcontext(d,30);
   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  a += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + configparse(c,d,e) + registerrproc; c = invalidcontext(c,30);

   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  e += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  d += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; c += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; b += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; a += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; e += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; d += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; c += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  b += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  a += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  e += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  d += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  c += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  b += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  a += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  e += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + emulationhandler(b,c,d) + powergpiod; b = invalidcontext(b,30);
   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  d += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + emulationhandler(a,b,c) + powergpiod; a = invalidcontext(a,30);
   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  c += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + emulationhandler(e,a,b) + powergpiod; e = invalidcontext(e,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; b += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + emulationhandler(d,e,a) + powergpiod; d = invalidcontext(d,30);
   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; a += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + emulationhandler(c,d,e) + powergpiod; c = invalidcontext(c,30);

   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; e += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; d += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; c += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; b += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[13]^countshift[8] ^countshift[2] ^countshift[0];  a += (countshift[0]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);

   brightnesslimit = countshift[14]^countshift[9] ^countshift[3] ^countshift[1];  e += (countshift[1]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[15]^countshift[10]^countshift[4] ^countshift[2];  d += (countshift[2]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[0] ^countshift[11]^countshift[5] ^countshift[3];  c += (countshift[3]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[1] ^countshift[12]^countshift[6] ^countshift[4];  b += (countshift[4]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[2] ^countshift[13]^countshift[7] ^countshift[5];  a += (countshift[5]  = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);

   brightnesslimit = countshift[3] ^countshift[14]^countshift[8] ^countshift[6];  e += (countshift[6]  = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[4] ^countshift[15]^countshift[9] ^countshift[7];  d += (countshift[7]  = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[5] ^countshift[0] ^countshift[10]^countshift[8];  c += (countshift[8]  = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[6] ^countshift[1] ^countshift[11]^countshift[9];  b += (countshift[9]  = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[7] ^countshift[2] ^countshift[12]^countshift[10]; a += (countshift[10] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);

   brightnesslimit = countshift[8] ^countshift[3] ^countshift[13]^countshift[11]; e += (countshift[11] = invalidcontext(brightnesslimit,1)) + invalidcontext(a,5) + es3plushwmod(b,c,d) + allockernel; b = invalidcontext(b,30);
   brightnesslimit = countshift[9] ^countshift[4] ^countshift[14]^countshift[12]; d += (countshift[12] = invalidcontext(brightnesslimit,1)) + invalidcontext(e,5) + es3plushwmod(a,b,c) + allockernel; a = invalidcontext(a,30);
   brightnesslimit = countshift[10]^countshift[5] ^countshift[15]^countshift[13]; c += (countshift[13] = invalidcontext(brightnesslimit,1)) + invalidcontext(d,5) + es3plushwmod(e,a,b) + allockernel; e = invalidcontext(e,30);
   brightnesslimit = countshift[11]^countshift[6] ^countshift[0] ^countshift[14]; b += (countshift[14] = invalidcontext(brightnesslimit,1)) + invalidcontext(c,5) + es3plushwmod(d,e,a) + allockernel; d = invalidcontext(d,30);
   brightnesslimit = countshift[12]^countshift[7] ^countshift[1] ^countshift[15]; a += (countshift[15] = invalidcontext(brightnesslimit,1)) + invalidcontext(b,5) + es3plushwmod(c,d,e) + allockernel; c = invalidcontext(c,30);
   #endif

   registermcasp->state[0] += a;
   registermcasp->state[1] += b;
   registermcasp->state[2] += c;
   registermcasp->state[3] += d;
   registermcasp->state[4] += e;

   #undef allockernel
   #undef powergpiod
   #undef registerrproc
   #undef serial0pdata

   #undef es3plushwmod
   #undef emulationhandler
   #undef configparse
   #undef pwdowninverted

   #undef invalidcontext
}


SHARKSSL_API void SharkSslSha1Ctx_constructor(SharkSslSha1Ctx *registermcasp)
{
   baAssert(((unsigned int)(UPTR)(registermcasp->buffer) & (sizeof(int)-1)) == 0);

   registermcasp->total[0] = 0;
   registermcasp->total[1] = 0;

   registermcasp->state[0] = 0x67452301;
   registermcasp->state[1] = 0xEFCDAB89;
   registermcasp->state[2] = 0x98BADCFE;
   registermcasp->state[3] = 0x10325476;
   registermcasp->state[4] = 0xC3D2E1F0;
}


SHARKSSL_API void SharkSslSha1Ctx_append(SharkSslSha1Ctx *registermcasp, const U8 *in, U32 len)
{
   unsigned int dm9000platdata, pxa300evalboard;

   dm9000platdata = (unsigned int)(registermcasp->total[0]) & 0x3F;
   pxa300evalboard = 64 - dm9000platdata;

   registermcasp->total[0] += len;
   if (registermcasp->total[0] < len)
   {
      registermcasp->total[1]++;
   }

   if((dm9000platdata) && (len >= pxa300evalboard))
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, pxa300evalboard);
      #ifndef B_BIG_ENDIAN
      irqwakeintallow(registermcasp, registermcasp->buffer);
      #else
      irqwakeintallow(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= pxa300evalboard;
      in  += pxa300evalboard;
      dm9000platdata = 0;
   }

   while (len >= 64)
   {
      #ifndef B_BIG_ENDIAN
      irqwakeintallow(registermcasp, in);
      #else
      memcpy(registermcasp->buffer, in, 64);
      irqwakeintallow(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= 64;
      in  += 64;
   }

   if (len)
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, len);
   }
}


SHARKSSL_API void SharkSslSha1Ctx_finish(SharkSslSha1Ctx *registermcasp, U8 secondaryentry[SHARKSSL_SHA1_HASH_LEN])
{
   U32 timerenable, dummywrites;
   U32 timer0start, checkcontext;
   U8  usbgadgetresource[8];

   timer0start = (registermcasp->total[0] >> 29) | (registermcasp->total[1] <<  3);
   checkcontext  = (registermcasp->total[0] <<  3);

   inputlevel(timer0start, usbgadgetresource, 0);
   inputlevel(checkcontext,  usbgadgetresource, 4);

   timerenable = registermcasp->total[0] & 0x3F;
   dummywrites = (timerenable < 56) ? (56 - timerenable) : (120 - timerenable);

   SharkSslSha1Ctx_append(registermcasp, (U8*)prusspdata, dummywrites);
   SharkSslSha1Ctx_append(registermcasp, usbgadgetresource, 8);

   inputlevel(registermcasp->state[0], secondaryentry,  0);
   inputlevel(registermcasp->state[1], secondaryentry,  4);
   inputlevel(registermcasp->state[2], secondaryentry,  8);
   inputlevel(registermcasp->state[3], secondaryentry, 12);
   inputlevel(registermcasp->state[4], secondaryentry, 16);
}


SHARKSSL_API int sharkssl_sha1(const U8 *alloccontroller, U16 len, U8 *secondaryentry)
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslSha1Ctx *hctx = (SharkSslSha1Ctx *)baMalloc(claimresource(sizeof(SharkSslSha1Ctx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }

   #else
   SharkSslSha1Ctx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(secondaryentry);

   SharkSslSha1Ctx_constructor(hctx);
   SharkSslSha1Ctx_append(hctx, alloccontroller, len);
   SharkSslSha1Ctx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


#if SHARKSSL_USE_SHA_256

static const U32 callchainentry[64] =
{
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
   0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
   0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
   0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
   0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
   0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
   0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
   0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
   0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};


#ifndef B_BIG_ENDIAN
static void alignmentfinish(SharkSslSha256Ctx *registermcasp, const U8 alloccontroller[64])
#else
static void alignmentfinish(SharkSslSha256Ctx *registermcasp, U32 countshift[16])
#endif
{
   U32 a, b, c, d, e, f, g, h, T1, T2;
   #if SHARKSSL_SHA256_SMALL_FOOTPRINT
   unsigned int i;
   #else
   const U32 *p;
   #endif
   #ifndef B_BIG_ENDIAN
   U32 countshift[16];

   #if SHARKSSL_SHA256_SMALL_FOOTPRINT
   for (i = 0; !(i & 16); i++)
   {
      read64uint32(countshift[i], alloccontroller, (i << 2));
   }
   #else
   read64uint32(countshift[0],  alloccontroller,  0);
   read64uint32(countshift[1],  alloccontroller,  4);
   read64uint32(countshift[2],  alloccontroller,  8);
   read64uint32(countshift[3],  alloccontroller, 12);
   read64uint32(countshift[4],  alloccontroller, 16);
   read64uint32(countshift[5],  alloccontroller, 20);
   read64uint32(countshift[6],  alloccontroller, 24);
   read64uint32(countshift[7],  alloccontroller, 28);
   read64uint32(countshift[8],  alloccontroller, 32);
   read64uint32(countshift[9],  alloccontroller, 36);
   read64uint32(countshift[10], alloccontroller, 40);
   read64uint32(countshift[11], alloccontroller, 44);
   read64uint32(countshift[12], alloccontroller, 48);
   read64uint32(countshift[13], alloccontroller, 52);
   read64uint32(countshift[14], alloccontroller, 56);
   read64uint32(countshift[15], alloccontroller, 60);
   #endif
   #endif

   #define invalidcontext(x,n)  ((U32)((U32)x << n) | ((U32)x >> (32 - n)))
   #define SHR(x,n)   ((U32)((U32)x >> n))
   #define CH(x,y,z)  ((x & (y ^ z)) ^ z)
   #define MAJ(x,y,z) ((x & y) | ((x | y) & z))
   #define injectundefined(x)  (invalidcontext(x, 30) ^ invalidcontext(x, 19) ^ invalidcontext(x, 10))
   #define clearhighpage(x)  (invalidcontext(x, 26) ^ invalidcontext(x, 21) ^ invalidcontext(x, 7))
   #define joystickdisable(x)  (invalidcontext(x, 25) ^ invalidcontext(x, 14) ^ SHR(x, 3))
   #define sm501resources(x)  (invalidcontext(x, 15) ^ invalidcontext(x, 13) ^ SHR(x, 10))

   a = registermcasp->state[0];
   b = registermcasp->state[1];
   c = registermcasp->state[2];
   d = registermcasp->state[3];
   e = registermcasp->state[4];
   f = registermcasp->state[5];
   g = registermcasp->state[6];
   h = registermcasp->state[7];

   #if SHARKSSL_SHA256_SMALL_FOOTPRINT
   for (i = 0; (0 == (i & 0x40)); i++)
   {
      if (i >= 16)
      {
         T1 = countshift[(i + 1) & 0xF];
         T1 = joystickdisable(T1);
         T2 = countshift[(i + 14) & 0xF];
         T2 = sm501resources(T2);
         countshift[i & 0xF] += (countshift[(i + 9) & 0xF] + T1 + T2);
      }
      T1 = countshift[i & 0xF];
      T1 += callchainentry[i] + h + CH(e,f,g) + clearhighpage(e);
      T2 = MAJ(a,b,c) + injectundefined(a);
      h = g;
      g = f;
      f = e;
      e = d + T1;
      d = c;
      c = b;
      b = a;
      a = T1 + T2;
   }

   #else  
   #define mismatchedcache(i,a,b,c,d,e,f,g,h) do {  \
      T1 = clearhighpage(e);  \
      T2 = CH(e,f,g);  \
      h += countshift[(i) & 0xF] + T1 + T2 + (*p++); \
      d += h;  \
      T1 = injectundefined(a);  \
      T2 = MAJ(a,b,c);  \
      h += T1 + T2;  \
   } while (0)

   #define machinetable(i,a,b,c,d,e,f,g,h) do {  \
      T1 = countshift[((i) + 1) & 0xF];  \
      T1 = joystickdisable(T1);  \
      T2 = countshift[((i) + 14) & 0xF];  \
      T2 = sm501resources(T2);  \
      countshift[(i) & 0xF] += (countshift[((i) + 9) & 0xF] + T1 + T2);  \
      mismatchedcache(i,a,b,c,d,e,f,g,h);  \
   } while (0)

   p = &callchainentry[0];

   mismatchedcache( 0,a,b,c,d,e,f,g,h);
   mismatchedcache( 1,h,a,b,c,d,e,f,g);
   mismatchedcache( 2,g,h,a,b,c,d,e,f);
   mismatchedcache( 3,f,g,h,a,b,c,d,e);
   mismatchedcache( 4,e,f,g,h,a,b,c,d);
   mismatchedcache( 5,d,e,f,g,h,a,b,c);
   mismatchedcache( 6,c,d,e,f,g,h,a,b);
   mismatchedcache( 7,b,c,d,e,f,g,h,a);
   mismatchedcache( 8,a,b,c,d,e,f,g,h);
   mismatchedcache( 9,h,a,b,c,d,e,f,g);
   mismatchedcache(10,g,h,a,b,c,d,e,f);
   mismatchedcache(11,f,g,h,a,b,c,d,e);
   mismatchedcache(12,e,f,g,h,a,b,c,d);
   mismatchedcache(13,d,e,f,g,h,a,b,c);
   mismatchedcache(14,c,d,e,f,g,h,a,b);
   mismatchedcache(15,b,c,d,e,f,g,h,a);

   while (p < &callchainentry[63])  
   {
      machinetable( 0,a,b,c,d,e,f,g,h);
      machinetable( 1,h,a,b,c,d,e,f,g);
      machinetable( 2,g,h,a,b,c,d,e,f);
      machinetable( 3,f,g,h,a,b,c,d,e);
      machinetable( 4,e,f,g,h,a,b,c,d);
      machinetable( 5,d,e,f,g,h,a,b,c);
      machinetable( 6,c,d,e,f,g,h,a,b);
      machinetable( 7,b,c,d,e,f,g,h,a);
      machinetable( 8,a,b,c,d,e,f,g,h);
      machinetable( 9,h,a,b,c,d,e,f,g);
      machinetable(10,g,h,a,b,c,d,e,f);
      machinetable(11,f,g,h,a,b,c,d,e);
      machinetable(12,e,f,g,h,a,b,c,d);
      machinetable(13,d,e,f,g,h,a,b,c);
      machinetable(14,c,d,e,f,g,h,a,b);
      machinetable(15,b,c,d,e,f,g,h,a);
   }

   #undef mismatchedcache
   #undef machinetable
   #endif

   registermcasp->state[0] += a;
   registermcasp->state[1] += b;
   registermcasp->state[2] += c;
   registermcasp->state[3] += d;
   registermcasp->state[4] += e;
   registermcasp->state[5] += f;
   registermcasp->state[6] += g;
   registermcasp->state[7] += h;

   #undef sm501resources
   #undef joystickdisable
   #undef injectundefined
   #undef clearhighpage
   #undef MAJ
   #undef CH
   #undef SHR
   #undef invalidcontext
}


SHARKSSL_API void SharkSslSha256Ctx_constructor(SharkSslSha256Ctx *registermcasp)
{
   baAssert(((unsigned int)(UPTR)(registermcasp->buffer) & (sizeof(int)-1)) == 0);

   registermcasp->total[0] = 0;
   registermcasp->total[1] = 0;

   registermcasp->state[0] = 0x6A09E667;
   registermcasp->state[1] = 0xBB67AE85;
   registermcasp->state[2] = 0x3C6EF372;
   registermcasp->state[3] = 0xA54FF53A;
   registermcasp->state[4] = 0x510E527F;
   registermcasp->state[5] = 0x9B05688C;
   registermcasp->state[6] = 0x1F83D9AB;
   registermcasp->state[7] = 0x5BE0CD19;
}


SHARKSSL_API void SharkSslSha256Ctx_append(SharkSslSha256Ctx *registermcasp, const U8 *in, U32 len)
{
   unsigned int dm9000platdata, pxa300evalboard;

   dm9000platdata = (unsigned int)(registermcasp->total[0]) & 0x3F;
   pxa300evalboard = 64 - dm9000platdata;

   registermcasp->total[0] += len;
   if (registermcasp->total[0] < len)
   {
      registermcasp->total[1]++;
   }

   if((dm9000platdata) && (len >= pxa300evalboard))
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, pxa300evalboard);
      #ifndef B_BIG_ENDIAN
      alignmentfinish(registermcasp, registermcasp->buffer);
      #else
      alignmentfinish(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= pxa300evalboard;
      in  += pxa300evalboard;
      dm9000platdata = 0;
   }

   while (len >= 64)
   {
      #ifndef B_BIG_ENDIAN
      alignmentfinish(registermcasp, in);
      #else
      memcpy(registermcasp->buffer, in, 64);
      alignmentfinish(registermcasp, (U32*)(registermcasp->buffer));
      #endif
      len -= 64;
      in  += 64;
   }

   if (len)
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, len);
   }
}


SHARKSSL_API void SharkSslSha256Ctx_finish(SharkSslSha256Ctx *registermcasp, U8 secondaryentry[SHARKSSL_SHA256_HASH_LEN])
{
   U32 timerenable, dummywrites;
   U32 timer0start, checkcontext;
   U8  usbgadgetresource[8];

   timer0start = (registermcasp->total[0] >> 29) | (registermcasp->total[1] <<  3);
   checkcontext  = (registermcasp->total[0] <<  3);

   inputlevel(timer0start, usbgadgetresource, 0);
   inputlevel(checkcontext,  usbgadgetresource, 4);

   timerenable = registermcasp->total[0] & 0x3F;
   dummywrites = (timerenable < 56) ? (56 - timerenable) : (120 - timerenable);

   SharkSslSha256Ctx_append(registermcasp, (U8*)prusspdata, dummywrites);
   SharkSslSha256Ctx_append(registermcasp, usbgadgetresource, 8);

   inputlevel(registermcasp->state[0], secondaryentry,  0);
   inputlevel(registermcasp->state[1], secondaryentry,  4);
   inputlevel(registermcasp->state[2], secondaryentry,  8);
   inputlevel(registermcasp->state[3], secondaryentry, 12);
   inputlevel(registermcasp->state[4], secondaryentry, 16);
   inputlevel(registermcasp->state[5], secondaryentry, 20);
   inputlevel(registermcasp->state[6], secondaryentry, 24);
   inputlevel(registermcasp->state[7], secondaryentry, 28);
}


SHARKSSL_API int sharkssl_sha256(const U8 *alloccontroller, U16 len, U8 *secondaryentry)
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslSha256Ctx *hctx = (SharkSslSha256Ctx *)baMalloc(claimresource(sizeof(SharkSslSha256Ctx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }
   #else
   SharkSslSha256Ctx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(secondaryentry);

   SharkSslSha256Ctx_constructor(hctx);
   SharkSslSha256Ctx_append(hctx, alloccontroller, len);
   SharkSslSha256Ctx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


#if (SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)

static const U64 pxa270income[80] =
{
   0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
   0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL, 0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
   0xd807aa98a3030242ULL, 0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
   0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
   0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL, 0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
   0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
   0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
   0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL, 0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
   0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
   0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
   0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL, 0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
   0xd192e819d6ef5218ULL, 0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
   0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
   0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL, 0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
   0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
   0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
   0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, 0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
   0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
   0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
   0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL, 0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
};


static U64 injectundefined(U64 *x)
{
   U32 x1, x2, r1, r2;

   x1 = (U32)(*x >> 32);
   x2 = (U32)*x;
   r1 = (x1 >> 28) ^ (x1 << 30) ^ (x1 << 25) ^ (x2 << 4) ^ (x2 >> 2) ^ (x2 >> 7);
   r2 = (x2 >> 28) ^ (x2 << 30) ^ (x2 << 25) ^ (x1 << 4) ^ (x1 >> 2) ^ (x1 >> 7);

   return ((U64)r1 << 32) | r2;
}


static U64 clearhighpage(U64 *x)
{
   U32 x1, x2, r1, r2;

   x1 = (U32)(*x >> 32);
   x2 = (U32)*x;
   r1 = (x1 >> 14) ^ (x1 >> 18) ^ (x1 << 23) ^ (x2 << 18) ^ (x2 << 14) ^ (x2 >> 9);
   r2 = (x2 >> 14) ^ (x2 >> 18) ^ (x2 << 23) ^ (x1 << 18) ^ (x1 << 14) ^ (x1 >> 9);

   return ((U64)r1 << 32) | r2;
}


static U64 joystickdisable(U64 *x)
{
   U32 x1, x2, r1, r2;

   x1 = (U32)(*x >> 32);
   x2 = (U32)*x;
   r1 = (x1 >> 1) ^ (x1 >> 8) ^ (x1 >> 7) ^ (x2 << 31) ^ (x2 << 24);
   r2 = (x2 >> 1) ^ (x2 >> 8) ^ (x2 >> 7) ^ (x1 << 31) ^ (x1 << 24) ^ (x1 << 25);

   return ((U64)r1 << 32) | r2;
}


static U64 sm501resources(U64 *x)
{
   U32 x1, x2, r1, r2;

   x1 = (U32)(*x >> 32);
   x2 = (U32)*x;
   r1 = (x1 >> 19) ^ (x1 << 3) ^ (x1 >> 6) ^ (x2 << 13) ^ (x2 >> 29);
   r2 = (x2 >> 19) ^ (x2 << 3) ^ (x2 >> 6) ^ (x1 << 13) ^ (x1 >> 29) ^ (x1 << 26);

   return ((U64)r1 << 32) | r2;
}


#ifndef B_BIG_ENDIAN
static void pcimtresource(SharkSslSha384Ctx *registermcasp, const U8 alloccontroller[128])
#else
static void pcimtresource(SharkSslSha384Ctx *registermcasp, U64 countshift[16])
#endif
{
   U64 a, b, c, d, e, f, g, h, T1, T2;
   unsigned int i;
   #ifndef B_BIG_ENDIAN
   U64 countshift[16];

   detectboard(countshift[0],  alloccontroller,   0);
   detectboard(countshift[1],  alloccontroller,   8);
   detectboard(countshift[2],  alloccontroller,  16);
   detectboard(countshift[3],  alloccontroller,  24);
   detectboard(countshift[4],  alloccontroller,  32);
   detectboard(countshift[5],  alloccontroller,  40);
   detectboard(countshift[6],  alloccontroller,  48);
   detectboard(countshift[7],  alloccontroller,  56);
   detectboard(countshift[8],  alloccontroller,  64);
   detectboard(countshift[9],  alloccontroller,  72);
   detectboard(countshift[10], alloccontroller,  80);
   detectboard(countshift[11], alloccontroller,  88);
   detectboard(countshift[12], alloccontroller,  96);
   detectboard(countshift[13], alloccontroller, 104);
   detectboard(countshift[14], alloccontroller, 112);
   detectboard(countshift[15], alloccontroller, 120);
   #endif

   #define CH(x,y,z)  ((x & (y ^ z)) ^ z)
   #define MAJ(x,y,z) ((x & y) | ((x | y) & z))

   a = registermcasp->state[0];
   b = registermcasp->state[1];
   c = registermcasp->state[2];
   d = registermcasp->state[3];
   e = registermcasp->state[4];
   f = registermcasp->state[5];
   g = registermcasp->state[6];
   h = registermcasp->state[7];

   for (i = 0; i < 80; i++)
   {
      if (i >= 16)
      {
         countshift[i & 0xF] += countshift[(i + 9) & 0xF] + joystickdisable(&countshift[(i + 1) & 0xF]) + sm501resources(&countshift[(i + 14) & 0xF]);
      }
      T1 = countshift[i & 0xF] + pxa270income[i] + h + CH(e,f,g) + clearhighpage(&e);
      T2 = MAJ(a,b,c) + injectundefined(&a);
      h = g;
      g = f;
      f = e;
      e = d + T1;
      d = c;
      c = b;
      b = a;
      a = T1 + T2;
   }

   registermcasp->state[0] += a;
   registermcasp->state[1] += b;
   registermcasp->state[2] += c;
   registermcasp->state[3] += d;
   registermcasp->state[4] += e;
   registermcasp->state[5] += f;
   registermcasp->state[6] += g;
   registermcasp->state[7] += h;

   #undef MAJ
   #undef CH
}
#endif  


#if SHARKSSL_USE_SHA_384
SHARKSSL_API void SharkSslSha384Ctx_constructor(SharkSslSha384Ctx *registermcasp)
{
   baAssert(((unsigned int)(UPTR)(registermcasp->buffer) & (sizeof(int)-1)) == 0);

   registermcasp->total[0] = 0;
   registermcasp->total[1] = 0;
   registermcasp->total[2] = 0;
   registermcasp->total[3] = 0;

   registermcasp->state[0] = 0xCBBB9D5DC1059ED8ULL;
   registermcasp->state[1] = 0x629A292A367CD507ULL;
   registermcasp->state[2] = 0x9159015A3070DD17ULL;
   registermcasp->state[3] = 0x152FECD8F70E5939ULL;
   registermcasp->state[4] = 0x67332667FFC00B31ULL;
   registermcasp->state[5] = 0x8EB44A8768581511ULL;
   registermcasp->state[6] = 0xDB0C2E0D64F98FA7ULL;
   registermcasp->state[7] = 0x47B5481DBEFA4FA4ULL;
}
#endif


#if SHARKSSL_USE_SHA_512
SHARKSSL_API void SharkSslSha512Ctx_constructor(SharkSslSha512Ctx *registermcasp)
{
   baAssert(((unsigned int)(UPTR)(registermcasp->buffer) & (sizeof(int)-1)) == 0);

   registermcasp->total[0] = 0;
   registermcasp->total[1] = 0;
   registermcasp->total[2] = 0;
   registermcasp->total[3] = 0;

   registermcasp->state[0] = 0x6A09E667F3BCC908ULL;
   registermcasp->state[1] = 0xBB67AE8584CAA73BULL;
   registermcasp->state[2] = 0x3C6EF372FE94F82BULL;
   registermcasp->state[3] = 0xA54FF53A5F1D36F1ULL;
   registermcasp->state[4] = 0x510E527FADE682D1ULL;
   registermcasp->state[5] = 0x9B05688C2B3E6C1FULL;
   registermcasp->state[6] = 0x1F83D9ABFB41BD6BULL;
   registermcasp->state[7] = 0x5BE0CD19137E2179ULL;
}
#endif


#if (SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_512)
SHARKSSL_API void SharkSslSha384Ctx_append(SharkSslSha384Ctx *registermcasp, const U8 *in, U32 len)
{
   unsigned int dm9000platdata, pxa300evalboard;

   dm9000platdata = (unsigned int)(registermcasp->total[0]) & 0x7F;
   pxa300evalboard = 128 - dm9000platdata;

   registermcasp->total[0] += len;
   if (registermcasp->total[0] < len)
   {
      if (0 == ++registermcasp->total[1])
      {
         if (0 == ++registermcasp->total[2])
         {
            ++registermcasp->total[3];
         }
      }
   }

   if((dm9000platdata) && (len >= pxa300evalboard))
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, pxa300evalboard);
      #ifndef B_BIG_ENDIAN
      pcimtresource(registermcasp, registermcasp->buffer);
      #else
      pcimtresource(registermcasp, (U64*)(registermcasp->buffer));
      #endif
      len -= pxa300evalboard;
      in  += pxa300evalboard;
      dm9000platdata = 0;
   }

   while (len >= 128)
   {
      #ifndef B_BIG_ENDIAN
      pcimtresource(registermcasp, in);
      #else
      memcpy(registermcasp->buffer, in, 128);
      pcimtresource(registermcasp, (U64*)(registermcasp->buffer));
      #endif
      len -= 128;
      in  += 128;
   }

   if (len)
   {
      memcpy((registermcasp->buffer + dm9000platdata), in, len);
   }
}


SHARKSSL_API void SharkSslSha384Ctx_finish(SharkSslSha384Ctx *registermcasp, U8 secondaryentry[SHARKSSL_SHA384_HASH_LEN])
{
   U32 timerenable, dummywrites;
   U32 enablekernel[4];
   U8  usbgadgetresource[16];

   enablekernel[3] = (registermcasp->total[0] << 3);
   enablekernel[2] = (registermcasp->total[1] << 3) | (registermcasp->total[0] >> 29);
   enablekernel[1] = (registermcasp->total[2] << 3) | (registermcasp->total[1] >> 29);
   enablekernel[0] = (registermcasp->total[3] << 3) | (registermcasp->total[2] >> 29);

   inputlevel(enablekernel[0], usbgadgetresource, 0);
   inputlevel(enablekernel[1], usbgadgetresource, 4);
   inputlevel(enablekernel[2], usbgadgetresource, 8);
   inputlevel(enablekernel[3], usbgadgetresource, 12);

   timerenable = registermcasp->total[0] & 0x7F;
   dummywrites = (timerenable < 112) ? (112 - timerenable) : (240 - timerenable);

   SharkSslSha384Ctx_append(registermcasp, (U8*)prusspdata, dummywrites);
   SharkSslSha384Ctx_append(registermcasp, usbgadgetresource, 16);

   hwmoddisable(registermcasp->state[0], secondaryentry,  0);
   hwmoddisable(registermcasp->state[1], secondaryentry,  8);
   hwmoddisable(registermcasp->state[2], secondaryentry, 16);
   hwmoddisable(registermcasp->state[3], secondaryentry, 24);
   hwmoddisable(registermcasp->state[4], secondaryentry, 32);
   hwmoddisable(registermcasp->state[5], secondaryentry, 40);
}
#endif


#if SHARKSSL_USE_SHA_384
SHARKSSL_API int sharkssl_sha384(const U8 *alloccontroller, U16 len, U8 *secondaryentry)
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslSha384Ctx *hctx = (SharkSslSha384Ctx *)baMalloc(claimresource(sizeof(SharkSslSha384Ctx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }
   #else
   SharkSslSha384Ctx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(secondaryentry);

   SharkSslSha384Ctx_constructor(hctx);
   SharkSslSha384Ctx_append(hctx, alloccontroller, len);
   SharkSslSha384Ctx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


#if SHARKSSL_USE_SHA_512
SHARKSSL_API void SharkSslSha512Ctx_finish(SharkSslSha512Ctx *registermcasp, U8 secondaryentry[SHARKSSL_SHA512_HASH_LEN])
{
   baAssert(sizeof(SharkSslSha512Ctx) == sizeof(SharkSslSha384Ctx));
   SharkSslSha384Ctx_finish((SharkSslSha384Ctx*)registermcasp, secondaryentry);
   hwmoddisable(registermcasp->state[6], secondaryentry, 48);
   hwmoddisable(registermcasp->state[7], secondaryentry, 56);
}


SHARKSSL_API int sharkssl_sha512(const U8 *alloccontroller, U16 len, U8 *secondaryentry)
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslSha512Ctx *hctx = (SharkSslSha512Ctx *)baMalloc(claimresource(sizeof(SharkSslSha512Ctx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }
   #else
   SharkSslSha512Ctx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(secondaryentry);

   SharkSslSha512Ctx_constructor(hctx);
   SharkSslSha512Ctx_append(hctx, alloccontroller, len);
   SharkSslSha512Ctx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


static U16 prminstglobal(U8 configwrite)
{
   baAssert(SHARKSSL_SHA512_BLOCK_LEN == SHARKSSL_SHA384_BLOCK_LEN);
   baAssert(SHARKSSL_SHA256_BLOCK_LEN == SHARKSSL_MD5_BLOCK_LEN);
   baAssert(SHARKSSL_SHA1_BLOCK_LEN == SHARKSSL_MD5_BLOCK_LEN);

   switch (configwrite)
   {
      #if (SHARKSSL_USE_SHA_512 || SHARKSSL_USE_SHA_384)
      #if SHARKSSL_USE_SHA_512
      case SHARKSSL_HASHID_SHA512:
      #endif
      #if SHARKSSL_USE_SHA_384
      case SHARKSSL_HASHID_SHA384:
      #endif
         return SHARKSSL_SHA384_BLOCK_LEN;
      #endif

      #if (SHARKSSL_USE_SHA_256 || SHARKSSL_USE_SHA1 || SHARKSSL_USE_MD5)
      #if SHARKSSL_USE_SHA_256
      case SHARKSSL_HASHID_SHA256:
      #endif
      #if SHARKSSL_USE_SHA1
      case SHARKSSL_HASHID_SHA1:
      #endif
      #if SHARKSSL_USE_MD5
      case SHARKSSL_HASHID_MD5:
      #endif
         return SHARKSSL_MD5_BLOCK_LEN;
      #endif

      default:
         break;
   }

   return 0;
}


U16 sharkssl_getHashLen(U8 configwrite)
{
   switch (configwrite)
   {
      #if SHARKSSL_USE_SHA_512
      case SHARKSSL_HASHID_SHA512:
         return SHARKSSL_SHA512_HASH_LEN;
      #endif

      #if SHARKSSL_USE_SHA_384
      case SHARKSSL_HASHID_SHA384:
         return SHARKSSL_SHA384_HASH_LEN;
      #endif

      #if SHARKSSL_USE_SHA_256
      case SHARKSSL_HASHID_SHA256:
         return SHARKSSL_SHA256_HASH_LEN;
      #endif

      #if SHARKSSL_USE_SHA1
      case SHARKSSL_HASHID_SHA1:
         return SHARKSSL_SHA1_HASH_LEN;
      #endif

      #if SHARKSSL_USE_MD5
      case SHARKSSL_HASHID_MD5:
         return SHARKSSL_MD5_HASH_LEN;
      #endif

      default:
         break;
   }

   return 0;
}


int sharkssl_hash(U8 *secondaryentry, U8 *alloccontroller, U16 len, U8 configwrite)
{
   if (alloccontroller && secondaryentry)
   {
      switch (configwrite)
      {
         #if SHARKSSL_USE_SHA_512
         case SHARKSSL_HASHID_SHA512:
            return sharkssl_sha512(alloccontroller, len, secondaryentry);
         #endif

         #if SHARKSSL_USE_SHA_384
         case SHARKSSL_HASHID_SHA384:
            return sharkssl_sha384(alloccontroller, len, secondaryentry);
         #endif

         #if SHARKSSL_USE_SHA_256
         case SHARKSSL_HASHID_SHA256:
            return sharkssl_sha256(alloccontroller, len, secondaryentry);
         #endif

         #if SHARKSSL_USE_SHA1
         case SHARKSSL_HASHID_SHA1:
            return sharkssl_sha1(alloccontroller, len, secondaryentry);
         #endif

         #if SHARKSSL_USE_MD5
         case SHARKSSL_HASHID_MD5:
            return sharkssl_md5(alloccontroller, len, secondaryentry);
         #endif

         default:
            break;
      }
   }

   return -1;
}


#if (SHARKSSL_USE_SHA_512 || SHARKSSL_USE_SHA_384 || SHARKSSL_USE_SHA_256 || SHARKSSL_USE_SHA1 || SHARKSSL_USE_MD5)
SHARKSSL_API void  SharkSslHMACCtx_constructor(SharkSslHMACCtx *registermcasp, U8 configwrite, const U8 *sourcerouting, U16 creategroup)
{
   U16 usb11device = prminstglobal(configwrite);
   baAssert(0 == (usb11device & 0x03));

   registermcasp->hashID = 0;  
   if (usb11device)
   {
      U8 *k;
      U16 l4 = (usb11device >> 2);

      memset(registermcasp->key, 0, usb11device);
      if (creategroup <= usb11device)
      {
         memcpy(registermcasp->key, sourcerouting, creategroup);
      }
      else
      {
         
         sharkssl_hash((U8*)&(registermcasp->key), (U8*)sourcerouting, creategroup, configwrite);
         creategroup = sharkssl_getHashLen(configwrite);
         baAssert(creategroup);
      }

      k = registermcasp->key;
      while (l4--)
      {
         *(k++) ^= 0x36;
         *(k++) ^= 0x36;
         *(k++) ^= 0x36;
         *(k++) ^= 0x36;
      }

      registermcasp->hashID = configwrite;
      switch (configwrite)
      {
         #if SHARKSSL_USE_SHA_512
         case SHARKSSL_HASHID_SHA512:
            SharkSslSha512Ctx_constructor(&(registermcasp->hashCtx.sha512Ctx));
            SharkSslSha512Ctx_append(&(registermcasp->hashCtx.sha512Ctx), (U8*)&(registermcasp->key), usb11device);
            break;
         #endif

         #if SHARKSSL_USE_SHA_384
         case SHARKSSL_HASHID_SHA384:
            SharkSslSha384Ctx_constructor(&(registermcasp->hashCtx.sha384Ctx));
            SharkSslSha384Ctx_append(&(registermcasp->hashCtx.sha384Ctx), (U8*)&(registermcasp->key), usb11device);
            break;
         #endif

         #if SHARKSSL_USE_SHA_256
         case SHARKSSL_HASHID_SHA256:
            SharkSslSha256Ctx_constructor(&(registermcasp->hashCtx.sha256Ctx));
            SharkSslSha256Ctx_append(&(registermcasp->hashCtx.sha256Ctx), (U8*)&(registermcasp->key), usb11device);
            break;
         #endif

         #if SHARKSSL_USE_SHA1
         case SHARKSSL_HASHID_SHA1:
            SharkSslSha1Ctx_constructor(&(registermcasp->hashCtx.sha1Ctx));
            SharkSslSha1Ctx_append(&(registermcasp->hashCtx.sha1Ctx), (U8*)&(registermcasp->key), usb11device);
            break;
         #endif

         #if SHARKSSL_USE_MD5
         case SHARKSSL_HASHID_MD5:
            SharkSslMd5Ctx_constructor(&(registermcasp->hashCtx.md5Ctx));
            SharkSslMd5Ctx_append(&(registermcasp->hashCtx.md5Ctx), (U8*)&(registermcasp->key), usb11device);
            break;
         #endif

         default:
            break;
      }
   }
}


SHARKSSL_API void  SharkSslHMACCtx_append(SharkSslHMACCtx *registermcasp, const U8 *alloccontroller, U32 len)
{
   switch (registermcasp->hashID)
   {
      #if SHARKSSL_USE_SHA_512
      case SHARKSSL_HASHID_SHA512:
         SharkSslSha512Ctx_append(&(registermcasp->hashCtx.sha512Ctx), alloccontroller, len);
         break;
      #endif

      #if SHARKSSL_USE_SHA_384
      case SHARKSSL_HASHID_SHA384:
         SharkSslSha384Ctx_append(&(registermcasp->hashCtx.sha384Ctx), alloccontroller, len);
         break;
      #endif

      #if SHARKSSL_USE_SHA_256
      case SHARKSSL_HASHID_SHA256:
         SharkSslSha256Ctx_append(&(registermcasp->hashCtx.sha256Ctx), alloccontroller, len);
         break;
      #endif

      #if SHARKSSL_USE_SHA1
      case SHARKSSL_HASHID_SHA1:
         SharkSslSha1Ctx_append(&(registermcasp->hashCtx.sha1Ctx), alloccontroller, len);
         break;
      #endif

      #if SHARKSSL_USE_MD5
      case SHARKSSL_HASHID_MD5:
         SharkSslMd5Ctx_append(&(registermcasp->hashCtx.md5Ctx), alloccontroller, len);
         break;
      #endif

      default:
         break;
   }
}


SHARKSSL_API void  SharkSslHMACCtx_finish(SharkSslHMACCtx *registermcasp, U8 *cfconresource)
{
   U16 usb11device = prminstglobal(registermcasp->hashID);

   if (usb11device)
   {
      U8 *k;
      U16 l4, ftraceupdate;

      k = registermcasp->key;
      l4 = (usb11device >> 2);
      while (l4--)
      {
         *(k++) ^= (0x36 ^ 0x5C);  
         *(k++) ^= (0x36 ^ 0x5C);
         *(k++) ^= (0x36 ^ 0x5C);
         *(k++) ^= (0x36 ^ 0x5C);
      }

      ftraceupdate = sharkssl_getHashLen(registermcasp->hashID);
      switch (registermcasp->hashID)  
      {
         #if SHARKSSL_USE_SHA_512
         case SHARKSSL_HASHID_SHA512:
            SharkSslSha512Ctx_finish(&(registermcasp->hashCtx.sha512Ctx), cfconresource);
            SharkSslSha512Ctx_constructor(&(registermcasp->hashCtx.sha512Ctx));
            SharkSslSha512Ctx_append(&(registermcasp->hashCtx.sha512Ctx), (U8*)&(registermcasp->key), usb11device);
            SharkSslSha512Ctx_append(&(registermcasp->hashCtx.sha512Ctx), cfconresource, ftraceupdate);
            SharkSslSha512Ctx_finish(&(registermcasp->hashCtx.sha512Ctx), cfconresource);
            break;
         #endif

         #if SHARKSSL_USE_SHA_384
         case SHARKSSL_HASHID_SHA384:
            SharkSslSha384Ctx_finish(&(registermcasp->hashCtx.sha384Ctx), cfconresource);
            SharkSslSha384Ctx_constructor(&(registermcasp->hashCtx.sha384Ctx));
            SharkSslSha384Ctx_append(&(registermcasp->hashCtx.sha384Ctx), (U8*)&(registermcasp->key), usb11device);
            SharkSslSha384Ctx_append(&(registermcasp->hashCtx.sha384Ctx), cfconresource, ftraceupdate);
            SharkSslSha384Ctx_finish(&(registermcasp->hashCtx.sha384Ctx), cfconresource);
            break;
         #endif

         #if SHARKSSL_USE_SHA_256
         case SHARKSSL_HASHID_SHA256:
            SharkSslSha256Ctx_finish(&(registermcasp->hashCtx.sha256Ctx), cfconresource);
            SharkSslSha256Ctx_constructor(&(registermcasp->hashCtx.sha256Ctx));
            SharkSslSha256Ctx_append(&(registermcasp->hashCtx.sha256Ctx), (U8*)&(registermcasp->key), usb11device);
            SharkSslSha256Ctx_append(&(registermcasp->hashCtx.sha256Ctx), cfconresource, ftraceupdate);
            SharkSslSha256Ctx_finish(&(registermcasp->hashCtx.sha256Ctx), cfconresource);
            break;
         #endif

         #if SHARKSSL_USE_SHA1
         case SHARKSSL_HASHID_SHA1:
            SharkSslSha1Ctx_finish(&(registermcasp->hashCtx.sha1Ctx), cfconresource);
            SharkSslSha1Ctx_constructor(&(registermcasp->hashCtx.sha1Ctx));
            SharkSslSha1Ctx_append(&(registermcasp->hashCtx.sha1Ctx), (U8*)&(registermcasp->key), usb11device);
            SharkSslSha1Ctx_append(&(registermcasp->hashCtx.sha1Ctx), cfconresource, ftraceupdate);
            SharkSslSha1Ctx_finish(&(registermcasp->hashCtx.sha1Ctx), cfconresource);
            break;
         #endif

         #if SHARKSSL_USE_MD5
         case SHARKSSL_HASHID_MD5:
            SharkSslMd5Ctx_finish(&(registermcasp->hashCtx.md5Ctx), cfconresource);
            SharkSslMd5Ctx_constructor(&(registermcasp->hashCtx.md5Ctx));
            SharkSslMd5Ctx_append(&(registermcasp->hashCtx.md5Ctx), (U8*)&(registermcasp->key), usb11device);
            SharkSslMd5Ctx_append(&(registermcasp->hashCtx.md5Ctx), cfconresource, ftraceupdate);
            SharkSslMd5Ctx_finish(&(registermcasp->hashCtx.md5Ctx), cfconresource);
            break;
         #endif

         default:
            break;
      }
   }
}


SHARKSSL_API int sharkssl_HMAC(const U8 configwrite, const U8 *alloccontroller, U16 len, const U8 *sourcerouting, U16 creategroup, U8 *secondaryentry)
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslHMACCtx *hctx = (SharkSslHMACCtx *)baMalloc(claimresource(sizeof(SharkSslHMACCtx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }
   #else
   SharkSslHMACCtx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(sourcerouting);
   baAssert(creategroup);
   baAssert(secondaryentry);

   SharkSslHMACCtx_constructor(hctx, configwrite, sourcerouting, creategroup);
   SharkSslHMACCtx_append(hctx, alloccontroller, len);
   SharkSslHMACCtx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


#if SHARKSSL_USE_POLY1305

#if SHARKSSL_OPTIMIZED_POLY1305_ASM
extern
#else
static
#endif
void recheckdelay(SharkSslPoly1305Ctx *registermcasp, const U8 *msg, U32 acsnhadvnh)
#if SHARKSSL_OPTIMIZED_POLY1305_ASM
;
#else
{
   U64 d;
   U32 t[8], r[5];
   U32 sha256export = registermcasp->flag;

   r[0] = registermcasp->r[0];
   r[1] = registermcasp->r[1];
   r[2] = registermcasp->r[2];
   r[3] = registermcasp->r[3];
   r[4] = registermcasp->r[4];

   baAssert(0 == (acsnhadvnh & 0xF));
   while (acsnhadvnh > 0)
   {
      cleanupcount(t[0], msg, 0);
      cleanupcount(t[1], msg, 4);
      cleanupcount(t[2], msg, 8);
      cleanupcount(t[3], msg, 12);

      r[0] += t[0];
      d = (U64)(r[0] < t[0]);
      d += (U64)r[1] + t[1];
      r[1] = (U32)d; d >>= 32;
      d += (U64)r[2] + t[2];
      r[2] = (U32)d; d >>= 32;
      d += (U64)r[3] + t[3];
      r[3] = (U32)d; d >>= 32;
      d += (U64)r[4] + sha256export;
      r[4] = (U32)d;

      
      d = (U64)r[0] * registermcasp->key[0];
      t[0] = (U32)d; d >>= 32;

      d += (U64)r[0] * registermcasp->key[1];
      d += (U64)r[1] * registermcasp->key[0];
      t[1] = (U32)d; d >>= 32;

      d += (U64)r[0] * registermcasp->key[2];
      d += (U64)r[1] * registermcasp->key[1];
      d += (U64)r[2] * registermcasp->key[0];
      t[2] = (U32)d; d >>= 32;

      d += (U64)r[0] * registermcasp->key[3];
      d += (U64)r[1] * registermcasp->key[2];
      d += (U64)r[2] * registermcasp->key[1];
      d += (U64)r[3] * registermcasp->key[0];
      t[3] = (U32)d; d >>= 32;

      d += (U64)r[1] * registermcasp->key[3];
      d += (U64)r[2] * registermcasp->key[2];
      d += (U64)r[3] * registermcasp->key[1];
      d += (U32)((U8)r[4] * registermcasp->key[0]);  
      t[4] = (U32)d; d >>= 32;

      d += (U64)r[2] * registermcasp->key[3];
      d += (U64)r[3] * registermcasp->key[2];
      d += (U32)((U8)r[4] * registermcasp->key[1]);
      t[5] = (U32)d; d >>= 32;

      d += (U64)r[3] * registermcasp->key[3];
      d += (U32)((U8)r[4] * registermcasp->key[2]);
      t[6] = (U32)d;
      t[7] = (U32)(d >> 32) + (U32)((U8)r[4] * registermcasp->key[3]);

      d = (U64)t[0] + (t[4] & ~0x3) + ((t[4] >> 2) | (t[5] << 30)) + ((U64)(t[5] & 0x3) << 32);
      r[0] = (U32)d; d >>= 32;
      d += (U64)t[1] + (t[5] & ~0x3) + ((t[5] >> 2) | (t[6] << 30)) + ((U64)(t[6] & 0x3) << 32);
      r[1] = (U32)d; d >>= 32;
      d += (U64)t[2] + (t[6] & ~0x3) + ((t[6] >> 2) | (t[7] << 30)) + ((U64)(t[7] & 0x3) << 32);
      r[2] = (U32)d; d >>= 32;
      d += (U64)t[3] + (t[7] & ~0x3) + (t[7] >> 2);
      r[3] = (U32)d;
      r[4] = (U32)(d >> 32) + (t[4] & 0x03);

      msg += 16;
      acsnhadvnh -= 16;
   }

   registermcasp->r[0] = r[0];
   registermcasp->r[1] = r[1];
   registermcasp->r[2] = r[2];
   registermcasp->r[3] = r[3];
   registermcasp->r[4] = r[4];
}
#endif


SHARKSSL_API void SharkSslPoly1305Ctx_constructor(SharkSslPoly1305Ctx *registermcasp, const U8 sourcerouting[32])
{
   baAssert(((unsigned int)(UPTR)registermcasp & (sizeof(int)-1)) == 0);

   cleanupcount(registermcasp->key[0],   sourcerouting, 0);
   cleanupcount(registermcasp->key[1],   sourcerouting, 4);
   cleanupcount(registermcasp->key[2],   sourcerouting, 8);
   cleanupcount(registermcasp->key[3],   sourcerouting, 12);
   cleanupcount(registermcasp->nonce[0], sourcerouting, 16);
   cleanupcount(registermcasp->nonce[1], sourcerouting, 20);
   cleanupcount(registermcasp->nonce[2], sourcerouting, 24);
   cleanupcount(registermcasp->nonce[3], sourcerouting, 28);

   
   registermcasp->key[0] &= 0x0FFFFFFF;
   registermcasp->key[1] &= 0x0FFFFFFC;
   registermcasp->key[2] &= 0x0FFFFFFC;
   registermcasp->key[3] &= 0x0FFFFFFC;

   registermcasp->r[0] = 0;
   registermcasp->r[1] = 0;
   registermcasp->r[2] = 0;
   registermcasp->r[3] = 0;
   registermcasp->r[4] = 0;
   registermcasp->blen = 0;
   registermcasp->flag = 1;
}


SHARKSSL_API void SharkSslPoly1305Ctx_append(SharkSslPoly1305Ctx *registermcasp, const U8 *in, U32 len)
{
   U32 pxa300evalboard = 16 - registermcasp->blen;

   if((registermcasp->blen) && (len >= pxa300evalboard))
   {
      memcpy((registermcasp->buffer + registermcasp->blen), in, pxa300evalboard);
      recheckdelay(registermcasp, registermcasp->buffer, 16);
      len -= pxa300evalboard;
      in  += pxa300evalboard;
      registermcasp->blen = 0;
   }

   if (len > 0xF)
   {
      pxa300evalboard = (len & ~0xF);
      recheckdelay(registermcasp, in, pxa300evalboard);
      in += pxa300evalboard;
      len &= 0xF;
   }

   if (len)  
   {
      memcpy((registermcasp->buffer + registermcasp->blen), in, len);
      registermcasp->blen += (U8)len;
   }
}


SHARKSSL_API void SharkSslPoly1305Ctx_finish(SharkSslPoly1305Ctx *registermcasp, U8 secondaryentry[SHARKSSL_POLY1305_HASH_LEN])
{
   U64 d;

   if (registermcasp->blen)
   {
      registermcasp->flag = 0;
      registermcasp->buffer[registermcasp->blen++] = 0x01;
      while (registermcasp->blen < 16)
      {
         registermcasp->buffer[registermcasp->blen++] = 0x00;
      }
      recheckdelay(registermcasp, &registermcasp->buffer[0], 16);
   }

   
   d = (U64)registermcasp->r[0] + registermcasp->nonce[0] + (registermcasp->r[4] & ~3) + (registermcasp->r[4] >> 2);
   hsotgpdata((U32)d, secondaryentry, 0);
   d >>= 32;
   d += (U64)registermcasp->r[1] + registermcasp->nonce[1];
   hsotgpdata((U32)d, secondaryentry, 4);
   d >>= 32;
   d += (U64)registermcasp->r[2] + registermcasp->nonce[2];
   hsotgpdata((U32)d, secondaryentry, 8);
   d >>= 32;
   d += (U64)registermcasp->r[3] + registermcasp->nonce[3];
   hsotgpdata((U32)d, secondaryentry, 12);

   memset(registermcasp, 0, sizeof(SharkSslPoly1305Ctx));
}


SHARKSSL_API int sharkssl_poly1305(const U8 *alloccontroller, U16 len, U8 *secondaryentry, const U8 sourcerouting[32])
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   SharkSslPoly1305Ctx *hctx = (SharkSslPoly1305Ctx *)baMalloc(claimresource(sizeof(SharkSslPoly1305Ctx)));
   baAssert(hctx);
   if (!hctx)
   {
      return -1;
   }
   #else
   SharkSslPoly1305Ctx registermcasp;
   #define hctx &registermcasp
   #endif

   baAssert(alloccontroller);
   baAssert(len);
   baAssert(secondaryentry);
   baAssert(sourcerouting);

   SharkSslPoly1305Ctx_constructor(hctx, sourcerouting);
   SharkSslPoly1305Ctx_append(hctx, alloccontroller, len);
   SharkSslPoly1305Ctx_finish(hctx, secondaryentry);

   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(hctx);
   #else
   #undef hctx
   #endif
   return 0;
}
#endif


#if SHARKSSL_USE_CHACHA20

#if SHARKSSL_OPTIMIZED_CHACHA_ASM
extern
#else
#define invalidcontext(x,n) ((U32)((U32)x << n) | ((U32)x >> (32 - n)))
#define disablecharger(a,b,c,d) \
  state[a] = registermcasp->state[a] + registermcasp->state[b]; \
  state[d] = invalidcontext((registermcasp->state[d] ^ state[a]), 16); \
  state[c] = registermcasp->state[c] + state[d]; \
  state[b] = invalidcontext((registermcasp->state[b] ^ state[c]), 12); \
  state[a] += state[b]; \
  state[d] = invalidcontext((state[d] ^ state[a]), 8);  \
  state[c] += state[d]; \
  state[b] = invalidcontext((state[b] ^ state[c]), 7);

#define firstdevice(a,b,c,d) \
  state[a] += state[b]; \
  state[d] = invalidcontext((state[d] ^ state[a]), 16); \
  state[c] += state[d]; \
  state[b] = invalidcontext((state[b] ^ state[c]), 12); \
  state[a] += state[b]; \
  state[d] = invalidcontext((state[d] ^ state[a]), 8);  \
  state[c] += state[d]; \
  state[b] = invalidcontext((state[b] ^ state[c]), 7);

#define ptracesethbpregs(a,b,c,d) \
  state[a] += state[b]; \
  state[d] = invalidcontext((state[d] ^ state[a]), 16); \
  state[c] += state[d]; \
  state[b] = invalidcontext((state[b] ^ state[c]), 12); \
  t = state[a] + state[b]; \
  state[a] = t + registermcasp->state[a]; \
  t = invalidcontext((state[d] ^ t), 8);  \
  state[d] = t + registermcasp->state[d]; \
  t += state[c]; \
  state[c] = t + registermcasp->state[c]; \
  t = invalidcontext((state[b] ^ t), 7); \
  state[b] = t + registermcasp->state[b];
#endif
SHARKSSL_API void SharkSslChaChaCtx_crypt(SharkSslChaChaCtx *registermcasp, const U8 *updatecause, U8 *enablehazard, U32 len)
#if SHARKSSL_OPTIMIZED_CHACHA_ASM
;
#else
{
   U32 state[16];
   int i;

   while (len > 0)
   {
      #if SHARKSSL_CHACHA_SMALL_FOOTPRINT
      memcpy(state, registermcasp->state, 64);
      for (i = 10; i > 0; i--)
      {
         firstdevice(0, 4, 8,12)
         firstdevice(1, 5, 9,13)
         firstdevice(2, 6,10,14)
         firstdevice(3, 7,11,15)
         firstdevice(0, 5,10,15)
         firstdevice(1, 6,11,12)
         firstdevice(2, 7, 8,13)
         firstdevice(3, 4, 9,14)
      }
      #else
      disablecharger(0, 4, 8,12)
      disablecharger(1, 5, 9,13)
      disablecharger(2, 6,10,14)
      disablecharger(3, 7,11,15)
      for (i = 9; i > 0; i--)
      {
         firstdevice(0, 5,10,15)
         firstdevice(1, 6,11,12)
         firstdevice(2, 7, 8,13)
         firstdevice(3, 4, 9,14)
         firstdevice(0, 4, 8,12)
         firstdevice(1, 5, 9,13)
         firstdevice(2, 6,10,14)
         firstdevice(3, 7,11,15)
      }
      {
         U32 t;
         ptracesethbpregs(0, 5,10,15)
         ptracesethbpregs(1, 6,11,12)
         ptracesethbpregs(2, 7, 8,13)
         ptracesethbpregs(3, 4, 9,14)
      }
      #endif

      i = 0;
      #if (!(SHARKSSL_UNALIGNED_ACCESS) && !(SHARKSSL_CHACHA_SMALL_FOOTPRINT))
      if (0 == ((unsigned int)(UPTR)updatecause & 3))  
      #endif
      #if (SHARKSSL_UNALIGNED_ACCESS || !(SHARKSSL_CHACHA_SMALL_FOOTPRINT))
      {
         if (len < 64)
         {
            while (len >= 4)
            {
               #ifdef B_LITTLE_ENDIAN
               #if SHARKSSL_CHACHA_SMALL_FOOTPRINT
               hsotgpdata((state[i] + registermcasp->state[i]) ^ (*(__sharkssl_packed U32*)updatecause), enablehazard, 0);
               #else
               hsotgpdata(state[i] ^ (*(__sharkssl_packed U32*)updatecause), enablehazard, 0);
               #endif

               #elif defined(B_BIG_ENDIAN)
               #if SHARKSSL_CHACHA_SMALL_FOOTPRINT
               hsotgpdata((state[i] + registermcasp->state[i]) ^ blockarray(*(__sharkssl_packed U32*)updatecause), enablehazard, 0);
               #else
               hsotgpdata(state[i] ^ blockarray(*(__sharkssl_packed U32*)updatecause), enablehazard, 0);
               #endif

               #else
               #error #define either B_LITTLE_ENDIAN or B_BIG_ENDIAN
               #endif
               i++;
               enablehazard += 4;
               updatecause += 4;
               len -= 4;
            }

            if (len > 0)  
            {
               #if SHARKSSL_CHACHA_SMALL_FOOTPRINT
               state[i] += registermcasp->state[i];
               #endif
               *enablehazard++ = (U8)(state[i]) ^ *updatecause++;
               if (len >= 2)
               {
                  *enablehazard++ = (U8)(state[i] >> 8) ^ *updatecause++;
                  if (len >= 3)
                  {
                     *enablehazard++ = (U8)(state[i] >> 16) ^ *updatecause++;
                  }
               }
               len = 0;
            }
         }
         else
         {
            #ifdef B_LITTLE_ENDIAN
            #if SHARKSSL_CHACHA_SMALL_FOOTPRINT
            hsotgpdata((state[0]  + registermcasp->state[0])  ^ ((__sharkssl_packed U32*)updatecause)[0],  enablehazard, 0);
            hsotgpdata((state[1]  + registermcasp->state[1])  ^ ((__sharkssl_packed U32*)updatecause)[1],  enablehazard, 4);
            hsotgpdata((state[2]  + registermcasp->state[2])  ^ ((__sharkssl_packed U32*)updatecause)[2],  enablehazard, 8);
            hsotgpdata((state[3]  + registermcasp->state[3])  ^ ((__sharkssl_packed U32*)updatecause)[3],  enablehazard, 12);
            hsotgpdata((state[4]  + registermcasp->state[4])  ^ ((__sharkssl_packed U32*)updatecause)[4],  enablehazard, 16);
            hsotgpdata((state[5]  + registermcasp->state[5])  ^ ((__sharkssl_packed U32*)updatecause)[5],  enablehazard, 20);
            hsotgpdata((state[6]  + registermcasp->state[6])  ^ ((__sharkssl_packed U32*)updatecause)[6],  enablehazard, 24);
            hsotgpdata((state[7]  + registermcasp->state[7])  ^ ((__sharkssl_packed U32*)updatecause)[7],  enablehazard, 28);
            hsotgpdata((state[8]  + registermcasp->state[8])  ^ ((__sharkssl_packed U32*)updatecause)[8],  enablehazard, 32);
            hsotgpdata((state[9]  + registermcasp->state[9])  ^ ((__sharkssl_packed U32*)updatecause)[9],  enablehazard, 36);
            hsotgpdata((state[10] + registermcasp->state[10]) ^ ((__sharkssl_packed U32*)updatecause)[10], enablehazard, 40);
            hsotgpdata((state[11] + registermcasp->state[11]) ^ ((__sharkssl_packed U32*)updatecause)[11], enablehazard, 44);
            hsotgpdata((state[12] + registermcasp->state[12]) ^ ((__sharkssl_packed U32*)updatecause)[12], enablehazard, 48);
            hsotgpdata((state[13] + registermcasp->state[13]) ^ ((__sharkssl_packed U32*)updatecause)[13], enablehazard, 52);
            hsotgpdata((state[14] + registermcasp->state[14]) ^ ((__sharkssl_packed U32*)updatecause)[14], enablehazard, 56);
            hsotgpdata((state[15] + registermcasp->state[15]) ^ ((__sharkssl_packed U32*)updatecause)[15], enablehazard, 60);
            #else
            hsotgpdata(state[0]  ^ ((__sharkssl_packed U32*)updatecause)[0],  enablehazard, 0);
            hsotgpdata(state[1]  ^ ((__sharkssl_packed U32*)updatecause)[1],  enablehazard, 4);
            hsotgpdata(state[2]  ^ ((__sharkssl_packed U32*)updatecause)[2],  enablehazard, 8);
            hsotgpdata(state[3]  ^ ((__sharkssl_packed U32*)updatecause)[3],  enablehazard, 12);
            hsotgpdata(state[4]  ^ ((__sharkssl_packed U32*)updatecause)[4],  enablehazard, 16);
            hsotgpdata(state[5]  ^ ((__sharkssl_packed U32*)updatecause)[5],  enablehazard, 20);
            hsotgpdata(state[6]  ^ ((__sharkssl_packed U32*)updatecause)[6],  enablehazard, 24);
            hsotgpdata(state[7]  ^ ((__sharkssl_packed U32*)updatecause)[7],  enablehazard, 28);
            hsotgpdata(state[8]  ^ ((__sharkssl_packed U32*)updatecause)[8],  enablehazard, 32);
            hsotgpdata(state[9]  ^ ((__sharkssl_packed U32*)updatecause)[9],  enablehazard, 36);
            hsotgpdata(state[10] ^ ((__sharkssl_packed U32*)updatecause)[10], enablehazard, 40);
            hsotgpdata(state[11] ^ ((__sharkssl_packed U32*)updatecause)[11], enablehazard, 44);
            hsotgpdata(state[12] ^ ((__sharkssl_packed U32*)updatecause)[12], enablehazard, 48);
            hsotgpdata(state[13] ^ ((__sharkssl_packed U32*)updatecause)[13], enablehazard, 52);
            hsotgpdata(state[14] ^ ((__sharkssl_packed U32*)updatecause)[14], enablehazard, 56);
            hsotgpdata(state[15] ^ ((__sharkssl_packed U32*)updatecause)[15], enablehazard, 60);
            #endif

            #elif defined(B_BIG_ENDIAN)
            #if SHARKSSL_CHACHA_SMALL_FOOTPRINT
            hsotgpdata((state[0]  + registermcasp->state[0])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[0]),  enablehazard, 0);
            hsotgpdata((state[1]  + registermcasp->state[1])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[1]),  enablehazard, 4);
            hsotgpdata((state[2]  + registermcasp->state[2])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[2]),  enablehazard, 8);
            hsotgpdata((state[3]  + registermcasp->state[3])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[3]),  enablehazard, 12);
            hsotgpdata((state[4]  + registermcasp->state[4])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[4]),  enablehazard, 16);
            hsotgpdata((state[5]  + registermcasp->state[5])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[5]),  enablehazard, 20);
            hsotgpdata((state[6]  + registermcasp->state[6])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[6]),  enablehazard, 24);
            hsotgpdata((state[7]  + registermcasp->state[7])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[7]),  enablehazard, 28);
            hsotgpdata((state[8]  + registermcasp->state[8])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[8]),  enablehazard, 32);
            hsotgpdata((state[9]  + registermcasp->state[9])  ^ blockarray(((__sharkssl_packed U32*)updatecause)[9]),  enablehazard, 36);
            hsotgpdata((state[10] + registermcasp->state[10]) ^ blockarray(((__sharkssl_packed U32*)updatecause)[10]), enablehazard, 40);
            hsotgpdata((state[11] + registermcasp->state[11]) ^ blockarray(((__sharkssl_packed U32*)updatecause)[11]), enablehazard, 44);
            hsotgpdata((state[12] + registermcasp->state[12]) ^ blockarray(((__sharkssl_packed U32*)updatecause)[12]), enablehazard, 48);
            hsotgpdata((state[13] + registermcasp->state[13]) ^ blockarray(((__sharkssl_packed U32*)updatecause)[13]), enablehazard, 52);
            hsotgpdata((state[14] + registermcasp->state[14]) ^ blockarray(((__sharkssl_packed U32*)updatecause)[14]), enablehazard, 56);
            hsotgpdata((state[15] + registermcasp->state[15]) ^ blockarray(((__sharkssl_packed U32*)updatecause)[15]), enablehazard, 60);
            #else
            hsotgpdata(state[0]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[0]),  enablehazard, 0);
            hsotgpdata(state[1]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[1]),  enablehazard, 4);
            hsotgpdata(state[2]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[2]),  enablehazard, 8);
            hsotgpdata(state[3]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[3]),  enablehazard, 12);
            hsotgpdata(state[4]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[4]),  enablehazard, 16);
            hsotgpdata(state[5]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[5]),  enablehazard, 20);
            hsotgpdata(state[6]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[6]),  enablehazard, 24);
            hsotgpdata(state[7]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[7]),  enablehazard, 28);
            hsotgpdata(state[8]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[8]),  enablehazard, 32);
            hsotgpdata(state[9]  ^ blockarray(((__sharkssl_packed U32*)updatecause)[9]),  enablehazard, 36);
            hsotgpdata(state[10] ^ blockarray(((__sharkssl_packed U32*)updatecause)[10]), enablehazard, 40);
            hsotgpdata(state[11] ^ blockarray(((__sharkssl_packed U32*)updatecause)[11]), enablehazard, 44);
            hsotgpdata(state[12] ^ blockarray(((__sharkssl_packed U32*)updatecause)[12]), enablehazard, 48);
            hsotgpdata(state[13] ^ blockarray(((__sharkssl_packed U32*)updatecause)[13]), enablehazard, 52);
            hsotgpdata(state[14] ^ blockarray(((__sharkssl_packed U32*)updatecause)[14]), enablehazard, 56);
            hsotgpdata(state[15] ^ blockarray(((__sharkssl_packed U32*)updatecause)[15]), enablehazard, 60);
            #endif

            #endif
            len -= 64;
            enablehazard += 64;
            updatecause += 64;
         }
      }
      #endif
      #if (!(SHARKSSL_UNALIGNED_ACCESS))
      #if (!(SHARKSSL_CHACHA_SMALL_FOOTPRINT))
      else
      #endif
      {
         while (!(i & 0x10) && (len > 0))
         {
            U32 st;
            #if SHARKSSL_CHACHA_SMALL_FOOTPRINT
            state[i] += registermcasp->state[i];
            #endif
            st = state[i];
            *enablehazard++ = (U8)(st) ^ *updatecause++;
            if (--len)
            {
               *enablehazard++ = (U8)(st >> 8) ^ *updatecause++;
               if (--len)
               {
                  *enablehazard++ = (U8)(st >> 16) ^ *updatecause++;
                  if (--len)
                  {
                     *enablehazard++ = (U8)(st >> 24) ^ *updatecause++;
                     len--;
                     i++;
                  }
               }
            }
         }
      }
      #endif  

      if (0 == (++registermcasp->state[12]))
      {
         registermcasp->state[13]++;
         
      }
   }
}
#undef ptracesethbpregs
#undef firstdevice
#undef disablecharger
#undef invalidcontext
#endif


SHARKSSL_API void SharkSslChaChaCtx_constructor(SharkSslChaChaCtx *registermcasp, const U8 *sourcerouting, U8 creategroup)
{
   static const char mcbsp1hwmod[] = "\145\170\160\141\156\144\040\063\062\055\142\171\164\145\040\153";
   static const char tau[] = "\145\170\160\141\156\144\040\061\066\055\142\171\164\145\040\153";
   const char *write64uint32;

   cleanupcount(registermcasp->state[4], sourcerouting, 0);
   cleanupcount(registermcasp->state[5], sourcerouting, 4);
   cleanupcount(registermcasp->state[6], sourcerouting, 8);
   cleanupcount(registermcasp->state[7], sourcerouting, 12);

   if (creategroup == 32)
   { 
      sourcerouting += 16;
      write64uint32 = mcbsp1hwmod;
   }
   else
   { 
      write64uint32 = tau;
   }
   cleanupcount(registermcasp->state[8],  sourcerouting, 0);
   cleanupcount(registermcasp->state[9],  sourcerouting, 4);
   cleanupcount(registermcasp->state[10], sourcerouting, 8);
   cleanupcount(registermcasp->state[11], sourcerouting, 12);

   cleanupcount(registermcasp->state[0], write64uint32, 0);
   cleanupcount(registermcasp->state[1], write64uint32, 4);
   cleanupcount(registermcasp->state[2], write64uint32, 8);
   cleanupcount(registermcasp->state[3], write64uint32, 12);
}


SHARKSSL_API void SharkSslChaChaCtx_setIV(SharkSslChaChaCtx *registermcasp, const U8 IV[12])
{
  registermcasp->state[12] = 0;
  cleanupcount(registermcasp->state[13], IV, 0);
  cleanupcount(registermcasp->state[14], IV, 4);
  cleanupcount(registermcasp->state[15], IV, 8);
}
#endif


#if (SHARKSSL_SSL_CLIENT_CODE || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_ENABLE_AES_GCM || SHARKSSL_ENABLE_PEM_API)

SHARKSSL_API int sharkssl_kmemcmp(const void *a, const void *b, U32 n)
{
   U8 cmp = 0;
   #if SHARKSSL_UNALIGNED_ACCESS
   const U8  *p8a, *p8b;
   __sharkssl_packed const U32 *exceptionlevel = (const U32*)a;
   __sharkssl_packed const U32 *movinandinserted = (const U32*)b;
   U32 dointvecminmax = 0;

   while (n >= 4)
   {
      dointvecminmax |= (*exceptionlevel++ ^ *movinandinserted++);
      n -= 4;
   }

   
   dointvecminmax = (dointvecminmax & 0xFFFF) | (dointvecminmax >> 16);
   cmp   = (U8)dointvecminmax  | (U8)(dointvecminmax >> 8);

   p8a = (U8*)exceptionlevel;
   p8b = (U8*)movinandinserted;
   #else

   U8 *p8a = (U8*)a;
   U8 *p8b = (U8*)b;
   #endif

   while (n--)
   {
      cmp |= (*p8a++ ^ *p8b++);
   }

   return (int)cmp;
}
#endif


#if (SHARKSSL_USE_AES_256 || SHARKSSL_USE_AES_192 || SHARKSSL_USE_AES_128)

#if SHARKSSL_AES_TABLES_IN_RAM
static U32 alloczeroed[256];
static U32 domainalways[256];
static U32 timeoutshift[10];
#if (!SHARKSSL_AES_DISABLE_SBOX)
static U8 class3configure[256];
#endif
#if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
static U8 powerpdata[256];
#endif
#endif

#if (!SHARKSSL_AES_DISABLE_SBOX)
#if SHARKSSL_AES_TABLES_IN_RAM
static const U8 singlefuito[256] =
#else
static const U8 class3configure[256] =
#endif
{
   0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
   0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
   0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
   0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
   0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
   0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
   0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
   0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
   0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
   0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
   0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
   0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
   0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
   0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
   0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
   0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
   0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
   0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
   0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
   0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
   0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
   0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
   0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
   0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
   0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
   0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
   0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
   0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
   0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
   0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
   0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
   0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};
#endif

#if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
#if SHARKSSL_AES_TABLES_IN_RAM
static const U8 spinboxhwmod[256] =
#else
static const U8 powerpdata[256] =
#endif
{
   0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
   0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
   0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
   0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
   0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
   0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
   0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
   0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
   0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
   0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
   0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
   0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
   0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
   0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
   0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
   0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
   0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
   0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
   0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
   0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
   0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
   0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
   0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
   0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
   0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
   0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
   0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
   0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
   0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
   0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
   0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
   0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};
#endif

#if SHARKSSL_AES_TABLES_IN_RAM
static const U32 timerevtstrm[256] =
#else
static const U32 alloczeroed[256] =
#endif
{
   0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d,
   0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,
   0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d,
   0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,
   0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87,
   0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,
   0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea,
   0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,
   0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a,
   0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,
   0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108,
   0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,
   0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e,
   0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5,
   0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d,
   0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,
   0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e,
   0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,
   0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce,
   0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,
   0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c,
   0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,
   0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b,
   0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,
   0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16,
   0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,
   0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81,
   0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,
   0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a,
   0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,
   0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163,
   0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,
   0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f,
   0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,
   0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47,
   0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,
   0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f,
   0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883,
   0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c,
   0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,
   0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e,
   0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,
   0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6,
   0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,
   0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7,
   0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,
   0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25,
   0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,
   0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72,
   0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,
   0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21,
   0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85,
   0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa,
   0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,
   0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0,
   0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,
   0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133,
   0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7,
   0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920,
   0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,
   0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17,
   0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,
   0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11,
   0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a
};

#if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
#if SHARKSSL_AES_TABLES_IN_RAM
static const U32 thumb32break[256] =
#else
static const U32 domainalways[256] =
#endif
{
   0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96,
   0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393,
   0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25,
   0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f,
   0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1,
   0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6,
   0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da,
   0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844,
   0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd,
   0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4,
   0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45,
   0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94,
   0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7,
   0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a,
   0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5,
   0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c,
   0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1,
   0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a,
   0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75,
   0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051,
   0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46,
   0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff,
   0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77,
   0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb,
   0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000,
   0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e,
   0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927,
   0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a,
   0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e,
   0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16,
   0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d,
   0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8,
   0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd,
   0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34,
   0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163,
   0xd731dcca, 0x42638510, 0x13972240, 0x84c61120,
   0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d,
   0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0,
   0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422,
   0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef,
   0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36,
   0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4,
   0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662,
   0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5,
   0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3,
   0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b,
   0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8,
   0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6,
   0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6,
   0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0,
   0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815,
   0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f,
   0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df,
   0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f,
   0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e,
   0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713,
   0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89,
   0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c,
   0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf,
   0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86,
   0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f,
   0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541,
   0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190,
   0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742
};
#endif

#if SHARKSSL_AES_TABLES_IN_RAM
static const U32 enterlowpower[10] =
#else
static const U32 timeoutshift[10] =
#endif
{
   0x01000000, 0x02000000, 0x04000000, 0x08000000,
   0x10000000, 0x20000000, 0x40000000, 0x80000000,
   0x1B000000, 0x36000000
};

#define mcspidevice(a, n) (((a) >> n) | ((a) << (32 - n)))


SHARKSSL_API void SharkSslAesCtx_constructor(SharkSslAesCtx *registermcasp,
                                             SharkSslAesCtx_Type rightsvalid,
                                             const U8 *sourcerouting, U8 creategroup)
{
   U32 *countshift, brightnesslimit;
   U16 i;
   #if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
   U16 j;
   #endif

   baAssert(registermcasp);
   baAssert(sourcerouting);
   #if (SHARKSSL_USE_AES_256)
   #if (SHARKSSL_USE_AES_192)
   #if (SHARKSSL_USE_AES_128)
   baAssert((creategroup == 32) || (creategroup == 24) || (creategroup == 16));
   #else  
   baAssert((creategroup == 32) || (creategroup == 24));
   #endif
   #else  
   #if (SHARKSSL_USE_AES_128)
   baAssert((creategroup == 32) || (creategroup == 16));
   #else  
   baAssert(creategroup == 32);
   #endif
   #endif
   #else  
   #if (SHARKSSL_USE_AES_192)
   #if (SHARKSSL_USE_AES_128)
   baAssert((creategroup == 24) || (creategroup == 16));
   #else  
   baAssert((creategroup == 24));
   #endif
   #else
   baAssert((SHARKSSL_USE_AES_128) && (creategroup == 16));
   #endif
   #endif

   #if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
   baAssert((rightsvalid == SharkSslAesCtx_Decrypt) || (rightsvalid == SharkSslAesCtx_Encrypt));
   #else
   baAssert(rightsvalid == SharkSslAesCtx_Decrypt);
   #endif

   #if SHARKSSL_AES_TABLES_IN_RAM
   if (!alloczeroed[0])
   {
      memcpy(alloczeroed, timerevtstrm, sizeof(timerevtstrm));
      memcpy(domainalways, thumb32break, sizeof(thumb32break));
      memcpy(timeoutshift, enterlowpower, sizeof(enterlowpower));
      #if (!SHARKSSL_AES_DISABLE_SBOX)
      memcpy(class3configure, singlefuito, sizeof(singlefuito));
      #endif
      #if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
      memcpy(powerpdata, spinboxhwmod, sizeof(spinboxhwmod));
      #endif
   }
   #endif

   countshift = registermcasp->key;
   read64uint32(countshift[0], sourcerouting, 0);
   read64uint32(countshift[1], sourcerouting, 4);
   read64uint32(countshift[2], sourcerouting, 8);
   read64uint32(countshift[3], sourcerouting, 12);

   switch (creategroup)
   {
      #if (SHARKSSL_USE_AES_128)
      case 16:
         registermcasp->nr = 10;
         for (i = 0; i < 10; i++, countshift += 4)
         {
            brightnesslimit = countshift[3];
            #if SHARKSSL_AES_DISABLE_SBOX
            brightnesslimit  = ((alloczeroed[exceptionupdates(brightnesslimit)] << 8) & 0xFF000000) |
                     (alloczeroed[iisv4resource(brightnesslimit)]       & 0x00FF0000) |
                     (alloczeroed[translationfault(brightnesslimit)]       & 0x0000FF00) |
                    ((alloczeroed[setupcmdline(brightnesslimit)] >> 8) & 0x000000FF);
            #else
            brightnesslimit  = ((U32)class3configure[exceptionupdates(brightnesslimit)] << 24) |
                    ((U32)class3configure[iisv4resource(brightnesslimit)] << 16) |
                    ((U32)class3configure[translationfault(brightnesslimit)] <<  8) |
                    ((U32)class3configure[setupcmdline(brightnesslimit)]      );
            #endif
            countshift[4] = brightnesslimit ^ countshift[0] ^ timeoutshift[i];
            countshift[5] = countshift[1] ^ countshift[4];
            countshift[6] = countshift[2] ^ countshift[5];
            countshift[7] = countshift[3] ^ countshift[6];
         }
         break;
      #endif

      #if (SHARKSSL_USE_AES_192)
      case 24:
         read64uint32(countshift[4], sourcerouting, 16);
         read64uint32(countshift[5], sourcerouting, 20);
         registermcasp->nr = 12;
         for (i = 0; i < 8; i++, countshift += 6)
         {
            brightnesslimit  = countshift[5];
            #if SHARKSSL_AES_DISABLE_SBOX
            brightnesslimit  = ((alloczeroed[exceptionupdates(brightnesslimit)] << 8) & 0xFF000000) |
                     (alloczeroed[iisv4resource(brightnesslimit)]       & 0x00FF0000) |
                     (alloczeroed[translationfault(brightnesslimit)]       & 0x0000FF00) |
                    ((alloczeroed[setupcmdline(brightnesslimit)] >> 8) & 0x000000FF);
            #else
            brightnesslimit  = ((U32)class3configure[exceptionupdates(brightnesslimit)] << 24) |
                    ((U32)class3configure[iisv4resource(brightnesslimit)] << 16) |
                    ((U32)class3configure[translationfault(brightnesslimit)] <<  8) |
                    ((U32)class3configure[setupcmdline(brightnesslimit)]      );
            #endif
            countshift[6]  = brightnesslimit ^ countshift[0] ^ timeoutshift[i];
            countshift[7]  = countshift[1] ^ countshift[6];
            countshift[8]  = countshift[2] ^ countshift[7];
            countshift[9]  = countshift[3] ^ countshift[8];
            if (i < 7)
            {
               countshift[10] = countshift[4] ^ countshift[9];
               countshift[11] = countshift[5] ^ countshift[10];
            }
         }
         break;
      #endif

      #if (SHARKSSL_USE_AES_256)
      case 32:
         read64uint32(countshift[4], sourcerouting, 16);
         read64uint32(countshift[5], sourcerouting, 20);
         read64uint32(countshift[6], sourcerouting, 24);
         read64uint32(countshift[7], sourcerouting, 28);
         registermcasp->nr = 14;
         for (i = 0; i < 7; i++, countshift += 8)
         {
            brightnesslimit  = countshift[7];
            #if SHARKSSL_AES_DISABLE_SBOX
            brightnesslimit  = ((alloczeroed[exceptionupdates(brightnesslimit)] << 8) & 0xFF000000) |
                     (alloczeroed[iisv4resource(brightnesslimit)]       & 0x00FF0000) |
                     (alloczeroed[translationfault(brightnesslimit)]       & 0x0000FF00) |
                    ((alloczeroed[setupcmdline(brightnesslimit)] >> 8) & 0x000000FF);
            #else
            brightnesslimit  = ((U32)class3configure[exceptionupdates(brightnesslimit)] << 24) |
                    ((U32)class3configure[iisv4resource(brightnesslimit)] << 16) |
                    ((U32)class3configure[translationfault(brightnesslimit)] <<  8) |
                    ((U32)class3configure[setupcmdline(brightnesslimit)]      );
            #endif
            countshift[8]  = brightnesslimit ^ countshift[0] ^ timeoutshift[i];
            countshift[9]  = countshift[1] ^ countshift[8];
            countshift[10] = countshift[2] ^ countshift[9];
            countshift[11] = countshift[3] ^ countshift[10];

            if (i < 6)
            {
               brightnesslimit  = countshift[11];
               #if SHARKSSL_AES_DISABLE_SBOX
               brightnesslimit  = ((alloczeroed[setupcmdline(brightnesslimit)] << 8) & 0xFF000000) |
                        (alloczeroed[exceptionupdates(brightnesslimit)]       & 0x00FF0000) |
                        (alloczeroed[iisv4resource(brightnesslimit)]       & 0x0000FF00) |
                       ((alloczeroed[translationfault(brightnesslimit)] >> 8) & 0x000000FF);
               #else
               brightnesslimit  = ((U32)class3configure[setupcmdline(brightnesslimit)] << 24) |
                       ((U32)class3configure[exceptionupdates(brightnesslimit)] << 16) |
                       ((U32)class3configure[iisv4resource(brightnesslimit)] <<  8) |
                       ((U32)class3configure[translationfault(brightnesslimit)]      );
               #endif
               countshift[12] = brightnesslimit ^ countshift[4];
               countshift[13] = countshift[5] ^ countshift[12];
               countshift[14] = countshift[6] ^ countshift[13];
               countshift[15] = countshift[7] ^ countshift[14];
            }
         }
         break;
      #endif

      default:
         baAssert(0); 
         break;
   }

   #if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
   if (rightsvalid == SharkSslAesCtx_Decrypt)
   {
      countshift += 4;

      for (i = 1; i < registermcasp->nr; i++)
      {
         countshift -= 8;

         for (j = 4; j > 0; j--)
         {
            brightnesslimit = *countshift;
            #if SHARKSSL_AES_DISABLE_SBOX
            *countshift++ =      domainalways[(U8)(alloczeroed[setupcmdline(brightnesslimit)] >> 8)]      ^
                   mcspidevice(domainalways[(U8)(alloczeroed[exceptionupdates(brightnesslimit)] >> 8)], 8)  ^
                   mcspidevice(domainalways[(U8)(alloczeroed[iisv4resource(brightnesslimit)] >> 8)], 16) ^
                   mcspidevice(domainalways[(U8)(alloczeroed[translationfault(brightnesslimit)] >> 8)], 24);
            #else
            *countshift++ =      domainalways[class3configure[setupcmdline(brightnesslimit)]]      ^
                   mcspidevice(domainalways[class3configure[exceptionupdates(brightnesslimit)]], 8)  ^
                   mcspidevice(domainalways[class3configure[iisv4resource(brightnesslimit)]], 16) ^
                   mcspidevice(domainalways[class3configure[translationfault(brightnesslimit)]], 24);
            #endif
         }
      }
   }
   #endif

   #if ((!SHARKSSL_AES_SMALL_FOOTPRINT) && SHARKSSL_AES_CIPHER_LOOP_UNROLL)
   registermcasp->nr >>= 1;
   #endif
   registermcasp->nr--;
}


#define AES_ENC_ROUND(s, t, k, mixtable)  do {              \
   k += 4;                                                  \
   t[0] = k[0] ^       mixtable[setupcmdline(s[0])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[1])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[2])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[3])], 24);       \
   t[1] = k[1] ^       mixtable[setupcmdline(s[1])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[2])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[3])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[0])], 24);       \
   t[2] = k[2] ^       mixtable[setupcmdline(s[2])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[3])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[0])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[1])], 24);       \
   t[3] = k[3] ^       mixtable[setupcmdline(s[3])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[0])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[1])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[2])], 24);       \
} while (0);

#if SHARKSSL_AES_DISABLE_SBOX
#define AES_ENC_FINAL_ROUND(out, s, k, sbox) do {           \
   k += 4;                                                  \
   out[0]  = (U8)((setupcmdline(k[0])) ^ ((U8)(sbox[setupcmdline(s[0])] >> 8))); \
   out[1]  = (U8)((exceptionupdates(k[0])) ^ ((U8)(sbox[exceptionupdates(s[1])] >> 8))); \
   out[2]  = (U8)((iisv4resource(k[0])) ^ ((U8)(sbox[iisv4resource(s[2])] >> 8))); \
   out[3]  = (U8)((translationfault(k[0])) ^ ((U8)(sbox[translationfault(s[3])] >> 8))); \
   out[4]  = (U8)((setupcmdline(k[1])) ^ ((U8)(sbox[setupcmdline(s[1])] >> 8))); \
   out[5]  = (U8)((exceptionupdates(k[1])) ^ ((U8)(sbox[exceptionupdates(s[2])] >> 8))); \
   out[6]  = (U8)((iisv4resource(k[1])) ^ ((U8)(sbox[iisv4resource(s[3])] >> 8))); \
   out[7]  = (U8)((translationfault(k[1])) ^ ((U8)(sbox[translationfault(s[0])] >> 8))); \
   out[8]  = (U8)((setupcmdline(k[2])) ^ ((U8)(sbox[setupcmdline(s[2])] >> 8))); \
   out[9]  = (U8)((exceptionupdates(k[2])) ^ ((U8)(sbox[exceptionupdates(s[3])] >> 8))); \
   out[10] = (U8)((iisv4resource(k[2])) ^ ((U8)(sbox[iisv4resource(s[0])] >> 8))); \
   out[11] = (U8)((translationfault(k[2])) ^ ((U8)(sbox[translationfault(s[1])] >> 8))); \
   out[12] = (U8)((setupcmdline(k[3])) ^ ((U8)(sbox[setupcmdline(s[3])] >> 8))); \
   out[13] = (U8)((exceptionupdates(k[3])) ^ ((U8)(sbox[exceptionupdates(s[0])] >> 8))); \
   out[14] = (U8)((iisv4resource(k[3])) ^ ((U8)(sbox[iisv4resource(s[1])] >> 8))); \
   out[15] = (U8)((translationfault(k[3])) ^ ((U8)(sbox[translationfault(s[2])] >> 8))); \
} while (0);
#else
#define AES_ENC_FINAL_ROUND(out, s, k, sbox) do {           \
   k += 4;                                                  \
   out[0]  = (U8)((setupcmdline(k[0])) ^ sbox[setupcmdline(s[0])]); \
   out[1]  = (U8)((exceptionupdates(k[0])) ^ sbox[exceptionupdates(s[1])]); \
   out[2]  = (U8)((iisv4resource(k[0])) ^ sbox[iisv4resource(s[2])]); \
   out[3]  = (U8)((translationfault(k[0])) ^ sbox[translationfault(s[3])]); \
   out[4]  = (U8)((setupcmdline(k[1])) ^ sbox[setupcmdline(s[1])]); \
   out[5]  = (U8)((exceptionupdates(k[1])) ^ sbox[exceptionupdates(s[2])]); \
   out[6]  = (U8)((iisv4resource(k[1])) ^ sbox[iisv4resource(s[3])]); \
   out[7]  = (U8)((translationfault(k[1])) ^ sbox[translationfault(s[0])]); \
   out[8]  = (U8)((setupcmdline(k[2])) ^ sbox[setupcmdline(s[2])]); \
   out[9]  = (U8)((exceptionupdates(k[2])) ^ sbox[exceptionupdates(s[3])]); \
   out[10] = (U8)((iisv4resource(k[2])) ^ sbox[iisv4resource(s[0])]); \
   out[11] = (U8)((translationfault(k[2])) ^ sbox[translationfault(s[1])]); \
   out[12] = (U8)((setupcmdline(k[3])) ^ sbox[setupcmdline(s[3])]); \
   out[13] = (U8)((exceptionupdates(k[3])) ^ sbox[exceptionupdates(s[0])]); \
   out[14] = (U8)((iisv4resource(k[3])) ^ sbox[iisv4resource(s[1])]); \
   out[15] = (U8)((translationfault(k[3])) ^ sbox[translationfault(s[2])]); \
} while (0);
#endif


SHARKSSL_API void SharkSslAesCtx_encrypt(SharkSslAesCtx *registermcasp, U8 updatecause[16], U8 enablehazard[16])
{
   U32 *K, S[4], T[4];
   U16  i;
   #if SHARKSSL_AES_SMALL_FOOTPRINT
   U16 j, z, y;
   #endif

   baAssert(registermcasp->nr > 0);
   i = registermcasp->nr;
   K = registermcasp->key;

   read64uint32(S[0], updatecause,  0); S[0] ^= K[0];
   read64uint32(S[1], updatecause,  4); S[1] ^= K[1];
   read64uint32(S[2], updatecause,  8); S[2] ^= K[2];
   read64uint32(S[3], updatecause, 12); S[3] ^= K[3];

   #if SHARKSSL_AES_SMALL_FOOTPRINT
   K += 4;
   do
   {
      for (j = 0; !(j & 4); j++)
      {
         T[j] = *K++;
         for (z = 0, y = 0; !(z & 4); z++, y += 8)
         {
            U32 r = alloczeroed[(U8)(S[(j + z) & 3] >> (24 - y))];
            T[j] ^= mcspidevice(r, y);
         }
      }

      S[0] = T[0]; S[1] = T[1]; S[2] = T[2]; S[3] = T[3];
   } while (--i);

   i = 0;
   for (j = 0; !(j & 4); j++)
   {
      for (z = 0, y = 24; !(z & 4); z++, y -= 8)
      {
         #if SHARKSSL_AES_DISABLE_SBOX
         enablehazard[i++] = (U8)((K[j] >> y) ^ (U8)(alloczeroed[(U8)(T[(j + z) & 3] >> y)] >> 8));
         #else
         enablehazard[i++] = (U8)((K[j] >> y) ^ class3configure[(U8)(T[(j + z) & 3] >> y)]);
         #endif
      }
   }

   #else
   #if SHARKSSL_AES_CIPHER_LOOP_UNROLL
   AES_ENC_ROUND(S, T, K, alloczeroed);
   #endif
   do
   {
      #if SHARKSSL_AES_CIPHER_LOOP_UNROLL
      AES_ENC_ROUND(T, S, K, alloczeroed);
      AES_ENC_ROUND(S, T, K, alloczeroed);

      #else
      AES_ENC_ROUND(S, T, K, alloczeroed);
      S[0] = T[0]; S[1] = T[1]; S[2] = T[2]; S[3] = T[3];

      #endif

   } while (--i);

   #if SHARKSSL_AES_DISABLE_SBOX
   AES_ENC_FINAL_ROUND(enablehazard, T, K, alloczeroed);
   #else
   AES_ENC_FINAL_ROUND(enablehazard, T, K, class3configure);
   #endif
   #endif
}


#undef AES_ENC_ROUND
#undef AES_ENC_FINAL_ROUND

#if (!SHARKSSL_DISABLE_AES_ECB_DECRYPT)
#define AES_DEC_ROUND(s, t, k, mixtable)  do {              \
   k -= 4;                                                  \
   t[0] = k[0] ^       mixtable[setupcmdline(s[0])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[3])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[2])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[1])], 24);       \
   t[1] = k[1] ^       mixtable[setupcmdline(s[1])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[0])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[3])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[2])], 24);       \
   t[2] = k[2] ^       mixtable[setupcmdline(s[2])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[1])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[0])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[3])], 24);       \
   t[3] = k[3] ^       mixtable[setupcmdline(s[3])]      ^      \
                  mcspidevice(mixtable[exceptionupdates(s[2])], 8)  ^      \
                  mcspidevice(mixtable[iisv4resource(s[1])], 16) ^      \
                  mcspidevice(mixtable[translationfault(s[0])], 24);       \
} while (0);


#define AES_DEC_FINAL_ROUND(out, s, k, sbox) do {           \
   k -= 4;                                                  \
   out[0]  = (U8)((setupcmdline(k[0])) ^ sbox[setupcmdline(s[0])]); \
   out[1]  = (U8)((exceptionupdates(k[0])) ^ sbox[exceptionupdates(s[3])]); \
   out[2]  = (U8)((iisv4resource(k[0])) ^ sbox[iisv4resource(s[2])]); \
   out[3]  = (U8)((translationfault(k[0])) ^ sbox[translationfault(s[1])]); \
   out[4]  = (U8)((setupcmdline(k[1])) ^ sbox[setupcmdline(s[1])]); \
   out[5]  = (U8)((exceptionupdates(k[1])) ^ sbox[exceptionupdates(s[0])]); \
   out[6]  = (U8)((iisv4resource(k[1])) ^ sbox[iisv4resource(s[3])]); \
   out[7]  = (U8)((translationfault(k[1])) ^ sbox[translationfault(s[2])]); \
   out[8]  = (U8)((setupcmdline(k[2])) ^ sbox[setupcmdline(s[2])]); \
   out[9]  = (U8)((exceptionupdates(k[2])) ^ sbox[exceptionupdates(s[1])]); \
   out[10] = (U8)((iisv4resource(k[2])) ^ sbox[iisv4resource(s[0])]); \
   out[11] = (U8)((translationfault(k[2])) ^ sbox[translationfault(s[3])]); \
   out[12] = (U8)((setupcmdline(k[3])) ^ sbox[setupcmdline(s[3])]); \
   out[13] = (U8)((exceptionupdates(k[3])) ^ sbox[exceptionupdates(s[2])]); \
   out[14] = (U8)((iisv4resource(k[3])) ^ sbox[iisv4resource(s[1])]); \
   out[15] = (U8)((translationfault(k[3])) ^ sbox[translationfault(s[0])]); \
} while (0);


SHARKSSL_API void SharkSslAesCtx_decrypt(SharkSslAesCtx *registermcasp, const U8 updatecause[16], U8 enablehazard[16])
{
   U32 *K, S[4], T[4];
   U16  i;
   #if SHARKSSL_AES_SMALL_FOOTPRINT
   U16 j, z, y;
   #endif

   baAssert(registermcasp->nr > 0);
   i = registermcasp->nr;
   #if ((!SHARKSSL_AES_SMALL_FOOTPRINT) && SHARKSSL_AES_CIPHER_LOOP_UNROLL)
   K = &registermcasp->key[(i + 1) << 3];
   #else
   K = &registermcasp->key[(i + 1) << 2];
   #endif

   read64uint32(S[0], updatecause,  0); S[0] ^= K[0];
   read64uint32(S[1], updatecause,  4); S[1] ^= K[1];
   read64uint32(S[2], updatecause,  8); S[2] ^= K[2];
   read64uint32(S[3], updatecause, 12); S[3] ^= K[3];

   #if SHARKSSL_AES_SMALL_FOOTPRINT
   do
   {
      j = 3;
      do
      {
         T[j] = *(--K);
         for (z = 4, y = 0; z > 0; z--, y += 8)
         {
            U32 r = domainalways[(U8)(S[(j + z) & 3] >> (24 - y))];
            T[j] ^= mcspidevice(r, y);
         }
      } while (j--);

      S[0] = T[0]; S[1] = T[1]; S[2] = T[2]; S[3] = T[3];
   } while (--i);

   i = 0;
   K -= 4;
   for (j = 0; !(j & 4); j++)
   {
      for (z = 0, y = 24; !(z & 4); z++, y -= 8)
      {
         enablehazard[i++] = (U8)((K[j] >> y) ^ powerpdata[(U8)(T[((U8)(j - z)) & 3] >> y)]);
      }
   }

   #else
   #if SHARKSSL_AES_CIPHER_LOOP_UNROLL
   AES_DEC_ROUND(S, T, K, domainalways);
   #endif
   do
   {
      #if SHARKSSL_AES_CIPHER_LOOP_UNROLL
      AES_DEC_ROUND(T, S, K, domainalways);
      AES_DEC_ROUND(S, T, K, domainalways);

      #else
      AES_DEC_ROUND(S, T, K, domainalways);
      S[0] = T[0]; S[1] = T[1]; S[2] = T[2]; S[3] = T[3];
      #endif
   } while (--i);

   AES_DEC_FINAL_ROUND(enablehazard, T, K, powerpdata);
   #endif
}

#undef AES_DEC_ROUND
#undef AES_DEC_FINAL_ROUND
#endif  

#undef mcspidevice


#if SHARKSSL_ENABLE_AES_CBC
SHARKSSL_API void SharkSslAesCtx_cbc_encrypt(SharkSslAesCtx *registermcasp, U8 vect[16],
                                             const U8 *updatecause, U8 *enablehazard, U16 len)
{
   U8 *q = vect;

   baAssert(registermcasp);
   baAssert(vect);
   baAssert(updatecause);
   baAssert(enablehazard);
   baAssert((len & 0x0F) == 0);
   len &= ~0xF;
   while (len > 0)
   {
      #if SHARKSSL_UNALIGNED_ACCESS
      ((__sharkssl_packed U32*)enablehazard)[0] = ((__sharkssl_packed U32*)updatecause)[0] ^ ((__sharkssl_packed U32*)q)[0];
      ((__sharkssl_packed U32*)enablehazard)[1] = ((__sharkssl_packed U32*)updatecause)[1] ^ ((__sharkssl_packed U32*)q)[1];
      ((__sharkssl_packed U32*)enablehazard)[2] = ((__sharkssl_packed U32*)updatecause)[2] ^ ((__sharkssl_packed U32*)q)[2];
      ((__sharkssl_packed U32*)enablehazard)[3] = ((__sharkssl_packed U32*)updatecause)[3] ^ ((__sharkssl_packed U32*)q)[3];
      #else
      enablehazard[0]  = (U8)(updatecause[0]  ^ q[0]);
      enablehazard[1]  = (U8)(updatecause[1]  ^ q[1]);
      enablehazard[2]  = (U8)(updatecause[2]  ^ q[2]);
      enablehazard[3]  = (U8)(updatecause[3]  ^ q[3]);
      enablehazard[4]  = (U8)(updatecause[4]  ^ q[4]);
      enablehazard[5]  = (U8)(updatecause[5]  ^ q[5]);
      enablehazard[6]  = (U8)(updatecause[6]  ^ q[6]);
      enablehazard[7]  = (U8)(updatecause[7]  ^ q[7]);
      enablehazard[8]  = (U8)(updatecause[8]  ^ q[8]);
      enablehazard[9]  = (U8)(updatecause[9]  ^ q[9]);
      enablehazard[10] = (U8)(updatecause[10] ^ q[10]);
      enablehazard[11] = (U8)(updatecause[11] ^ q[11]);
      enablehazard[12] = (U8)(updatecause[12] ^ q[12]);
      enablehazard[13] = (U8)(updatecause[13] ^ q[13]);
      enablehazard[14] = (U8)(updatecause[14] ^ q[14]);
      enablehazard[15] = (U8)(updatecause[15] ^ q[15]);
      #endif
      SharkSslAesCtx_encrypt(registermcasp, enablehazard, enablehazard);
      q  = enablehazard;
      updatecause  += 16;
      enablehazard += 16;
      len    -= 16;
   }

   memcpy(vect, q, 16);
}


SHARKSSL_API void SharkSslAesCtx_cbc_decrypt(SharkSslAesCtx *registermcasp, U8 vect[16],
                                             const U8 *updatecause, U8 *enablehazard, U16 len)
{
   U8 rememberstate[16];
   const U8 *q;

   rememberstate[0]=0; 
   baAssert(registermcasp);
   baAssert(updatecause);
   baAssert(enablehazard);
   baAssert((len & 0x0F) == 0);
   len &= ~0xF;

   if (0 == len)
   {
      return;
   }

   enablehazard += (len - 16);
   updatecause  += (len - 16);

   
   if (vect)
   {
      memcpy(rememberstate, updatecause, 16);
   }

   while (len > 0)
   {
      len -= 16;
      if (len)
      {
         q = updatecause - 16;
      }
      else if (vect)
      {
         q = vect;
      }
      else
      {
         return;
      }
      SharkSslAesCtx_decrypt(registermcasp, updatecause, enablehazard);
      updatecause = q;
      #if SHARKSSL_UNALIGNED_ACCESS
      ((__sharkssl_packed U32*)enablehazard)[0] ^= ((__sharkssl_packed U32*)q)[0];
      ((__sharkssl_packed U32*)enablehazard)[1] ^= ((__sharkssl_packed U32*)q)[1];
      ((__sharkssl_packed U32*)enablehazard)[2] ^= ((__sharkssl_packed U32*)q)[2];
      ((__sharkssl_packed U32*)enablehazard)[3] ^= ((__sharkssl_packed U32*)q)[3];
      #else
      enablehazard[0]  ^= q[0];
      enablehazard[1]  ^= q[1];
      enablehazard[2]  ^= q[2];
      enablehazard[3]  ^= q[3];
      enablehazard[4]  ^= q[4];
      enablehazard[5]  ^= q[5];
      enablehazard[6]  ^= q[6];
      enablehazard[7]  ^= q[7];
      enablehazard[8]  ^= q[8];
      enablehazard[9]  ^= q[9];
      enablehazard[10] ^= q[10];
      enablehazard[11] ^= q[11];
      enablehazard[12] ^= q[12];
      enablehazard[13] ^= q[13];
      enablehazard[14] ^= q[14];
      enablehazard[15] ^= q[15];
      #endif
      enablehazard -= 16;
   }

   baAssert(vect);
   memcpy(vect, rememberstate, 16);
}
#endif  


#if (SHARKSSL_ENABLE_AES_CTR_MODE)  
SHARKSSL_API void SharkSslAesCtx_ctr_mode(SharkSslAesCtx *registermcasp, U8 ctr[16],
                                          const U8 *updatecause, U8 *enablehazard, U16 len)
{
   U8 sossirecalc[16], k;

   baAssert(registermcasp);
   baAssert(ctr);
   baAssert(updatecause);
   baAssert(enablehazard);
   baAssert((len & 0x0F) == 0);

   len >>= 4;
   while (len--)
   {
      
      k = 0;
      #if (defined(B_LITTLE_ENDIAN) && SHARKSSL_UNALIGNED_ACCESS)
      while ((k < 4)  && (0 == ++((__sharkssl_packed U32*)ctr)[k]))
      #else
      while ((k < 16) && (0 == ++ctr[k]))
      #endif
      {
         k++;
      }

      
      SharkSslAesCtx_encrypt(registermcasp, ctr, sossirecalc);

      
      #if SHARKSSL_UNALIGNED_ACCESS
      ((__sharkssl_packed U32*)enablehazard)[0] = ((__sharkssl_packed U32*)updatecause)[0] ^ ((U32*)sossirecalc)[0];
      ((__sharkssl_packed U32*)enablehazard)[1] = ((__sharkssl_packed U32*)updatecause)[1] ^ ((U32*)sossirecalc)[1];
      ((__sharkssl_packed U32*)enablehazard)[2] = ((__sharkssl_packed U32*)updatecause)[2] ^ ((U32*)sossirecalc)[2];
      ((__sharkssl_packed U32*)enablehazard)[3] = ((__sharkssl_packed U32*)updatecause)[3] ^ ((U32*)sossirecalc)[3];
      #else
      enablehazard[0]  = (U8)(updatecause[0]  ^ sossirecalc[0]);
      enablehazard[1]  = (U8)(updatecause[1]  ^ sossirecalc[1]);
      enablehazard[2]  = (U8)(updatecause[2]  ^ sossirecalc[2]);
      enablehazard[3]  = (U8)(updatecause[3]  ^ sossirecalc[3]);
      enablehazard[4]  = (U8)(updatecause[4]  ^ sossirecalc[4]);
      enablehazard[5]  = (U8)(updatecause[5]  ^ sossirecalc[5]);
      enablehazard[6]  = (U8)(updatecause[6]  ^ sossirecalc[6]);
      enablehazard[7]  = (U8)(updatecause[7]  ^ sossirecalc[7]);
      enablehazard[8]  = (U8)(updatecause[8]  ^ sossirecalc[8]);
      enablehazard[9]  = (U8)(updatecause[9]  ^ sossirecalc[9]);
      enablehazard[10] = (U8)(updatecause[10] ^ sossirecalc[10]);
      enablehazard[11] = (U8)(updatecause[11] ^ sossirecalc[11]);
      enablehazard[12] = (U8)(updatecause[12] ^ sossirecalc[12]);
      enablehazard[13] = (U8)(updatecause[13] ^ sossirecalc[13]);
      enablehazard[14] = (U8)(updatecause[14] ^ sossirecalc[14]);
      enablehazard[15] = (U8)(updatecause[15] ^ sossirecalc[15]);
      #endif

      updatecause  += 16;
      enablehazard += 16;
   }
}
#endif


#if (SHARKSSL_ENABLE_AES_GCM || SHARKSSL_ENABLE_AES_CCM)

#define ntosd2nandflash(r, a, b, l)  do {  \
   register U16 debugstate = (U16)l;  \
   while (debugstate--) (r)[debugstate] = (a)[debugstate] ^ (b)[debugstate];  \
} while (0)


#if SHARKSSL_UNALIGNED_ACCESS

#define paz00wifikill(r, a, b)  do {  \
  ((__sharkssl_packed U32*)(r))[0] = ((__sharkssl_packed U32*)(a))[0] ^ ((__sharkssl_packed U32*)(b))[0];  \
  ((__sharkssl_packed U32*)(r))[1] = ((__sharkssl_packed U32*)(a))[1] ^ ((__sharkssl_packed U32*)(b))[1];  \
  ((__sharkssl_packed U32*)(r))[2] = ((__sharkssl_packed U32*)(a))[2] ^ ((__sharkssl_packed U32*)(b))[2];  \
  ((__sharkssl_packed U32*)(r))[3] = ((__sharkssl_packed U32*)(a))[3] ^ ((__sharkssl_packed U32*)(b))[3];  \
} while (0)

#else

#define paz00wifikill(r, a, b)   ntosd2nandflash(r, a, b, 16)

#endif
#endif  


#if SHARKSSL_ENABLE_AES_GCM
static const U16 serialsetup[16] =
{
    0x0000, 0x1C20, 0x3840, 0x2460,
    0x7080, 0x6ca0, 0x48c0, 0x54e0,
    0xe100, 0xfd20, 0xd940, 0xc560,
    0x9180, 0x8da0, 0xa9c0, 0xb5e0
};


static void machinecheck(U8* X)
{
   U32 Z[4];
   U8  b;

   #if ((!defined(B_LITTLE_ENDIAN)) && (!defined(B_BIG_ENDIAN)))
   if (0x20 == (*(U8*)&serialsetup[1]))  
   #endif
   #ifndef B_BIG_ENDIAN
   {
      cleanupcount(Z[0], X, 0);
      cleanupcount(Z[1], X, 4);
      cleanupcount(Z[2], X, 8);
      cleanupcount(Z[3], X, 12);
   }
   #endif
   #if ((!defined(B_LITTLE_ENDIAN)) && (!defined(B_BIG_ENDIAN)))
   else
   #endif
   #ifndef B_LITTLE_ENDIAN
   {
      read64uint32(Z[0], X, 0);
      read64uint32(Z[1], X, 4);
      read64uint32(Z[2], X, 8);
      read64uint32(Z[3], X, 12);
   }
   #endif

   b = (U8)(Z[3] & 0x01);
   Z[3] >>= 1;
   if (Z[2] & 0x00000001)
   {
      Z[3] |= 0x80000000;
   }
   Z[2] >>= 1;
   if (Z[1] & 0x00000001)
   {
      Z[2] |= 0x80000000;
   }
   Z[1] >>= 1;
   if (Z[0] & 0x00000001)
   {
      Z[1] |= 0x80000000;
   }
   Z[0] >>= 1;
   if (b)
   {
      Z[0] ^= 0xE1000000;
   }

   #if ((!defined(B_LITTLE_ENDIAN)) && (!defined(B_BIG_ENDIAN)))
   if (0x20 == (*(U8*)&serialsetup[1]))  
   #endif
   #ifndef B_BIG_ENDIAN
   {
      hsotgpdata(Z[0], X, 0);
      hsotgpdata(Z[1], X, 4);
      hsotgpdata(Z[2], X, 8);
      hsotgpdata(Z[3], X, 12);
   }
   #endif
   #if ((!defined(B_LITTLE_ENDIAN)) && (!defined(B_BIG_ENDIAN)))
   else
   #endif
   #ifndef B_LITTLE_ENDIAN
   {
      inputlevel(Z[0], X, 0);
      inputlevel(Z[1], X, 4);
      inputlevel(Z[2], X, 8);
      inputlevel(Z[3], X, 12);
   }
   #endif
}


static void pcibiossetup(SharkSslAesGcmCtx *aes)
{
   U8 (*m)[16] = aes->M0;
   #if 0
   U8 i, j;
   #endif

   memset(m[0], 0, 16);
   memset(m[8], 0, 16);
   SharkSslAesCtx_encrypt((SharkSslAesCtx*)aes, m[8], m[8]);

   #ifndef B_BIG_ENDIAN
   #ifndef B_LITTLE_ENDIAN
   if (0x20 == (*(U8*)&serialsetup[1]))  
   #endif
   {
      U32 t;

      cleanupcount(t, (U8*)(&m[8]), 0);  inputlevel(t, m[8], 0);
      cleanupcount(t, (U8*)(&m[8]), 4);  inputlevel(t, m[8], 4);
      cleanupcount(t, (U8*)(&m[8]), 8);  inputlevel(t, m[8], 8);
      cleanupcount(t, (U8*)(&m[8]), 12); inputlevel(t, m[8], 12);
   }
   #endif

   memcpy(m[4], m[8], 16);
   machinecheck(m[4]);
   memcpy(m[2], m[4], 16);
   machinecheck(m[2]);
   memcpy(m[1], m[2], 16);
   machinecheck(m[1]);

   #if 1  
   memcpy(m[3],  m[2], 16);
   memcpy(m[5],  m[4], 16);
   memcpy(m[6],  m[4], 16);
   memcpy(m[7],  m[4], 16);
   memcpy(m[9],  m[8], 16);
   memcpy(m[10], m[8], 16);
   memcpy(m[11], m[8], 16);
   memcpy(m[12], m[8], 16);
   memcpy(m[13], m[8], 16);
   memcpy(m[14], m[8], 16);
   memcpy(m[15], m[8], 16);
   paz00wifikill(m[3],  m[3],  m[1]);
   paz00wifikill(m[5],  m[5],  m[1]);
   paz00wifikill(m[6],  m[6],  m[2]);
   paz00wifikill(m[7],  m[7],  m[3]);
   paz00wifikill(m[9],  m[9],  m[1]);
   paz00wifikill(m[10], m[10], m[2]);
   paz00wifikill(m[11], m[11], m[3]);
   paz00wifikill(m[12], m[12], m[4]);
   paz00wifikill(m[13], m[13], m[5]);
   paz00wifikill(m[14], m[14], m[6]);
   paz00wifikill(m[15], m[15], m[7]);

   #else
   for (i = 2; i <= 8; i <<= 1)
   {
      for (j = 1; j < i; j++)
      {
         memcpy(m[i+j], m[i], 16);
         paz00wifikill(m[i+j], m[i+j], m[j]);
      }
   }
   #endif
}


#define simplebuffer(c,x) audioplatdata(c->M0, x)
static void audioplatdata(U8 (*M0)[16], U8 *x)
{
    U32 Z[4];
    U8  i, a;

    Z[0] = Z[1] = Z[2] = Z[3] = 0;

    for (i = 15; ; i--)
    {
        paz00wifikill((U8*)&Z[0], (U8*)&Z[0], M0[x[i]&0xF]);
        a = (U8)(Z[3] & 0xF);
        Z[3] = (Z[3] >> 4) | (Z[2] << 28);
        Z[2] = (Z[2] >> 4) | (Z[1] << 28);
        Z[1] = (Z[1] >> 4) | (Z[0] << 28);
        Z[0] >>= 4;
        Z[0] ^= ((U32)serialsetup[a]) << 16;


        paz00wifikill((U8*)&Z[0], (U8*)&Z[0], M0[x[i]>>4]);
        if (i == 0) break;
        a = (U8)(Z[3] & 0xF);
        Z[3] = (Z[3] >> 4) | (Z[2] << 28);
        Z[2] = (Z[2] >> 4) | (Z[1] << 28);
        Z[1] = (Z[1] >> 4) | (Z[0] << 28);
        Z[0] >>= 4;
        Z[0] ^= ((U32)serialsetup[a]) << 16;
    }

    inputlevel(Z[0], x, 0);
    inputlevel(Z[1], x, 4);
    inputlevel(Z[2], x, 8);
    inputlevel(Z[3], x, 12);
}


SHARKSSL_API void SharkSslAesGcmCtx_constructor(SharkSslAesGcmCtx *registermcasp,
                                                const U8 *sourcerouting, U8 creategroup)
{
   SharkSslAesCtx_constructor((SharkSslAesCtx*)registermcasp, SharkSslAesCtx_Encrypt, sourcerouting, creategroup);
   pcibiossetup(registermcasp);
}


static int pcmciaregister(SharkSslAesGcmCtx *registermcasp,
                                     const U8 vect[12], U8 tag[16],
                                     const U8 *pmuv3event, U16 authlen,
                                     const U8 *updatecause, U8 *enablehazard, U16 len,
                                     SharkSslAesCtx_Type rightsvalid)
{
   U8 remapiospace[16], sossirecalc[16], tagi[16];
   U32 alen, pxafbmodes;

   baAssert(registermcasp);
   baAssert(vect);
   baAssert(tag);
   baAssert(updatecause);
   baAssert(enablehazard);

   alen = ((U32)authlen << 3);  
   pxafbmodes = ((U32)len << 3);      

   memset(&tagi[0], 0, 16);
   if (pmuv3event)
   {
      
      while (authlen)
      {
         if (authlen >= 16)
         {
            paz00wifikill(tagi, tagi, pmuv3event);  
            pmuv3event += 16;
            authlen -= 16;
         }
         else
         {
            ntosd2nandflash(tagi, tagi, pmuv3event, authlen);  
            authlen = 0;
         }
         simplebuffer(registermcasp, tagi);
      }
   }

   memcpy(&remapiospace[0], vect, 12);
   inputlevel(1, remapiospace, 12);  

   while (len)
   {
      
      U32 requestflags;
      read64uint32(requestflags, remapiospace, 12);
      requestflags++;
      inputlevel(requestflags, remapiospace, 12);

      
      SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, remapiospace, sossirecalc);

      
      if (len >= 16)
      {
         if (SharkSslAesCtx_Encrypt == rightsvalid)
         {
            paz00wifikill(enablehazard, updatecause, sossirecalc);
            paz00wifikill(tagi, tagi, enablehazard);
         }
         else
         {
            paz00wifikill(tagi, tagi, updatecause);
            paz00wifikill(enablehazard, updatecause, sossirecalc);
         }

         updatecause  += 16;
         enablehazard += 16;
         len -= 16;
      }
      else
      {
         if (SharkSslAesCtx_Encrypt == rightsvalid)
         {
            ntosd2nandflash(enablehazard, updatecause, sossirecalc, len);
            ntosd2nandflash(tagi, tagi, enablehazard, len);
         }
         else
         {
            ntosd2nandflash(tagi, tagi, updatecause, len);
            ntosd2nandflash(enablehazard, updatecause, sossirecalc, len);
         }
         len = 0;
      }

      simplebuffer(registermcasp, tagi);
   }

   
   inputlevel(0,    sossirecalc, 0);
   inputlevel(alen, sossirecalc, 4);
   inputlevel(0,    sossirecalc, 8);
   inputlevel(pxafbmodes, sossirecalc, 12);
   paz00wifikill(tagi, tagi, sossirecalc);
   simplebuffer(registermcasp, tagi);

   
   inputlevel(1, remapiospace, 12);
   SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, remapiospace, sossirecalc);
   if (SharkSslAesCtx_Encrypt == rightsvalid)
   {
      paz00wifikill(tag, tagi, sossirecalc);
   }
   else
   {
      paz00wifikill(tagi, tagi, sossirecalc);
      return sharkssl_kmemcmp(tagi, tag, 16);
   }
   return 0;
}


SHARKSSL_API int SharkSslAesGcmCtx_encrypt(SharkSslAesGcmCtx *registermcasp,
                                           const U8 vect[12], U8 panickernel[16],
                                           const U8 *pmuv3event, U16 authlen,
                                           const U8 *updatecause, U8 *enablehazard, U16 len)
{
   return pcmciaregister(registermcasp, vect, panickernel, pmuv3event, authlen, updatecause, enablehazard, len, SharkSslAesCtx_Encrypt);
}


SHARKSSL_API int SharkSslAesGcmCtx_decrypt(SharkSslAesGcmCtx *registermcasp,
                                           const U8 vect[12], U8 directionoutput[16],
                                           const U8 *pmuv3event, U16 authlen,
                                           U8 *updatecause, U8 *enablehazard, U16 len)
{
   return pcmciaregister(registermcasp, vect, directionoutput, pmuv3event, authlen, updatecause, enablehazard, len, SharkSslAesCtx_Decrypt);
}
#endif  


#if SHARKSSL_ENABLE_AES_CCM
SHARKSSL_API void SharkSslAesCcmCtx_constructor(SharkSslAesCcmCtx *registermcasp,
                                                const U8 *sourcerouting, U8 creategroup, U8 requestarray)
{
   SharkSslAesCtx_constructor((SharkSslAesCtx*)registermcasp, SharkSslAesCtx_Encrypt, sourcerouting, creategroup);
   baAssert((requestarray == 8) || (requestarray == 16));
   registermcasp->tagLen = requestarray;
}


#ifndef SHARKSSL_ENABLE_CCM_AUTH_ALL
#define SHARKSSL_ENABLE_CCM_AUTH_ALL  0  
#endif

static int modifyparam(SharkSslAesCcmCtx *registermcasp,
                                     const U8 vect[12], U8 *tag,
                                     const U8 *pmuv3event, U16 authlen,
                                     const U8 *updatecause, U8 *enablehazard, U16 len,
                                     SharkSslAesCtx_Type rightsvalid)
{
   U8 remapiospace[16], sossirecalc[16], tagi[16];

   baAssert(registermcasp);
   baAssert(vect);
   baAssert(tag);
   baAssert(updatecause);
   baAssert(enablehazard);

   
   inputlevel((U32)len, remapiospace, 12);
   memcpy(&remapiospace[1], vect, 12);
   remapiospace[0] = (8 * ((registermcasp->tagLen >> 1) - 1))  + (3 - 1); 

   if ((pmuv3event) && (authlen))
   {
      remapiospace[0] += 64;
      SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, remapiospace, tagi);  

      baAssert(authlen < 0xFEFF);
      remapiospace[0] = (U8)((authlen >> 8) & 0xFF);
      remapiospace[1] = (U8)(authlen & 0xFF);
      #if SHARKSSL_ENABLE_CCM_AUTH_ALL
      if (authlen < 15)
      #else
      baAssert(authlen < 15);
      #endif
      {
         memcpy(&remapiospace[2], pmuv3event, authlen);
         memset(&remapiospace[2 + authlen], 0, 14 - authlen);
      }
      #if SHARKSSL_ENABLE_CCM_AUTH_ALL
      else
      {
         memcpy(&remapiospace[2], pmuv3event, 14);
         pmuv3event += 14;
         authlen -= 14;
      }
      #endif
      paz00wifikill(tagi, tagi, remapiospace);
      SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, tagi, tagi);  

      #if SHARKSSL_ENABLE_CCM_AUTH_ALL
      while (authlen)
      {
         if (authlen >= 16)
         {
            paz00wifikill(tagi, tagi, pmuv3event);  
            pmuv3event += 16;
            authlen -= 16;
         }
         else
         {
            ntosd2nandflash(tagi, tagi, pmuv3event, authlen);  
            authlen = 0;
         }
         SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, tagi, tagi);
      }
      #endif
   }

   inputlevel(0, remapiospace, 12);  
   memcpy(&remapiospace[1], vect, 12);
   remapiospace[0] = (3 - 1);  

   while (len)
   {
      
      U32 requestflags;
      read64uint32(requestflags, remapiospace, 12);
      requestflags++;
      inputlevel(requestflags, remapiospace, 12);

      
      SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, remapiospace, sossirecalc);

      
      if (len >= 16)
      {
         if (SharkSslAesCtx_Encrypt == rightsvalid)
         {
            paz00wifikill(tagi, tagi, updatecause);
            paz00wifikill(enablehazard, updatecause, sossirecalc);
         }
         else
         {
            paz00wifikill(enablehazard, updatecause, sossirecalc);
            paz00wifikill(tagi, tagi, enablehazard);
         }

         updatecause  += 16;
         enablehazard += 16;
         len -= 16;
      }
      else
      {
         if (SharkSslAesCtx_Encrypt == rightsvalid)
         {
            ntosd2nandflash(tagi, tagi, updatecause, len);
            ntosd2nandflash(enablehazard, updatecause, sossirecalc, len);
         }
         else
         {
            ntosd2nandflash(enablehazard, updatecause, sossirecalc, len);
            ntosd2nandflash(tagi, tagi, enablehazard, len);
         }
         len = 0;
      }

      
      SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, tagi, tagi);
   }

   
   remapiospace[13] =  remapiospace[14] = remapiospace[15] = 0;
   SharkSslAesCtx_encrypt((SharkSslAesCtx*)registermcasp, remapiospace, sossirecalc);
   if (SharkSslAesCtx_Encrypt == rightsvalid)
   {
      ntosd2nandflash(tag, tagi, sossirecalc, registermcasp->tagLen);
   }
   else
   {
      paz00wifikill(tagi, tagi, sossirecalc);
      return sharkssl_kmemcmp(tagi, tag, registermcasp->tagLen);
   }
   return 0;
}


SHARKSSL_API int SharkSslAesCcmCtx_encrypt(SharkSslAesCcmCtx *registermcasp,
                                           const U8 vect[12], U8 *panickernel,
                                           const U8 *pmuv3event, U16 authlen,
                                           const U8 *updatecause, U8 *enablehazard, U16 len)
{
   return modifyparam(registermcasp, vect, panickernel, pmuv3event, authlen, updatecause, enablehazard, len, SharkSslAesCtx_Encrypt);
}


SHARKSSL_API int SharkSslAesCcmCtx_decrypt(SharkSslAesCcmCtx *registermcasp,
                                           const U8 vect[12], U8 *directionoutput,
                                           const U8 *pmuv3event, U16 authlen,
                                           const U8 *updatecause, U8 *enablehazard, U16 len)
{
   return modifyparam(registermcasp, vect, directionoutput, pmuv3event, authlen, updatecause, enablehazard, len, SharkSslAesCtx_Decrypt);
}
#endif  
#endif


#ifndef BA_LIB
#define BA_LIB
#endif

#include "SharkSslASN1.h"

#include "SharkSslCrypto.h"
#if SHARKSSL_USE_ECC

#endif
#include <string.h>

#ifndef EXT_SHARK_LIB
#define sharkStrstr strstr
#endif

#define SHARKSSL_DIM_ARR(a)  (sizeof(a)/sizeof(a[0]))

#if SHARKSSL_USE_ECC
#if   SHARKSSL_ECC_USE_SECP521R1
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_SECP521R1_POINTLEN
#elif SHARKSSL_ECC_USE_BRAINPOOLP512R1
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_BRAINPOOLP512R1_POINTLEN
#elif SHARKSSL_ECC_USE_CURVE448
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_CURVE448_POINTLEN
#elif SHARKSSL_ECC_USE_SECP384R1
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_SECP384R1_POINTLEN
#elif SHARKSSL_ECC_USE_BRAINPOOLP384R1
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_BRAINPOOLP384R1_POINTLEN
#elif SHARKSSL_ECC_USE_SECP256R1
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_SECP256R1_POINTLEN
#elif SHARKSSL_ECC_USE_BRAINPOOLP256R1
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_BRAINPOOLP256R1_POINTLEN
#elif SHARKSSL_ECC_USE_CURVE25519
#define SHARKSSL_MAX_ECC_POINTLEN  SHARKSSL_CURVE25519_POINTLEN
#else
#define SHARKSSL_MAX_ECC_POINTLEN  0
#endif
#endif


#if (((SHARKSSL_SSL_CLIENT_CODE || SHARKSSL_SSL_SERVER_CODE) && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)) ||  \
     (SHARKSSL_ENABLE_CERTSTORE_API) || (SHARKSSL_ENABLE_PEM_API))

#define ALGO_ID_UNKNOWN                    processsdccr
#define ALGO_ID_SHA512                     batterythread
#define ALGO_ID_SHA384                     probewrite
#define ALGO_ID_SHA256                     domainnumber
#define ALGO_ID_SHA1                       presentpages
#define ALGO_ID_MD5                        skciphercreate
#define ALGO_ID_MD2                        0x0F
#define ALGO_ID_PKCS5_PBES2                0x9A  
#define ALGO_ID_PKCS5_PBKDF2               0x9B  

#define ALGO_ID_RSA_ENCRYPTION             entryearly
#define ALGO_ID_ECDSA                      accessactive
#define ALGO_ID_HMAC                       0x08  

#define ALGO_ID_SHA512_WITH_RSA_ENCRYPTION ((ALGO_ID_RSA_ENCRYPTION << 4) | ALGO_ID_SHA512)
#define ALGO_ID_SHA384_WITH_RSA_ENCRYPTION ((ALGO_ID_RSA_ENCRYPTION << 4) | ALGO_ID_SHA384)
#define ALGO_ID_SHA256_WITH_RSA_ENCRYPTION ((ALGO_ID_RSA_ENCRYPTION << 4) | ALGO_ID_SHA256)
#define ALGO_ID_SHA1_WITH_RSA_ENCRYPTION   ((ALGO_ID_RSA_ENCRYPTION << 4) | ALGO_ID_SHA1)
#define ALGO_ID_MD5_WITH_RSA_ENCRYPTION    ((ALGO_ID_RSA_ENCRYPTION << 4) | ALGO_ID_MD5)
#define ALGO_ID_MD2_WITH_RSA_ENCRYPTION    ((ALGO_ID_RSA_ENCRYPTION << 4) | ALGO_ID_MD2)

#define ALGO_ID_ECDSA_WITH_SHA512          ((ALGO_ID_ECDSA << 4) | ALGO_ID_SHA512)
#define ALGO_ID_ECDSA_WITH_SHA384          ((ALGO_ID_ECDSA << 4) | ALGO_ID_SHA384)
#define ALGO_ID_ECDSA_WITH_SHA256          ((ALGO_ID_ECDSA << 4) | ALGO_ID_SHA256)
#define ALGO_ID_ECDSA_WITH_SHA1            ((ALGO_ID_ECDSA << 4) | ALGO_ID_SHA1)

#define ALGO_ID_HMAC_WITH_SHA256           ((ALGO_ID_HMAC << 4) | ALGO_ID_SHA256)

#define GET_ALGO_HASH_ID(id)               (id & 0x0F)
#define GET_ALGO_SIGNATURE_ID(id)          ((id & 0xF0) >> 4)

#define ALGO_ID_AES_128_CBC                0xE1  
#define ALGO_ID_AES_256_CBC                0xE2  
#define ALGO_ID_CHACHA20                   0xE4  


U8 SharkSslParseASN1_getAlgoID(const SharkSslParseASN1 *o)
{
   switch (o->datalen)
   {
      case 9:
         #if SHARKSSL_ENABLE_RSA
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_rsaEncryption, SHARKSSL_DIM_ARR(sharkssl_oid_rsaEncryption)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_rsaEncryption));  
            return ALGO_ID_RSA_ENCRYPTION;
         }
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_md2withRSAEncryption, SHARKSSL_DIM_ARR(sharkssl_oid_md2withRSAEncryption)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_md2withRSAEncryption));  
            return ALGO_ID_MD2_WITH_RSA_ENCRYPTION;
         }
         #if SHARKSSL_USE_MD5
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_md5withRSAEncryption, SHARKSSL_DIM_ARR(sharkssl_oid_md5withRSAEncryption)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_md5withRSAEncryption));  
            return ALGO_ID_MD5_WITH_RSA_ENCRYPTION;
         }
         #endif
         
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha1withRSAEncryption, SHARKSSL_DIM_ARR(sharkssl_oid_sha1withRSAEncryption)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_sha1withRSAEncryption));  
            return ALGO_ID_SHA1_WITH_RSA_ENCRYPTION;
         }
         #if SHARKSSL_USE_SHA_256
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha256withRSAEncryption, SHARKSSL_DIM_ARR(sharkssl_oid_sha256withRSAEncryption)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_sha256withRSAEncryption));  
            return ALGO_ID_SHA256_WITH_RSA_ENCRYPTION;
         }
         #endif
         #if SHARKSSL_USE_SHA_384
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha384withRSAEncryption, SHARKSSL_DIM_ARR(sharkssl_oid_sha384withRSAEncryption)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_sha384withRSAEncryption));  
            return ALGO_ID_SHA384_WITH_RSA_ENCRYPTION;
         }
         #endif
         #if SHARKSSL_USE_SHA_512
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha512withRSAEncryption, SHARKSSL_DIM_ARR(sharkssl_oid_sha512withRSAEncryption)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_sha512withRSAEncryption));  
            return ALGO_ID_SHA512_WITH_RSA_ENCRYPTION;
         }
         #endif
         #endif  

         #if SHARKSSL_USE_SHA_256
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha256, SHARKSSL_DIM_ARR(sharkssl_oid_sha256)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_sha256));  
            return ALGO_ID_SHA256;
         }
         #endif
         #if SHARKSSL_USE_SHA_384
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha384, SHARKSSL_DIM_ARR(sharkssl_oid_sha384)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_sha384));  
            return ALGO_ID_SHA384;
         }
         #endif
         #if SHARKSSL_USE_SHA_512
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha512, SHARKSSL_DIM_ARR(sharkssl_oid_sha512)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_sha512));  
            return ALGO_ID_SHA512;
         }
         #endif
         #if SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_pkcs5PBES2, SHARKSSL_DIM_ARR(sharkssl_oid_pkcs5PBES2)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_pkcs5PBES2));  
            return ALGO_ID_PKCS5_PBES2;
         }
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_pkcs5PBKDF2, SHARKSSL_DIM_ARR(sharkssl_oid_pkcs5PBKDF2)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_pkcs5PBKDF2));  
            return ALGO_ID_PKCS5_PBKDF2;
         }
         #if (SHARKSSL_USE_AES_128 && SHARKSSL_ENABLE_AES_CBC)
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_aes128cbc, SHARKSSL_DIM_ARR(sharkssl_oid_aes128cbc)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_aes128cbc));  
            return ALGO_ID_AES_128_CBC;
         }
         #endif
         #if (SHARKSSL_USE_AES_256 && SHARKSSL_ENABLE_AES_CBC)
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_aes256cbc, SHARKSSL_DIM_ARR(sharkssl_oid_aes256cbc)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_aes256cbc));  
            return ALGO_ID_AES_256_CBC;
         }
         #endif
         #endif
         break;

      case 8:
         #if SHARKSSL_USE_MD5
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_md5, SHARKSSL_DIM_ARR(sharkssl_oid_md5)))
         {
            baAssert(8 == SHARKSSL_DIM_ARR(sharkssl_oid_md5));  
            return ALGO_ID_MD5;
         }
         #endif
         #if SHARKSSL_ENABLE_ECDSA
         #if SHARKSSL_USE_SHA_256
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_ecdsaWithSHA256, SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA256)))
         {
            baAssert(8 == SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA256));  
            return ALGO_ID_ECDSA_WITH_SHA256;
         }
         #endif
         #if SHARKSSL_USE_SHA_384
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_ecdsaWithSHA384, SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA384)))
         {
            baAssert(8 == SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA384));  
            return ALGO_ID_ECDSA_WITH_SHA384;
         }
         #endif
         #if SHARKSSL_USE_SHA_512
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_ecdsaWithSHA512, SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA512)))
         {
            baAssert(8 == SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA512));  
            return ALGO_ID_ECDSA_WITH_SHA512;
         }
         #endif
         #endif  
         #if SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT
         #if SHARKSSL_USE_SHA_256
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_HMACWithSHA256, SHARKSSL_DIM_ARR(sharkssl_oid_HMACWithSHA256)))
         {
            baAssert(8 == SHARKSSL_DIM_ARR(sharkssl_oid_HMACWithSHA256));  
            return ALGO_ID_HMAC_WITH_SHA256;
         }
         #endif
         #endif
         break;

      #if SHARKSSL_USE_ECC
      case 7:
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_ecPublicKey, SHARKSSL_DIM_ARR(sharkssl_oid_ecPublicKey)))
         {
            baAssert(7 == SHARKSSL_DIM_ARR(sharkssl_oid_ecPublicKey));  
            return ALGO_OID_EC_PUBLIC_KEY;
         }
         #if SHARKSSL_ENABLE_ECDSA
         #if SHARKSSL_USE_SHA1
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_ecdsaWithSHA1, SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA1)))
         {
            baAssert(7 == SHARKSSL_DIM_ARR(sharkssl_oid_ecdsaWithSHA1));  
            return ALGO_ID_ECDSA_WITH_SHA1;
         }
         #endif
         #endif
         break;
      #endif  

      #if SHARKSSL_USE_SHA1
      case 5:
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_sha1, SHARKSSL_DIM_ARR(sharkssl_oid_sha1)))
         {
            baAssert(5 == SHARKSSL_DIM_ARR(sharkssl_oid_sha1));  
            return ALGO_ID_SHA1;
         }
         break;
      #endif

      default:
         break;
   }

   return ALGO_ID_UNKNOWN;
}


#if SHARKSSL_USE_ECC
U8 controllerregister(U16 defaultsdhci1)
{
   
   switch (defaultsdhci1)
   {
      #if SHARKSSL_ECC_USE_SECP256R1
      case SHARKSSL_EC_CURVE_ID_SECP256R1:
         return SHARKSSL_SECP256R1_POINTLEN;
      #endif

      #if SHARKSSL_ECC_USE_SECP384R1
      case SHARKSSL_EC_CURVE_ID_SECP384R1:
         return SHARKSSL_SECP384R1_POINTLEN;
      #endif

      #if SHARKSSL_ECC_USE_SECP521R1
      case SHARKSSL_EC_CURVE_ID_SECP521R1:
         return SHARKSSL_SECP521R1_POINTLEN;
      #endif

      #if SHARKSSL_ECC_USE_BRAINPOOLP256R1
      case SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1:
         return SHARKSSL_BRAINPOOLP256R1_POINTLEN;
      #endif

      #if SHARKSSL_ECC_USE_BRAINPOOLP384R1
      case SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1:
         return SHARKSSL_BRAINPOOLP384R1_POINTLEN;
      #endif

      #if SHARKSSL_ECC_USE_BRAINPOOLP512R1
      case SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1:
         return SHARKSSL_BRAINPOOLP512R1_POINTLEN;
      #endif

      #if SHARKSSL_ECC_USE_CURVE25519
      case SHARKSSL_EC_CURVE_ID_CURVE25519:
         return SHARKSSL_CURVE25519_POINTLEN;
      #endif

      #if SHARKSSL_ECC_USE_CURVE448
      case SHARKSSL_EC_CURVE_ID_CURVE448:
         return SHARKSSL_CURVE448_POINTLEN;
      #endif

      default:
         break;
   }

   return 0;
}


U8 SharkSslParseASN1_getCurveID(const SharkSslParseASN1 *o)
{
   switch (o->datalen)
   {
      case 5:
         #if SHARKSSL_ECC_USE_SECP384R1
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_secp384r1, SHARKSSL_DIM_ARR(sharkssl_oid_secp384r1)))
         {
            baAssert(5 == SHARKSSL_DIM_ARR(sharkssl_oid_secp384r1));  
            return SHARKSSL_EC_CURVE_ID_SECP384R1;
         }
         #endif
         #if SHARKSSL_ECC_USE_SECP521R1
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_secp521r1, SHARKSSL_DIM_ARR(sharkssl_oid_secp521r1)))
         {
            baAssert(5 == SHARKSSL_DIM_ARR(sharkssl_oid_secp521r1));  
            return SHARKSSL_EC_CURVE_ID_SECP521R1;
         }
         #endif
         break;

      case 8:
         #if SHARKSSL_ECC_USE_SECP256R1
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_prime256v1, SHARKSSL_DIM_ARR(sharkssl_oid_prime256v1)))
         {
            baAssert(8 == SHARKSSL_DIM_ARR(sharkssl_oid_prime256v1));  
            return SHARKSSL_EC_CURVE_ID_SECP256R1;
         }
         #endif
         break;

      case 9:
         #if SHARKSSL_ECC_USE_BRAINPOOLP256R1
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_brainpoolP256r1, SHARKSSL_DIM_ARR(sharkssl_oid_brainpoolP256r1)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_brainpoolP256r1));  
            return SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1;
         }
         #endif
         #if SHARKSSL_ECC_USE_BRAINPOOLP384R1
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_brainpoolP384r1, SHARKSSL_DIM_ARR(sharkssl_oid_brainpoolP384r1)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_brainpoolP384r1));  
            return SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1;
         }
         #endif
         #if SHARKSSL_ECC_USE_BRAINPOOLP512R1
         if (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_brainpoolP512r1, SHARKSSL_DIM_ARR(sharkssl_oid_brainpoolP512r1)))
         {
            baAssert(9 == SHARKSSL_DIM_ARR(sharkssl_oid_brainpoolP512r1));  
            return SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1;
         }
         #endif
         break;

      default:
         break;
   }

   return SHARKSSL_EC_CURVE_ID_UNKNOWN;
}
#endif
#endif


#if (((SHARKSSL_SSL_CLIENT_CODE || SHARKSSL_SSL_SERVER_CODE) && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)) || \
     (SHARKSSL_ENABLE_CERTSTORE_API))
static int sha256final(SharkSslParseASN1 *o)
{
   if (o->len < 1)
   {
      return -1;
   }

   o->datalen = 0;

   
   if (*(o->ptr) != 0xA0)  
   {
      return 0;
   }
   o->ptr++;
   o->len--;

   if (SharkSslParseASN1_getLength(o) < 0)
   {
      return -1;
   }
   if ((SharkSslParseASN1_getInt(o) < 0) || (o->datalen > 4))
   {
      return -1;
   }

   return 0;
}


static int deltacamera(SharkSslParseASN1 *o, SharkSslCertDN *dn)
{
   U8 *end, attrib, rightsvalid;
   int l;

   if ((l = SharkSslParseASN1_getSequence(o)) < 0)
   {
      return -1;
   }
   end = o->ptr + l;

   memset(dn, 0, sizeof(SharkSslCertDN));
   while (o->ptr < end)
   {
      SharkSslParseASN1_getSet(o);
      if ((SharkSslParseASN1_getSequence(o) < 0) || (o->ptr >= end) ||
          (*(o->ptr++) != SHARKSSL_ASN1_OID) ||
          ((l = SharkSslParseASN1_getLength(o)) < 0) || (o->len < 2))
      {
         return -1;
      }
      o->len--;

      attrib = 0;
      if (*(o->ptr) != SHARKSSL_OID_JIIT_DS)
      {
         attrib = 1;
         if (*(o->ptr) == sharkssl_oid_emailAddress[0])
         {
            attrib++;
         }
      }
      o->ptr++;
      o->len--;
      if (0 == attrib)
      {
         if (*(o->ptr++) != SHARKSSL_OID_JIIT_DS_ATTRTYPE)
         {
            attrib = 1;
         }
         o->len--;
      }
      if (attrib)
      {
         attrib = (U8)sharkssl_kmemcmp(o->ptr, &sharkssl_oid_emailAddress[1], (int)(SHARKSSL_DIM_ARR(sharkssl_oid_emailAddress) - 1));
         o->ptr += (U32)l;
         o->len -= (U32)l;
         if ((l = SharkSslParseASN1_getLength(o)) < 0)
         {
            return -1;
         }
         if (0 == attrib)
         {
            dn->emailAddress = o->ptr;
            dn->emailAddressLen = (U8)l;
         }
         o->ptr += (U32)l;
         o->len -= (U32)l;
         continue;
      }

      if (l != 3)
      {
         return -1;
      }

      attrib  = *(o->ptr++);
      rightsvalid    = *(o->ptr++);
      o->len -= 2;
      if ((l = SharkSslParseASN1_getLength(o)) < 0)
      {
         return -1;  
      }

      if (l > 0xFF)  
      {
         return -1;  
      }

      if ((rightsvalid == SHARKSSL_ASN1_UTF8_STRING) || (rightsvalid == SHARKSSL_ASN1_PRINTABLE_STRING) || (rightsvalid == SHARKSSL_ASN1_T61_STRING) ||
          (rightsvalid == SHARKSSL_ASN1_IA5_STRING) || (rightsvalid == SHARKSSL_ASN1_BMP_STRING))
      {
         switch (attrib)
         {
            case SHARKSSL_OID_JIIT_DS_ATTRTYPE_CN:
               dn->commonName = o->ptr;
               dn->commonNameLen = (U8)l;
               break;

            case SHARKSSL_OID_JIIT_DS_ATTRTYPE_COUNTRY:
               dn->countryName = o->ptr;
               dn->countryNameLen = (U8)l;
               break;

            case SHARKSSL_OID_JIIT_DS_ATTRTYPE_LOCALITY:
               dn->locality = o->ptr;
               dn->localityLen = (U8)l;
               break;

            case SHARKSSL_OID_JIIT_DS_ATTRTYPE_PROVINCE:
               dn->province = o->ptr;
               dn->provinceLen = (U8)l;
               break;

            case SHARKSSL_OID_JIIT_DS_ATTRTYPE_ORGANIZATION:
               dn->organization = o->ptr;
               dn->organizationLen = (U8)l;
               break;

            case SHARKSSL_OID_JIIT_DS_ATTRTYPE_UNIT:
               dn->unit = o->ptr;
               dn->unitLen = (U8)l;
               break;

            default:
               break;
         }
      }
      o->ptr += (U32)l;
      o->len -= (U32)l;
   }

   return 0;
}
#endif


#if ((SHARKSSL_SSL_CLIENT_CODE && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)) || \
     (SHARKSSL_SSL_SERVER_CODE) || (SHARKSSL_ENABLE_CSR_SIGNING))

int spromregister(SharkSslCertParam *o, const U8 *p, U32 len, U8 *doublefnmul)
{
   SharkSslParseASN1 parseCert, parseBitString;
   U8 *pTemp, tag;
   U32 probealchemy = 0;
   int l, v;

   baAssert((doublefnmul == NULL) || ((U32)-1 == len) || ((U32)-2 == len) || ((U32)-3 == len) || ((U32)-4 == len) || ((U32)-5 == len));

   parseCert.ptr = (U8*)p;
   #if (SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-4 == len)  
   {
      parseCert.len = *(U32*)doublefnmul;
   }
   else
   #endif
   {
      parseCert.len = len;
   }

   if ((l = SharkSslParseASN1_getSequence(&parseCert)) < 0)
   {
      return -1;    
   }

   
   pTemp = parseCert.ptr;

   if ((l = SharkSslParseASN1_getSequence(&parseCert)) < 0)
   {
      return -1;    
   }

   
   parseBitString.len = parseCert.len - (U32)l;
   parseBitString.ptr = parseCert.ptr + (U32)l;
   if (SharkSslParseASN1_getSequence(&parseBitString) < 0)
   {
      return -1;
   }
   if (SharkSslParseASN1_getOID(&parseBitString) < 0)
   {
      return -1;
   }
   
   tag = SharkSslParseASN1_getAlgoID(&parseBitString);

   if ((doublefnmul == NULL) && ((U32)-1 == len))  
   {
      return ((U16)(GET_ALGO_HASH_ID(tag)) << 8) + GET_ALGO_SIGNATURE_ID(tag);
   }

   #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
   if ((doublefnmul != NULL) && ((U32)-3 == len))  
   {
      *(int*)doublefnmul = ((U16)(GET_ALGO_HASH_ID(tag)) << 8) + GET_ALGO_SIGNATURE_ID(tag);
      goto SharkSslCertParam_parseCert_1;
   }
   #endif

   #if (SHARKSSL_ENABLE_CLIENT_AUTH || SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-2 == len)
   {
      goto SharkSslCertParam_parseCert_1;
   }
   #endif

   o->signature.hashAlgo = GET_ALGO_HASH_ID(tag);
   o->signature.signatureAlgo = GET_ALGO_SIGNATURE_ID(tag);

   
   if (tag == ALGO_ID_MD2_WITH_RSA_ENCRYPTION)  
   {
      memset(o->signature.hash, 0, 20);
   }
   #if (!SHARKSSL_USE_SHA1)
   else if (tag == ALGO_ID_SHA1_WITH_RSA_ENCRYPTION)  
   {
      memset(o->signature.hash, 0, 20);
   }
   #endif
   else if (sharkssl_hash(o->signature.hash, pTemp, (U16)(l + (U16)(parseCert.ptr - pTemp)), o->signature.hashAlgo) < 0)
   {
      return -1;  
   }

   
   probealchemy = parseBitString.len;
   pTemp  = parseBitString.ptr;

   #if (SHARKSSL_ENABLE_CLIENT_AUTH || (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI) || SHARKSSL_ENABLE_CSR_SIGNING)
   SharkSslCertParam_parseCert_1:
   #endif

   parseCert.len = (U32)l;

   #if (SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-4 != len)  
   #endif
   {
      if (sha256final(&parseCert) < 0)
      {
         return -1;    
      }

      #if (SHARKSSL_ENABLE_CLIENT_AUTH || (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI) || SHARKSSL_ENABLE_CSR_SIGNING)
      if (((U32)-2 != len) && ((U32)-3 != len))
      #endif
      {
         if (parseCert.datalen == 1)
         {
            o->certInfo.version = *(parseCert.dataptr);
         }
         else
         {
            o->certInfo.version = 0;
         }
      }
   }

   
   if (SharkSslParseASN1_getInt(&parseCert) < 0)
   {
      return -1;
   }

   #if (SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-4 != len)  
   #endif
   {
      #if (SHARKSSL_ENABLE_CLIENT_AUTH || (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI) || SHARKSSL_ENABLE_CSR_SIGNING)
      if (((U32)-2 != len) && ((U32)-3 != len))
      #endif
      {
         o->certInfo.sn = parseCert.dataptr;
         o->certInfo.snLen = (U16)parseCert.datalen;
      }

      
      if (SharkSslParseASN1_getSequence(&parseCert) < 0)
      {
         return -1;
      }
      if (SharkSslParseASN1_getOID(&parseCert) < 0)
      {
         return -1;
      }
      
      if (SharkSslParseASN1_getAlgoID(&parseCert) != tag)
      {
         return -1;
      }

      #if (SHARKSSL_ENABLE_CLIENT_AUTH || SHARKSSL_ENABLE_CSR_SIGNING)
      if ((U32)-2 == len)
      {
         
         if (doublefnmul)
         {
            
            parseBitString.ptr = parseCert.ptr;
            parseBitString.len = parseCert.len;
            if ((l = SharkSslParseASN1_getSequence(&parseBitString)) < 0)
            {
               return -1;
            }
            l += (int)(parseBitString.ptr - parseCert.ptr);
            if (((U32)l > parseCert.len) || ((U32)l > 0xFFFF))
            {
               return -1;
            }
            *(U16*)doublefnmul = (U16)l;
         }
         return (int)(parseCert.ptr - p);
      }
      #endif

      
      if (deltacamera(&parseCert, &(o->certInfo.issuer)) < 0)
      {
         return -1;
      }

      if (SharkSslParseASN1_getSequence(&parseCert) < 0)
      {
         return -1;
      }

      
      if (!SharkSslParseASN1_getUTCTime(&parseCert))
      {
         if ((parseCert.datalen != 13) || (parseCert.dataptr[12] != '\132'))
         {
            return -1;  
         }
      }
      else if (!SharkSslParseASN1_getGenTime(&parseCert))
      {
         if ((parseCert.datalen < 13) || (parseCert.dataptr[parseCert.datalen - 1] != '\132') || (parseCert.datalen > 0xFF))
         {
            return -1;  
         }
      }
      else
      {
         return -1;
      }
      o->certInfo.timeFrom = parseCert.dataptr;
      o->certInfo.timeFromLen = (U8)parseCert.datalen;

      
      if (!SharkSslParseASN1_getUTCTime(&parseCert))
      {
         if ((parseCert.datalen != 13) || (parseCert.dataptr[12] != '\132'))
         {
            return -1;  
         }
      }
      else if (!SharkSslParseASN1_getGenTime(&parseCert))
      {
         if ((parseCert.datalen < 13) || (parseCert.dataptr[parseCert.datalen - 1] != '\132') || (parseCert.datalen > 0xFF))
         {
            return -1;  
         }
      }
      else
      {
         return -1;
      }
      o->certInfo.timeTo = parseCert.dataptr;
      o->certInfo.timeToLen = (U8)parseCert.datalen;
   }

   #if (SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-4 == len)  
   {
      *(U16*)&(o->certInfo.issuer.countryNameLen) = (U16)parseCert.len;
   }
   #endif
   
   if (deltacamera(&parseCert, &(o->certInfo.subject)) < 0)
   {
      return -1;
   }
   #if (SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-4 == len)  
   {
      *(U16*)&(o->certInfo.issuer.countryNameLen) -= (U16)parseCert.len;
      
   }
   #endif

   
   if (SharkSslParseASN1_getSequence(&parseCert) < 0)
   {
      return -1;
   }

   
   if (SharkSslParseASN1_getSequence(&parseCert) < 0)
   {
      return -1;
   }
   if (SharkSslParseASN1_getOID(&parseCert) < 0)
   {
      return -1;
   }

   
   switch (SharkSslParseASN1_getAlgoID(&parseCert))
   {
      #if SHARKSSL_USE_ECC
      case ALGO_OID_EC_PUBLIC_KEY:
         if (SharkSslParseASN1_getOID(&parseCert) < 0)
         {
            return -1;
         }
         l = SharkSslParseASN1_getCurveID(&parseCert);
         baAssert(l < 0x0100);  
         if ((l == SHARKSSL_EC_CURVE_ID_UNKNOWN) || (SharkSslParseASN1_getBitString(&parseCert) < 0))
         {
            return -1;
         }

         #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
         if ((U32)-3 == len)
         {
            goto SharkSslCertParam_parseCert_2;
         }
         #endif

         parseBitString.len = parseCert.datalen;
         parseBitString.ptr = parseCert.dataptr;
         while ((0 == *parseBitString.ptr) && (parseBitString.len))
         {
            parseBitString.ptr++;
            parseBitString.len--;
         }
         if (0 == parseBitString.len)
         {
            return -1;
         }
         parseBitString.len--;
         if  (*parseBitString.ptr++ != SHARKSSL_EC_POINT_UNCOMPRESSED)
         {
            return -1;
         }

         
         baAssert(parseBitString.len < 0x0100);
         o->certKey.mod = parseBitString.ptr;
         o->certKey.modLen = (U16)parseBitString.len >> 1;
         if ((parseBitString.len & 0x1) || (o->certKey.modLen != (U16)controllerregister((U16)l)))
         {
            return -1;
         }

         
         baAssert((U8)l);
         nomsrnoirq(o->certKey.modLen, (U16)l);

         
         o->certKey.exp = (U8*)0;
         o->certKey.expLen = 0;
         deltaticks(o->certKey.expLen);

         
         baAssert(loaderbinfmt(o->certKey.modLen,o->certKey.expLen) == ((U16)parseBitString.len >> 1));
         baAssert(targetoracle(o->certKey.modLen,o->certKey.expLen) == (U8)l);
         baAssert(mousethresh(o->certKey.expLen) == 0);
         baAssert(monadiccheck(o->certKey.expLen) == 0);
         baAssert(coupledexynos(o->certKey.expLen));
         baAssert(machinereboot(o->certKey.expLen));
         parseBitString.ptr += parseBitString.len;
         break;
      #endif

      #if SHARKSSL_ENABLE_RSA
      case ALGO_ID_RSA_ENCRYPTION:
         
         if (SharkSslParseASN1_getBitString(&parseCert) < 0)
         {
            return -1;
         }

         #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
         if ((U32)-3 == len)
         {
            goto SharkSslCertParam_parseCert_2;
         }
         #endif

         parseBitString.len = parseCert.datalen;
         parseBitString.ptr = parseCert.dataptr;
         if ((parseBitString.len < 1) || (*(parseBitString.ptr++) != 0x00))
         {
            return -1;
         }
         parseBitString.len--;
         if (SharkSslParseASN1_getSequence(&parseBitString) < 0)
         {
            return -1;
         }

         
         if (SharkSslParseASN1_getInt(&parseBitString) < 0)
         {
            return -1;
         }
         o->certKey.mod = parseBitString.dataptr;
         o->certKey.modLen = (U16)parseBitString.datalen;

         
         baAssert(supportedvector(o->certKey.modLen) == (U16)parseBitString.datalen);

         
         while (supportedvector(o->certKey.modLen) & 0x1F)
         {
            
            o->certKey.modLen--;  
            if (*(o->certKey.mod++) != 0x00)
            {
               return -1;
            }
         }

         
         if ((SharkSslParseASN1_getInt(&parseBitString) < 0) || (parseBitString.len))
         {
            return -1;
         }
         o->certKey.exp = parseBitString.dataptr;
         o->certKey.expLen = (U16)parseBitString.datalen;
         specialmapping(o->certKey.expLen);

         
         baAssert(mousethresh(o->certKey.expLen) == (U16)parseBitString.datalen);

         

         
         baAssert(monadiccheck(o->certKey.expLen) == 0);
         baAssert(coupledexynos(o->certKey.expLen));
         baAssert(machinekexec(o->certKey.expLen));
         break;
      #endif


      default:
         return -1;
   }

   if (parseCert.ptr != parseBitString.ptr)
   {
      return -1;
   }

   #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
   SharkSslCertParam_parseCert_2:
   #endif

   #if (SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-4 == len)  
   {
      
      l = SharkSslParseASN1_getCSRAttributes(&parseCert);
      *(U32*)doublefnmul = 0;  
   }
   else
   #endif
   {
      
      SharkSslParseASN1_getIssuerUniqueID(&parseCert);
      SharkSslParseASN1_getSubjectUniqueID(&parseCert);
      l = SharkSslParseASN1_getExtensions(&parseCert);
   }

   
   if (parseCert.len != 0)
   {
      return -1;
   }

   o->certInfo.CAflag = 0;
   o->certInfo.subjectAltNamesPtr = 0;
   o->certInfo.subjectAltNamesLen = 0;

   if (l == 0)  
   {
      
      parseCert.ptr = parseCert.dataptr;
      parseCert.len = parseCert.datalen;
      if (((v = SharkSslParseASN1_getSequence(&parseCert)) > 0) && ((U32)v < parseCert.datalen))
      {
         #if (SHARKSSL_ENABLE_CSR_SIGNING)
         if ((U32)-4 == len)  
         {
            if (SharkSslParseASN1_getOID(&parseCert) < 0)
            {
               return -1;
            }
            if ((parseCert.datalen != SHARKSSL_DIM_ARR(sharkssl_oid_csr_ext_req)) ||
                (sharkssl_kmemcmp(parseCert.dataptr, sharkssl_oid_csr_ext_req, SHARKSSL_DIM_ARR(sharkssl_oid_csr_ext_req))))
            {
               return -1;
            }
            if ((v = SharkSslParseASN1_getSet(&parseCert)) <= 0)
            {
               return -1;
            }
            if ((v = SharkSslParseASN1_getSequence(&parseCert)) < 0)
            {
               return -1;
            }
            *(U16*)&(o->certInfo.issuer.commonNameLen) = (U16)(int)(parseCert.ptr - p);  
            *(U32*)doublefnmul = (U16)v;  
         }
         else
         #endif
         while (parseCert.len)
         {
            if ((l = SharkSslParseASN1_getSequence(&parseCert)) < 0)
            {
               break;
            }

            
            parseBitString.ptr = parseCert.ptr;
            parseBitString.len = (U32)l;

            parseCert.ptr += (U32)l;
            parseCert.len -= (U32)l;

            if (SharkSslParseASN1_getOID(&parseBitString) < 0)
            {
               continue;
            }

            if ((parseBitString.datalen == 3) && (parseBitString.dataptr[1] == SHARKSSL_OID_JIIT_DS_CERTEXT) && (parseBitString.dataptr[0] == SHARKSSL_OID_JIIT_DS))
            {
               if (parseBitString.dataptr[2] == SHARKSSL_OID_JIIT_DS_CERTEXT_BASICCONSTRAINTS)
               {
                  
                  SharkSslParseASN1_getBool(&parseBitString);
                  if ((SharkSslParseASN1_getOctetString(&parseBitString) == 0) && (parseBitString.len == 0))
                  {
                     
                     parseBitString.ptr = parseBitString.dataptr;
                     parseBitString.len = parseBitString.datalen;
                     if (SharkSslParseASN1_getSequence(&parseBitString) > 0)
                     {
                        if ((SharkSslParseASN1_getBool(&parseBitString) == 0) &&
                            (parseBitString.datalen == 1) && (parseBitString.dataptr[0] != 0))
                        {
                           o->certInfo.CAflag++;
                           break;  
                        }
                     }
                  }
               }
               #if SHARKSSL_ENABLE_CERT_KEYUSAGE
               
               else if (parseBitString.dataptr[2] == SHARKSSL_OID_JIIT_DS_CERTEXT_KEYUSAGE)
               {
                  
                  if (SharkSslParseASN1_getBool(&parseBitString) == 0)
                  {
                     
                     if ((parseBitString.datalen == 1) && *(parseBitString.dataptr))
                     {
                        o->certInfo.keyUsagePurposes |= SHARKSSL_CERT_KEYUSAGE_CRITICAL;
                     }
                  }
                  #if (SHARKSSL_CERT_KEYUSAGE_DIGITALSIGNATURE !=  0x00000001) || \
                      (SHARKSSL_CERT_KEYUSAGE_NONREPUDIATION   !=  0x00000002) || \
                      (SHARKSSL_CERT_KEYUSAGE_KEYENCIPHERMENT  !=  0x00000004) || \
                      (SHARKSSL_CERT_KEYUSAGE_DATAENCIPHERMENT !=  0x00000008) || \
                      (SHARKSSL_CERT_KEYUSAGE_KEYAGREEMENT     !=  0x00000010) || \
                      (SHARKSSL_CERT_KEYUSAGE_KEYCERTSIGN      !=  0x00000020) || \
                      (SHARKSSL_CERT_KEYUSAGE_CRLSIGN          !=  0x00000040) || \
                      (SHARKSSL_CERT_KEYUSAGE_ENCIPHERONLY     !=  0x00000080) || \
                      (SHARKSSL_CERT_KEYUSAGE_DECIPHERONLY     !=  0x00000100)
                  #error wrong SHARKSSL_CERT_KEYUSAGE_ values
                  #endif
                  if (SharkSslParseASN1_getOctetString(&parseBitString) == 0)
                  {
                     parseBitString.ptr = parseBitString.dataptr;
                     parseBitString.len = parseBitString.datalen;
                     if (SharkSslParseASN1_getBitString(&parseBitString) == 0)
                     {
                        U8 a, *pb = parseBitString.dataptr;
                        l = parseBitString.datalen;
                        if ((parseBitString.len == 0) && (l >= 2))
                        {
                           l--;
                           v = l * 8;
                           
                           if (v >= *pb)
                           {
                              v -= *pb;  
                              pb++;      
                              if (v > 8)
                              {
                                 v = 8;
                                 if ((l > 1) && (pb[1] & 0x80))  
                                 {
                                    o->certInfo.keyUsagePurposes |= 0x100;
                                 }
                              }
                              a = *pb;  
                              for (l = 0x1; v > 0; v--, l <<= 1, a <<= 1)
                              {
                                 if (a & 0x80)
                                 {
                                    o->certInfo.keyUsagePurposes |= (U8)l;
                                 }
                              }
                              o->certInfo.keyUsagePurposes |= SHARKSSL_CERT_KEYUSAGE_PRESENT;
                           }
                        }
                     }
                  }
               }
               #endif
               else if ((parseBitString.dataptr[2] == SHARKSSL_OID_JIIT_DS_CERTEXT_SUBJALTNAMES) && (!o->certInfo.CAflag)) 
               {
                  if ((SharkSslParseASN1_getOctetString(&parseBitString) == 0) && (parseBitString.len == 0))
                  {
                     parseBitString.ptr = parseBitString.dataptr;
                     parseBitString.len = parseBitString.datalen;
                     if (SharkSslParseASN1_getSequence(&parseBitString) > 0)
                     {
                        baAssert(parseBitString.len <= 0xFFFF);
                        o->certInfo.subjectAltNamesPtr = parseBitString.ptr;
                        o->certInfo.subjectAltNamesLen = (U16)parseBitString.len;
                     }
                  }
               }
            }
            else if ((parseBitString.datalen == SHARKSSL_DIM_ARR(sharkssl_oid_ns_cert_type)) &&
                     (0 == sharkssl_kmemcmp(parseBitString.dataptr, sharkssl_oid_ns_cert_type, SHARKSSL_DIM_ARR(sharkssl_oid_ns_cert_type))))
            {
               
               if ((SharkSslParseASN1_getOctetString(&parseBitString) == 0) && (parseBitString.len == 0))
               {
                  parseBitString.ptr = parseBitString.dataptr;
                  parseBitString.len = parseBitString.datalen;
                  if (SharkSslParseASN1_getBitString(&parseBitString) == 0)
                  {
                     
                     if ((parseBitString.datalen) &&  (parseBitString.dataptr[parseBitString.datalen - 1] & 0x04))
                     {
                        o->certInfo.CAflag++;
                        break;  
                     }
                  }
               }
            }
         }
      }
   }

   #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
   if ((U32)-3 == len)
   {
      return 0;
   }
   #endif

   parseBitString.ptr = pTemp;
   parseBitString.len = probealchemy;
   if (SharkSslParseASN1_getBitString(&parseBitString) < 0)
   {
      return -1;
   }
   o->signature.signature = parseBitString.dataptr;
   o->signature.signLen   = (U16)parseBitString.datalen;

   #if SHARKSSL_ENABLE_ECDSA
   if (o->signature.signatureAlgo == ALGO_ID_ECDSA)
   {
      
      while ((o->signature.signLen) && (0 == *(o->signature.signature)))
      {
         o->signature.signLen--;
         o->signature.signature++;
      }
   }
   #if SHARKSSL_ENABLE_RSA
   else
   #endif
   #endif
   #if SHARKSSL_ENABLE_RSA
   if (o->signature.signatureAlgo == ALGO_ID_RSA_ENCRYPTION)
   {
      
      while (o->signature.signLen & 0x1F)
      {
         
         o->signature.signLen--;
         if (*(o->signature.signature++) != 0x00)
         {
            return -1;
         }
      }
   }
   #endif  

   #if (SHARKSSL_ENABLE_CSR_SIGNING)
   if ((U32)-4 == len)  
   {
      *(U32*)doublefnmul |= ((U32)(*(U16*)&(o->certInfo.issuer.countryNameLen)) << 16);
      return (int)*(U16*)&(o->certInfo.issuer.commonNameLen);  
   }
   #endif

   return 0;
}


SharkSslCert removerecursive(SharkSslCertEnum *o)
{
   #if SHARKSSL_ENABLE_CERT_CHAIN
   if (o->cert != NULL)
   {
      if (o->priv_notFirstCertFlag)  
      {
         if (o->priv_chainLen)
         {
            o->priv_chainLen--;
            o->cert += o->certLen;
         }
         else
         {
            o->cert = NULL;
         }
      }
      else  
      {
         U16 setpropinplace, chargeerror;
         o->priv_notFirstCertFlag++;
         o->cert += o->certLen;
         
         while (0xFF == *o->cert)
         {
            o->cert++;
         }
         
         setpropinplace  = (U16)(*(o->cert++)) << 8;
         setpropinplace += *(o->cert++);
         o->priv_chainLen = monadiccheck(setpropinplace);
         if (o->priv_chainLen)
         {
            o->priv_chainLen--;
            
            chargeerror  = (U16)(*(o->cert++)) << 8;
            chargeerror += *(o->cert++);
            
            o->cert += mousethresh(setpropinplace);
            #if SHARKSSL_ENABLE_RSA
            if (machinekexec(setpropinplace))
            {
               baAssert(chargeerror == supportedvector(chargeerror));
               baAssert((chargeerror <= 0x3FFF) && (0 == (chargeerror & 0x01)));
               o->cert += (U16)(chargeerror << 2);
               o->cert -= (U16)(chargeerror >> 1);
            }
            #if SHARKSSL_USE_ECC
            else
            #endif
            #endif
            #if SHARKSSL_USE_ECC
            if (machinereboot(setpropinplace))
            {
               chargeerror = attachdevice(chargeerror);
               baAssert((chargeerror < 0x00FF) && (0 == (chargeerror & 0x01)));
               o->cert += (U16)(chargeerror << 1);
            }
            #endif
            else
            {
               o->cert = NULL;  
            }
         }
         else
         {
            o->cert = NULL;  
         }
      }
   }
   #else
   o->cert = NULL;
   #endif
   o->certLen = SharkSslCert_len(o->cert);
   return o->cert;
}


#if SHARKSSL_ENABLE_RSASSA_PSS

static int resetquirks(U8 *singleunpack, U8 *resourceaddress64, U16 pxacameraplatform, U8 configwrite)
{
   U8  chargerplatform[SHARKSSL_MAX_HASH_LEN], save[4];
   U16 usb11device, ftraceupdate, j;
   int offsetarray = 0;

   baAssert(resourceaddress64);
   ftraceupdate = sharkssl_getHashLen(configwrite);
   if (0 == ftraceupdate)
   {
      return -1;
   }
   memcpy(&save[0], singleunpack + ftraceupdate, 4);  
   *(U32*)(singleunpack + ftraceupdate) = 0x00000000;
   for (;;)
   {
      if (sharkssl_hash(&chargerplatform[0], singleunpack, ftraceupdate + 4, configwrite))
      {
         offsetarray = -1;
         break;
      }

      usb11device = (pxacameraplatform >= ftraceupdate) ? ftraceupdate : pxacameraplatform;
      for (j = 0; j < usb11device; j++)
      {
         *resourceaddress64++ ^= chargerplatform[j];
      }
      pxacameraplatform -= usb11device;
      if (pxacameraplatform > 0)
      {
         (*(singleunpack + ftraceupdate + 3))++;  
      }
      else
      {
         break;
      }
   }
   memcpy(singleunpack + ftraceupdate, &save[0], 4);  
   return offsetarray;
}
#endif  


int systemcapabilities(const SharkSslSignParam *o)
{
   #if SHARKSSL_ENABLE_ECDSA
   U8 kexecprepare[claimresource(SHARKSSL_MAX_ECC_POINTLEN)];
   U8 stackoverflow[claimresource(SHARKSSL_MAX_ECC_POINTLEN)];
   SharkSslECDSAParam ecdsaParam;
   #endif
   SharkSslParseASN1 parseSgn;
   U8 *s;
   int len;

   s = o->signature.signature;

   switch (o->signature.signatureAlgo)
   {
      #if SHARKSSL_ENABLE_RSA
      #if (SHARKSSL_TLS_1_2 || SHARKSSL_ENABLE_RSA_PKCS1)
      case entryearly:
      #endif
      #if SHARKSSL_ENABLE_RSASSA_PSS
      case SHARKSSL_SIGNATUREALGORITHM_RSA_PSS:
      #endif
         if (!(machinekexec(o->pCertKey->expLen)) || (o->signature.signLen != supportedvector(o->pCertKey->modLen)))
         {
            return -1;
         }

         len = (int)handleguest(o->pCertKey, o->signature.signLen, s, s,
               #if SHARKSSL_ENABLE_RSASSA_PSS
               (o->signature.signatureAlgo == SHARKSSL_SIGNATUREALGORITHM_RSA_PSS) ? SHARKSSL_RSA_NO_PADDING :
               #endif
               SHARKSSL_RSA_PKCS1_PADDING);
         if (len < 0)
         {
            return -1;
         }

         #if SHARKSSL_ENABLE_RSASSA_PSS
         if (o->signature.signatureAlgo == SHARKSSL_SIGNATUREALGORITHM_RSA_PSS)
         {
            U32 sgnWord, lzbMask;
            U16 locationnotifier;

            
            len = supportedvector(o->pCertKey->modLen) - 1;  
            if (*(s + len) != 0xBC)
            {
               return -1;  
            }
            locationnotifier = sharkssl_getHashLen(o->signature.hashAlgo);
            len -= locationnotifier;  
            
            read64uint32(lzbMask, s, 0);
            if (0 == lzbMask)
            {
               return -1;  
            }
            lzbMask |= (lzbMask >> 1);
            lzbMask |= (lzbMask >> 2);
            lzbMask |= (lzbMask >> 4);
            lzbMask |= (lzbMask >> 8);
            lzbMask |= (lzbMask >> 16);
            
            if (resetquirks(s + (U16)len, s, (U16)len, o->signature.hashAlgo))
            {
               return -1;
            }
            
            read64uint32(sgnWord, s, 0);
            sgnWord &= lzbMask;  
            inputlevel(sgnWord, s, 0);
            
            len -= locationnotifier;
            len--;  
            if (len < 0)
            {
               return -1;  
            }
            while (len >= 4)
            {
               read64uint32(sgnWord, s, 0);
               if (sgnWord)
               {
                  return -1;  
               }
               s += 4;
               len -= 4;
            }
            while ((len > 0) && (0 == *s++))
            {
               len--;
            }
            if ((len > 0) || (*s++ != 0x01))
            {
               return -1;  
            }
            
            s -= locationnotifier;
            memcpy(s, o->signature.hash, locationnotifier);
            len = 8 + (locationnotifier << 1);
            if (sharkssl_hash(s, s - 8, (U16)len, o->signature.hashAlgo))
            {
               return -1;
            }
            len -= 8;
            if (sharkssl_kmemcmp(s, s + len, locationnotifier))
            {
               return -1;
            }
            break;
         }
         else
         #endif
         {
            if (o->signature.hashAlgo == defaultspectre)
            {
               if (sharkssl_kmemcmp(o->signature.hash, s, (U16)len))
               {
                  return -1;
               }
            }
            #if SHARKSSL_TLS_1_2
            else  
            {
               parseSgn.ptr = s;
               parseSgn.len = (U16)len;

               if ((len = SharkSslParseASN1_getSequence(&parseSgn)) < 0)
               {
                  return -1;
               }

               if (((U32)len != parseSgn.len) || (SharkSslParseASN1_getSequence(&parseSgn) < 0) ||
                   (SharkSslParseASN1_getOID(&parseSgn) < 0))
               {
                  return -1;
               }

               if (SharkSslParseASN1_getAlgoID(&parseSgn) != o->signature.hashAlgo)
               {
                  return -1;
               }

               if ((SharkSslParseASN1_getOctetString(&parseSgn)) || (parseSgn.len))
               {
                  return -1;
               }

               if (parseSgn.datalen != sharkssl_getHashLen(o->signature.hashAlgo))
               {
                  return -1;
               }

               if (sharkssl_kmemcmp(o->signature.hash, parseSgn.dataptr, parseSgn.datalen))
               {
                  return -1;
               }
            }
            #endif  
         }
         break;
      #endif

      #if SHARKSSL_ENABLE_ECDSA
      case accessactive:
         if (!(machinereboot(o->pCertKey->expLen)))
         {
            return -1;
         }

         parseSgn.ptr = s;
         parseSgn.len = o->signature.signLen;

         if (((len = SharkSslParseASN1_getSequence(&parseSgn)) < 0) || (SharkSslParseASN1_getInt(&parseSgn) < 0) || ((U32)len < parseSgn.datalen))
         {
            return -1;
         }
         ecdsaParam.keyLen = attachdevice(o->pCertKey->modLen);
         if ((U16)parseSgn.datalen > ecdsaParam.keyLen)
         {
            return -1;
         }
         #if 1
         len = (ecdsaParam.keyLen - parseSgn.datalen);
         if (len)
         {
            memset(kexecprepare, 0, len);
            memcpy(&kexecprepare[len], parseSgn.dataptr, parseSgn.datalen);
            ecdsaParam.R = kexecprepare;
         }
         else
         {
            ecdsaParam.R = parseSgn.dataptr;
         }

         if (SharkSslParseASN1_getInt(&parseSgn) < 0)
         {
            return -1;
         }
         len = (ecdsaParam.keyLen - parseSgn.datalen);
         if (len)
         {
            memset(stackoverflow, 0, len);
            memcpy(&stackoverflow[len], parseSgn.dataptr, parseSgn.datalen);
            ecdsaParam.S = stackoverflow;
         }
         else
         {
            ecdsaParam.S = parseSgn.dataptr;
         }
         #else
         ecdsaParam.R = parseSgn.dataptr;
         if (parseSgn.datalen < ecdsaParam.keyLen)  
         {
            *(--(ecdsaParam.R)) = 0x00;
            parseSgn.datalen++;
            if (parseSgn.datalen < ecdsaParam.keyLen)
            {
               *(--(ecdsaParam.R)) = 0x00;
               parseSgn.datalen++;
               if (parseSgn.datalen < ecdsaParam.keyLen)
               {
                  return -1;
               }
            }
         }
         if (SharkSslParseASN1_getInt(&parseSgn) < 0)
         {
            return -1;
         }
         ecdsaParam.S = parseSgn.dataptr;
         if (parseSgn.datalen < ecdsaParam.keyLen)  
         {
            *(--(ecdsaParam.S)) = 0x00;
            parseSgn.datalen++;
            if (parseSgn.datalen < ecdsaParam.keyLen)
            {
               *(--(ecdsaParam.S)) = 0x00;
               parseSgn.datalen++;
               if (parseSgn.datalen < ecdsaParam.keyLen)
               {
                  return -1;
               }
            }
         }
         #endif

         ecdsaParam.key = o->pCertKey->mod;
         ecdsaParam.curveType = wakeupenable(o->pCertKey->modLen);
         ecdsaParam.hash = (U8*)o->signature.hash;
         ecdsaParam.hashLen = sharkssl_getHashLen(o->signature.hashAlgo);

         if (SharkSslECDSAParam_ECDSA(&ecdsaParam, fixupdevices))
         {
            return -1;  
         }
         break;
      #endif

      default:
         return -1;
   }

   return 0;
}



static int systemconfiguration(const U8 *s1, const U8 *s2, const U32 disablechannel, const U32 modifymisccr)
{
   if (s1 == NULL)
   {
      if (s2 == NULL)
      {
         return (disablechannel + modifymisccr);
      }
   }
   else if ((s2) && (disablechannel == modifymisccr))
   {
      return sharkssl_kmemcmp((const char*)s1, (const char*)s2, disablechannel);
   }

   
   return 1;
}



U8 SharkSslCertDN_equal(const SharkSslCertDN *o1, const SharkSslCertDN *o2)
{
   if ( systemconfiguration(o1->organization, o2->organization, o1->organizationLen, o2->organizationLen) ||
        systemconfiguration(o1->unit,         o2->unit,         o1->unitLen,         o2->unitLen)         ||
        systemconfiguration(o1->commonName,   o2->commonName,   o1->commonNameLen,   o2->commonNameLen)   ||
        systemconfiguration(o1->countryName,  o2->countryName,  o1->countryNameLen,  o2->countryNameLen)  ||
        systemconfiguration(o1->locality,     o2->locality,     o1->localityLen,     o2->localityLen)     ||
        systemconfiguration(o1->province,     o2->province,     o1->provinceLen,     o2->provinceLen) )
   {
      return 0;
   }

   return 1;  
}

#endif  


#if SHARKSSL_ENABLE_ECDSA
static sharkssl_ECDSA_RetVal registerboard(SharkSslECDSAParam *audioshutdown, U8 *sig, U16 *platformconfig)
{
   SharkSslASN1Create wasn1;
   U8 kexecprepare[claimresource(SHARKSSL_MAX_ECC_POINTLEN)];
   U8 stackoverflow[claimresource(SHARKSSL_MAX_ECC_POINTLEN)];
   int ret;

   baAssert(0 == SHARKSSL_ECDSA_OK);
   audioshutdown->R = kexecprepare;
   audioshutdown->S = stackoverflow;

   ret = SharkSslECDSAParam_ECDSA(audioshutdown, iommupdata);
   if (ret)
   {
      if ((int)SharkSslCon_AllocationError == ret)
      {
         return SHARKSSL_ECDSA_ALLOCATION_ERROR;
      }

      return SHARKSSL_ECDSA_INTERNAL_ERROR;
   }

   if (0 == *platformconfig)
   {
      return SHARKSSL_ECDSA_SIGLEN_TOO_SMALL;
   }

   SharkSslASN1Create_constructor(&wasn1, sig, *platformconfig);
   *platformconfig = 0;
   
   if (SharkSslASN1Create_int(&wasn1, audioshutdown->S, audioshutdown->keyLen) < 0)
   {
      return SHARKSSL_ECDSA_INTERNAL_ERROR;
   }
   if (SharkSslASN1Create_int(&wasn1, audioshutdown->R, audioshutdown->keyLen) < 0)
   {
      return SHARKSSL_ECDSA_INTERNAL_ERROR;
   }
   if (SharkSslASN1Create_length(&wasn1, SharkSslASN1Create_getLen(&wasn1)) < 0)
   {
      return SHARKSSL_ECDSA_SIGLEN_TOO_SMALL;
   }
   if (SharkSslASN1Create_sequence(&wasn1) < 0)
   {
      return SHARKSSL_ECDSA_INTERNAL_ERROR;
   }
   *platformconfig = (U16)SharkSslASN1Create_getLen(&wasn1);
   memmove(sig, SharkSslASN1Create_getData(&wasn1), *platformconfig);

   return SHARKSSL_ECDSA_OK;
}
#endif


#if (((SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CLIENT_AUTH) || (SHARKSSL_SSL_SERVER_CODE) || \
     (SHARKSSL_ENABLE_CSR_SIGNING) || (SHARKSSL_ENABLE_CSR_CREATION)) && \
     (SHARKSSL_ENABLE_DHE_RSA || SHARKSSL_ENABLE_ECDHE_RSA || SHARKSSL_ENABLE_ECDHE_ECDSA))
int checkactions(SharkSslSignParam *o)
{
   #if SHARKSSL_ENABLE_RSA
   int len;
   #if SHARKSSL_ENABLE_RSASSA_PSS
   int kernelirqfd;
   U32 sgnWord, lzbMask;
   #endif
   #endif
   U8 *pciercxcfg448;
   U16 ftraceupdate;

   #if SHARKSSL_ENABLE_RSA
   const U8 *oid;
   U8  fieldvalue;
   #endif
   #if SHARKSSL_ENABLE_ECDSA
   SharkSslECDSAParam audioshutdown;
   #endif

   pciercxcfg448 = o->signature.signature;
   o->signature.signLen = 0;
   ftraceupdate = sharkssl_getHashLen(o->signature.hashAlgo);

   switch (o->signature.signatureAlgo)
   {
      #if SHARKSSL_ENABLE_RSA
      #if (SHARKSSL_TLS_1_2 || SHARKSSL_ENABLE_RSA_PKCS1)
      case entryearly:
         if (!(machinekexec(o->pCertKey->expLen)))
         {
            return -1;
         }

         switch (o->signature.hashAlgo)
         {
            #if SHARKSSL_USE_SHA_512
            case batterythread:
               oid    = sharkssl_oid_sha512;
               fieldvalue = SHARKSSL_DIM_ARR(sharkssl_oid_sha512);
               goto _sharkssl_cs_common_1_2;
            #endif

            #if SHARKSSL_USE_SHA_384
            case probewrite:
               oid    = sharkssl_oid_sha384;
               fieldvalue = SHARKSSL_DIM_ARR(sharkssl_oid_sha384);
               goto _sharkssl_cs_common_1_2;
            #endif

            #if SHARKSSL_USE_SHA_256
            case domainnumber:
               oid    = sharkssl_oid_sha256;
               fieldvalue = SHARKSSL_DIM_ARR(sharkssl_oid_sha256);
               goto _sharkssl_cs_common_1_2;
            #endif

            #if SHARKSSL_USE_SHA1
            case presentpages:
               oid    = sharkssl_oid_sha1;
               fieldvalue = SHARKSSL_DIM_ARR(sharkssl_oid_sha1);
            #endif
               _sharkssl_cs_common_1_2:
               len = (fieldvalue + ftraceupdate + 10);
               baAssert(len < 0x80);  
               *pciercxcfg448++ = 0x30;  
               *pciercxcfg448++ = (U8)(len - 2);
               *pciercxcfg448++ = 0x30;  
               *pciercxcfg448++ = (fieldvalue + 4);
               *pciercxcfg448++ = 0x06;  
               *pciercxcfg448++ = fieldvalue;
               memcpy(pciercxcfg448, oid, fieldvalue);
               pciercxcfg448 += fieldvalue;
               *pciercxcfg448++ = 0x05;
               *pciercxcfg448++ = 0x00;
               *pciercxcfg448++ = 0x04;
               *pciercxcfg448++ = (U8)ftraceupdate;
               break;

            default:
               return -1;
         }

         memcpy(pciercxcfg448, o->signature.hash, ftraceupdate);

         
         len = (int)clockaccess(o->pCertKey, (U16)len, o->signature.signature, o->signature.signature, SHARKSSL_RSA_PKCS1_PADDING);
         if ((len < 0) || ((U16)len != supportedvector(o->pCertKey->modLen)))
         {
            return -1;
         }
         o->signature.signLen = (U16)len;
         break;
      #endif  

      #if SHARKSSL_ENABLE_RSASSA_PSS
      case SHARKSSL_SIGNATUREALGORITHM_RSA_PSS:
         if (!(machinekexec(o->pCertKey->expLen)))
         {
            return -1;
         }
         
         len = supportedvector(o->pCertKey->modLen);
         if (len < ((int)2048/8))  
         {
            return -1;  
         }
         len--;
         *(U8*)(pciercxcfg448 + len) = 0xBC;  
         len--;
         kernelirqfd = (int)(ftraceupdate << 1);
         
         if (len < kernelirqfd)
         {
            return -1;  
         }
         
         memset(pciercxcfg448, 0, 8);
         memcpy(pciercxcfg448 + 8, o->signature.hash, ftraceupdate);
         sharkssl_rng(pciercxcfg448 + 8 + ftraceupdate, ftraceupdate);  
         
         len++;
         len -= ftraceupdate;
         sharkssl_hash(pciercxcfg448 + len, pciercxcfg448, 8 + (U16)kernelirqfd, o->signature.hashAlgo);
         
         len -= ftraceupdate;
         memmove(pciercxcfg448 + len, pciercxcfg448 + 8 + ftraceupdate, ftraceupdate);
         
         len--;
         memset(pciercxcfg448, 0, len);
         
         *(U8*)(pciercxcfg448 + len) = 0x01;
         len++;
         len += ftraceupdate;
         
         if (resetquirks(pciercxcfg448 + (U16)len, pciercxcfg448, (U16)len, o->signature.hashAlgo))
         {
            return -1;
         }
         
         read64uint32(lzbMask, o->pCertKey->mod, 0);
         if (0 == lzbMask)
         {
            return -1;  
         }
         lzbMask |= (lzbMask >> 1);
         lzbMask |= (lzbMask >> 2);
         lzbMask |= (lzbMask >> 4);
         lzbMask |= (lzbMask >> 8);
         lzbMask |= (lzbMask >> 16);
         lzbMask >>= 1;
         read64uint32(sgnWord, pciercxcfg448, 0);
         sgnWord &= lzbMask;  
         inputlevel(sgnWord, pciercxcfg448, 0);
         
         len = (int)clockaccess(o->pCertKey, supportedvector(o->pCertKey->modLen), pciercxcfg448, pciercxcfg448, SHARKSSL_RSA_NO_PADDING);
         if ((len < 0) || ((U16)len != supportedvector(o->pCertKey->modLen)))
         {
            return -1;
         }
         o->signature.signLen = (U16)len;
         break;
      #endif  
      #endif  

      #if SHARKSSL_ENABLE_ECDSA
      case accessactive:
         if (!(machinereboot(o->pCertKey->expLen)) || coupledexynos(o->pCertKey->expLen))
         {
            return -1;
         }
         audioshutdown.curveType = wakeupenable(o->pCertKey->modLen);
         audioshutdown.hash = o->signature.hash;
         audioshutdown.hashLen = ftraceupdate;
         audioshutdown.key = o->pCertKey->exp;
         audioshutdown.keyLen = mousethresh(o->pCertKey->expLen);
         if ((audioshutdown.key == NULL) || (audioshutdown.keyLen == 0))
         {
            return -1;
         }
         o->signature.signLen = relocationchain(o->pCertKey);
         if (registerboard(&audioshutdown, pciercxcfg448, &(o->signature.signLen)) < 0)
         {
            
            return -1;
         }
         break;
      #endif

      default:
         return -1;
   }

   return 0;
}
#endif  


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)

SHARKSSL_API U16 SharkSslCert_len(SharkSslCert kernelvaddr)
{
   if ((kernelvaddr != NULL) && (0x30 == kernelvaddr[0]) && (0x82 == kernelvaddr[1]))
   {
      return (U16)(((U16)(kernelvaddr[2]) * 256) + kernelvaddr[3] + 4);
   }
   return (U16)-1;
}



U16 interrupthandler(SharkSslCertKey *disableclock, SharkSslCert kernelvaddr)
{
   U16 ret, len;

   if (kernelvaddr)
   {
      ret = SharkSslCert_len(kernelvaddr);
      if (ret != (U16)-1)
      {
         ret += 0x03;
         ret &= ~0x03;  
         kernelvaddr += ret;
         disableclock->expLen = (U16)((U16)(kernelvaddr[0]) * 256 + kernelvaddr[1]);
         len = mousethresh(disableclock->expLen);
         kernelvaddr += 2;
         disableclock->modLen = (U16)((U16)(kernelvaddr[0]) * 256 + kernelvaddr[1]);
         kernelvaddr += 2;
         disableclock->exp = len ? (U8*)kernelvaddr : (U8*)0;
         kernelvaddr += len;
         disableclock->mod = (U8*)kernelvaddr;
         return ret;  
      }
   }

   memset(disableclock, 0, sizeof(SharkSslCertKey));
   return 0;
}



U16  SharkSslCert_vectSize_keyType(const SharkSslCert kernelvaddr, U8 *earlyconsole)
{
   SharkSslCertKey disableclock;
   U16 icachealiases;
   #if SHARKSSL_ENABLE_CERT_CHAIN
   U16 nc0;
   #endif

   
   icachealiases = interrupthandler(&disableclock, kernelvaddr);
   if (icachealiases)
   {
      #if SHARKSSL_ENABLE_CERT_CHAIN
      nc0 = monadiccheck(disableclock.expLen);
      #endif
      
      icachealiases += 4 + mousethresh(disableclock.expLen);
      if (machinekexec(disableclock.expLen))
      {
         if (earlyconsole)
         {
            *earlyconsole = SHARKSSL_KEYTYPE_RSA;
         }
         
         icachealiases += supportedvector(disableclock.modLen);
         if (!coupledexynos(disableclock.expLen))
         {
            
            icachealiases += (U16)((supportedvector(disableclock.modLen) / 2) * 5);
         }
      }
      else if (machinereboot(disableclock.expLen))
      {
         if (earlyconsole)
         {
            *earlyconsole = SHARKSSL_KEYTYPE_EC;
         }
         
         icachealiases += (U16)(2 * attachdevice(disableclock.modLen));
      }
      else
      {
         icachealiases = 0;  
      }
      #if SHARKSSL_ENABLE_CERT_CHAIN
      if (icachealiases && nc0)  
      {
         U8 *postcoreinitcall = (U8*)(&kernelvaddr[icachealiases]);
         while (nc0--)
         {
            U16 ebasecpunum = SharkSslCert_len((SharkSslCert)postcoreinitcall);
            if ((U16)-1 == ebasecpunum)
            {
               icachealiases = nc0 = 0;  
            }
            else
            {
               postcoreinitcall += ebasecpunum;
               icachealiases += ebasecpunum;
            }
         }
      }
      #endif
   }
   return icachealiases;
}



SHARKSSL_API U16 SharkSslKey_vectSize(const SharkSslKey sourcerouting)
{
   return SharkSslCert_vectSize_keyType((SharkSslCert)sourcerouting, (U8*)0);
}


#if ((SHARKSSL_SSL_CLIENT_CODE && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)) || \
     (SHARKSSL_SSL_SERVER_CODE))

U8 fixupresources(SharkSslCert kernelvaddr, U16 len, U8 *ptr)
{
   SharkSslCertEnum cEnum;

   baAssert(len >= 3);
   baAssert(ptr);

   
   len -= 3;
   *ptr++ = 0x00;
   *ptr++ = (U8)(len >> 8);
   *ptr++ = (U8)(len & 0xFF);

   registerautodeps(&cEnum, kernelvaddr);
   kernelvaddr = updatesctlr(&cEnum);

   while (kernelvaddr != NULL)
   {
      U16 pxafbmodes = SharkSslCertEnum_getCertLength(&cEnum);
      *ptr++ = 0x00;
      *ptr++ = (U8)(pxafbmodes >> 8);
      *ptr++ = (U8)(pxafbmodes & 0xFF);
      memcpy(ptr, kernelvaddr, pxafbmodes);
      ptr += pxafbmodes;
      len -= 3;
      len -= pxafbmodes;

      kernelvaddr = removerecursive(&cEnum);
   }

   return (U8)((len >> 8) | (len & 0xFF));
}



U16 setupboard(SharkSslCert kernelvaddr)
{
   SharkSslCertEnum cEnum;
   U16 len = 3;

   registerautodeps(&cEnum, kernelvaddr);
   kernelvaddr = updatesctlr(&cEnum);

   while (kernelvaddr != NULL)
   {
      len += 3 + SharkSslCertEnum_getCertLength(&cEnum);
      kernelvaddr = removerecursive(&cEnum);
   }

   return len;
}
#endif


#if SHARKSSL_ENABLE_CLIENT_AUTH

U8 domainassociate(SharkSslCert kernelvaddr, U8 *dn, U16 installidmap)
{
   SharkSslCertEnum cEnum;

   registerautodeps(&cEnum, kernelvaddr);
   kernelvaddr = updatesctlr(&cEnum);

   while (kernelvaddr != NULL)
   {
      U16 certLen, dnCLen;
      int registerinterrupts;

      certLen = SharkSslCertEnum_getCertLength(&cEnum);
      registerinterrupts = spromregister(0, (U8*)kernelvaddr, (U32)-2, (U8*)&dnCLen);
      if ((registerinterrupts > 0) && ((U32)registerinterrupts < certLen) && (installidmap == dnCLen))
      {
         if (0 == sharkssl_kmemcmp(((U8*)kernelvaddr + registerinterrupts), dn, installidmap))
         {
            return 1;  
         }
      }

      kernelvaddr = removerecursive(&cEnum);
   }

   return 0;
}
#endif
#endif  


#if ((SHARKSSL_ENABLE_PEM_API) || (SHARKSSL_ENABLE_CERTSTORE_API))
static const U8 sysrqreboot[128] =
{
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  
   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  62,0xFF,0xFF,0xFF,  63,  
     52,  53,  54,  55,  56,  57,  58,  59,  60,  61,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  
   0xFF,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  
     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,0xFF,0xFF,0xFF,0xFF,0xFF,  
   0xFF,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  
     41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,0xFF,0xFF,0xFF,0xFF,0xFF   
};



SHARKSSL_API U32 sharkssl_B64Decode(
   U8 *disableevent, U32 queryinput, const char *joystickmonitor, const char *requestpending)
{
   U32 len;
   U8  phase, d, prev_d, c;

   len = 0;
   prev_d = phase = 0;
   for (; joystickmonitor != requestpending; joystickmonitor++)
   {
      if (((U8)(*joystickmonitor)) & 0x80)
      {
         continue;
      }
      d = sysrqreboot[(U8)*joystickmonitor];
      if (d != 0xFF)
      {
         switch (phase & 0x03)
         {
            case 0:
               phase++;
               break;

            case 1:
               c = (U8)((prev_d << 2) | ((d & 0x30) >> 4));
               goto _sharkssl_outstr_c;

            case 2:
               c = (U8)(((prev_d & 0xf) << 4) | ((d & 0x3c) >> 2));
               goto _sharkssl_outstr_c;

            case 3:
               c = (U8)(((prev_d & 0x03) << 6) | d);
               _sharkssl_outstr_c:
               if (len < queryinput)
               {
                  disableevent[len++] = c;
               }
               phase++;
               break;
         }
         prev_d = d;
      }
   }

   return len;
}
#endif  


#if (SHARKSSL_ENABLE_PEM_API)
typedef enum
{
  mmcsd0device = 0,
  branchinstruction = 1,
  devicecamera,
  beforeprobe,
  unmapdomain
} key_enc_type;



#define setupfixed 4
#define disablehazard (4 + setupfixed)
#define pwrdmclear  4

static U32 clockgettime64(U8 **sourcerouting, const char *statesuspended, U32 pernodememory)
{
   if (pernodememory)
   {
      
      *sourcerouting = (U8*)baMalloc(((U32)(pernodememory * 3) >> 2) + disablehazard);
      if (*sourcerouting)
      {
         #if (4 == setupfixed)
         
         *(*sourcerouting+0) = 0x30;
         *(*sourcerouting+1) = 0x82;
         #if (disablehazard > setupfixed)
         memset(*sourcerouting + 2, 0, disablehazard - 2);
         #else
         (*sourcerouting)[2] = 0x00;
         (*sourcerouting)[3] = 0x00;
         #endif
         #elif (disablehazard > 0)
         memset(*sourcerouting, 0, disablehazard);
         #endif
         return sharkssl_B64Decode(*sourcerouting + disablehazard, pernodememory, statesuspended, statesuspended+pernodememory);
      }
   }
   return 0;
}


static sharkssl_PEM_RetVal tcpudpnofold(SharkSslCertKey *disableclock, U8 *sourcerouting, U32 signaldefined)
{
   
   U16 expLen, modLen;
   baAssert(signaldefined <= 0xFF);
   expLen = mousethresh(disableclock->expLen);
   if (signaldefined)
   {
      baAssert((U16)signaldefined >= expLen);
      gpiolibbanka(disableclock->expLen, signaldefined);
      signaldefined -= expLen;
   }
   
   *sourcerouting++ = (U8)(disableclock->expLen >> 8);
   *sourcerouting++ = (U8)disableclock->expLen;
   *sourcerouting++ = (U8)(disableclock->modLen >> 8);
   *sourcerouting++ = (U8)disableclock->modLen;
   
   memset(sourcerouting, 0, signaldefined);
   sourcerouting += signaldefined;
   memmove(sourcerouting, disableclock->exp, expLen);
   sourcerouting += expLen;
   modLen = loaderbinfmt(disableclock->modLen, disableclock->expLen);
   #if SHARKSSL_USE_ECC
   if (machinereboot(disableclock->expLen))
   {
      
      memmove(sourcerouting, disableclock->mod, modLen << 1);
   }
   else
   #endif
   {
      
      memmove(sourcerouting, disableclock->mod, modLen);
   }
   return SHARKSSL_PEM_OK;
}



int sharkssl_PEM_getSeqVersion(SharkSslParseASN1 *sharkrestart, U32 len)
{
   int l = SharkSslParseASN1_getSequence(sharkrestart);
   if ((l < 0) || ((U32)l > len))
   {
      return SHARKSSL_PEM_KEY_PARSE_ERROR;
   }
   l = SharkSslParseASN1_getInt(sharkrestart);
   if ((l < 0) || (sharkrestart->datalen != 1))
   {
      return SHARKSSL_PEM_KEY_PARSE_ERROR;
   }
   return *sharkrestart->dataptr;  
}


#if SHARKSSL_USE_ECC

static sharkssl_PEM_RetVal mmcsd1device(SharkSslParseASN1 *sharkrestart, SharkSslCertKey *disableclock)
{
   int l;
   if (SharkSslParseASN1_getOID(sharkrestart) < 0)
   {
      return SHARKSSL_PEM_KEY_PARSE_ERROR;
   }
   l = SharkSslParseASN1_getCurveID(sharkrestart);
   baAssert(l <= 0xFF);
   if (SHARKSSL_EC_CURVE_ID_UNKNOWN == (U8)l)
   {
      return SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT;
   }
   disableclock->modLen = 0;
   nomsrnoirq(disableclock->modLen, (U8)l);
   return SHARKSSL_PEM_OK;
}


static sharkssl_PEM_RetVal countslave(SharkSslParseASN1 *sharkrestart, SharkSslCertKey *disableclock)
{
   U32 softirqclear;
   if (!coupledexynos(disableclock->expLen))
   {
      
      if (SharkSslParseASN1_getECPublicKey(sharkrestart) < 0)
      {
         return SHARKSSL_PEM_KEY_PARSE_ERROR;
      }
   }
   if (SharkSslParseASN1_getBitString(sharkrestart) < 0)
   {
      return SHARKSSL_PEM_KEY_PARSE_ERROR;
   }
   while ((0 == *(sharkrestart->dataptr)) && (sharkrestart->datalen))
   {
      sharkrestart->dataptr++;
      sharkrestart->datalen--;
   }
   if (0 == sharkrestart->datalen)
   {
      return SHARKSSL_PEM_KEY_PARSE_ERROR;
   }
   sharkrestart->datalen--;
   if (SHARKSSL_EC_POINT_UNCOMPRESSED != *sharkrestart->dataptr++)
   {
      return SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT;
   }
   
   disableclock->mod = sharkrestart->dataptr;
   softirqclear = sharkrestart->datalen >> 1;
   if ((sharkrestart->datalen & 1) || (softirqclear != (U16)controllerregister(wakeupenable(disableclock->modLen))))
   {
      return SHARKSSL_PEM_KEY_WRONG_LENGTH;
   }
   baAssert(softirqclear <= 0xFF);
   dcdc1consumers(disableclock->modLen, (U8)softirqclear);
   return SHARKSSL_PEM_OK;
}
#endif


#if SHARKSSL_ENABLE_RSA
static sharkssl_PEM_RetVal signalinject(SharkSslParseASN1 *sharkrestart, SharkSslCertKey *disableclock)
{
   
   if (SharkSslParseASN1_getInt(sharkrestart) < 0)
   {
      return SHARKSSL_PEM_KEY_PARSE_ERROR;
   }
   disableclock->mod = sharkrestart->dataptr;
   disableclock->modLen = (U16)sharkrestart->datalen;
   
   if (disableclock->modLen & 0x1F)
   {
      return SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT;
   }
   
   if ((disableclock->modLen < 0x040) || (disableclock->modLen > 0x200))
   {
      return SHARKSSL_PEM_KEY_UNSUPPORTED_MODULUS_LENGTH;
   }
   
   if (SharkSslParseASN1_getInt(sharkrestart) < 0)
   {
      return SHARKSSL_PEM_KEY_PARSE_ERROR;
   }
   disableclock->exp = sharkrestart->dataptr;
   disableclock->expLen = (U16)sharkrestart->datalen;
   if (disableclock->expLen > 0xF0)  
   {
      return SHARKSSL_PEM_KEY_UNSUPPORTED_EXPONENT_LENGTH;
   }
   return SHARKSSL_PEM_OK;
}
#endif


#if (SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT || (SHARKSSL_USE_MD5 && (SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256)))
static sharkssl_PEM_RetVal pwrdmdisable(U8 *out, U8 *in, U32 len, U8 *pcmciascoop, U8 *iv, U32 loongson3priority, key_enc_type debugpreserved)
{
   #if ((SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256) && SHARKSSL_ENABLE_AES_CBC)
   union
   {
      SharkSslAesCtx aesCtx;
   } decCtx;

   if ((devicecamera == debugpreserved) || (beforeprobe == debugpreserved))
   {
      if (len & 0xF)
      {
         return SHARKSSL_PEM_KEY_WRONG_LENGTH;
      }
      if (loongson3priority != 16)
      {
         return SHARKSSL_PEM_KEY_WRONG_IV;
      }
      SharkSslAesCtx_constructor(&(decCtx.aesCtx), SharkSslAesCtx_Decrypt, pcmciascoop, ((debugpreserved == devicecamera) ? 16 : 32));
      SharkSslAesCtx_cbc_decrypt(&(decCtx.aesCtx), iv, in, in, (U16)len);  
      SharkSslAesCtx_destructor(&(decCtx.aesCtx));
   }
   else
   {
      return SHARKSSL_PEM_KEY_UNSUPPORTED_ENCRYPTION_TYPE;
   }

   if (out != in)
   {
      memmove(out, in, len);
   }
   return SHARKSSL_PEM_OK;
   #else
   (void)out;
   (void)in;
   (void)len;
   (void)pcmciascoop;
   (void)iv;
   (void)loongson3priority;
   (void)debugpreserved;
   return SHARKSSL_PEM_KEY_UNSUPPORTED_ENCRYPTION_TYPE;
   #endif
}
#endif


#if (SHARKSSL_USE_MD5 && (SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256))
static U8 pxa270baseboard(U8 c)
{
    return (U8)((c >= '\101') ? (0xA + c - '\101') : (c - '\060'));
}
#endif


static sharkssl_PEM_RetVal debugmonitors(const char *pxa270flash, key_enc_type debugpreserved, U8 *ptr, U32 len, const char *registerguest, U8 fixupbridge)
{
   #if (SHARKSSL_USE_MD5 && (SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256))
   SharkSslMd5Ctx md5Ctx;
   U8 softresetcomplete[16], pcmciascoop[32], i;

   
   fixupbridge >>= 1;
   if (fixupbridge > SHARKSSL_DIM_ARR(softresetcomplete))
   {
      return SHARKSSL_PEM_KEY_WRONG_LENGTH;
   }
   for (i = 0; i < fixupbridge; i++)
   {
      softresetcomplete[i] = pxa270baseboard(*registerguest++);
      softresetcomplete[i] <<= 4;
      softresetcomplete[i] |= pxa270baseboard(*registerguest++);
   }
   
   SharkSslMd5Ctx_constructor(&md5Ctx);
   SharkSslMd5Ctx_append(&md5Ctx, (const U8*)pxa270flash, (U32)strlen(pxa270flash));
   SharkSslMd5Ctx_append(&md5Ctx, (const U8*)softresetcomplete, 8 );
   SharkSslMd5Ctx_finish(&md5Ctx, &pcmciascoop[0]);

   SharkSslMd5Ctx_constructor(&md5Ctx);
   SharkSslMd5Ctx_append(&md5Ctx, &pcmciascoop[0], SHARKSSL_MD5_HASH_LEN);
   SharkSslMd5Ctx_append(&md5Ctx, (const U8*)pxa270flash, (U32)strlen(pxa270flash));
   SharkSslMd5Ctx_append(&md5Ctx, (const U8*)softresetcomplete, 8 );
   SharkSslMd5Ctx_finish(&md5Ctx, &pcmciascoop[SHARKSSL_MD5_HASH_LEN]);

   return pwrdmdisable(ptr, ptr, len, pcmciascoop, softresetcomplete, fixupbridge, debugpreserved);
   #else
   (void)pxa270flash;
   (void)debugpreserved;
   (void)ptr;
   (void)len;
   (void)registerguest;
   (void)fixupbridge;
   return SHARKSSL_PEM_KEY_UNSUPPORTED_ENCRYPTION_TYPE;
   #endif
}


#if SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT
SHARKSSL_API int sharkssl_PEM_PBKDF2(U8 *dk, const char *pxa270flash, const char *softresetcomplete, U32 singleftoui, U32 syskeyunlock, U16 registerioapic, U8 configwrite)
{
   SharkSslHMACCtx registermcasp;
   U8 handledomain[4], chargerplatform[SHARKSSL_MAX_HASH_LEN];
   U32 i;
   U16 usb11device, ftraceupdate, j;

   baAssert(pxa270flash);
   ftraceupdate = sharkssl_getHashLen(configwrite);
   if (0 == ftraceupdate)
   {
      return -1;
   }
   handledomain[0] = 0;
   handledomain[1] = 0;
   handledomain[2] = 0;
   handledomain[3] = 1;
   for (;;)
   {
      SharkSslHMACCtx_constructor(&registermcasp, configwrite, (const U8*)pxa270flash, (U16)strlen(pxa270flash));
      SharkSslHMACCtx_append(&registermcasp, (const U8*)softresetcomplete, singleftoui);
      SharkSslHMACCtx_append(&registermcasp, handledomain, 4);
      SharkSslHMACCtx_finish(&registermcasp, chargerplatform);  
      usb11device = (ftraceupdate >= registerioapic) ? ftraceupdate : registerioapic;
      memcpy(dk, chargerplatform, usb11device);
      for (i = 1; i < syskeyunlock; i++)
      {
         SharkSslHMACCtx_constructor(&registermcasp, configwrite, (const U8*)pxa270flash, (U16)strlen(pxa270flash));
         SharkSslHMACCtx_append(&registermcasp, chargerplatform, ftraceupdate);
         SharkSslHMACCtx_finish(&registermcasp, chargerplatform);
         for (j = 0; j < usb11device; j++)
         {
            dk[j] ^= chargerplatform[j];
         }
      }
      if (registerioapic > ftraceupdate)
      {
         registerioapic -= ftraceupdate;
         dk += ftraceupdate;
         
         if (0 == ++handledomain[3])
         {
            if (0 == ++handledomain[2])
            {
               if (0 == ++handledomain[1])
               {
                  handledomain[0]++;
               }
            }
         }
      }
      else
      {
         break;
      }
   }
   return 0;
}
#endif


static sharkssl_PEM_RetVal clusterpower(const char *logicpwrst, const char *pxa270flash, SharkSslCert *psizecompute)
{
   SharkSslParseASN1 sharkrestart;
   SharkSslCertKey disableclock;
   const char *statesuspended, *requestresources, *vectoraddress, *kaux, *kenc;
   int l;
   U32 pernodememory;
   U8 *sourcerouting;
   int loongson3priority = 0;
   key_enc_type debugpreserved = mmcsd0device;

   
   baAssert(NULL == (void*)0);
   *psizecompute = 0;

   if (logicpwrst == NULL)
   {
      return SHARKSSL_PEM_KEY_REQUIRED;
   }

   statesuspended = sharkStrstr(logicpwrst, "\055\055\055\055\055\102\105\107\111\116\040");
   if (NULL != statesuspended)
   {
      statesuspended += 11;  
      vectoraddress = sharkStrstr(statesuspended, "\040\113\105\131\055\055\055\055\055");
      if (NULL != vectoraddress)
      {
         vectoraddress += 9;  
         while (('\015' == *vectoraddress) || ('\012' == *vectoraddress))
         {
            vectoraddress++;  
         }
         requestresources = sharkStrstr(vectoraddress, "\055\055\055\055\055\105\116\104\040");
         if ((NULL != requestresources) && (vectoraddress < requestresources))  
         {
            kaux = sharkStrstr(statesuspended, "\120\122\111\126\101\124\105");
            if (NULL == kaux)
            {
               if (NULL == sharkStrstr(statesuspended, "\120\125\102\114\111\103"))
               {
                  return SHARKSSL_PEM_KEY_UNRECOGNIZED_FORMAT;
               }
               
               pernodememory = clockgettime64(&sourcerouting, vectoraddress, (U32)(requestresources - vectoraddress));
               if (0 == pernodememory)
               {
                  return SHARKSSL_PEM_ALLOCATION_ERROR;
               }
               sharkrestart.len = pernodememory;
               sharkrestart.ptr = sourcerouting + disablehazard;
               #if SHARKSSL_ENABLE_RSA
               if (NULL != sharkStrstr(statesuspended, "\122\123\101\040\120\125\102\114\111\103"))
               {
                  goto _key_parse_RSA_pub;
               }
               #endif
               
               l = SharkSslParseASN1_getSequence(&sharkrestart);
               if ((l < 0) || ((U32)l > pernodememory))
               {
                  _key_parse_error:
                  baFree(sourcerouting);
                  return SHARKSSL_PEM_KEY_PARSE_ERROR;
               }
               if ((SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getOID(&sharkrestart) < 0))
               {
                  goto _key_parse_error;
               }
               l = SharkSslParseASN1_getAlgoID(&sharkrestart);
               #if SHARKSSL_ENABLE_RSA
               if (ALGO_ID_RSA_ENCRYPTION == l)
               {
                  if (SharkSslParseASN1_getBitString(&sharkrestart) < 0)
                  {
                     goto _key_parse_error;
                  }
                  sharkrestart.ptr = sharkrestart.dataptr;
                  sharkrestart.len = sharkrestart.datalen;
                  if ((0 == *(sharkrestart.ptr)) && (sharkrestart.len > 0))
                  {
                     sharkrestart.ptr++;
                     sharkrestart.len--;
                  }
                  _key_parse_RSA_pub:
                  if (SharkSslParseASN1_getSequence(&sharkrestart) < 0)
                  {
                     goto _key_parse_error;
                  }
                  l = signalinject(&sharkrestart, &disableclock);
                  if (SHARKSSL_PEM_OK != l)
                  {
                     baFree(sourcerouting);
                     return (sharkssl_PEM_RetVal)l;
                  }
                  specialmapping(disableclock.expLen);
                  pernodememory = claimresource(mousethresh(disableclock.expLen));
               }
               else
               #endif  
               #if SHARKSSL_USE_ECC
               if (ALGO_OID_EC_PUBLIC_KEY == l)
               {
                  disableclock.expLen = 0;
                  disableclock.exp = NULL;
                  deltaticks(disableclock.expLen);
                  l = mmcsd1device(&sharkrestart, &disableclock);
                  if (SHARKSSL_PEM_OK == l)
                  {
                     l = countslave(&sharkrestart, &disableclock);
                  }
                  if (SHARKSSL_PEM_OK != l)
                  {
                     baFree(sourcerouting);
                     return (sharkssl_PEM_RetVal)l;
                  }
                  pernodememory = 0;
               }
               else
               #endif  
               {
                  goto _key_parse_error;
               }
               l = tcpudpnofold(&disableclock, sourcerouting + setupfixed, pernodememory);
               if (SHARKSSL_PEM_OK != l)
               {
                  baFree(sourcerouting);
                  return (sharkssl_PEM_RetVal)l;
               }
               *psizecompute = (SharkSslCert)sourcerouting;
               return SHARKSSL_PEM_OK_PUBLIC;
            }
            if (kaux < vectoraddress)
            {
               
               kenc = strstr(statesuspended, "\105\116\103\122\131\120\124\105\104");
               if ((NULL == kenc) || (kenc > vectoraddress))
               {
                  if (NULL != kenc)
                  {
                     if (NULL == pxa270flash)
                     {
                        return SHARKSSL_PEM_KEY_PASSPHRASE_REQUIRED;
                     }
                     
                     #if ((SHARKSSL_USE_AES_256 || SHARKSSL_USE_AES_128) && SHARKSSL_ENABLE_AES_CBC)
                     kenc += 9;  
                     #endif
                     #if (SHARKSSL_USE_AES_256 && SHARKSSL_ENABLE_AES_CBC)
                     kaux = sharkStrstr(kenc, "\101\105\123\055\062\065\066\055\103\102\103");
                     if (kaux)
                     {
                        kaux += 11;  
                        debugpreserved = beforeprobe;
                     }
                     else
                     #endif
                     {
                        #if (SHARKSSL_USE_AES_128 && SHARKSSL_ENABLE_AES_CBC)
                        kaux = sharkStrstr(kenc, "\101\105\123\055\061\062\070\055\103\102\103");
                        if (kaux)
                        {
                           kaux += 11;  
                           debugpreserved = devicecamera;
                        }
                        else
                        #endif
                        {
                           #if 0 
                           kaux = sharkStrstr(kenc, "\103\150\141\103\150\141\062\060");
                           if (kaux)
                           {
                              kaux += 8;  
                              debugpreserved = unmapdomain;
                           }
                           else
                           #endif
                           {
                              return SHARKSSL_PEM_KEY_UNSUPPORTED_ENCRYPTION_TYPE;
                           }
                        }
                     }
                     #if ((SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256) && SHARKSSL_ENABLE_AES_CBC)
                     
                     if ('\054' != *kaux++)
                     {
                        return SHARKSSL_PEM_KEY_UNRECOGNIZED_FORMAT;
                     }
                     
                     vectoraddress = kaux;
                     while (('\015' != *vectoraddress) && ('\012' != *vectoraddress))
                     {
                        if (((*vectoraddress < '\101') || (*vectoraddress > '\106')) && ((*vectoraddress < '\060') || (*vectoraddress > '\071')))
                        {
                           return SHARKSSL_PEM_KEY_WRONG_IV;
                        }
                        vectoraddress++;
                     }
                     
                     loongson3priority = (int)(vectoraddress - kaux);
                     if (0 ||
                         #if (SHARKSSL_USE_AES_128 || SHARKSSL_USE_AES_256)
                         ((loongson3priority != 0x20) && ((devicecamera == debugpreserved) || (beforeprobe == debugpreserved))) ||
                         #endif
                         0)
                     {
                        return SHARKSSL_PEM_KEY_WRONG_IV;
                     }
                     
                     while (('\015' == *vectoraddress) || ('\012' == *vectoraddress))
                     {
                        vectoraddress++;  
                     }
                     #endif
                  }
                  
                  pernodememory = clockgettime64(&sourcerouting, vectoraddress, (U32)(requestresources - vectoraddress));
                  if (0 == pernodememory)
                  {
                     return SHARKSSL_PEM_ALLOCATION_ERROR;
                  }
                  sharkrestart.len = pernodememory;
                  sharkrestart.ptr = sourcerouting + disablehazard;
                  #if SHARKSSL_ENABLE_RSA
                  if (statesuspended == sharkStrstr(statesuspended, "\122\123\101\040\120\122\111\126\101\124\105"))
                  {
                     
                     if (NULL != kenc)  
                     {
                        l = debugmonitors(pxa270flash, debugpreserved, sharkrestart.ptr, sharkrestart.len, kaux, (U8)loongson3priority);
                        if (SHARKSSL_PEM_OK != l)
                        {
                           goto _RSA_RetVal_not_OK;
                        }
                     }
                     
                     _key_parse_RSA_priv:
                     if (sharkssl_PEM_getSeqVersion(&sharkrestart, pernodememory) < 0)
                     {
                        goto _key_parse_error;
                     }
                     l = signalinject(&sharkrestart, &disableclock);
                     if (SHARKSSL_PEM_OK != l)
                     {
                        _RSA_RetVal_not_OK:
                        baFree(sourcerouting);
                        return (sharkssl_PEM_RetVal)l;
                     }
                     if (SharkSslParseASN1_getInt(&sharkrestart) < 0)  
                     {
                        goto _key_parse_error;
                     }
                     cryptoresources(disableclock.expLen);
                     pernodememory = claimresource(mousethresh(disableclock.expLen));
                     l = tcpudpnofold(&disableclock, sourcerouting + setupfixed, pernodememory);
                     if (SHARKSSL_PEM_OK != l)
                     {
                        goto _RSA_RetVal_not_OK;
                     }
                     pernodememory = supportedvector(disableclock.modLen);
                     kaux = (char*)(sourcerouting + setupfixed + pwrdmclear + mousethresh(disableclock.expLen) + pernodememory);
                     
                     baAssert((U8*)kaux <= sharkrestart.ptr);
                     
                     pernodememory >>= 1;
                     for (l = 5; l > 0; l--)
                     {
                        if ((SharkSslParseASN1_getInt(&sharkrestart) < 0) || (sharkrestart.datalen > pernodememory))
                        {
                           goto _key_parse_error;
                        }
                        if (sharkrestart.datalen < pernodememory)
                        {
                           
                           memset((U8*)kaux, 0, (U16)(pernodememory - sharkrestart.datalen));
                           kaux += (U16)(pernodememory - sharkrestart.datalen);
                        }
                        memmove((U8*)kaux, sharkrestart.dataptr, sharkrestart.datalen);
                        kaux += sharkrestart.datalen;
                     }
                     *psizecompute = (SharkSslCert)sourcerouting;
                     return SHARKSSL_PEM_OK;
                  }
                  else
                  #endif
                  #if SHARKSSL_USE_ECC
                  
                  if (statesuspended == sharkStrstr(statesuspended, "\105\103\040\120\101\122\101\115\105\124\105\122\123"))
                  {
                     statesuspended = sharkStrstr(statesuspended, "\105\103\040\120\122\111\126\101\124\105");
                     if (NULL == statesuspended)
                     {
                        l = SHARKSSL_PEM_KEY_UNRECOGNIZED_FORMAT;
                        goto _EC_RetVal_not_OK;
                     }
                  }
                  if (statesuspended == sharkStrstr(statesuspended, "\105\103\040\120\122\111\126\101\124\105"))
                  {
                     
                     if (NULL != kenc)  
                     {
                        l = debugmonitors(pxa270flash, debugpreserved, sharkrestart.ptr, sharkrestart.len, kaux, (U8)loongson3priority);
                        if (SHARKSSL_PEM_OK != l)
                        {
                           goto _EC_RetVal_not_OK;
                        }
                     }
                     kaux = NULL;  
                     _key_parse_EC_priv:
                     
                     if (sharkssl_PEM_getSeqVersion(&sharkrestart, pernodememory) != 1)
                     {
                        baFree(sourcerouting);
                        return SHARKSSL_PEM_KEY_UNSUPPORTED_VERSION;
                     }
                     if (SharkSslParseASN1_getOctetString(&sharkrestart) < 0)
                     {
                        goto _key_parse_error;
                     }
                     disableclock.exp = sharkrestart.dataptr;
                     disableclock.expLen = (U8)sharkrestart.datalen;
                     baAssert(disableclock.expLen <= 0xFF);
                     hsspidevice(disableclock.expLen);
                     
                     if (NULL == kaux)
                     {
                        if (SharkSslParseASN1_getECParameters(&sharkrestart) < 0)
                        {
                           goto _key_parse_error;
                        }
                        l = mmcsd1device(&sharkrestart, &disableclock);
                        if (SHARKSSL_PEM_OK != l)
                        {
                           _EC_RetVal_not_OK:
                           baFree(sourcerouting);
                           return (sharkssl_PEM_RetVal)l;
                        }
                     }
                     l = countslave(&sharkrestart, &disableclock);
                     if (SHARKSSL_PEM_OK != l)
                     {
                        goto _EC_RetVal_not_OK;
                     }
                     l = tcpudpnofold(&disableclock, sourcerouting + setupfixed, 0);
                     if (SHARKSSL_PEM_OK != l)
                     {
                        goto _EC_RetVal_not_OK;
                     }
                     *psizecompute = (SharkSslCert)sourcerouting;
                     return SHARKSSL_PEM_OK;
                  }
                  else
                  #endif
                  if (NULL == kenc)
                  {
                     if (statesuspended == kaux)  
                     {
                        
                        #if (SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT && SHARKSSL_ENABLE_AES_CBC)
                        _plain_PKCS8_parsing:
                        #endif
                        if (sharkssl_PEM_getSeqVersion(&sharkrestart, pernodememory) < 0)
                        {
                           goto _key_parse_error;
                        }
                        if ((SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getOID(&sharkrestart) < 0))
                        {
                           goto _key_parse_error;
                        }
                        l = SharkSslParseASN1_getAlgoID(&sharkrestart);
                        #if SHARKSSL_ENABLE_RSA
                        if (ALGO_ID_RSA_ENCRYPTION == l)
                        {
                           if (SharkSslParseASN1_getOctetString(&sharkrestart) < 0)
                           {
                              goto _key_parse_error;
                           }
                           sharkrestart.ptr = sharkrestart.dataptr;
                           sharkrestart.len = sharkrestart.datalen;
                           goto _key_parse_RSA_priv;
                        }
                        else
                        #endif  
                        #if SHARKSSL_USE_ECC
                        if (ALGO_OID_EC_PUBLIC_KEY == l)
                        {
                           if (SharkSslParseASN1_getOID(&sharkrestart) < 0)
                           {
                              return SHARKSSL_PEM_KEY_PARSE_ERROR;
                           }
                           l = SharkSslParseASN1_getCurveID(&sharkrestart);
                           baAssert(l <= 0xFF);
                           if (SHARKSSL_EC_CURVE_ID_UNKNOWN == (U8)l)
                           {
                              return SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT;
                           }
                           if (SharkSslParseASN1_getOctetString(&sharkrestart) < 0)
                           {
                              goto _key_parse_error;
                           }
                           disableclock.modLen = 0;
                           nomsrnoirq(disableclock.modLen, (U8)l);
                           sharkrestart.ptr = sharkrestart.dataptr;
                           sharkrestart.len = sharkrestart.datalen;
                           baAssert(kaux);
                           goto _key_parse_EC_priv;
                        }
                        else
                        #endif  
                        goto _key_parse_error;
                     }
                  }
               }
               else if (kenc == statesuspended)  
               {
                  #if SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT
                  #if ((!SHARKSSL_USE_SHA_256) || (!SHARKSSL_ENABLE_AES_CBC))
                  #error SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT requires SHARKSSL_USE_SHA_256 and SHARKSSL_ENABLE_AES_CBC
                  #endif
                  
                  if (NULL == pxa270flash)
                  {
                     return SHARKSSL_PEM_KEY_PASSPHRASE_REQUIRED;
                  }
                  
                  pernodememory = clockgettime64(&sourcerouting, vectoraddress, (U32)(requestresources - vectoraddress));
                  if (0 == pernodememory)
                  {
                     return SHARKSSL_PEM_ALLOCATION_ERROR;
                  }
                  sharkrestart.len = pernodememory;
                  sharkrestart.ptr = sourcerouting + disablehazard;
                  
                  l = SharkSslParseASN1_getSequence(&sharkrestart);
                  if ((l < 0) || ((U32)l > pernodememory))
                  {
                     goto _key_parse_error;
                  }
                  if ((SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getOID(&sharkrestart) < 0))
                  {
                     goto _key_parse_error;
                  }
                  if (ALGO_ID_PKCS5_PBES2 != SharkSslParseASN1_getAlgoID(&sharkrestart))
                  {
                     _key_unsupported_enctype:
                     baFree(sourcerouting);
                     return SHARKSSL_PEM_KEY_UNSUPPORTED_ENCRYPTION_TYPE;
                  }
                  if ((SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getOID(&sharkrestart) < 0))
                  {
                     goto _key_parse_error;
                  }
                  if (ALGO_ID_PKCS5_PBKDF2 != SharkSslParseASN1_getAlgoID(&sharkrestart))
                  {
                     goto _key_unsupported_enctype;
                  }
                  if ((SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getOctetString(&sharkrestart) < 0))
                  {
                     goto _key_parse_error;
                  }
                  loongson3priority = sharkrestart.datalen;
                  kaux = (const char*)sharkrestart.dataptr;
                  if (loongson3priority > 16)
                  {
                     _key_unsupported_format:
                     baFree(sourcerouting);
                     return SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT;
                  }
                  if (SharkSslParseASN1_getInt(&sharkrestart) < 0)  
                  {
                     goto _key_parse_error;
                  }
                  if (sharkrestart.datalen > 4)
                  {
                     goto _key_unsupported_format;  
                  }
                  pernodememory = 0;
                  while (sharkrestart.datalen--)
                  {
                     pernodememory <<= 8;
                     pernodememory |= *sharkrestart.dataptr++;
                  }
                  if ((SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getOID(&sharkrestart) < 0))
                  {
                     goto _key_parse_error;
                  }
                  l = SharkSslParseASN1_getAlgoID(&sharkrestart);
                  
                  #if SHARKSSL_USE_SHA_256
                  if (ALGO_ID_HMAC_WITH_SHA256 != l)
                  #endif
                  {
                     goto _key_unsupported_enctype;
                  }
                  if (sharkssl_PEM_PBKDF2(sourcerouting + disablehazard, pxa270flash, kaux, loongson3priority, pernodememory, 32, GET_ALGO_HASH_ID(l)))
                  {
                     baFree(sourcerouting);
                     return SHARKSSL_PEM_INTERNAL_ERROR;
                  }
                  if ((SharkSslParseASN1_getSequence(&sharkrestart) < 0) || (SharkSslParseASN1_getOID(&sharkrestart) < 0))
                  {
                     goto _key_parse_error;
                  }
                  l = SharkSslParseASN1_getAlgoID(&sharkrestart);
                  #if SHARKSSL_ENABLE_AES_CBC
                  #if SHARKSSL_USE_AES_128
                  if (ALGO_ID_AES_128_CBC == l)
                  {
                     debugpreserved = devicecamera;
                  }
                  else
                  #endif
                  #if SHARKSSL_USE_AES_256
                  if (ALGO_ID_AES_256_CBC == l)
                  {
                     debugpreserved = beforeprobe;
                  }
                  else
                  #endif
                  #endif
                  {
                     goto _key_unsupported_enctype;
                  }
                  #if SHARKSSL_ENABLE_AES_CBC
                  if (SharkSslParseASN1_getOctetString(&sharkrestart) < 0)
                  {
                     goto _key_parse_error;
                  }
                  loongson3priority = sharkrestart.datalen;
                  kaux = (const char*)sharkrestart.dataptr;
                  if (SharkSslParseASN1_getOctetString(&sharkrestart) < 0)
                  {
                     goto _key_parse_error;
                  }
                  
                  sharkrestart.ptr = sourcerouting + disablehazard;  
                  sharkrestart.len = sharkrestart.datalen;
                  l = pwrdmdisable(sharkrestart.ptr, sharkrestart.dataptr, sharkrestart.datalen, sourcerouting + disablehazard, (U8*)kaux, loongson3priority, debugpreserved);
                  if (SHARKSSL_PEM_OK != l)
                  {
                     baFree(sourcerouting);
                     return (sharkssl_PEM_RetVal)l;
                  }
                  goto _plain_PKCS8_parsing;
                  #endif  
                  #else
                  return SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT;
                  #endif
               }
            }  
         }  
      }   
   }   
   return SHARKSSL_PEM_KEY_UNRECOGNIZED_FORMAT;
}



static sharkssl_PEM_RetVal cpuidledevice(const char **begin, const char **end)
{
   *begin = sharkStrstr(*begin, "\055\055\055\055\055\102\105\107\111\116");
   if (*begin)
   {
      *begin = sharkStrstr(*begin, "\103\105\122\124\111\106\111\103\101\124\105\055\055\055\055\055");
      if (NULL == *begin)
      {
         return SHARKSSL_PEM_CERT_UNRECOGNIZED_FORMAT;
      }
      *begin += 16;  
      while (('\015' == **begin) || ('\012' == **begin))
      {
         (*begin)++;
      }
      *end = sharkStrstr(*begin, "\055\055\055\055\055\105\116\104");
      if (NULL == *end)
      {
         return SHARKSSL_PEM_CERT_UNRECOGNIZED_FORMAT;
      }
   }
   return SHARKSSL_PEM_OK;
}



SHARKSSL_API sharkssl_PEM_RetVal sharkssl_PEM(const char *allowresize, const char *logicpwrst,
                                              const char *pxa270flash, SharkSslCert *psizecompute)
{
   U8 *ptr;
   const char *cbeg, *cend;
   sharkssl_PEM_RetVal ret = clusterpower(logicpwrst, pxa270flash, psizecompute);
   U32 pernodememory = 0;  
   U32 pxafbmodes;
   U8  rdlo12rdhi16rn0rm8rwflags;
   #if SHARKSSL_ENABLE_CERT_CHAIN
   U8  devicerelease;
   #endif

   if ((SHARKSSL_PEM_OK_PUBLIC == ret) && (allowresize))
   {
      return SHARKSSL_PEM_KEY_PRIVATE_KEY_REQUIRED;
   }
   if (ret >= 0)  
   {
      pernodememory = SharkSslKey_vectSize((SharkSslKey)*psizecompute);
   }
   
   if ((SHARKSSL_PEM_OK != ret) || (!allowresize))
   {
      if (ret >= 0)
      {
         
         void *devicehandle = baRealloc((void*)*psizecompute, pernodememory);
         if (devicehandle)
         {
            *psizecompute = (SharkSslCert)devicehandle;
         }
      }
      return ret;
   }
   
   cbeg = allowresize;
   pxafbmodes = 0;
   #if SHARKSSL_ENABLE_CERT_CHAIN
   devicerelease = 0;
   _sharkssl_PEM_scan_next_cert:
   #endif
   ret = cpuidledevice(&cbeg, &cend);
   if (SHARKSSL_PEM_OK != ret)
   {
      _sharkssl_PEM_free_ret:
      baFree((void*)*psizecompute);
      return ret;
   }
   if (cbeg)
   {
      if (((U32)(cend - cbeg)) > 0xFFFF)
      {
         ret = SHARKSSL_PEM_CERT_UNSUPPORTED_TYPE;
         goto _sharkssl_PEM_free_ret;
      }
      pxafbmodes += (U32)(cend - cbeg);
      #if SHARKSSL_ENABLE_CERT_CHAIN
      devicerelease++;
      cbeg = cend;
      goto _sharkssl_PEM_scan_next_cert;
      #endif
   }
   else
   {
      #if SHARKSSL_ENABLE_CERT_CHAIN
      if (devicerelease)
      {
         devicerelease--;
      }
      else
      #endif
      {
         ret = SHARKSSL_PEM_CERT_UNRECOGNIZED_FORMAT;
         goto _sharkssl_PEM_free_ret;
      }
   }
   
   ptr = (U8*)baMalloc(((pxafbmodes * 3) >> 2) + pernodememory + SHARKSSL_ALIGNMENT - setupfixed);
   if (NULL == ptr)
   {
      ret = SHARKSSL_PEM_ALLOCATION_ERROR;
      goto _sharkssl_PEM_free_ret;
   }
   cbeg = allowresize;
   cpuidledevice(&cbeg, &cend);
   pxafbmodes = sharkssl_B64Decode(ptr, (U32)(cend - cbeg), cbeg, cend);
   
   if (pxafbmodes != SharkSslCert_len((SharkSslCert)ptr))
   {
      ret = SHARKSSL_PEM_CERT_UNSUPPORTED_TYPE;
      baFree(ptr);
      goto _sharkssl_PEM_free_ret;
   }
   rdlo12rdhi16rn0rm8rwflags = (((U8)(~pxafbmodes & 0x3)) + 1) & 0x3;  
   memset(ptr + pxafbmodes, 0xFF, rdlo12rdhi16rn0rm8rwflags);
   memcpy(ptr + pxafbmodes + rdlo12rdhi16rn0rm8rwflags, *psizecompute + setupfixed, pernodememory - setupfixed);
   baFree((void*)*psizecompute);  
   *psizecompute = ptr;
   #if SHARKSSL_ENABLE_CERT_CHAIN
   if (devicerelease)
   {
      ptr = (U8*)*psizecompute + pxafbmodes + rdlo12rdhi16rn0rm8rwflags;
      *ptr = (*ptr & 0x0F) | ((U8)devicerelease << 4);  
      ptr += pernodememory - setupfixed;
      while (devicerelease--)
      {
         
         cbeg = cend;
         cpuidledevice(&cbeg, &cend);
         pxafbmodes = sharkssl_B64Decode(ptr, (U32)(cend - cbeg), cbeg, cend);
         
         if (pxafbmodes != SharkSslCert_len((SharkSslCert)ptr))
         {
            ret = SHARKSSL_PEM_CERT_UNSUPPORTED_TYPE;
            goto _sharkssl_PEM_free_ret;
         }
         ptr += pxafbmodes;
      }
   }
   #endif
   return SHARKSSL_PEM_OK;
}



#if ((SHARKSSL_ENABLE_RSA_API || SHARKSSL_ENABLE_ECDSA_API) && \
    ((SHARKSSL_SSL_CLIENT_CODE && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)) || \
     (SHARKSSL_SSL_SERVER_CODE)))
SHARKSSL_API SharkSslKey sharkssl_PEM_extractPublicKey_ext(const char *allowresize, U8 *earlyconsole)
{
   SharkSslCertParam certParam;
   char *cbeg, *cend;
   U8  *aemifresources, *buttontable;
   U16  kco, kcoa, pxafbmodes;

   if (allowresize)
   {
      
      cbeg = (char*)sharkStrstr(allowresize, "\055\055\055\055\055\102\105\107\111\116");
      if (cbeg)
      {
         cbeg = sharkStrstr(cbeg, "\103\105\122\124\111\106\111\103\101\124\105\055\055\055\055\055");
      }
      if (cbeg == NULL)
      {
         return NULL;
      }
      cbeg += 16; 
      while ((*cbeg == '\015') || (*cbeg == '\012'))
      {
         cbeg++;
      }
      cend = (char*)sharkStrstr(cbeg, "\055\055\055\055\055\105\116\104");
      if (cend == NULL)
      {
         return NULL;
      }
      if (((U32)(cend - cbeg)) > 0xFFFF)
      {
         return NULL;
      }
      pxafbmodes = (U16)(cend - cbeg);
      kco  = ((U16)(pxafbmodes * 3)) >> 2;
   }
   else
   {
      return NULL;
   }

   aemifresources = (U8*)baMalloc(4 + kco);
   if (aemifresources == NULL)
   {
      return NULL;
   }

   
   kco = (U16)sharkssl_B64Decode(aemifresources, pxafbmodes, cbeg, cend);

   
   if ((kco != SharkSslCert_len((SharkSslCert)aemifresources)) || (spromregister(&certParam, aemifresources, kco, 0) < 0))
   {
      sharkssl_PEM_extractPublicKey_1:
      baFree(aemifresources);
      return NULL;
   }

   kco = kcoa = mousethresh(certParam.certKey.expLen);
   pxafbmodes = loaderbinfmt(certParam.certKey.modLen, certParam.certKey.expLen);
   *earlyconsole = allocatoralloc(certParam.certKey.expLen);
   if (rewindsingle == *earlyconsole)
   {
      
      kcoa = claimresource(kco);
      
      certParam.certKey.expLen = (certParam.certKey.expLen & 0xFF00) + kcoa;
   }
   #if SHARKSSL_USE_ECC
   else
   {
      baAssert(0 == kco);
      pxafbmodes *= 2;
   }
   #endif

   kcoa -= kco;
   buttontable = (U8*)baMalloc(8 + mousethresh(certParam.certKey.expLen) + pxafbmodes);
   if (buttontable == NULL)
   {
      goto sharkssl_PEM_extractPublicKey_1;
   }

   
   cbeg = (char*)buttontable;
   *cbeg++ = (char)0x30;
   *cbeg++ = (unsigned char)0x82;
   *cbeg++ = (char)0x00;
   *cbeg++ = (char)0x00;
   *cbeg++ = (char)(certParam.certKey.expLen >> 8);    
   *cbeg++ = (char)(certParam.certKey.expLen & 0xFF);
   *cbeg++ = (char)(certParam.certKey.modLen >> 8);
   *cbeg++ = (char)(certParam.certKey.modLen & 0xFF);  
   while (kcoa--)
   {
      *cbeg++ = 0;
   }
   memcpy(cbeg, certParam.certKey.exp, kco);
   cbeg += kco;
   memcpy(cbeg, certParam.certKey.mod, pxafbmodes);
   baFree(aemifresources);
   return (SharkSslKey)buttontable;
}


SHARKSSL_API SharkSslKey sharkssl_PEM_extractPublicKey(const char *allowresize)
{
   U8 earlyconsole;
   return sharkssl_PEM_extractPublicKey_ext(allowresize, &earlyconsole);
}
#endif  
#endif  


#if SHARKSSL_ENABLE_RSA

int omap3430common(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe)
{
   U16 creategroup;

   baAssert(NULL == (void*)0);
   baAssert((seepromprobe == SHARKSSL_RSA_NO_PADDING) || (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING));
   if ((in == NULL) || (out == NULL) || (disableclock == NULL) || (!(machinekexec(disableclock->expLen))))
   {
      return (int)SHARKSSL_RSA_WRONG_PARAMETERS;
   }
   creategroup = supportedvector(disableclock->modLen);
   #if (SHARKSSL_ENABLE_RSA_PKCS1 || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE)
   if (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING)
   {
      U16 kl;

      if (creategroup < 11)
      {
         return (int)SHARKSSL_RSA_WRONG_KEY_LENGTH;
      }

      if (len > (creategroup - 11))
      {
         return (int)SHARKSSL_RSA_INPUT_DATA_LENGTH_TOO_BIG;
      }
      kl = creategroup - len;
      memmove(out + kl, in, len);
      in = out;
      *in++ = 0x00;  
      *in++ = 0x02;
      kl -= 3;
      len = (kl & 0x0003);
      kl &= 0xFFFC;  
      if (sharkssl_rng(in, kl) < 0)
      {
         return (int)SHARKSSL_RSA_INTERNAL_ERROR;
      }
      in += kl;
      if (len)
      {
         in -= (4 - len);
         if (sharkssl_rng(in, 4) < 0)
         {
            return (int)SHARKSSL_RSA_INTERNAL_ERROR;
         }
         in += 4;
      }
      *in-- = 0x00;
      while (in != out)
      {
         if (0x00 == *in)
         {
            *in = 0x55;
         }
         in--;
      }
   }
   else  
   #endif
   {
      if (len != creategroup)
      {
         return (int)SHARKSSL_RSA_INPUT_DATA_LENGTH_AND_KEY_LENGTH_MISMATCH;
      }
      memmove(out, in, len);
   }
   if (async3clksrc(disableclock, hsmmcplatform, out))
   {
      return (int)SHARKSSL_RSA_ALLOCATION_ERROR;
   }
   return creategroup;
}


int writemessage(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe)
{
   U16 creategroup;

   baAssert(NULL == (void*)0);
   baAssert((seepromprobe == SHARKSSL_RSA_NO_PADDING) || (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING));
   if ((in == NULL) || (out == NULL) || (disableclock == NULL) || (!(machinekexec(disableclock->expLen))))
   {
      return (int)SHARKSSL_RSA_WRONG_PARAMETERS;
   }
   creategroup = supportedvector(disableclock->modLen);
   if (0 == creategroup)
   {
      return (int)SHARKSSL_RSA_WRONG_KEY_LENGTH;
   }
   if (len != creategroup)
   {
      return (int)SHARKSSL_RSA_INPUT_DATA_LENGTH_AND_KEY_LENGTH_MISMATCH;
   }
   if (async3clksrc(disableclock, sleepstore, in))
   {
      return (int)SHARKSSL_RSA_ALLOCATION_ERROR;
   }
   #if (SHARKSSL_ENABLE_RSA_PKCS1 || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE)
   if (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING)
   {
      
      if ((*in++ != 0x00) || (*in++ != 0x02))
      {
         return (int)SHARKSSL_RSA_PKCS1_PADDING_ERROR;
      }
      creategroup -= 2;
      while ((--creategroup) && (*in++ != 0x00))
      {
      }
      if (0 == creategroup)
      {
         return (int)SHARKSSL_RSA_PKCS1_PADDING_ERROR;
      }
   }
   #endif
   memmove(out, in, creategroup);
   return creategroup;
}


int clockaccess(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe)
{
   U16 creategroup;

   baAssert(NULL == (void*)0);
   baAssert((seepromprobe == SHARKSSL_RSA_NO_PADDING) || (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING));
   if ((in == NULL) || (out == NULL) || (disableclock == NULL) || (!(machinekexec(disableclock->expLen))))
   {
      return (int)SHARKSSL_RSA_WRONG_PARAMETERS;
   }
   creategroup = supportedvector(disableclock->modLen);
   #if (SHARKSSL_ENABLE_RSA_PKCS1 || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE)
   if (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING)
   {
      U16 kl;

      if (creategroup < 11)
      {
         return (int)SHARKSSL_RSA_WRONG_KEY_LENGTH;
      }

      if (len >= (creategroup - 11))
      {
         return (int)SHARKSSL_RSA_INPUT_DATA_LENGTH_TOO_BIG;
      }
      kl = creategroup - len;
      memmove(out + kl, in, len);
      in = out;
      *in++ = 0x00;  
      *in++ = 0x01;
      kl -= 3;
      memset(in, 0xFF, kl);
      *(in + kl) = 0x00;
   }
   else  
   #endif
   {
      if (len != creategroup)
      {
         return (int)SHARKSSL_RSA_INPUT_DATA_LENGTH_AND_KEY_LENGTH_MISMATCH;
      }
      memmove(out, in, len);
   }
   if (async3clksrc(disableclock, sleepstore, out))
   {
      return (int)SHARKSSL_RSA_ALLOCATION_ERROR;
   }
   return creategroup;
}


int handleguest(const SharkSslCertKey *disableclock, U16 len, U8 *in, U8 *out, U8 seepromprobe)
{
   U16 creategroup;

   baAssert(NULL == (void*)0);
   baAssert((seepromprobe == SHARKSSL_RSA_NO_PADDING) || (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING));
   if ((in == NULL) || (out == NULL) || (disableclock == NULL) || (!(machinekexec(disableclock->expLen))))
   {
      return (int)SHARKSSL_RSA_WRONG_PARAMETERS;
   }
   creategroup = supportedvector(disableclock->modLen);
   if (0 == creategroup)
   {
      return (int)SHARKSSL_RSA_WRONG_KEY_LENGTH;
   }
   if (len != creategroup)
   {
      return (int)SHARKSSL_RSA_INPUT_DATA_LENGTH_AND_KEY_LENGTH_MISMATCH;
   }
   if (async3clksrc(disableclock, hsmmcplatform, in))
   {
      return (int)SHARKSSL_RSA_ALLOCATION_ERROR;
   }
   #if (SHARKSSL_ENABLE_RSA_PKCS1 || SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE)
   if (seepromprobe == SHARKSSL_RSA_PKCS1_PADDING)
   {
      
      if ((*in++ != 0x00) || (*in++ != 0x01))
      {
         return (int)SHARKSSL_RSA_PKCS1_PADDING_ERROR;
      }
      creategroup -= 2;
      while (--creategroup)
      {
         U8 c = *in++;
         if (c == 0)
         {
            break;
         }
         else if (c != 0xFF)
         {
            return (int)SHARKSSL_RSA_PKCS1_PADDING_ERROR;
         }
      }
      if (0 == creategroup)
      {
         return (int)SHARKSSL_RSA_PKCS1_PADDING_ERROR;
      }
   }
   #endif
   memmove(out, in, creategroup);
   return creategroup;
}


#if (SHARKSSL_ENABLE_RSA_API)
#if (SHARKSSL_ENABLE_PEM_API)
SHARKSSL_API SharkSslRSAKey sharkssl_PEM_to_RSAKey(const char *clearnopref, const char *pxa270flash)
{
   SharkSslCert kernelvaddr;

   baAssert(NULL == (void*)0);
   if ((clearnopref == NULL) || (sharkssl_PEM(NULL, clearnopref, pxa270flash, &kernelvaddr) < 0))
   {
      return NULL;
   }
   return (SharkSslRSAKey)kernelvaddr;
}


SHARKSSL_API void SharkSslRSAKey_free(SharkSslRSAKey hsspiregister)
{
   if (hsspiregister)
   {
      baFree((void*)hsspiregister);
   }
}
#endif  



SHARKSSL_API U16 SharkSslRSAKey_size(SharkSslRSAKey sourcerouting)
{
   SharkSslCertKey disableclock;
   baAssert(NULL == (void*)0);

   if (interrupthandler(&disableclock, (SharkSslCert)sourcerouting))
   {
      if (machinekexec(disableclock.expLen))
      {
         return disableclock.modLen;
      }
   }
   return 0;
}


typedef int (*SharkSslCertKey_RSA_func)(const SharkSslCertKey*, U16, U8*, U8*, U8);

static sharkssl_RSA_RetVal switchcompletion(SharkSslCertKey_RSA_func orderarray, SharkSslRSAKey sourcerouting, U16 len, U8 *in, U8 *out, U8 seepromprobe)
{
   SharkSslCertKey disableclock;

   if ((in == NULL) || (out == NULL) || (sourcerouting == NULL))
   {
      return SHARKSSL_RSA_WRONG_PARAMETERS;
   }

   if (0 == interrupthandler(&disableclock, sourcerouting))
   {
      return SHARKSSL_RSA_WRONG_KEY_FORMAT;
   }

   return (sharkssl_RSA_RetVal)orderarray(&disableclock, len, in, out, seepromprobe);
}


SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_public_encrypt(U16 len, U8 *in, U8 *out, SharkSslRSAKey sourcerouting, U8 seepromprobe)
{
   return switchcompletion(omap3430common, sourcerouting, len, in, out, seepromprobe);
}


SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_private_decrypt(U16 len, U8 *in, U8 *out, SharkSslRSAKey resumeenabler, U8 seepromprobe)
{
   return switchcompletion(writemessage, resumeenabler, len, in, out, seepromprobe);
}


#if SHARKSSL_ENABLE_RSA_OAEP
static void aliasstart(U8 *pciercxcfg448, U16 allocskcipher, U8 *src, U16 consolewrite, U8 configwrite)
{
   if (allocskcipher)
   {
      U8 *ptr, *dptr, *buf;
      U16 ftraceupdate, i;

      ftraceupdate = sharkssl_getHashLen(configwrite);
      buf = baMalloc(ftraceupdate + consolewrite + 4);
      if (buf)
      {
         dptr = buf + ftraceupdate;
         memcpy(dptr, src, consolewrite);
         ptr = dptr + consolewrite;
         hsotgpdata(0, ptr, 0);
         consolewrite += 4;
         for (;;)
         {
            sharkssl_hash(buf, dptr, consolewrite, configwrite);
            if (allocskcipher < ftraceupdate)
            {
               ftraceupdate = (U8)allocskcipher;
            }
            for (i = 0; i < ftraceupdate; i++)
            {
               *pciercxcfg448++ ^= buf[i];
            }
            allocskcipher -= ftraceupdate;
            if (allocskcipher)
            {
               U32 requestflags;
               read64uint32(requestflags, ptr, 0);
               requestflags++;
               inputlevel(requestflags, ptr, 0);
            }
            else
            {
               break;
            }
         }
         memset(buf, 0, ftraceupdate + consolewrite);
         baFree(buf);
      }
   }
}


SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_private_decrypt_OAEP(U16 len, U8 *in, U8 *out, SharkSslRSAKey resumeenabler, U8 configwrite, const char *clkdmoperations, U16 auxdatalookup)
{
   int ret;
   U16 ftraceupdate, i;

   ftraceupdate = sharkssl_getHashLen(configwrite);
   ret = (int)switchcompletion(writemessage, resumeenabler, len, in, in, SHARKSSL_RSA_NO_PADDING);
   if (ftraceupdate == 0)
   {
      ret = SHARKSSL_RSA_WRONG_PARAMETERS;  
   }
   else if (ret < (2 * ftraceupdate + 2))
   {
      ret = SHARKSSL_RSA_WRONG_KEY_LENGTH;
   }
   else
   {
      int PSLen, buttonsbuffalo;
      U8 logicstate[SHARKSSL_MAX_HASH_LEN], *ptr, sum, flg;

      aliasstart(&in[1], ftraceupdate, &in[1 + ftraceupdate], (U16)ret - ftraceupdate - 1, configwrite);
      aliasstart(&in[ftraceupdate + 1], (U16)ret - ftraceupdate - 1, &in[1], ftraceupdate, configwrite);
      sharkssl_hash(logicstate, (U8*)clkdmoperations, auxdatalookup, configwrite);

      
      ptr = in;
      sum = *ptr++; 
      ret--;
      ptr += ftraceupdate; 
      ret -= (ftraceupdate << 1);
      for (i = 0; ftraceupdate--; i++)
      {
         sum |= *ptr++ ^ logicstate[i];
      }
      
      buttonsbuffalo = ret;
      flg = 0;
      in = ptr;
      PSLen = 0;
      while (--buttonsbuffalo)
      {
         flg |= *in++;
         PSLen += (~flg) & 0x01;  
      }
      if (PSLen >= ret)
      {
         return SHARKSSL_RSA_PKCS1_PADDING_ERROR;
      }
      ret -= PSLen;
      ptr += PSLen;
      sum |= *ptr++ ^ 0x01;
      if ((0 == ret) || (sum))
      {
         return SHARKSSL_RSA_PKCS1_PADDING_ERROR;
      }
      ret--;
      memcpy(out, ptr, ret);
      memset(logicstate, 0, SHARKSSL_DIM_ARR(logicstate));
   }

   return (sharkssl_RSA_RetVal)ret;
}


SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_public_encrypt_OAEP(U16 len, const U8 *in, U8 *out, SharkSslRSAKey setupreset, U8 configwrite, const char *clkdmoperations, U16 auxdatalookup)
{
   int ret;
   U16 ftraceupdate, h2Len;

   ftraceupdate = sharkssl_getHashLen(configwrite);
   h2Len = (ftraceupdate * 2) + 2;
   ret = SharkSslRSAKey_size(setupreset);
   if (ftraceupdate == 0)
   {
      ret = SHARKSSL_RSA_WRONG_PARAMETERS;  
   }
   else if (ret == 0)
   {
      ret = SHARKSSL_RSA_WRONG_KEY_FORMAT;
   }
   else if (ret < h2Len)
   {
      ret = SHARKSSL_RSA_WRONG_KEY_LENGTH;
   }
   else if (len > (ret - h2Len))
   {
      ret = SHARKSSL_RSA_INPUT_DATA_LENGTH_TOO_BIG;
   }
   else
   {
      U8 *ptr = out;
      *ptr++ = 0x00;
      sharkssl_rng(ptr, ftraceupdate);
      ptr += ftraceupdate;
      sharkssl_hash(ptr, (U8*)clkdmoperations, auxdatalookup, configwrite);
      ptr += ftraceupdate;
      h2Len = (U16)ret - h2Len - len;
      memset(ptr, 0, h2Len);
      ptr += h2Len;
      *ptr++ = 0x01;
      memcpy(ptr, in, len);
      aliasstart(&out[ftraceupdate + 1], (U16)ret - ftraceupdate - 1, &out[1], ftraceupdate, configwrite);
      aliasstart(&out[1], ftraceupdate, &out[1 + ftraceupdate], (U16)ret - ftraceupdate - 1, configwrite);
      ret = (int)switchcompletion(omap3430common, setupreset, (U16)ret, out, out, SHARKSSL_RSA_NO_PADDING);
   }

   return (sharkssl_RSA_RetVal)ret;
}
#endif  


SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_private_encrypt(U16 len, U8 *in, U8 *out, SharkSslRSAKey resumeenabler, U8 seepromprobe)
{
   return switchcompletion(clockaccess, resumeenabler, len, in, out, seepromprobe);
}


SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_public_decrypt(U16 len, U8 *in, U8 *out, SharkSslRSAKey sourcerouting, U8 seepromprobe)
{
   return switchcompletion(handleguest, sourcerouting, len, in, out, seepromprobe);
}
#endif  
#endif  


#if SHARKSSL_USE_ECC
#if (SHARKSSL_ENABLE_PEM_API)
SHARKSSL_API SharkSslECCKey sharkssl_PEM_to_ECCKey(const char *clearnopref, const char *pxa270flash)
{
   SharkSslCert kernelvaddr;

   baAssert(NULL == (void*)0);
   if ((clearnopref == NULL) || (sharkssl_PEM(NULL, clearnopref, pxa270flash, &kernelvaddr) < 0))
   {
      return NULL;
   }
   return (SharkSslECCKey)kernelvaddr;
}
#endif  


#if (SHARKSSL_ENABLE_PEM_API || SHARKSSL_ENABLE_ECCKEY_CREATE)
SHARKSSL_API void SharkSslECCKey_free(SharkSslECCKey dividetable)
{
   if (dividetable)
   {
      baFree((void*)dividetable);
   }
}
#endif


#if (SHARKSSL_ENABLE_ECDSA && SHARKSSL_ENABLE_ECDSA_API)
#if (!SHARKSSL_ECDSA_ONLY_VERIFY)

U16 relocationchain(SharkSslCertKey *disableclock)
{
   U16 len = mousethresh(disableclock->expLen);
   if (len && (len < 0x70))
   {
      len <<= 1;
      len += 8;
      #if SHARKSSL_ECC_USE_SECP521R1
      if (len >= 0x80)
      {
         len++;
      }
      #endif
      return len;
   }
   return 0;
}


SHARKSSL_API U16 sharkssl_ECDSA_siglen(SharkSslECCKey resumeenabler)
{
   SharkSslCertKey disableclock;

   if ((interrupthandler(&disableclock, resumeenabler)) &&
       (machinereboot(disableclock.expLen)) &&
       !(coupledexynos(disableclock.expLen)))
   {
      return relocationchain(&disableclock);
   }

   return 0;
}


SHARKSSL_API sharkssl_ECDSA_RetVal sharkssl_ECDSA_sign_hash(SharkSslECCKey resumeenabler, U8 *sig, U16 *platformconfig, U8 *chargerplatform, U8 clearscratchpad)
{
   SharkSslCertKey disableclock;
   SharkSslECDSAParam audioshutdown;
   sharkssl_ECDSA_RetVal ret;

   if ((NULL == sig) || (NULL == chargerplatform) || (0 == clearscratchpad))
   {
      return SHARKSSL_ECDSA_WRONG_PARAMETERS;
   }
   if ((0 == interrupthandler(&disableclock, resumeenabler)) || !(machinereboot(disableclock.expLen)))
   {
      return SHARKSSL_ECDSA_WRONG_KEY_FORMAT;
   }
   if (coupledexynos(disableclock.expLen))
   {
      return SHARKSSL_ECDSA_KEY_NOT_PRIVATE;
   }

   audioshutdown.curveType = wakeupenable(disableclock.modLen);
   audioshutdown.hash = chargerplatform;
   audioshutdown.hashLen = clearscratchpad;
   audioshutdown.key = disableclock.exp;
   audioshutdown.keyLen = mousethresh(disableclock.expLen);

   ret = registerboard(&audioshutdown, sig, platformconfig);
   if (ret < 0)
   {
      
      return ret;
   }

   return SHARKSSL_ECDSA_OK;
}
#endif


SHARKSSL_API sharkssl_ECDSA_RetVal sharkssl_ECDSA_verify_hash(SharkSslECCKey setupreset, U8 *sig, U16 platformconfig, U8 *chargerplatform, U8 clearscratchpad)
{
   U8 kexecprepare[claimresource(SHARKSSL_MAX_ECC_POINTLEN)];
   U8 stackoverflow[claimresource(SHARKSSL_MAX_ECC_POINTLEN)];
   SharkSslParseASN1 parseSgn;
   SharkSslCertKey disableclock;
   SharkSslECDSAParam audioshutdown;
   int ret;

   if ((NULL == sig) || (NULL == chargerplatform) || (0 == clearscratchpad) || (0 == platformconfig))
   {
      return SHARKSSL_ECDSA_WRONG_PARAMETERS;
   }
   if ((0 == interrupthandler(&disableclock, setupreset)) || !(machinereboot(disableclock.expLen)))
   {
      return SHARKSSL_ECDSA_WRONG_KEY_FORMAT;
   }
   if (!(coupledexynos(disableclock.expLen)))
   {
      
      return SHARKSSL_ECDSA_KEY_NOT_PUBLIC;
   }

   audioshutdown.curveType = wakeupenable(disableclock.modLen);
   audioshutdown.hash = chargerplatform;
   audioshutdown.hashLen = clearscratchpad;
   audioshutdown.key = disableclock.mod;
   audioshutdown.keyLen = attachdevice(disableclock.modLen);

   parseSgn.ptr = sig;
   parseSgn.len = platformconfig;
   if (((ret = SharkSslParseASN1_getSequence(&parseSgn)) < 0) ||
        (SharkSslParseASN1_getInt(&parseSgn) < 0) || ((U32)ret < parseSgn.datalen) ||
        (parseSgn.datalen > audioshutdown.keyLen))
   {
      return SHARKSSL_ECDSA_WRONG_SIGNATURE;
   }
   ret = (audioshutdown.keyLen - parseSgn.datalen);
   if (ret)
   {
      
      memset(kexecprepare, 0, ret);
      memcpy(&kexecprepare[ret], parseSgn.dataptr, parseSgn.datalen);
      audioshutdown.R = kexecprepare;
   }
   else
   {
      audioshutdown.R = parseSgn.dataptr;
   }

   if (SharkSslParseASN1_getInt(&parseSgn) < 0)
   {
      return SHARKSSL_ECDSA_WRONG_SIGNATURE;
   }
   ret = (audioshutdown.keyLen - parseSgn.datalen);
   if (ret)
   {
      
      memset(stackoverflow, 0, ret);
      memcpy(&stackoverflow[ret], parseSgn.dataptr, parseSgn.datalen);
      audioshutdown.S = stackoverflow;
   }
   else
   {
      audioshutdown.S = parseSgn.dataptr;
   }

   ret = SharkSslECDSAParam_ECDSA(&audioshutdown, fixupdevices);
   if (ret)
   {
      if ((int)SharkSslCon_AllocationError == ret)
      {
         return SHARKSSL_ECDSA_ALLOCATION_ERROR;
      }

      return SHARKSSL_ECDSA_VERIFICATION_FAIL;
   }

   return SHARKSSL_ECDSA_OK;
}
#endif  
#endif  


#if (SHARKSSL_ENABLE_CA_LIST && SHARKSSL_ENABLE_CERTSTORE_API)
SHARKSSL_API void SharkSslCertStore_constructor(SharkSslCertStore *o)
{
   DoubleList_constructor(&o->certList);
   o->caList = 0;
   o->elements = 0;
}


SHARKSSL_API void SharkSslCertStore_destructor(SharkSslCertStore* o)
{
   SharkSslCSCert *kernelvaddr;

   if (o->caList)
   {
      baFree((void*)o->caList);
      o->caList = 0;
   }

   while ((kernelvaddr = (SharkSslCSCert*)DoubleList_firstNode(&o->certList)) != 0)
   {
      DoubleLink_unlink((DoubleLink*)kernelvaddr);
      o->elements--;
      baAssert(kernelvaddr->ptr);
      baFree(kernelvaddr->ptr);
      baFree(kernelvaddr);
   }
}


#define SHARKSSL_PARSESEQ_SINGLE_CERT             1
#define SHARKSSL_PARSESEQ_MULTIPLE_CERT           0
#define SHARKSSL_PARSESEQ_PARSE_ERROR            -1
#define SHARKSSL_PARSESEQ_NOT_BINARY_FORMAT      -2
#define SHARKSSL_PARSESEQ_UNSUPPORTED_CERT       -3

static int clockgetres(SharkSslParseASN1 *o)
{
   int ls;

   o->dataptr = o->ptr;  
   o->datalen = o->len;  

   if ((ls = SharkSslParseASN1_getSequence(o)) < 0)
   {
      return SHARKSSL_PARSESEQ_NOT_BINARY_FORMAT;
   }

   if (!(SharkSslParseASN1_getOID(o) < 0))
   {
      
      if ((o->datalen == SHARKSSL_DIM_ARR(sharkssl_oid_signedData)) &&
          (0 == sharkssl_kmemcmp(o->dataptr, sharkssl_oid_signedData, SHARKSSL_DIM_ARR(sharkssl_oid_signedData))))
      {
         if ((SharkSslParseASN1_getVersion(o) < 0)  || (SharkSslParseASN1_getSequence(o) < 0) ||
             (SharkSslParseASN1_getInt(o) < 0)      || (SharkSslParseASN1_getSet(o) < 0) ||
             (SharkSslParseASN1_getSequence(o) < 0) || (SharkSslParseASN1_getOID(o) < 0))
         {
            return SHARKSSL_PARSESEQ_PARSE_ERROR;
         }

         #if 0
         if (0 == ls)  
         {
            if (SharkSslParseASN1_getSetSeq(o, 0x00))
            {
               return SHARKSSL_PARSESEQ_PARSE_ERROR;
            }
         }
         #endif

         if ((ls = SharkSslParseASN1_getVersion(o)) < 0)
         {
            return SHARKSSL_PARSESEQ_PARSE_ERROR;
         }

         o->datalen = ls;
         return SHARKSSL_PARSESEQ_MULTIPLE_CERT;
      }
   }

   else if (ls > 0) 
   {
      if ((U32)ls != o->len)
      {
         return SHARKSSL_PARSESEQ_PARSE_ERROR;
      }

      o->ptr = o->dataptr;  
      o->len = o->datalen;  
      return SHARKSSL_PARSESEQ_SINGLE_CERT;
   }

   return SHARKSSL_PARSESEQ_UNSUPPORTED_CERT;
}


static U16 serialdevice(SharkSslCertStore *o, SharkSslParseASN1 *p, U8 timer5hwmod)
{
   SharkSslCSCert *newCert = 0;
   SharkSslCertDN  issuerDN, subjectDN;
   U8 *gpio1config, *cp, *cr;
   int rc, ls;
   U16 nc = 0;  

   cp = p->ptr;
   rc = p->len;

   
   while (rc > 0)
   {
      if (o->elements == 0xFFFF)  
      {
         break;
      }

      p->ptr = cr = cp;
      p->len = rc;

      if ((ls = SharkSslParseASN1_getSequence(p)) < 0)
      {
         break;  
      }

      cp = p->ptr + ls;  
      rc = p->len - ls;

      if ((ls = SharkSslParseASN1_getSequence(p)) < 0)
      {
         continue;  
      }

      p->len = ls;
      if ((sha256final(p) < 0)  ||
          (SharkSslParseASN1_getInt(p) < 0)      ||
          (SharkSslParseASN1_getSequence(p) < 0) ||
          (SharkSslParseASN1_getOID(p) < 0)      ||
          (deltacamera(p, &issuerDN) < 0) ||
          (SharkSslParseASN1_getSequence(p) < 0))
      {
         continue;   
      }

      if (SharkSslParseASN1_getUTCTime(p) && (SharkSslParseASN1_getGenTime(p)))
      {
         continue;    
      }
      if (SharkSslParseASN1_getUTCTime(p) && (SharkSslParseASN1_getGenTime(p)))
      {
         continue;    
      }
      if ((deltacamera(p, &subjectDN) < 0) ||
          (SharkSslParseASN1_getSequence(p) < 0))
      {
         continue;    
      }

      newCert = (SharkSslCSCert*)baMalloc(sizeof(SharkSslCSCert));
      if (newCert == NULL)
      {
         break;  
      }

      if (timer5hwmod)  
      {
         ls = (U32)claimresource(cp - cr);
         newCert->ptr = (U8*)baMalloc((U32)ls);
         if (newCert->ptr == NULL)
         {
            baFree(newCert);
            break;  
         }
         memcpy(newCert->ptr, cr, (U32)ls);
      }
      else
      {
         baAssert(0 == nc);
         newCert->ptr = cr;
      }

      
      if ((subjectDN.commonName) && (subjectDN.commonNameLen))
      {
         ls = subjectDN.commonNameLen;
         gpio1config = (U8*)subjectDN.commonName;
      }
      else if ((subjectDN.organization) && (subjectDN.organizationLen))
      {
         ls = subjectDN.organizationLen;
         gpio1config = (U8*)subjectDN.organization;
      }
      else
      {
         continue;  
      }

      if (ls >= SHARKSSL_MAX_SNAME_LEN)
      {
         ls = SHARKSSL_MAX_SNAME_LEN;
         newCert->name[SHARKSSL_MAX_SNAME_LEN] = 0; 
      }
      else
      {
         memset(newCert->name, 0, (SHARKSSL_MAX_SNAME_LEN + 1));
      }
      memcpy(newCert->name, gpio1config, ls);

      o->elements++;
      nc++;

      DoubleLink_constructor(&newCert->super);
      if (DoubleList_isEmpty(&o->certList))
      {
         DoubleList_insertLast(&o->certList, newCert);
      }
      else
      {
         DoubleListEnumerator instructioncounter;
         SharkSslCSCert *kernelvaddr;
         DoubleListEnumerator_constructor(&instructioncounter, &o->certList);
         for (kernelvaddr = (SharkSslCSCert*)DoubleListEnumerator_getElement(&instructioncounter); kernelvaddr;
              kernelvaddr = (SharkSslCSCert*)DoubleListEnumerator_nextElement(&instructioncounter))
         {
            if (strcmp(newCert->name, kernelvaddr->name) < 0)
            {
               break;
            }
         }

         if (kernelvaddr)
         {
            DoubleLink_insertBefore(kernelvaddr, newCert);
         }
         else
         {
            DoubleList_insertLast(&o->certList, newCert);
         }
      }
   }

   return nc;
}



SHARKSSL_API U16 SharkSslCertStore_add(SharkSslCertStore *o, const char *kernelvaddr, U32 doublenormaliseround)
{
   SharkSslParseASN1 parseASN;
   const char *cbeg, *cend;
   U8 *freezemonarch;
   int ls, lr;
   U16 nc = 0;

   parseASN.ptr = (U8*)kernelvaddr;
   parseASN.len = doublenormaliseround;

   switch (clockgetres(&parseASN))
   {
      case SHARKSSL_PARSESEQ_NOT_BINARY_FORMAT:
         
         cbeg = sharkStrstr(kernelvaddr, "\055\055\055\055\055\102\105\107\111\116");
         cend = 0;

         do
         {
            if (cbeg)
            {
               cbeg += 10;  
               cbeg = sharkStrstr(cbeg, "\055\055\055\055\055");
               if (cbeg)
               {
                  cbeg += 5;  
                  while ((*cbeg == '\015') || (*cbeg == '\012'))
                  {
                     cbeg++;
                  }
                  cend = sharkStrstr(cbeg, "\055\055\055\055\055\105\116\104");
               }
            }
            if ((cbeg == NULL) || (cend == NULL))
            {
               return 0;  
            }

            parseASN.len = (U32)(cend - cbeg);
            freezemonarch = (U8*)baMalloc(claimresource((parseASN.len * 3) >> 2) + 4);
            if (freezemonarch == NULL)
            {
               return 0;  
            }

            
            parseASN.len = sharkssl_B64Decode(freezemonarch, parseASN.len, cbeg, cend);
            parseASN.ptr = freezemonarch;
            ls = lr = clockgetres(&parseASN);
            if (ls >= 0)
            {
               ls = (ls == SHARKSSL_PARSESEQ_MULTIPLE_CERT);
               
               lr = serialdevice(o, &parseASN, (U8)ls);
               if (lr > 0)
               {
                  baAssert(lr <= 0xFFFF);
                  nc += (U16)lr;
               }
            }
            if ((lr <= 0)  ||  ls)
            {
               
               baFree(freezemonarch);
            }


            
            cbeg = sharkStrstr(cend, "\055\055\055\055\055\102\105\107\111\116");
         } while (cbeg);
         break;


      case SHARKSSL_PARSESEQ_SINGLE_CERT:
      case SHARKSSL_PARSESEQ_MULTIPLE_CERT:
         nc = serialdevice(o, &parseASN, 1);
         break;

      default:
         nc--;  
         break;
   }

   return nc;
}


SHARKSSL_API U8 SharkSslCertStore_assemble(SharkSslCertStore *o, SharkSslCAList *flushcounts)
{
   DoubleListEnumerator instructioncounter;
   SharkSslCSCert *kernelvaddr;
   U8 *p;

   if (o->caList)
   {
      *flushcounts = o->caList;
   }
   else
   {
      p = (U8*)baMalloc(4 + o->elements * (SHARKSSL_CA_LIST_NAME_SIZE +
                                           SHARKSSL_CA_LIST_PTR_SIZE));
      *flushcounts = o->caList = (SharkSslCAList)p;
      if (p == NULL)
      {
         return 0;
      }

      *p++ = SHARKSSL_CA_LIST_PTR_TYPE;
      *p++ = 0;
      *p++ = (U8)(((o->elements) >> 8));
      *p++ = (U8)((o->elements) & 0xFF);

      DoubleListEnumerator_constructor(&instructioncounter, &o->certList);
      for (kernelvaddr = (SharkSslCSCert*)DoubleListEnumerator_getElement(&instructioncounter); kernelvaddr;
           kernelvaddr = (SharkSslCSCert*)DoubleListEnumerator_nextElement(&instructioncounter))
      {
         memcpy(p, kernelvaddr->name, SHARKSSL_CA_LIST_NAME_SIZE);
         p += SHARKSSL_CA_LIST_NAME_SIZE;
         *(U8**)p = kernelvaddr->ptr;
         p += SHARKSSL_CA_LIST_PTR_SIZE;
      }
   }
   return 1;  
}
#endif  


#ifndef BA_LIB
#define BA_LIB
#endif



#include <string.h>



void traceaddress(shtype_t *o, U16 writepmresrn, void *alloccontroller)
{
   #if ((SHARKSSL_BIGINT_WORDSIZE > 8) && (!(SHARKSSL_UNALIGNED_ACCESS)))
   baAssert(0 == ((unsigned int)(UPTR)alloccontroller & computereturn));  
   #endif
   baAssert((sizeof(U64) == 8) && (sizeof(S64) == 8));
   baAssert((sizeof(U32) == 4) && (sizeof(S32) == 4));
   baAssert((sizeof(U16) == 2) && (sizeof(S16) == 2));
   baAssert((sizeof(U8)  == 1) && (sizeof(S8)  == 1));
   o->len = writepmresrn;
   o->mem = o->beg = (shtype_tWord*)alloccontroller;
}



void unassignedvector(const shtype_t *src, shtype_t *pciercxcfg448)
{
   pciercxcfg448->len = src->len;
   pciercxcfg448->beg = pciercxcfg448->mem;
   memcpy(pciercxcfg448->beg, src->beg, src->len * SHARKSSL__M);
}


#if SHARKSSL_ECC_USE_EDWARDS

void shtype_t_copyfull(const shtype_t *src, shtype_t *pciercxcfg448)
{
   U32 d = (U32)(src->beg - src->mem);
   pciercxcfg448->len = src->len;
   pciercxcfg448->beg = pciercxcfg448->mem + d;
   memcpy(pciercxcfg448->mem, src->mem, (d + src->len) * SHARKSSL__M);
}
#endif



void deviceparse(const shtype_t *o)
{
   memset(o->beg, 0, o->len * SHARKSSL__M);
}



void blastscache(shtype_t *o)
{
   while ((o->len > 1) && (o->beg[0] == 0))
   {
      o->beg++;
      o->len--;
   }
}


#if SHARKSSL_ENABLE_ECDSA  

U8 eventtimeout(shtype_t *o)
{
   shtype_tWord *p = o->beg;
   U16 len = o->len;

   
   while ((len > 1) && (*p == 0))
   {
      p++;
      len--;
   }

   return (U8)(*p == 0);
}
#endif


#if SHARKSSL_ECC_USE_EDWARDS

void shtype_t_swapConditional(shtype_t *o1, shtype_t *o2, U32 swapFlag)
{
   S32 diff_mem = (S32)(o1->mem - o2->mem);
   S32 diff_beg = (S32)(o1->beg - o2->beg);
   S16 diff_len = (S16)(o1->len - o2->len);
   swapFlag = ~(swapFlag - 1);  
   diff_mem = (S32)((U32)diff_mem & swapFlag);
   diff_beg = (S32)((U32)diff_beg & swapFlag);
   diff_len = (S16)((U16)diff_len & (U16)swapFlag);
   o2->mem += diff_mem;
   o1->mem -= diff_mem;
   o2->beg += diff_beg;
   o1->beg -= diff_beg;
   o2->len += diff_len;
   o1->len -= diff_len;
}
#endif



#if SHARKSSL_OPTIMIZED_BIGINT_ASM
#if (SHARKSSL_BIGINT_WORDSIZE != 32)
#error SharkSSL optimized big int library requires SHARKSSL_BIGINT_WORDSIZE = 32
#endif
#else
shtype_tWord updatepmull(shtype_t *o1,
                                      const shtype_t *o2)
{
   shtype_tWord *p1, *p2;
   shtype_tDoubleWordS d;

   p1 = &o1->beg[o1->len - 1];
   p2 = &o2->beg[o2->len - 1];

   d = 0;
   while (p1 >= o1->beg)
   {
      d += *p1;

      if (p2 >= o2->beg)
      {
         d -= *p2--;
      }

      *p1-- = (shtype_tWord)d;
      anatopdisconnect(d);
   }

   
   return (shtype_tWord)d;
}
#endif



#if (!SHARKSSL_OPTIMIZED_BIGINT_ASM)
shtype_tWord resolverelocs(shtype_t *o1,       
                                      const shtype_t *o2)
{
   shtype_tWord *p1, *p2;
   shtype_tDoubleWord d;

   p1 = &o1->beg[o1->len - 1];
   p2 = &o2->beg[o2->len - 1];

   d = 0;
   while (p1 >= o1->beg)
   {
      d += *p1;

      if (p2 >= o2->beg)
      {
         d += *p2--;
      }

      *p1-- = (shtype_tWord)d;
      d >>= SHARKSSL_BIGINT_WORDSIZE;
   }

   return (shtype_tWord)d;
}
#endif



U8 timerwrite(const shtype_t *o1,
                     const shtype_t *o2)
{
   U16 l1 = 0;
   U16 l2 = 0;

   while ((l1 < o1->len) && (o1->beg[l1] == 0))
   {
      l1++;
   }

   while ((l2 < o2->len) && (o2->beg[l2] == 0))
   {
      l2++;
   }

   if ((o1->len - l1) == (o2->len - l2))
   {
      while (l1 < o1->len)
      {
         if (o1->beg[l1] != o2->beg[l2])
         {
            return (U8)(o1->beg[l1] > o2->beg[l2]);
         }

         l1++;
         l2++;
      }
   }

   else
   {
      return (U8)((o1->len - l1) > (o2->len - l2));
   }

   return 1;  
}



void keypaddevice(shtype_t *o1,
                           const shtype_t *o2,
                           const shtype_t *mod)
{
   int sha256export = (timerwrite(o2, mod));
   if (sha256export)
   {
      updatepmull((shtype_t*)o2, mod);
   }
   if (updatepmull(o1, o2))
   {
      resolverelocs(o1, mod);
   }
   if (sha256export)  
   {
      resolverelocs((shtype_t*)o2, mod);
   }
}



void setupsdhci1(shtype_t *o1,
                           const shtype_t *o2,
                           const shtype_t *mod)
{
   while (o1->len < mod->len)
   {
      o1->len++;
      o1->beg--;
      o1->beg[0] = 0;
   }
   baAssert(o1->beg >= o1->mem);
   if (resolverelocs(o1, o2) || timerwrite(o1, mod))
   {
      updatepmull(o1, mod);
   }
}


#if SHARKSSL_OPTIMIZED_BIGINT_ASM
extern
#else
static
#endif

void shtype_t_mult_(const shtype_t *o1,
                          const shtype_t *o2,
                          shtype_t *deltadevices)
#if SHARKSSL_OPTIMIZED_BIGINT_ASM
;
#else
{
   shtype_tWord *p1, *p2, *pr, *pt;
   shtype_tDoubleWord s;
   U16 x1, x2;

   deltadevices->beg = deltadevices->mem;
   deviceparse(deltadevices);

   if (o1 != o2)
   {
      p2 = &o2->beg[o2->len];
      pt = &deltadevices->beg[deltadevices->len];
      for (x2 = o2->len; x2 > 0; x2--)
      {
         register shtype_tWord c = 0;
         p2--;
         pr = --pt;
         x1 = o1->len;
         p1 = &o1->beg[x1];
         #if SHARKSSL_BIGINT_MULT_LOOP_UNROLL
         while (x1 > 3)
         {
            s = ((shtype_tDoubleWord)(*--p1) * *p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            s = ((shtype_tDoubleWord)(*--p1) * *p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            s = ((shtype_tDoubleWord)(*--p1) * *p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            s = ((shtype_tDoubleWord)(*--p1) * *p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            x1 -= 4;
         }
         #endif
         while (x1--)
         {
            s = ((shtype_tDoubleWord)(*--p1) * *p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
         }
         *pr = c;
      }
   }
   else   
   {
      register shtype_tWord a, c;

      x1 = o1->len;
      p1 = &o1->beg[x1];
      pt = &deltadevices->beg[deltadevices->len];
      while (x1 > 1)
      {
         x1--;
         p1--;
         c = 0;
         x2 = x1;
         p2 = p1;
         pt--;
         pr = --pt;
         a = *p1;
         #if SHARKSSL_BIGINT_MULT_LOOP_UNROLL
         while (x2 > 3)
         {
            s = ((shtype_tDoubleWord)a * *--p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            s = ((shtype_tDoubleWord)a * *--p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            s = ((shtype_tDoubleWord)a * *--p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            s = ((shtype_tDoubleWord)a * *--p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
            x2 -= 4;
         }
         #endif
         while (x2--)
         {
            s = ((shtype_tDoubleWord)a * *--p2) + *pr + c;
            *pr-- = (shtype_tWord)s;
            c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
         }
         *pr = c;
      }

      
      pr = &deltadevices->beg[deltadevices->len - 1];
      p1 = &deltadevices->beg[0];
      x2 = 0;
      while (pr >= p1)
      {
         x1 = (U16)(*pr >> (SHARKSSL_BIGINT_WORDSIZE - 1));  
         *pr <<= 1;
         *pr |= x2;
         pr--;
         x2 = x1;
      }

      
      pr = &deltadevices->beg[deltadevices->len];
      x1 = o1->len;
      p1 = &o1->beg[x1];
      s = 0;
      while (x1--)
      {
         p1--;
         a = *p1;
         s += *--pr + ((shtype_tDoubleWord)a * a);
         *pr-- = (shtype_tWord)s;
         s >>= SHARKSSL_BIGINT_WORDSIZE;
         #if (!SHARKSSL_BIGINT_TIMING_RESISTANT)
         if (s)
         #endif
         {
            s += *pr;
            *pr = (shtype_tWord)s;
            s >>= SHARKSSL_BIGINT_WORDSIZE;
         }
      }
   }
}
#endif



void hotplugpgtable(const shtype_t *o1,
                         const shtype_t *o2,
                         shtype_t *deltadevices)
{
   
   deltadevices->len = (U16)(o1->len + o2->len);
   
   shtype_t_mult_(o1, o2, deltadevices);
}


void envdatamcheck(shtype_t *injectexception,
                            const shtype_t *mod,
                            shtype_tWord *afterhandler)
{
   shtype_t q, tmp1, tmpd, tmp2, dm, dr;
   U16 i;

   if (timerwrite(injectexception, mod))
   {
      traceaddress(&q, (U16)((injectexception->len - mod->len) + 1), afterhandler);
      deviceparse(&q);
      afterhandler += q.len;

      traceaddress(&tmp1, injectexception->len, afterhandler);
      afterhandler += injectexception->len;
      traceaddress(&tmpd, injectexception->len, afterhandler);
      deviceparse(&tmpd);

      
      memcpy(tmpd.beg, mod->beg, mod->len * SHARKSSL__M);

      
      while (timerwrite(injectexception, &tmpd))
      {
         q.beg[0]++;
         updatepmull(injectexception, &tmpd);
      }

      dm.len = 2;
      dm.beg = mod->beg; 
      dr.len = 1;
      tmp2.len = 3;

      for (i = 0; i < (q.len - 1); i++)
      {
         tmp2.beg = &injectexception->beg[i];
         dr.beg = &(q.beg[i]);

         if (tmp2.beg[0] == mod->beg[0])
         {
            dr.beg[0] = (shtype_tWord)(-1);
         }
         #if 0  
         else
         {
            U32 doublefnmul = (shtype_tWord)
             (((shtype_tDoubleWord)
              (((shtype_tDoubleWord)(tmp2.beg[0]) << SHARKSSL_BIGINT_WORDSIZE) |
                 tmp2.beg[1])) / mod->beg[0]);
            dr.beg[0] = (shtype_tWord)doublefnmul;
         }
         #elif (SHARKSSL_BIGINT_WORDSIZE == 32)
         {
            shtype_t dd, rr;
            shtype_tWord R[3];  
            U32 k;
            
            
            dr.beg[0] = R[0] = R[1] = R[2] = 0;
            traceaddress(&dd, 2, &mod->beg[0]);
            traceaddress(&rr, 3, &R[0]);
            for (k = 0x80000000; k > 0; k >>= 1)
            {
               R[0] = ((R[0] << 1) | (R[1] >> 31));
               R[1] = ((R[1] << 1) | (R[2] >> 31));
               R[2] <<= 1;
               if (tmp2.beg[0] & k) R[2] |= 1;

               if (timerwrite(&rr, &dd))
               {
                  updatepmull(&rr, &dd);
               }
            }
            for (k = 0x80000000; k > 0; k >>= 1)
            {
               R[0] = ((R[0] << 1) | (R[1] >> 31));
               R[1] = ((R[1] << 1) | (R[2] >> 31));
               R[2] <<= 1;
               if (tmp2.beg[1] & k) R[2] |= 1;

               if (timerwrite(&rr, &dd))
               {
                  updatepmull(&rr, &dd);
               }
            }
            for (k = 0x80000000; k > 0; k >>= 1)
            {
               R[0] = ((R[0] << 1) | (R[1] >> 31));
               R[1] = ((R[1] << 1) | (R[2] >> 31));
               R[2] <<= 1;
               if (tmp2.beg[2] & k) R[2] |= 1;

               if (timerwrite(&rr, &dd))
               {
                  updatepmull(&rr, &dd);
                  dr.beg[0] |= k;
               }
            }
            if ((dr.beg[0] == 0) && timerwrite(&tmp2, &dd))
            {
               dr.beg[0] = (shtype_tWord)(-1);
            }
         }
         #elif (SHARKSSL_BIGINT_WORDSIZE == 16)
         {
            U64 d1 = ((U64)(tmp2.beg[0]) << 32) | ((U32)(tmp2.beg[1]) << 16) | tmp2.beg[2];
            U32 d2 = ((U32)(mod->beg[0]) << 16) | mod->beg[1];
            dr.beg[0] = (U16)((U64)d1/(U32)d2);
            if ((d1 >= d2) && (dr.beg[0] == 0))
            {
               dr.beg[0] = (shtype_tWord)(-1);
            }
         }
         #elif (SHARKSSL_BIGINT_WORDSIZE == 8)
         {
            U32 d1 = ((U32)(tmp2.beg[0]) << 16) | ((U16)(tmp2.beg[1]) << 8) | tmp2.beg[2];
            U16 d2 = ((U16)(mod->beg[0]) << 8) | mod->beg[1];
            dr.beg[0] = (U8)((U32)d1/(U16)d2);
            if ((d1 >= d2) && (dr.beg[0] == 0))
            {
               dr.beg[0] = (shtype_tWord)(-1);
            }
         }
         #endif
         hotplugpgtable(&dm, &dr, &tmp1);
         while (!(timerwrite(&tmp2, &tmp1)))
         {
            dr.beg[0]--;
            hotplugpgtable(&dm, &dr, &tmp1);
         }
         tmpd.len--;
         hotplugpgtable(&tmpd, &dr, &tmp1); 
         if (timerwrite(injectexception, &tmp1))
         {
            updatepmull(injectexception, &tmp1);
         }
         else
         {
            updatepmull(&tmp1, &tmpd);
            updatepmull(injectexception, &tmp1);
            dr.beg[0]--;
         }
      }
   }

   blastscache(injectexception);
}


int suspendfinish(shtype_t *injectexception,
                          const shtype_t *mod)
{
   shtype_tWord *afterhandler;
   U16 flash1resources;

   flash1resources  = injectexception->len;
   flash1resources += (flash1resources << 1);
   flash1resources -= mod->len;
   flash1resources++;
   #if (SHARKSSL__M > 1)
   flash1resources *= SHARKSSL__M;
   #endif
   afterhandler = (shtype_tWord*)baMalloc(pcmciapdata(flash1resources));
   if (afterhandler == NULL)
   {
      return 1;
   }
   envdatamcheck(injectexception, mod, (shtype_tWord*)selectaudio(afterhandler));

   while (injectexception->len < mod->len)
   {
      baAssert(injectexception->beg > injectexception->mem);
      injectexception->len++;
      injectexception->beg--;
      baAssert(0 == injectexception->beg[0]);
   }

   baFree(afterhandler);
   return 0;
}

#if (SHARKSSL_ENABLE_RSA || (SHARKSSL_USE_ECC && (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)))

shtype_tWord remapcfgspace(const shtype_t *mod)
{
   shtype_tWord m0, mu;

   
   m0 = mod->beg[mod->len - 1];
   mu = (shtype_tWord)((((m0 + 2) & 4) << 1) + m0);
   mu = (shtype_tWord)(mu * (2 - m0 * mu));
   #if (SHARKSSL_BIGINT_WORDSIZE >= 16)
   mu = (shtype_tWord)(mu * (2 - m0 * mu));
   #endif
   #if (SHARKSSL_BIGINT_WORDSIZE == 32)
   mu = (shtype_tWord)(mu * (2 - m0 * mu));
   mu = (shtype_tWord)(mu * (2 - m0 * mu));
   #endif
   mu = (shtype_tWord)(~mu + 1);
   return mu;
}
#endif


#if (!SHARKSSL_OPTIMIZED_BIGINT_ASM)
void writebytes(const shtype_t *o1,
                           const shtype_t *o2,
                           shtype_t *deltadevices,
                           const shtype_t *mod,
                           shtype_tWord mu)
{
   shtype_tWord m0, *pr, *p1, *p2;
   shtype_tDoubleWord s;
   U16 x1, x2;

   deltadevices->len = (U16)((2 * mod->len) + 1);
   shtype_t_mult_(o1, o2, deltadevices);

   
   p2 = &deltadevices->beg[deltadevices->len];
   for (x2 = mod->len; x2 > 0; x2--)
   {
      register shtype_tWord c = 0;
      pr = --p2;
      x1 = mod->len;
      p1 = &mod->beg[x1];
      m0 = (shtype_tWord)((shtype_tDoubleWord)mu * *p2);
      #if SHARKSSL_BIGINT_MULT_LOOP_UNROLL
      while (x1 > 3)
      {
         s = ((shtype_tDoubleWord)m0 * *--p1) + *pr + c;
         *pr-- = (shtype_tWord)s;
         c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
         s = ((shtype_tDoubleWord)m0 * *--p1) + *pr + c;
         *pr-- = (shtype_tWord)s;
         c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
         s = ((shtype_tDoubleWord)m0 * *--p1) + *pr + c;
         *pr-- = (shtype_tWord)s;
         c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
         s = ((shtype_tDoubleWord)m0 * *--p1) + *pr + c;
         *pr-- = (shtype_tWord)s;
         c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
         x1 -= 4;
      }
      #endif
      while (x1--)
      {
         s = ((shtype_tDoubleWord)m0 * *--p1) + *pr + c;
         *pr-- = (shtype_tWord)s;
         c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
      }
      
      do
      {
         s = (shtype_tDoubleWord)*pr + c;
         *pr-- = (shtype_tWord)s;
         c = (shtype_tWord)(s >> SHARKSSL_BIGINT_WORDSIZE);
      }
      #if (SHARKSSL_BIGINT_TIMING_RESISTANT)
      while (pr >= deltadevices->beg);
      #else
      while (c > 0);
      #endif
      
   }

   deltadevices->len = (U16)(mod->len + 1);

   if (timerwrite(deltadevices, mod))
   {
      updatepmull(deltadevices, mod);
   }

   deltadevices->beg++;
   deltadevices->len--;
}
#endif


#if SHARKSSL_ENABLE_RSA
int chunkmutex(const shtype_t *validconfig,
                          shtype_t *exp,
                          const shtype_t *mod,
                          shtype_t *res,
                          U8 countersvalid)
{
   shtype_t doublefnmul, *brightnesslimit, deltadevices, *r3000write;
   shtype_t **r, **s, **t;
   shtype_t g[1 << (SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K - 1)];
   shtype_tWord mu, bitmask, *tmp_buf, *tmp_b;
   U16 i, m2_len, flash1resources;
   U8  nbits, valbits, base2;

   
   tmp_buf = &(validconfig->beg[0]);
   m2_len  = validconfig->len;
   while ((m2_len > 1) && (*tmp_buf == 0))
   {
      tmp_buf++;
      m2_len--;
   }
   base2 = ((m2_len == 1) && (*tmp_buf == 2));

   if ((countersvalid == 0) || (countersvalid > SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K))
   {
      countersvalid = SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K;
   }

   
   flash1resources  = (U16)((mod->len * SHARKSSL__M) + 2 * SHARKSSL__M);
   #if (SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K <= 3)
   flash1resources += (10 * mod->len * SHARKSSL__M) + 4; 
   #else
   if (base2)
   {
      flash1resources += (9 * mod->len * SHARKSSL__M);
   }
   else
   {
      flash1resources += SHARKSSL__M * ((1 << (SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K - 1)) +
               (mod->len * (5 + (1 << (SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K - 1)))));
   }
   #endif
   tmp_b = (shtype_tWord*)baMalloc(pcmciapdata(flash1resources));
   if (tmp_b == NULL)
   {
      return 1;
   }

   
   mu = remapcfgspace(mod);

   tmp_buf = (shtype_tWord*)selectaudio(tmp_b);
   brightnesslimit = &doublefnmul;
   m2_len = (U16)(mod->len * 2);
   traceaddress(brightnesslimit, m2_len, tmp_buf);
   tmp_buf += m2_len;

   if (base2)
   {
      tmp_buf++;
      r3000write = &deltadevices;
      traceaddress(r3000write, (U16)(m2_len + 1), tmp_buf);
      tmp_buf += m2_len;
      tmp_buf++;
      deviceparse(r3000write);
      deltadevices.beg[0] = 1;
      envdatamcheck(r3000write, mod, tmp_buf);

      traceaddress(&g[0], 1, tmp_buf);
      g[0].beg[0] = 1;
      tmp_buf++;

      writebytes(r3000write, &g[0], brightnesslimit, mod, mu);
   }
   else
   {
      unassignedvector(validconfig, brightnesslimit);
      envdatamcheck(brightnesslimit, mod, tmp_buf); 

      r3000write = &deltadevices;
      traceaddress(r3000write, (U16)(m2_len + 2), tmp_buf);
      tmp_buf += m2_len + 2;
      r3000write->len = (U16)(mod->len + 1);
      r3000write->beg = r3000write->mem;
      deviceparse(r3000write);
      r3000write->beg[0] = 0x1;
      updatepmull(r3000write, mod);
      blastscache(r3000write);

      traceaddress(&g[0], m2_len, tmp_buf);
      deviceparse(&g[0]);
      tmp_buf += m2_len;
      hotplugpgtable(brightnesslimit, r3000write, &g[0]);
      envdatamcheck(&g[0], mod, tmp_buf); 

      #if (SHARKSSL_BIGINT_EXP_SLIDING_WINDOW_K > 1)
      writebytes(&g[0], &g[0], brightnesslimit, mod, mu);
      m2_len++;
      for (i = 1; i < (1 << (countersvalid - 1)); i++)
      {
         traceaddress(&g[i], m2_len, tmp_buf);
         writebytes(brightnesslimit, &g[i - 1], &g[i], mod, mu);
         tmp_buf += g[i].len;
         tmp_buf++;
      }
      #endif
   }

   
   blastscache(exp);
   for (bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
        bitmask > 0; bitmask >>= 1)
   {
      if (exp->beg[0] & bitmask)
      {
         break;
      }
   }

   if (base2)
   {
      t = &r3000write;
      r = &brightnesslimit;

      for (i = 0; i < exp->len; i++)
      {
         for (; bitmask > 0; bitmask >>= 1)
         {
            
            if (g[0].beg[0] >= ((U32)1 << (SHARKSSL_BIGINT_WORDSIZE / 2)))
            {
               hotplugpgtable(*r, &g[0], *t);
               envdatamcheck(*t, mod, tmp_buf);
               s = r; r = t; t = s;
               g[0].beg[0] = 1;
            }
            else
            {
               g[0].beg[0] *= g[0].beg[0];
            }

            writebytes(*r, *r, *t, mod, mu);
            s = r; r = t; t = s;

            if (exp->beg[i] & bitmask)
            {
               if (g[0].beg[0] & (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1)))
               {
                  hotplugpgtable(*r, &g[0], *t);
                  envdatamcheck(*t, mod, tmp_buf);
                  s = r; r = t; t = s;
                  g[0].beg[0] = 2;
               }
               else
               {
                  g[0].beg[0] <<= 1; 
               }
            }
         }
         bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
      }

      if (g[0].beg[0] != 1)
      {
         hotplugpgtable(*r, &g[0], *t);
         envdatamcheck(*t, mod, tmp_buf);
         s = r; r = t; t = s;
         g[0].beg[0] = 1;
      }
   }
   else
   {
      r = &r3000write;
      t = &brightnesslimit;

      nbits = valbits = 0;
      for (i = 0; i < exp->len; i++)
      {
         for (; bitmask > 0; bitmask >>= 1)
         {
            valbits <<= 1;

            if (exp->beg[i] & bitmask)
            {
               valbits |= 0x1;
            }

            nbits++;
            if ( (nbits == countersvalid) || ((bitmask == 0x1) && (i == (exp->len - 1))) )
            {
               if (valbits > 0)
               {
                  U8 parentoffset = nbits;

                  while (!(valbits & 0x1))
                  {
                     valbits >>= 1;
                     parentoffset--;
                  }

                  nbits -= parentoffset;
                  while (parentoffset)
                  {
                     writebytes(*r, *r, *t, mod, mu);
                     s = r; r = t; t = s;
                     parentoffset--;
                  }

                  writebytes(*r, &g[valbits >> 1], *t, mod, mu);
                  s = r; r = t; t = s;

                  valbits = 0;
               }

               while (nbits)
               {
                  writebytes(*r, *r, *t, mod, mu);
                  s = r; r = t; t = s;
                  nbits--;
               }
            }
         }

         bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
      }

      g[0].len = mod->len;
      deviceparse(&g[0]);
      g[0].beg[g[0].len - 1] = 1;
   }

   writebytes(&g[0], *r, *t, mod, mu);
   r = t;  

   if (*r != r3000write)
   {
      blastscache(*r);
      unassignedvector(*r, res);
   }
   else
   {
      blastscache(r3000write);
      unassignedvector(r3000write, res);
   }

   baFree((void*)tmp_b);
   return 0;
}
#endif  



#if ((SHARKSSL_USE_ECC) || (SHARKSSL_ENABLE_RSAKEY_CREATE && SHARKSSL_ENABLE_RSA))
#if (!SHARKSSL_OPTIMIZED_BIGINT_ASM)
void backlightpdata(shtype_t *o)
{
   shtype_tWord *p, *q;

   p = &o->beg[o->len - 1];
   q = p - 1;

   for (;;)
   {
      *p >>= 1;

      if (p > o->beg)
      {
         if (*q & 0x1)
         {
            *p |= (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
         }
      }
      else
      {
         break;
      }

      p--;
      q--;
   }
}
#endif


void ioswabwdefault(shtype_t *u,   
                               const shtype_t *mod,
                               shtype_tWord *afterhandler)
{
   shtype_t v, A, C;

   traceaddress(&C, (U16)(mod->len + 1), afterhandler);
   deviceparse(&C);
   afterhandler += C.len;

   traceaddress(&v, 0 , afterhandler);
   unassignedvector(mod, &v);

   traceaddress(&A, (U16)(mod->len + 1), afterhandler + mod->len);
   deviceparse(&A);
   A.beg[A.len - 1] = 1;

   while ((u->len > 1) || (u->beg[0] > 0))
   {
      while (cachestride(u))
      {
         backlightpdata(u);
         if (!cachestride(&A))
         {
            resolverelocs(&A, mod);
         }
         backlightpdata(&A);
      }
      while (cachestride(&v))
      {
         backlightpdata(&v);
         if (!cachestride(&C))
         {
            resolverelocs(&C, mod);
         }
         backlightpdata(&C);
      }
      if (timerwrite(u, &v))
      {
         updatepmull(u, &v);
         keypaddevice(&A, &C, mod); 
      }
      else
      {
         updatepmull(&v, u);
         keypaddevice(&C, &A, mod); 
      }
      blastscache(u);
   }
   envdatamcheck(&C, mod, afterhandler);
   blastscache(&C);
   while ((C.len < mod->len) && (C.beg > C.mem))
   {
      C.len++;
      C.beg--;
      baAssert(0 == C.beg[0]);
   }
   unassignedvector(&C, u);
}
#endif  


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
#if SHARKSSL_ENABLE_RSAKEY_CREATE
static void ic0r1dispatch(shtype_t *o)
{
   
   backlightpdata(o);
   o->beg[0] |= ((o->beg[0] << 1) & (shtype_tWord)(1 << (SHARKSSL_BIGINT_WORDSIZE - 1)));
}



static void shtype_t_invmod_buf_even(shtype_t *u,   
                                           const shtype_t *mod,
                                           shtype_tWord *afterhandler)
{
   shtype_t v, A, B, C, D, ucopy, brightnesslimit;

   traceaddress(&ucopy, 0 , afterhandler);
   unassignedvector(u, &ucopy);
   afterhandler += ucopy.len;  

   traceaddress(&C, (U16)(mod->len + 1), afterhandler);
   deviceparse(&C);
   afterhandler += C.len;

   traceaddress(&brightnesslimit, (U16)(mod->len + 1), afterhandler);
   deviceparse(&brightnesslimit);
   afterhandler += brightnesslimit.len;

   traceaddress(&B, (U16)(mod->len + 1), afterhandler);
   deviceparse(&B);
   afterhandler += B.len;

   traceaddress(&D, (U16)(mod->len + 1), afterhandler);
   deviceparse(&D);
   D.beg[D.len - 1] = 1;
   afterhandler += D.len;

   traceaddress(&v, 0 , afterhandler);
   unassignedvector(mod, &v);

   traceaddress(&A, (U16)(mod->len + 1), afterhandler + mod->len);
   deviceparse(&A);
   A.beg[A.len - 1] = 1;

   while ((u->len > 1) || (u->beg[0] > 0))
   {
      while (cachestride(u))
      {
         backlightpdata(u);
         if (!cachestride(&A) || !cachestride(&B))
         {
            resolverelocs(&A, mod);
            updatepmull(&B, &ucopy);
         }
         ic0r1dispatch(&A);
         ic0r1dispatch(&B);
      }
      while (cachestride(&v))
      {
         backlightpdata(&v);
         if (!cachestride(&C) || !cachestride(&D))
         {
            resolverelocs(&C, mod);
            updatepmull(&D, &ucopy);
         }
         ic0r1dispatch(&C);
         ic0r1dispatch(&D);
      }
      if (timerwrite(u, &v))
      {
         updatepmull(u, &v);
         updatepmull(&A, &C); 
         updatepmull(&B, &D); 
      }
      else
      {
         updatepmull(&v, u);
         updatepmull(&C, &A); 
         updatepmull(&D, &B); 
      }
      blastscache(u);
   }
   if (C.beg[0] > 0)  
   {
      resolverelocs(&C, mod);
   }
   blastscache(&C);
   while ((C.len < mod->len) && (C.beg > C.mem))
   {
      C.len++;
      C.beg--;
      baAssert(0 == C.beg[0]);
   }
   unassignedvector(&C, u);
}
#endif  


int iommumapping(shtype_t *o,   
                          const shtype_t *mod)
{
   shtype_tWord *afterhandler;
   U16 flash1resources;

   flash1resources  = mod->len;
   #if (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSAKEY_CREATE)
   if (cachestride(mod))
   {
      flash1resources += flash1resources + (flash1resources << 2);
      flash1resources += o->len;
   }
   else
   #else
   baAssert(!cachestride(mod));
   #endif
   {
      flash1resources += (flash1resources << 1);
   }
   flash1resources += 8;

   #if (SHARKSSL__M > 1)
   flash1resources *= SHARKSSL__M;
   #endif
   afterhandler = (shtype_tWord*)baMalloc(pcmciapdata(flash1resources));
   if (afterhandler == NULL)
   {
      return 1;
   }
   #if (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSAKEY_CREATE)
   if (cachestride(mod))
   {
      shtype_t_invmod_buf_even(o, mod, (shtype_tWord*)selectaudio(afterhandler));
   }
   else
   #endif
   {
      ioswabwdefault(o, mod, (shtype_tWord*)selectaudio(afterhandler));
   }
   #if (SHARKSSL_BIGINT_WORDSIZE == 8)
   while (o->len < mod->len)
   {
      baAssert(o->beg > o->mem);
      o->len++;
      o->beg--;
      baAssert(0 == o->beg[0]);
   }
   #endif
   baFree(afterhandler);
   return 0;
}
#endif


#if (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSAKEY_CREATE)

static U8 irqwakeintmask(shtype_t *o)
{
   static const shtype_tWord one = 1;
   U8 *afterhandler, *p;
   shtype_t N, R, A, Y, M, ONE;
   U16 s, j, t = (U16)(o->len * SHARKSSL__M);
   U8 ret = 0;

   p = afterhandler = (U8*)baMalloc(t * 6);
   if (afterhandler == NULL)
   {
      return (U8)-2;
   }

   onenandpartitions(&ONE, SHARKSSL_BIGINT_WORDSIZE, &one);
   onenandpartitions(&N, (t * 8), p);
   p += t;
   onenandpartitions(&R, (t * 8), p);
   p += t;
   onenandpartitions(&A, (t * 8), p);
   p += t;
   onenandpartitions(&Y, (t * 8), p);
   p += t;
   onenandpartitions(&M, (t * 2 * 8), p);

   unassignedvector(o, &N);
   updatepmull(&N, &ONE);
   unassignedvector(&N, &R);

   s = 0;
   while cachestride(&R)
   {
      backlightpdata(&R);
      s += 1;
   }

   
   t *= 8;  
   if (t >= 1300)
   {
      t = 2;
   }
   else if (t >= 850)
   {
      t = 4;
      if (t >= 850)
      {
         t--;
      }
   }
   else if (t >= 400)
   {
      t = 7;
      if (t >= 550)
      {
         t--;
      }
      if (t >= 450)
      {
         t--;
      }
   }
   else if (t >= 300)
   {
      t = 9;
      if (t >= 350)
      {
         t--;
      }
   }
   else if (t >= 150)
   {
      if (t >= 250)
      {
         t = 12;
      }
      else if (t >= 200)
      {
         t = 15;
      }
      else
      {
         t = 18;
      }
   }
   else
   {
      t = 27;
   }

   while ((t--) && (0 == ret))
   {
      sharkssl_rng((U8*)A.beg, A.len * SHARKSSL__M);
      A.beg[0] |= (1 << (SHARKSSL_BIGINT_WORDSIZE - 2));  
      A.beg[A.len - 1] |= 2;  
      while (timerwrite(&A, &N))
      {
         backlightpdata(&A);
      }
      chunkmutex(&A, &R, o, &Y, 0);
      if (timerwrite(&Y, &N) && timerwrite(&N, &Y))  
      {
         continue;
      }
      if (timerwrite(&Y, &ONE) && timerwrite(&ONE, &Y))  
      {
         continue;
      }
      j = 1;
      while ((j < s) && (!timerwrite(&Y, &N) || !timerwrite(&N, &Y)))
      {
         
         hotplugpgtable(&Y, &Y, &M);
         suspendfinish(&M, o);
         if (timerwrite(&M, &ONE) && timerwrite(&ONE, &M))  
         {
            ret = 1;
            break;
         }
         j++;
      }
      if (!timerwrite(&M, &N) || !timerwrite(&N, &M))  
      {
         ret = 1;
      }
   }

   baFree(afterhandler);
   return ret;
}


static U16 pc104irqmasks(shtype_t *o, U16 div)
{
   int i;
   U32 mod = 0;
   #if   (SHARKSSL_BIGINT_WORDSIZE == 32)
   for (i = 0; i < o->len; i++)
   {
      mod <<= (SHARKSSL_BIGINT_WORDSIZE/2);
      mod |= (o->beg[i] >> (SHARKSSL_BIGINT_WORDSIZE/2));
      mod %= div;
      
      mod <<= (SHARKSSL_BIGINT_WORDSIZE/2);
      mod |= (o->beg[i] & ((1L << (SHARKSSL_BIGINT_WORDSIZE/2)) - 1));
      mod %= div;
   }
   #elif (SHARKSSL_BIGINT_WORDSIZE == 16)
   for (i = 0; i < o->len; i++)
   {
      mod <<= (SHARKSSL_BIGINT_WORDSIZE/2);
      mod |= o->beg[i];
      mod %= div;
   }
   #elif (SHARKSSL_BIGINT_WORDSIZE == 8)
   for (i = 0; i < o->len; )
   {
      mod <<= (SHARKSSL_BIGINT_WORDSIZE/2);
      mod |= (((U16)o->beg[i]) << 8);
      i++;
      if (i < o->len)
      {
         mod |= (((U16)o->beg[i]) << 8);
         i++;
      }
      mod %= div;
   }
   #endif

   baAssert((mod >> 16) == 0);
   return (mod & 0xFFFF);
}


static U8 mcaspresources(shtype_t *o)
{
   static const U16 ethernatshutdown[] =
   {
        3,    5,    7,   11,   13,   17,   19,   23,
       29,   31,   37,   41,   43,   47,   53,   59,
       61,   67,   71,   73,   79,   83,   89,   97,
      101,  103,  107,  109,  113,  127,  131,  137,
      139,  149,  151,  157,  163,  167,  173,  179,
      181,  191,  193,  197,  199,  211,  223,  227,
      229,  233,  239,  241,  251,  257,  263,  269,
      271,  277,  281,  283,  293,  307,  311,  313,
      317,  331,  337,  347,  349,  353,  359,  367,
      373,  379,  383,  389,  397,  401,  409,  419,
      421,  431,  433,  439,  443,  449,  457,  461,
      463,  467,  479,  487,  491,  499,  503,  509,
      521,  523,  541,  547,  557,  563,  569,  571,
      577,  587,  593,  599,  601,  607,  613,  617,
      619,  631,  641,  643,  647,  653,  659,  661,
      673,  677,  683,  691,  701,  709,  719,  727,
      733,  739,  743,  751,  757,  761,  769,  773,
      787,  797,  809,  811,  821,  823,  827,  829,
      839,  853,  857,  859,  863,  877,  881,  883,
      887,  907,  911,  919,  929,  937,  941,  947,
      953,  967,  971,  977,  983,  991,  997, 1009,
     1013, 1019, 1021, 1031, 1033, 1039, 1049,    0 
   };
   const U16 *pciercxcfg006 = &ethernatshutdown[0];
   do
   {
      if (0 == pc104irqmasks(o, *pciercxcfg006))
      {
         return 1;
      }
      
   } while (*(++pciercxcfg006));

   return irqwakeintmask(o);
}



int aemifdevice(shtype_t *o)
{
   static const shtype_tWord two = 2;
   shtype_t TWO;

   if (0 == o->len)
   {
      return -1;
   }

   shtype_t_genPrime_1:
   o->beg = o->mem;
   sharkssl_rng((U8*)o->beg, o->len * SHARKSSL__M);
   o->beg[0] |= (shtype_tWord)(1 << (SHARKSSL_BIGINT_WORDSIZE - 1));  
   o->beg[o->len - 1] |= 1;  
   onenandpartitions(&TWO, SHARKSSL_BIGINT_WORDSIZE, &two);

   while (mcaspresources(o))
   {
      resolverelocs(o, &TWO);
      if (0 == (o->beg[0] & (shtype_tWord)(1 << (SHARKSSL_BIGINT_WORDSIZE - 1))))    
      {
         goto shtype_t_genPrime_1;
      }
   }

   return 0;
}


int translateaddress(const shtype_t *o1,
                       const shtype_t *o2,
                       shtype_t *deltadevices)
{
   U8 *afterhandler, *p;
   shtype_t A;
   #if 0
   U16 n;
   #endif

   p = afterhandler = (U8*)baMalloc(o1->len * SHARKSSL__M);
   if (afterhandler == NULL)
   {
      return -2;
   }

   onenandpartitions(&A, o1->len * SHARKSSL_BIGINT_WORDSIZE, p);

   unassignedvector(o1, &A);
   unassignedvector(o2, deltadevices);

   
   #if 0  
   n = 0;
   while ((0 == (A.beg[A.len - 1] & 0x01)) && (0 == (deltadevices->beg[deltadevices->len - 1] & 0x01)))
   {
      backlightpdata(&A);
      backlightpdata(deltadevices);
      n++;

      blastscache(&A);
      blastscache(deltadevices);

      if (((1 == A.len) && (0 == A.beg[0])) || ((1 == deltadevices->len) && (0 == deltadevices->beg[0])))
      {
         break;
      }
   }
   #endif

   while ((A.len > 1) || (A.beg[0] > 0))  
   {
      while ((0 == (A.beg[A.len - 1] & 0x01)) && ((A.len > 1) || (A.beg[0] > 0)))
      {
         backlightpdata(&A);
         blastscache(&A);
      }
      while ((0 == (deltadevices->beg[deltadevices->len - 1] & 0x01)) && ((deltadevices->len > 1) || (deltadevices->beg[0] > 0)))
      {
         backlightpdata(deltadevices);
         blastscache(deltadevices);
      }
      if (timerwrite(&A, deltadevices))  
      {
         updatepmull(&A, deltadevices);
         backlightpdata(&A);
      }
      else  
      {
         updatepmull(deltadevices, &A);
         backlightpdata(deltadevices);
      }
      blastscache(&A);
   }

   #if 0
   while (n--)
   {
      shtype_t_shiftl(deltadevices);
   }
   #endif
   
   baFree(afterhandler);
   return 0;
}
#endif


#ifndef BA_LIB
#define BA_LIB
#endif

#include <SharkSslEx.h>
#include <string.h>
#include <ctype.h>

#ifndef EXT_SHARK_LIB
#define sharkStrchr strchr
#endif




#include "SharkSslASN1.h"
void
SubjectAltNameEnumerator_constructor(
   SubjectAltNameEnumerator *o, U8 *ptr, U16 len)
{
   baAssert(o);
   baAssert(ptr);
   o->ptr = ptr;
   o->len = len;
}


void
SubjectAltNameEnumerator_getElement(
   SubjectAltNameEnumerator *o, SubjectAltName *s)
{
   if ((o->len) && (SharkSslParseASN1_getContextSpecific(
                       (SharkSslParseASN1*)o, &(s->tag)) == 0))
   {
      baAssert(o->datalen < 0xFFFF);
      s->ptr = o->dataptr;
      s->len = (U16)o->datalen;   
   }
   else
   {
      s->ptr = NULL;
   }
}


int
sharkStrCaseCmp(const char *a, int enableblock, const char *b, int timerinterrupt)
{
   if(enableblock == timerinterrupt)
   {
      register int n=-1;
      while((enableblock) && 
            ((n = tolower((unsigned char)*a) - 
              tolower((unsigned char)*b)) == 0))
      {
         enableblock--;
         a++, b++;
      }
      return n;
   }
   return enableblock - timerinterrupt; 
}


static int
memblockregions(const char* cn, int cnl, const char* gpio1config, int alignresource)
{
   if((cn[0] == '\052') && (cn[1] == '\056') && (cnl > 2)) 
   {
      char* writereg16;
      if( ! sharkStrCaseCmp(cn+2,(cnl-2),gpio1config, alignresource) )
         return 0;
      
      writereg16=sharkStrchr(gpio1config, '\056');
      if(writereg16)
      {
         
         if( ! sharkStrCaseCmp(cn+2,(cnl-2),writereg16+1,alignresource - (int)(writereg16 - gpio1config) -1) )
            return 0;
      }
   }
   return -1;
}



int 
sharkSubjectSubjectAltCmp(const char *cn, U16 registermmcsd1, U8 *programattributes,
                          U16 smemcresume, const char* gpio1config, U16 alignresource)
{
   if(cn && registermmcsd1)
   {
      if( ! sharkStrCaseCmp(cn, registermmcsd1, gpio1config, alignresource) || 
          ! memblockregions(cn, registermmcsd1, gpio1config, alignresource))
      {
         return 0;
      }
   }
   if (programattributes && smemcresume)
   {
      SubjectAltNameEnumerator se;
      SubjectAltName s;
      SubjectAltNameEnumerator_constructor(&se, programattributes, smemcresume);
      for (SubjectAltNameEnumerator_getElement(&se, &s); 
            SubjectAltName_isValid(&s); 
            SubjectAltNameEnumerator_nextElement(&se, &s))
      {
         if (SUBJECTALTNAME_DNSNAME == SubjectAltName_getTag(&s))
         {
            if( ! sharkStrCaseCmp((const char*)SubjectAltName_getPtr(&s),
                                  SubjectAltName_getLen(&s),gpio1config,alignresource) ||
                  ! memblockregions((const char*)SubjectAltName_getPtr(&s),
                                 SubjectAltName_getLen(&s),gpio1config, alignresource) )
            {
               return 0;
            }
            
         }
      }
   }
   return -1;
}

#if SHARKSSL_CHECK_DATE

BaTime sharkParseCertTime(const U8* utc, U8 len)
{
   int i;
   int dt[7];
   if(len > 15) return 0;
   for (i = 0; i < (len >> 1); utc += 2, i++)
   {
      if (!isdigit(*utc)) break;
      dt[i] = 10 * (utc[0] - '\060') + (utc[1] - '\060');
   }
   if(utc[0] == '\132' && (len == 13 || len == 15))
   {
#ifdef ThreadLib_hpp 
      struct BaTm ts;
      BaTimeEx tex;
      memset(&ts,0,sizeof(ts));
      if (len == 13)
      {
         ts.tm_sec =  dt[5];
         ts.tm_min =  dt[4];
         ts.tm_hour = dt[3];
         ts.tm_mday = dt[2]; 
         ts.tm_mon =  dt[1]-1;
         ts.tm_year = dt[0]+2000; 
      }
      else
      {
         ts.tm_sec = dt[6];
         ts.tm_min = dt[5];
         ts.tm_hour = dt[4];
         ts.tm_mday = dt[3];
         ts.tm_mon = dt[2] - 1;
         ts.tm_year = dt[1] + dt[0] * 100;
      }
      if(baTm2TimeEx(&ts, FALSE, &tex))
         return 0; 
      return tex.sec;
#else
      struct tm ts;
      memset(&ts,0,sizeof(ts));
      if (len == 13)
      {
         ts.tm_sec = dt[5];
         ts.tm_min = dt[4];
         ts.tm_hour = dt[3];
         ts.tm_mday = dt[2];
         ts.tm_mon = dt[1] - 1;
         ts.tm_year = dt[0] + 100; 
      }
      else
      {
         ts.tm_sec = dt[6];
         ts.tm_min = dt[5];
         ts.tm_hour = dt[4];
         ts.tm_mday = dt[3];
         ts.tm_mon = dt[2] - 1;
         ts.tm_year = (dt[1] + dt[0] * 100) - 1900;
      }
      return (BaTime)mktime(&ts);
#endif
   }
   return 0; 
}

static SharkSslConTrust
dbdmastart(SharkSslCertInfo* ci)
{
   SharkSslCertInfo* instructioncounter;
   for(instructioncounter = ci ; instructioncounter ; instructioncounter = instructioncounter->parent)
   {
      
      if(instructioncounter->parent || instructioncounter == ci)
      {
         BaTime forcereload = sharkParseCertTime(instructioncounter->timeFrom, instructioncounter->timeFromLen);
         BaTime now = baGetUnixTime();
         BaTime to = sharkParseCertTime(instructioncounter->timeTo, instructioncounter->timeToLen);
         if(forcereload == 0 || to == 0 || forcereload > (now+86400) || to < now)
            return SharkSslConTrust_CertCn;
      }
   }
   return SharkSslConTrust_CertCnDate; 
}
#else
#define dbdmastart(ci) SharkSslConTrust_CertCn
#endif



SHARKSSL_API SharkSslConTrust
SharkSslCon_trusted(SharkSslCon* o, const char* gpio1config, SharkSslCertInfo** cPtr)
{
   if(o) 
   {
      SharkSslCertInfo* ci = SharkSslCon_getCertInfo(o);
      if(cPtr)
      {
         *cPtr = ci;
      }
      if(ci)
      {
         int usbsshwmod = SharkSslCon_trustedCA(o);
         if( !gpio1config )
         {
            return usbsshwmod ? SharkSslConTrust_CertCn : SharkSslConTrust_None;
         }
         if (!sharkSubjectSubjectAltCmp((const char*)ci->subject.commonName,
                                        ci->subject.commonNameLen, 
                                        ci->subjectAltNamesPtr,
                                        ci->subjectAltNamesLen,
                                        gpio1config, (U16)strlen(gpio1config)))
         {
            return usbsshwmod ?
               dbdmastart(ci) : SharkSslConTrust_Cn;
         }
         return usbsshwmod ? SharkSslConTrust_Cert : SharkSslConTrust_None;
      }
      return  SharkSslConTrust_None;
   }
   if(cPtr)
   {
      *cPtr = 0;
   }
   return SharkSslConTrust_NotSSL;
}


#ifndef BA_LIB
#define BA_LIB
#endif

#define _SHARKSSL_C_

#undef  _SHARKSSL_C_
#include <string.h>


#if (SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE)
SHARKSSL_API void SharkSsl_constructor(
   SharkSsl *o,
   SharkSsl_Role startkernel,
   U16 detectbootwidth,
   U16 inBufStartSize,
   U16 outBufSize
)
{
   baAssert(o);
   baAssert(NULL == (void*)0);
   #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_SSL_CLIENT_CODE)
   baAssert((startkernel == SharkSsl_Server) || (startkernel == SharkSsl_Client));
   o->role = startkernel;
   #else 
   #if   SHARKSSL_SSL_SERVER_CODE  
   baAssert(startkernel == SharkSsl_Server);
   #elif SHARKSSL_SSL_CLIENT_CODE  
   baAssert(startkernel == SharkSsl_Client);
   #endif
   (void)startkernel;
   #endif
   o->inBufStartSize = inBufStartSize;
   o->outBufSize = outBufSize;
   o->nCon = 0;  
   #if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
   SingleList_constructor(&o->certList);
   #if SHARKSSL_ENABLE_CA_LIST
   o->caList = 0;
   #endif
   #endif
   #if SHARKSSL_ENABLE_SESSION_CACHE
   counter1clocksource(&o->sessionCache, detectbootwidth);
   o->intf = 0;
   #else
   (void)detectbootwidth;
   #endif
}


SHARKSSL_API void SharkSsl_destructor(SharkSsl *o)
{
   #if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
   SharkSslCertList *link;
   while((link = (SharkSslCertList*)SingleList_removeFirst(&o->certList)) != 0)
   {
      baFree(link);
   }
   #endif
   baAssert(o);
   baAssert(o->nCon == 0);
   #if SHARKSSL_ENABLE_SESSION_CACHE
   if (o->intf)
   {
      o->intf->terminate(o->intf, o);
   }
   defaultsdhci0(&o->sessionCache);
   #endif
   memset(o, 0, sizeof(SharkSsl));
}


SharkSslCon *SharkSsl_createCon(SharkSsl *o)
{
   SharkSslCon *s;
   baAssert(o);
   s = (SharkSslCon*)baMalloc(pcmciapdata(sizeof(SharkSslCon)));
   if (s != NULL)
   {
      #if SHARKSSL_UNALIGNED_MALLOC
      SharkSslCon *su = s;
      s = (SharkSslCon*)selectaudio(s);
      conditionvalid(s, o);
      s->mem = su;
      #else
      conditionvalid(s, o);
      #endif
      o->nCon++;
   }
   return s;
}


void SharkSsl_terminateCon(const SharkSsl *o, SharkSslCon *emulaterd8rn16)
{
   #if SHARKSSL_UNALIGNED_MALLOC
   SharkSslCon *sslConMem = emulaterd8rn16->mem;
   baAssert(sslConMem);
   #endif
   baAssert(emulaterd8rn16);
   baAssert((!o) || (o == emulaterd8rn16->sharkSsl));
   baAssert(emulaterd8rn16->sharkSsl->nCon);
   (void)o;
   emulaterd8rn16->sharkSsl->nCon--;
   localenable(emulaterd8rn16);
   #if SHARKSSL_UNALIGNED_MALLOC
   baFree(sslConMem);
   #else
   baFree(emulaterd8rn16);
   #endif
}


#if SHARKSSL_ENABLE_SESSION_CACHE
U16 SharkSsl_getCacheSize(SharkSsl *o)
{
   baAssert(o);
   return (o->sessionCache.cacheSize);
}
#endif


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
SHARKSSL_API U8 SharkSsl_addCertificate(SharkSsl *o, SharkSslCert kernelvaddr)
{
   SharkSslCertList *c;
   SharkSslCertKey   sourcerouting;
   int modulesemaphore;

   baAssert(o);
   if (0 == o->nCon)
   {
      c = (SharkSslCertList*)baMalloc(sizeof(SharkSslCertList));

      if (c)
      {
         #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
         SharkSslCertInfo cp;
         #endif
         if ((c->certP.msgLen = setupboard(kernelvaddr)) == 0)
         {
            goto _SharkSsl_addCertificate_exit;
         }
         #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
         
         if (spromregister((SharkSslCertParam*)&cp, (U8*)kernelvaddr, (U32)-3, (U8*)&modulesemaphore) < 0)
         {
            goto _SharkSsl_addCertificate_exit;
         }
         #else
         modulesemaphore = spromregister(0, (U8*)kernelvaddr, (U32)-1, 0);
         if (modulesemaphore < 0)
         {
            goto _SharkSsl_addCertificate_exit;
         }
         #endif
         if (0 == interrupthandler(&sourcerouting, kernelvaddr))
         {
            goto _SharkSsl_addCertificate_exit;
         }
         if (machinekexec(sourcerouting.expLen))
         {
            c->certP.keyType = ahashchild;
            c->certP.keyOID  = camerareset(sourcerouting.modLen);
         }
         else if (machinereboot(sourcerouting.expLen))
         {
            c->certP.keyType = compatrestart;
            c->certP.keyOID =  wakeupenable(sourcerouting.modLen);
         }
         else  
         {
            _SharkSsl_addCertificate_exit:
            baFree(c);
            return 0;
         }
         c->certP.cert = kernelvaddr;
         c->certP.signatureAlgo = (modulesemaphore & 0xFF);
         c->certP.hashAlgo = ((modulesemaphore >> 8) & 0xFF);
         #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SNI)
         c->certP.commonName = cp.subject.commonName;
         c->certP.commonNameLen = cp.subject.commonNameLen;
         c->certP.subjectAltNamesPtr = cp.subjectAltNamesPtr;
         c->certP.subjectAltNamesLen = cp.subjectAltNamesLen;
         #endif
         SingleLink_constructor((SingleLink*)c);
         SingleList_insertLast(&o->certList, (SingleList*)c);
         return 1;
      }
   }

   return 0;
}


#if SHARKSSL_ENABLE_CA_LIST
SHARKSSL_API U8 SharkSsl_setCAList(SharkSsl *o, SharkSslCAList displaysetup)
{
   baAssert(o);
   if (0 == o->nCon)
   {
      o->caList = displaysetup;
      return 1;
   }

   return 0;
}
#endif  
#endif  

#endif  


#ifndef BA_LIB
#define BA_LIB
#endif


#define MAX_SHARK_BUF_SIZE 0xFFFF 

#include <HttpSharkSslServCon.h>
#include <HttpServer.h>
#include <HttpTrace.h>
 

#if SHARKSSL_ENABLE_SESSION_CACHE
#include <SharkSslSCMgr.h>
#endif

typedef struct
{
   SharkSslCon super;
   DoubleLink link;
   SoDispCon* con; /* Owner of BaSharkSslCon */
   char* host;
   U16 port;
} BaSharkSslCon;

#ifdef HTTP_TRACE
static void
gpio6resources(int reservevmcore, SoDispCon* con)
{
   char removestate[60]; 
   HttpSockaddr serialports;
   SoDispCon_getPeerName(con,&serialports,0);
   SoDispCon_addr2String(con,
                         &serialports,
                         removestate,
                         sizeof(removestate));
   removestate[59]=0;
   HttpTrace_write(reservevmcore,removestate, -1);
}
#endif

BA_API int
SoDispCon_getSharkAlert(SoDispCon* o, U8* disableerrgen, U8* local1irqdispatch)
{
   if(o->sslData) 
   {
      SharkSslCon *s = (SharkSslCon*)o->sslData;
      *disableerrgen=SharkSslCon_getAlertLevel(s);
      *local1irqdispatch=SharkSslCon_getAlertDescription(s);
      return 0;
   }
   return -1;
}


static int
tsx09parse(SoDispCon* con, int handlersetup)
{
   int x,desc;
   SharkSslCon *s = (SharkSslCon*)con->sslData;

   switch (handlersetup)
   {
      case SharkSslCon_AlertSend: 
      {
         BaBool queueevent=FALSE;
         ThreadMutex* m=0;
         
#ifdef HTTP_TRACE
         gpio6resources(12, con);
         HttpTrace_printf(
            11,
            "\040\123\150\141\162\153\123\123\114\040\072\040\123\145\156\164\040\141\154\145\162\164\040\155\145\163\163\141\147\145\054\040\154\145\166\145\154\040\045\144\054\040\144\145\163\143\162\151\160\164\151\157\156\040\045\144\012",
            SharkSslCon_getAlertLevel(s),
            SharkSslCon_getAlertDescription(s));
#endif
         x = SharkSslCon_getAlertDataLen(s);
         baAssert(x);
         HttpSocket_send(&con->httpSocket, m, &queueevent,
                         SharkSslCon_getAlertData(s),
                         x,
                         &x);
         (void)queueevent;
         return E_SOCKET_WRITE_FAILED; 
      }

      case SharkSslCon_AlertRecv: 
         x=SharkSslCon_getAlertLevel(s);
         desc=SharkSslCon_getAlertDescription(s);
         if(x == 1 && desc == 0) 
            return E_TLS_CLOSE_NOTIFY;
         
#ifdef HTTP_TRACE
         gpio6resources(12, con);
         HttpTrace_printf(
            11,
            "\040\123\150\141\162\153\123\123\114\040\072\040\122\145\143\145\151\166\145\144\040\141\154\145\162\164\054\040\154\145\166\145\154\040\045\144\054\040\144\145\163\143\162\151\160\164\151\157\156\040\045\144\012",
            x,
            desc);
#endif
         return E_SHARK_ALERT_RECV; 

      case SharkSslCon_Error:
#ifdef HTTP_TRACE
         gpio6resources(12, con);
         HttpTrace_printf(
            11,"\040\123\150\141\162\153\123\123\114\072\040\103\162\171\160\164\157\040\146\141\151\154\165\162\145\040\144\165\162\151\156\147\040\145\156\143\162\171\160\164\057\144\145\143\162\171\160\164\040\157\160\145\162\141\164\151\157\156\040"
            "\050\045\144\051\012", debugdestroy(s));
#endif
         return E_TLS_CRYPTOERR;

      case SharkSslCon_AllocationError:
#ifdef HTTP_TRACE
         HttpTrace_printf(
            0,"\123\150\141\162\153\123\123\114\072\040\101\154\154\157\143\040\145\162\162\157\162\040\144\165\162\151\156\147\040\145\156\143\162\171\160\164\057\144\145\143\162\171\160\164\040\157\160\145\162\141\164\151\157\156\012");
#endif
         return E_MALLOC;

      case SharkSslCon_HandshakeNotComplete:
#ifdef HTTP_TRACE
         gpio6resources(5, con);
         HttpTrace_printf(5,"\040\123\150\141\162\153\123\123\114\040\072\040\110\141\156\144\163\150\141\153\145\040\156\157\164\040\143\157\155\160\154\145\164\145\012");
#endif
         return E_TLS_HANDSHAKE;

      default:
         baAssert(0);
         return -1;
   }
}


static int
belowstart(SoDispCon* con, ThreadMutex* m, void* buf, int masterclock)
{
   int sockLen, nb, handlersetup;
   SharkSslCon *s = (SharkSslCon*)con->sslData;
   BaBool queueevent=FALSE;
   sockLen=0;
   for (;;)
   {
      switch (handlersetup = SharkSslCon_decrypt(s, (U16)sockLen))
      {
         case SharkSslCon_NeedMoreData:
            if(con->recTermPtr) 
               return E_SOCKET_READ_FAILED;
            if( ! SoDispCon_socketHasNonBlockData(con) )
            {
               SoDispCon_clearHasMoreData(con);
               if( ! SoDispCon_isNonBlocking(con) )
                  return 0;
            }
            con->recTermPtr=&queueevent;
            sockLen=SoDispCon_platReadData(con,m,&queueevent,
                                           SharkSslCon_getBuf(s),
                                           SharkSslCon_getBufLen(s));
            if(queueevent)
               return E_SOCKET_READ_FAILED;
            con->recTermPtr=0;
            if (sockLen <= 0)
            {
               SoDispCon_clearHasMoreData(con);
               return sockLen;
            }
            break; 

         case SharkSslCon_Decrypted:
            if( ! buf )
               return TRUE; 
            sockLen = SharkSslCon_copyDecData(s, buf, (U16)masterclock);
            if (SharkSslCon_decryptMore(s))
            {
               if ((sockLen == 0) && (masterclock > 0))
               {
                  break; 
               }
            }
            return sockLen;

            

         case SharkSslCon_Handshake:
            if ((nb = SharkSslCon_getHandshakeDataLen(s)) != 0)
            {
               const U8* alloccontroller = SharkSslCon_getHandshakeData(s);
               HttpSocket_send(&con->httpSocket, m, &queueevent, alloccontroller, nb, &sockLen);
               if (nb != sockLen)
               {
                  if ((sockLen < 0) || queueevent || (!SoDispCon_isNonBlocking(con)))
                  {
                     return E_SOCKET_WRITE_FAILED;
                  }
                  baAssert(sockLen < nb);
                  SoDispCon_setBlocking(con);
                  nb -= sockLen;
                  alloccontroller += sockLen;
                  HttpSocket_send(&con->httpSocket, m, &queueevent, alloccontroller, nb, &sockLen);
                  if ((sockLen < 0) || queueevent)
                  {
                     return E_SOCKET_WRITE_FAILED;
                  }
                  SoDispCon_setNonblocking(con);
               }
            }
            nb = SharkSslCon_isHandshakeComplete(s);
            if (nb)
            {
               if (!buf)
               {
                  sockLen = 0;
                  if (nb > 1)  
                  {
                     continue;  
                  }
               }

               if ((!buf) || (!masterclock))
               {
                  return 0;
               }
            }
            sockLen = 0;
            break;

         default:
            return tsx09parse(con, handlersetup);
      }
   }
}


static int
handlerfixup(SoDispCon* con,ThreadMutex* m,void* buf,int masterclock)
{
   int bytes, nb, handlersetup;
   SharkSslCon *s = (SharkSslCon*)con->sslData;
   if(con->sendTermPtr) 
      return E_SOCKET_WRITE_FAILED;
   for (;;)
   {
      switch (handlersetup = SharkSslCon_encrypt(s, buf, (U16)masterclock))
      {
         case SharkSslCon_Encrypted:
         {
            U8* buf = SharkSslCon_getEncData(s);
            BaBool queueevent=FALSE;
            nb = SharkSslCon_getEncDataLen(s);
            con->sendTermPtr=&queueevent;
            HttpSocket_send(&con->httpSocket,m,&queueevent,buf,nb,&bytes);
            if(queueevent)
               return E_SOCKET_WRITE_FAILED;
            con->sendTermPtr=0;
            if(bytes != nb)
            {
               return E_SOCKET_WRITE_FAILED;
            }

            
            if (SharkSslCon_encryptMore(s))
            {
               break;
            }
            return masterclock; 
         }

         default:
            return tsx09parse(con, handlersetup);
      }
   }
}


static int
timerretrigger(SoDispCon* con, int len)
{
   int rebootnotifier, handlersetup;
   U16* enablelevel;
   BaBool queueevent=FALSE;
   ThreadMutex* m=0;

   if( ! SoDispCon_isValid(con) )
      return -1;

   baAssert(len <= SharkSslCon_getEncBufSize(con->sslData));
   rebootnotifier = SharkSslCon_getEncDataLen(con->sslData);
   if ( ! rebootnotifier )
   {
      if (len == 0) 
         return 1;  
      handlersetup = SharkSslCon_encrypt(con->sslData, 0, (U16)len);
      if (handlersetup != SharkSslCon_Encrypted)
         return tsx09parse(con, handlersetup);
      rebootnotifier = SharkSslCon_getEncDataLen(con->sslData);
   }
   enablelevel = &((SharkSslCon*)con->sslData)->outBuf.temp;
   len = rebootnotifier - *enablelevel;
   HttpSocket_send(&con->httpSocket, m, &queueevent,
                   SharkSslCon_getEncData(con->sslData)+*enablelevel, len, &len);
   (void)queueevent;
   if (len < 0 || !SoDispCon_isValid(con))
      return E_SOCKET_WRITE_FAILED; 
   *enablelevel += (U16)len;
   baAssert(*enablelevel <= rebootnotifier);
   if (*enablelevel == rebootnotifier)
   {
      *enablelevel = ((SharkSslCon*)con->sslData)->outBuf.dataLen = 0;
      return 1; 
   }

   return 0; 
}


static int
registersubpacket(
   SoDispCon* con,ThreadMutex* m,SoDispCon_ExType s,void* alloccontroller,int len)
{
   if( ! con->sslData )
   {
      if(s == SoDispCon_GetSharkSslCon)
      {
         if(alloccontroller)
         {
            *((SharkSslCon**)alloccontroller) = 0;
            return FALSE; 
         }
         return TRUE; 
      }
      if(s == SoDispCon_ExTypeMoveCon)
         goto L_ExTypeMoveCon;
      return -1;
   }

   switch(s)
   {
      case SoDispCon_ExTypeRead:
         return belowstart(con, m, alloccontroller, len);

      case SoDispCon_ExTypeWrite:
         if(len > MAX_SHARK_BUF_SIZE)
         {
            U8* ptr=(U8*)alloccontroller;
            int ix=len;
            while(ix)
            {
               int devicelcdspi = ix > MAX_SHARK_BUF_SIZE ? MAX_SHARK_BUF_SIZE : ix;
               int rsp=handlerfixup(con, m, ptr, devicelcdspi);
               if(rsp < 0)
                  return rsp;
               ptr += devicelcdspi;
               ix -= devicelcdspi;
            }
            return len;
         }
         return handlerfixup(con, m, alloccontroller, len);

      case SoDispCon_ExTypeIdle: 
         
         ((SharkSslCon*)con->sslData)->outBuf.dataLen = 0;
         return FALSE; 

      case SoDispCon_GetSharkSslCon:
         if(alloccontroller)
         {
            *((SharkSslCon**)alloccontroller) = (SharkSslCon*)con->sslData;
         }
         return TRUE;

      case SoDispCon_ExTypeClose:
      {
         BaSharkSslCon* bs;
         baAssert(con->sslData);
         bs=(BaSharkSslCon*)con->sslData;
         if( con->sendTermPtr )
         {
            *con->sendTermPtr=TRUE;
            con->sendTermPtr=0;
         }
         if( con->recTermPtr )
         {
            *con->recTermPtr=TRUE;
            con->recTermPtr=0;
         }
         con->sslData=0;
         if(bs->host)
         { 
            SharkSslSCMgr* scMgr =
               (SharkSslSCMgr*)SharkSsl_getIntf(((SharkSslCon*)bs)->sharkSsl);
            if(scMgr && SharkSslCon_isHandshakeComplete((SharkSslCon*)bs))
            {
               if( ! SharkSslSCMgr_get(
                  scMgr, (SharkSslCon*)bs, bs->host, bs->port) )
               {
                  SharkSslSCMgr_save(scMgr,(SharkSslCon*)bs,bs->host,bs->port);
               }
            }
            baFree(bs->host);
            bs->host=0;
         }
         DoubleLink_destructor(&bs->link);
         SharkSslCon_terminate((SharkSslCon*)bs);
         return 0;
      }

      case SoDispCon_ExTypeMoveCon:
      L_ExTypeMoveCon:
         ((SoDispCon*)alloccontroller)->exec = registersubpacket;
         ((SoDispCon*)alloccontroller)->sslData = con->sslData;
         if(con->sslData) 
            ((BaSharkSslCon*)(con->sslData))->con = (SoDispCon*)alloccontroller;
         con->sslData=0;
         return 0;

      case SoDispCon_ExTypeAllocAsynchBuf:
         ((AllocAsynchBufArgs*)alloccontroller)->retVal =
            SharkSslCon_getEncBufPtr(con->sslData);
         ((AllocAsynchBufArgs*)alloccontroller)->size =
            (SharkSslCon_getEncBufSize(con->sslData));
         
         ((SharkSslCon*)con->sslData)->outBuf.dataLen = 0;
         return 0;

      case SoDispCon_ExTypeAsyncReady:
         return timerretrigger(con, len);

      default:
         baAssert(0);
   }
   return 0;
}


#ifndef NO_BA_SERVER
static void
erratumworkaround(HttpSharkSslServCon* o)
{
   int sffsdrnandflash;
   SoDispCon* fdc37m81xconfig = (SoDispCon*)o;
   HttpServer* uarchbuild = HttpConnection_getServer((HttpConnection*)fdc37m81xconfig);
   SoDispCon* boardmanufacturer = (SoDispCon*)HttpServer_getFreeCon(uarchbuild);
   if(boardmanufacturer)
   {
     L_tryAgain:
      HttpSocket_accept(&fdc37m81xconfig->httpSocket, &boardmanufacturer->httpSocket, &sffsdrnandflash);
      if( ! sffsdrnandflash )
      {
         BaSharkSslCon* bs = (BaSharkSslCon*)baMalloc(sizeof(BaSharkSslCon));
         if (bs)
         {
            memset(bs, 0, sizeof(BaSharkSslCon));
            SharkSsl_createCon2(o->sharkSsl,(SharkSslCon*)bs);
            if(o->favorRSA) SharkSslCon_favorRSA((SharkSslCon*)bs, TRUE);
            DoubleLink_constructor(&bs->link);
            DoubleList_insertLast(&o->sharkSslConList, &bs->link);
            boardmanufacturer->sslData = bs;
            bs->con=boardmanufacturer;
            if(SoDispCon_isIP6(fdc37m81xconfig))
               SoDispCon_setIP6(boardmanufacturer);
            boardmanufacturer->exec = registersubpacket;
            HttpConnection_setTCPNoDelay(boardmanufacturer,TRUE);
            HttpServer_installNewCon(uarchbuild, (HttpConnection*)boardmanufacturer);
            SoDispCon_newConnectionIsReady(boardmanufacturer);
            return;
         }
         SoDispCon_destructor(boardmanufacturer);
         HttpServer_returnFreeCon(uarchbuild, (HttpConnection*)boardmanufacturer);
         return;
      }
#ifdef HTTP_TRACE
      SoDispCon_printSockErr(fdc37m81xconfig, "\101\143\143\145\160\164", &fdc37m81xconfig->httpSocket, sffsdrnandflash);
#endif
      if( ! HttpServer_termOldestIdleCon(uarchbuild) )
         goto L_tryAgain;
      HttpServer_returnFreeCon(uarchbuild, (HttpConnection*)boardmanufacturer);
   }
   else
   {  
      SoDispCon con;
      memset(&con, 0, sizeof(SoDispCon));
      SoDispCon_constructor(&con,0,0);
      HttpSocket_accept(&fdc37m81xconfig->httpSocket, &con.httpSocket, &sffsdrnandflash);
      SoDispCon_destructor(&con);
      TRPR(("\123\145\162\166\145\162\040\143\157\156\156\145\143\164\151\157\156\163\040\145\170\150\141\165\163\164\145\144\012"));
   }
   TRPR(("\110\164\164\160\123\145\162\166\103\157\156\072\072\167\145\142\123\145\162\166\145\162\101\143\143\145\160\164\105\166\040\146\141\151\154\145\144\072\045\163\040\045\144\012",
         boardmanufacturer?"":"\040\163\145\162\166\145\162\040\143\157\156\040\145\170\150\141\165\163\164\145\144",sffsdrnandflash));
}
#endif


static void
rangeparser(HttpSharkSslServCon* o)
{
   HttpConnection boardmanufacturer;
   SoDispCon* newSoCon = (SoDispCon*)&boardmanufacturer;
   int sffsdrnandflash;
   HttpConnection* hCon = (HttpConnection*)o; 
   SoDispCon* soCon = (SoDispCon*)o; 
#ifndef NO_BA_SERVER
L_tryAgain:
#endif
   memset(&boardmanufacturer, 0, sizeof(HttpConnection));
   HttpSocket_accept(&soCon->httpSocket, &newSoCon->httpSocket, &sffsdrnandflash);
   if( ! sffsdrnandflash )
   {
      BaSharkSslCon* bs = (BaSharkSslCon*)baMalloc(sizeof(BaSharkSslCon));
      if (bs)
      {
         memset(bs, 0, sizeof(BaSharkSslCon));
         SharkSsl_createCon2(o->sharkSsl,(SharkSslCon*)bs);
         if(o->favorRSA) SharkSslCon_favorRSA((SharkSslCon*)bs, TRUE);
         DoubleLink_constructor(&bs->link);
         DoubleList_insertLast(&o->sharkSslConList, &bs->link);
         if(SoDispCon_isIP6(soCon))
            SoDispCon_setIP6(newSoCon);
         newSoCon->sslData = bs;
         bs->con=newSoCon;
         boardmanufacturer.server = hCon->server;
         newSoCon->exec = registersubpacket;
         newSoCon->dispatcher=soCon->dispatcher;
         ((HttpServCon*)o)->userDefinedAccept((HttpServCon*)o, &boardmanufacturer);
         if( ! HttpSocket_isValid(&newSoCon->httpSocket) )
         { 
            return;  
         }
#ifdef HTTP_TRACE
         HttpTrace_printf(0,"\111\156\166\141\154\151\144\040\155\157\166\145\103\157\156\012");
#endif
         
         
         DoubleLink_unlink(&bs->link);
         SharkSsl_terminateCon(o->sharkSsl, (SharkSslCon*)bs);
      }
      HttpSocket_close(&newSoCon->httpSocket);
   }
#ifndef NO_BA_SERVER
   else
   {
      HttpServer* uarchbuild = HttpConnection_getServer(hCon);
      if( uarchbuild && ! HttpServer_termOldestIdleCon(uarchbuild) )
         goto L_tryAgain;
   }
#endif
}



int
HttpSharkSslServCon_bindExec(
   SoDispCon* con, SharkSsl* ssl, const char* disableswapping, const char* writereg16, int hwmoddeassert)
{
   int rsp;
   ThreadMutex* m=0;
   SharkSslCon* mmcsd0resources;
   if(con->sslData)
      mmcsd0resources = con->sslData;
   else
   {
      baAssert(con->exec != registersubpacket );
      
      mmcsd0resources = (SharkSslCon*)baMalloc(sizeof(BaSharkSslCon));
      if(!mmcsd0resources) return E_MALLOC;
      
      memset(mmcsd0resources, 0, sizeof(BaSharkSslCon));
      SharkSsl_createCon2(ssl, mmcsd0resources);
      DoubleLink_constructor(&((BaSharkSslCon*)mmcsd0resources)->link);
      con->sslData = mmcsd0resources;
      con->exec=registersubpacket;
      m = con->dispatcher ? SoDisp_getMutex(con->dispatcher) : 0;
   }
#if SHARKSSL_ENABLE_SESSION_CACHE
   if(writereg16)
   {
      #if SHARKSSL_ENABLE_SNI
      U8 aLvl, aDsc;
      #endif
      SharkSslSCMgrNode* scn;
      SharkSslSCMgr* scMgr = (SharkSslSCMgr*)SharkSsl_getIntf(ssl);
      if( ! scMgr )
      {
         scMgr = baMalloc(sizeof(SharkSslSCMgr));
         if( ! scMgr )
            return E_MALLOC;
         SharkSslSCMgr_constructor(scMgr,ssl,60*60);
          
         SharkSsl_setIntf(ssl,(SharkSslIntf*)scMgr);
      }
      scn = SharkSslSCMgr_get(scMgr, mmcsd0resources, writereg16, (U16)hwmoddeassert);
#if SHARKSSL_ENABLE_SNI
      SharkSslCon_setSNI(mmcsd0resources, writereg16, (U16)strlen(writereg16)); 
      _skipWarning112:
#endif
      if(disableswapping)
         SharkSslCon_setALPNProtocols(mmcsd0resources, disableswapping);
      if( SoDispCon_isNonBlocking(con) )
      {
         do
         {
            SoDispCon_clearSocketHasNonBlockData(con);
            rsp=belowstart(con, 0, 0, 0);
         } while( ! rsp && SoDispCon_hasMoreData(con) );
      }
      else
      {
         do
         {
            SoDispCon_setDispHasRecData(con);
            rsp=belowstart(con, m, 0, 0);
         } while( ! rsp && ! SharkSslCon_isHandshakeComplete(mmcsd0resources) );
      }
#if SHARKSSL_ENABLE_SNI
      
      if ((rsp == E_SHARK_ALERT_RECV) &&
          (0 == SoDispCon_getSharkAlert(con, &aLvl, &aDsc)) &&
          ((SHARKSSL_ALERT_LEVEL_WARNING == aLvl) &&
           (SHARKSSL_ALERT_UNRECOGNIZED_NAME == aDsc)))
      {
         goto _skipWarning112;
      }
#endif
      if(SharkSslCon_isHandshakeComplete(mmcsd0resources))
      {
         if(!scn && SharkSslSCMgr_save(scMgr, mmcsd0resources, writereg16, (U16)hwmoddeassert))
         { 
            ((BaSharkSslCon*)mmcsd0resources)->host = baMalloc(strlen(writereg16)+1);
            strcpy(((BaSharkSslCon*)mmcsd0resources)->host, writereg16);
            ((BaSharkSslCon*)mmcsd0resources)->port=(U16)hwmoddeassert;
         }
         return 1;
      }
      return rsp;
   }
#endif
   if( SoDispCon_isNonBlocking(con) )
   {
      do
      {
         SoDispCon_clearSocketHasNonBlockData(con);
         rsp=belowstart(con, 0, 0, 0);
      } while( ! rsp && SoDispCon_hasMoreData(con) );
   }
   else
   {
      do
      {
         SoDispCon_setDispHasRecData(con);
         rsp=belowstart(con, m, 0, 0);
      } while( ! rsp && ! SharkSslCon_isHandshakeComplete(mmcsd0resources) );
   }
   if(rsp == 0 && SharkSslCon_isHandshakeComplete(mmcsd0resources))
      return 1;
   return rsp;
}


SHARKSSL_API  void
HttpSharkSslServCon_constructor(HttpSharkSslServCon* o,
                                SharkSsl* resetcounters,
                                struct HttpServer* uarchbuild,
                                struct SoDisp* sha256start,
                                U16 hwmoddeassert,
                                BaBool timercontext,
                                const void* sanitiseouter,
                                HttpServCon_AcceptNewCon emulateeffective)
{
   baAssert(resetcounters->role == SharkSsl_Server);
   if(resetcounters->role != SharkSsl_Server) return;
#ifdef NO_BA_SERVER
   if(!emulateeffective) baFatalE(FE_INCORRECT_USE,0);
   HttpConnection_constructor((HttpConnection*)o,uarchbuild,sha256start,
      (SoDispCon_DispRecEv)rangeparser);
#else
   HttpConnection_constructor( (HttpConnection*)o,uarchbuild,sha256start,
                               (SoDispCon_DispRecEv)
                               (emulateeffective ?
                                rangeparser : 
                                erratumworkaround) );
#endif
   o->sharkSsl=resetcounters;
   o->favorRSA=o->requestClientCert=FALSE;
   DoubleList_constructor(&o->sharkSslConList);
   ((SoDispCon*)o)->exec=registersubpacket;
   ((HttpServCon*)o)->userDefinedAccept=emulateeffective;
   if(!hwmoddeassert || 
      HttpServCon_init((HttpServCon*)o, uarchbuild, hwmoddeassert, timercontext, sanitiseouter))
   {
      return; 
   }
   SoDisp_addConnection(sha256start, (SoDispCon*)o);
   SoDisp_activateRec(sha256start, (SoDispCon*)o);
}


SHARKSSL_API int
HttpSharkSslServCon_setPort(HttpSharkSslServCon* o, U16 setuppcierr,
                            BaBool sama5d2config, const void* sanitiseouter)
{
   HttpSharkSslServCon boardmanufacturer;
   HttpServer* uarchbuild = HttpConnection_getServer((HttpConnection*)o);
   HttpSharkSslServCon_constructor(&boardmanufacturer,
                                   o->sharkSsl,
                                   uarchbuild,
                                   uarchbuild->dispatcher,
                                   setuppcierr,
                                   sama5d2config,
                                   sanitiseouter,
                                   0);
   if(HttpSharkSslServCon_isValid(&boardmanufacturer))
   {
      SoDispCon_closeCon((SoDispCon*)o);
      SoDispCon_moveCon((SoDispCon*)&boardmanufacturer, (SoDispCon*)o);
      SoDisp_addConnection(uarchbuild->dispatcher, (SoDispCon*)o);
      SoDisp_activateRec(uarchbuild->dispatcher, (SoDispCon*)o);
	  return 0;
   }
   return -1;
}

SHARKSSL_API void
HttpSharkSslServCon_destructor(HttpSharkSslServCon* o)
{
   DoubleLink* l;
   while( (l=DoubleList_firstNode(&o->sharkSslConList)) != 0)
   {
      BaSharkSslCon* bs=(BaSharkSslCon*)((U8*)l-offsetof(BaSharkSslCon,link));
      SoDispCon_closeCon(bs->con);
   }
   if(HttpServCon_isValid(o))
      HttpConnection_destructor((HttpConnection*)o);
}


#ifndef BA_LIB
#define BA_LIB
#endif



#include <string.h>


#if ((SHARKSSL_USE_AES_256 || SHARKSSL_USE_AES_128) && (SHARKSSL_ENABLE_AES_GCM))
int offsetkernel(SharkSslCon* o, U8 op, U8 *stackchecker, U16 len)
{
   SharkSslAesGcmCtx *registermcasp;
   #if SHARKSSL_TLS_1_3
   int ret;
   #endif

   baAssert(o);
   baAssert(o->minor >= 2);

   registermcasp = (SharkSslAesGcmCtx*)((op & populatebasepages) ? o->rCtx : o->wCtx);

   if (op & bcm1x80bcm1x55)
   {
      if (op & boardcompat)
      {
         if ((o->rCtx) && (op & populatebasepages))
         {
            SharkSslAesGcmCtx_destructor((SharkSslAesGcmCtx*)selectaudio(o->rCtx));
            baFree(o->rCtx);
            o->rCtx = 0;
         }
         else if ((o->wCtx) && (op & ptraceregsets))
         {
            SharkSslAesGcmCtx_destructor((SharkSslAesGcmCtx*)selectaudio(o->wCtx));
            baFree(o->wCtx);
            o->wCtx = 0;
         }
         return 0;
      }

      else
      {
         baAssert(!registermcasp);
         registermcasp = (SharkSslAesGcmCtx*)baMalloc(pcmciapdata(sizeof(SharkSslAesGcmCtx)));
         if (registermcasp == NULL)
         {
            return -1;  
         }
         if (op & populatebasepages)
         {
            SharkSslAesGcmCtx_constructor((SharkSslAesGcmCtx*)selectaudio(registermcasp), o->rKey, o->rCipherSuite->keyLen);
            o->rCtx = registermcasp;
         }
         else
         {
            SharkSslAesGcmCtx_constructor((SharkSslAesGcmCtx*)selectaudio(registermcasp), o->wKey, o->wCipherSuite->keyLen);
            o->wCtx = registermcasp;
         }
         if (op & SHARKSSL_OP_CONSTRUCTOR_FLAG)
         {
            return 0;
         }
      }
   }

   #if SHARKSSL_TLS_1_3
   #if SHARKSSL_TLS_1_2
   if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
   #endif
   {
      if (op & populatebasepages)
      {
         *(U32*)&o->rIV[4] ^= *(U32*)&o->rSeqNum[0];
         *(U32*)&o->rIV[8] ^= *(U32*)&o->rSeqNum[4];
         baAssert(16 == o->rCipherSuite->digestLen);
         baAssert(len >= 16);
         
         len -= 16;
         ret = SharkSslAesGcmCtx_decrypt((SharkSslAesGcmCtx*)selectaudio(registermcasp), o->rIV, &stackchecker[len], stackchecker - clkctrlmanaged, clkctrlmanaged, stackchecker, stackchecker, len);
         *(U32*)&o->rIV[4] ^= *(U32*)&o->rSeqNum[0];
         *(U32*)&o->rIV[8] ^= *(U32*)&o->rSeqNum[4];
         
         while ((len > 0) && (stackchecker[--len] == 0));
         templateentry(o, stackchecker[len], stackchecker - clkctrlmanaged, len);  
         return ret;
      }

      *(U32*)&o->wIV[4] ^= *(U32*)&o->wSeqNum[0];
      *(U32*)&o->wIV[8] ^= *(U32*)&o->wSeqNum[4];
      baAssert(16 == o->wCipherSuite->digestLen);
      
      stackchecker[len++] = stackchecker[-clkctrlmanaged];  
      #if ((SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH > 0) && (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH <= 0x100))
      baAssert(0 == (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH & (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH - 1)));
      baAssert((sizeof(ret) == 4) || (sizeof(ret) == 8));
      sharkssl_rng((U8*)&ret, sizeof(ret));
      ret = (U16)ret & (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH - 1);
      while (ret--)
      {
         stackchecker[len++] = 0;
      }
      #endif
      templateentry(o, polledbutton, stackchecker - clkctrlmanaged, len + 16);  
      ret = SharkSslAesGcmCtx_encrypt((SharkSslAesGcmCtx*)selectaudio(registermcasp), o->wIV, &stackchecker[len], stackchecker - clkctrlmanaged, clkctrlmanaged, stackchecker, stackchecker, len);
      *(U32*)&o->wIV[4] ^= *(U32*)&o->wSeqNum[0];
      *(U32*)&o->wIV[8] ^= *(U32*)&o->wSeqNum[4];
      return ret;
   }
   #if SHARKSSL_TLS_1_2
   else
   #endif
   #endif
   #if SHARKSSL_TLS_1_2
   {
      if (op & populatebasepages)
      {
         U8 *branchtarget = func3fixup(&o->inBuf);
         memcpy(&o->rIV[4], stackchecker, SHARKSSL_AES_GCM_EXPLICIT_IV_LEN);
         stackchecker += SHARKSSL_AES_GCM_EXPLICIT_IV_LEN ;
         baAssert(16 == o->rCipherSuite->digestLen);
         baAssert(len >= 24);
         len -= (SHARKSSL_AES_GCM_EXPLICIT_IV_LEN + 16);  
         templateentry(o, o->inBuf.data[0], branchtarget, len);
         
         *(U32*)&branchtarget[-8] = *(U32*)&o->rSeqNum[0];
         *(U32*)&branchtarget[-4] = *(U32*)&o->rSeqNum[4];
         return SharkSslAesGcmCtx_decrypt((SharkSslAesGcmCtx*)selectaudio(registermcasp), o->rIV, &stackchecker[len], branchtarget - SHARKSSL_AES_GCM_EXPLICIT_IV_LEN, SHARKSSL_AES_GCM_EXPLICIT_IV_LEN + clkctrlmanaged, stackchecker, stackchecker, len);
      }

      return SharkSslAesGcmCtx_encrypt((SharkSslAesGcmCtx*)selectaudio(registermcasp), o->wIV, &stackchecker[len], stackchecker - (SHARKSSL_AES_GCM_EXPLICIT_IV_LEN + clkctrlmanaged), SHARKSSL_AES_GCM_EXPLICIT_IV_LEN + clkctrlmanaged, stackchecker, stackchecker, len);
   }
   #endif
}
#endif


#if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
int updatecontext(SharkSslCon* o, U8 op, U8 *stackchecker, U16 len)
{
   SharkSslPoly1305Ctx timer8hwmod;
   SharkSslChaChaCtx  *registermcasp;
   U8 unalignedwarning[32];

   baAssert(o);
   baAssert(o->minor >= 2);

   registermcasp = (SharkSslChaChaCtx*)((op & populatebasepages) ? o->rCtx : o->wCtx);

   if (op & bcm1x80bcm1x55)
   {
      if (op & boardcompat)
      {
         if ((o->rCtx) && (op & populatebasepages))
         {
            SharkSslChaChaCtx_destructor((SharkSslChaChaCtx*)selectaudio(o->rCtx));
            baFree(o->rCtx);
            o->rCtx = 0;
         }
         else if ((o->wCtx) && (op & ptraceregsets))
         {
            SharkSslChaChaCtx_destructor((SharkSslChaChaCtx*)selectaudio(o->wCtx));
            baFree(o->wCtx);
            o->wCtx = 0;
         }
         return 0;
      }

      else
      {
         baAssert(!registermcasp);
         registermcasp = (SharkSslChaChaCtx*)baMalloc(pcmciapdata(sizeof(SharkSslChaChaCtx)));
         if (registermcasp == NULL)
         {
            return -1;  
         }
         if (op & populatebasepages)
         {
            SharkSslChaChaCtx_constructor((SharkSslChaChaCtx*)selectaudio(registermcasp), o->rKey, o->rCipherSuite->keyLen);
            o->rCtx = registermcasp;
         }
         else
         {
            SharkSslChaChaCtx_constructor((SharkSslChaChaCtx*)selectaudio(registermcasp), o->wKey, o->wCipherSuite->keyLen);
            o->wCtx = registermcasp;
         }
         if (op & SHARKSSL_OP_CONSTRUCTOR_FLAG)
         {
            return 0;
         }
      }
   }

   if (op & populatebasepages)
   {
      baAssert(16 == o->rCipherSuite->digestLen);
      baAssert(len >= 16);
      len -= 16;  
      *(U32*)&unalignedwarning[0] = *(U32*)&(o->rIV[0]);
      *(U32*)&unalignedwarning[4] = *(U32*)&(o->rIV[4]) ^ *(U32*)&o->rSeqNum[0];
      *(U32*)&unalignedwarning[8] = *(U32*)&(o->rIV[8]) ^ *(U32*)&o->rSeqNum[4];
   }
   else  
   {
      baAssert(16 == o->wCipherSuite->digestLen);
      *(U32*)&unalignedwarning[0] = *(U32*)&(o->wIV[0]);
      *(U32*)&unalignedwarning[4] = *(U32*)&(o->wIV[4]) ^ *(U32*)&o->wSeqNum[0];
      *(U32*)&unalignedwarning[8] = *(U32*)&(o->wIV[8]) ^ *(U32*)&o->wSeqNum[4];
   }

   
   SharkSslChaChaCtx_setIV((SharkSslChaChaCtx*)selectaudio(registermcasp), (const U8*)unalignedwarning);

   *(U32*)&unalignedwarning[0]  = 0;
   *(U32*)&unalignedwarning[4]  = 0;
   *(U32*)&unalignedwarning[8]  = 0;
   *(U32*)&unalignedwarning[12] = 0;
   *(U32*)&unalignedwarning[16] = 0;
   *(U32*)&unalignedwarning[20] = 0;
   *(U32*)&unalignedwarning[24] = 0;
   *(U32*)&unalignedwarning[28] = 0;
   SharkSslChaChaCtx_crypt((SharkSslChaChaCtx*)selectaudio(registermcasp), unalignedwarning, unalignedwarning, 32);
   SharkSslPoly1305Ctx_constructor(&timer8hwmod, unalignedwarning);

   
   *(U32*)&unalignedwarning[0]  = 0;
   *(U32*)&unalignedwarning[4]  = 0;
   *(U32*)&unalignedwarning[8]  = 0;
   *(U32*)&unalignedwarning[12] = 0;

   #if SHARKSSL_TLS_1_3
   #if SHARKSSL_TLS_1_2
   if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
   #endif
   {
      if (op & ptraceregsets)
      {
         U32 ret;
         
         stackchecker[len++] = stackchecker[-clkctrlmanaged];  
         #if ((SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH > 0) && (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH < 0x100))
         baAssert(0 == (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH & (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH - 1)));
         sharkssl_rng((U8*)&ret, sizeof(ret));
         ret &= (SHARKSSL_TLS_1_3_PADDING_MAX_LENGTH - 1);
         while (ret--)
         {
            stackchecker[len++] = 0;
         }
         #endif
         
         templateentry(o, polledbutton, stackchecker - clkctrlmanaged, len + 16);
      }
      SharkSslPoly1305Ctx_append(&timer8hwmod, stackchecker - clkctrlmanaged, clkctrlmanaged);
      SharkSslPoly1305Ctx_append(&timer8hwmod, unalignedwarning, SHARKSSL_POLY1305_HASH_LEN - clkctrlmanaged);
   }
   #if SHARKSSL_TLS_1_2
   else
   #endif
   #endif
   #if SHARKSSL_TLS_1_2
   {
      if (op & populatebasepages)
      {
         templateentry(o, o->inBuf.data[0], func3fixup(&o->inBuf), len);
         SharkSslPoly1305Ctx_append(&timer8hwmod, o->rSeqNum, SHARKSSL_SEQ_NUM_LEN);
         SharkSslPoly1305Ctx_append(&timer8hwmod, func3fixup(&o->inBuf), clkctrlmanaged);
      }
      else
      {
         baAssert(serial2platform(&o->outBuf));
         SharkSslPoly1305Ctx_append(&timer8hwmod, o->wSeqNum, SHARKSSL_SEQ_NUM_LEN);
         SharkSslPoly1305Ctx_append(&timer8hwmod, func3fixup(&o->outBuf), clkctrlmanaged);
      }
      SharkSslPoly1305Ctx_append(&timer8hwmod, unalignedwarning, SHARKSSL_POLY1305_HASH_LEN - SHARKSSL_SEQ_NUM_LEN - clkctrlmanaged);
   }
   #endif

   if (op & ptraceregsets)
   {
      SharkSslChaChaCtx_crypt((SharkSslChaChaCtx*)selectaudio(registermcasp), stackchecker, stackchecker, len);
   }

   SharkSslPoly1305Ctx_append(&timer8hwmod, stackchecker, len);
   baAssert(0 == (SHARKSSL_POLY1305_HASH_LEN & (SHARKSSL_POLY1305_HASH_LEN - 1)));
   SharkSslPoly1305Ctx_append(&timer8hwmod, unalignedwarning, (U8)-((U8)len) & (SHARKSSL_POLY1305_HASH_LEN - 1));  

   #if SHARKSSL_TLS_1_3
   #if SHARKSSL_TLS_1_2
   if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
   #endif
   {
      unalignedwarning[0] = clkctrlmanaged;  
   }
   #if SHARKSSL_TLS_1_2
   else
   #endif
   #endif
   #if SHARKSSL_TLS_1_2
   {
      unalignedwarning[0] = 13;                           
   }
   #endif
   SharkSslPoly1305Ctx_append(&timer8hwmod, &unalignedwarning[0], 8);
   unalignedwarning[0] = (U8)(len & 0xFF); 
   unalignedwarning[1] = (U8)(len >> 8);   
   SharkSslPoly1305Ctx_append(&timer8hwmod, &unalignedwarning[0], 8);

   if (op & populatebasepages)
   {
      SharkSslPoly1305Ctx_finish(&timer8hwmod, &unalignedwarning[0]);
      SharkSslPoly1305Ctx_destructor(&timer8hwmod);

      if (sharkssl_kmemcmp(&stackchecker[len], &unalignedwarning[0], 16))  
      {
         return 1;
      }
      SharkSslChaChaCtx_crypt((SharkSslChaChaCtx*)selectaudio(registermcasp), stackchecker, stackchecker, len);
      #if SHARKSSL_TLS_1_3
      #if SHARKSSL_TLS_1_2
      if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
      #endif
      {
         
         while ((len > 0) && (stackchecker[--len] == 0));
         templateentry(o, stackchecker[len], stackchecker - clkctrlmanaged, len);
      }
      #endif
   }
   else  
   {
      SharkSslPoly1305Ctx_finish(&timer8hwmod, &stackchecker[len]);
      SharkSslPoly1305Ctx_destructor(&timer8hwmod);
   }

   return 0;
}
#endif


#ifndef BA_LIB
#define BA_LIB
#endif



#include <string.h>


#if SHARKSSL_ENABLE_SESSION_CACHE

void counter1clocksource(SharkSslSessionCache *commoncontiguous, U16 detectbootwidth)
{
   U32 flash1resources = detectbootwidth * sizeof(SharkSslSession);
   baAssert(commoncontiguous);
   memset(commoncontiguous, 0, sizeof(SharkSslSessionCache));
   ThreadMutex_constructor(&(commoncontiguous->cacheMutex));
   if (detectbootwidth != 0)
   {
      commoncontiguous->cache = (SharkSslSession*)baMalloc(pcmciapdata(flash1resources));
      if (commoncontiguous->cache != NULL)
      {
         commoncontiguous->cacheSize = detectbootwidth;
         memset(selectaudio(commoncontiguous->cache), 0, flash1resources);
      }
   }
}


void defaultsdhci0(SharkSslSessionCache *commoncontiguous)
{
   baAssert(commoncontiguous);
   if (commoncontiguous->cacheSize != 0)
   {
      #if SHARKSSL_SSL_SERVER_CODE
      U32 uart2hwmod;
      SharkSslSession *func2fixup = (SharkSslSession*)selectaudio(commoncontiguous->cache);
      for (uart2hwmod = commoncontiguous->cacheSize; uart2hwmod > 0; uart2hwmod--, func2fixup++)
      {
         SHARKDBG_PRINTF(("\106\162\145\145\151\156\147\040\163\145\163\163\151\157\156\040\045\060\070\130\057\163\145\163\163\151\157\156\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\040\045\060\070\130\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)func2fixup, (U32)func2fixup->clonedCertInfo, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\103\141\143\150\145\137\144\145\163\164\162\165\143\164\157\162"));
         if (func2fixup->clonedCertInfo)
         {
            SHARKDBG_PRINTF(("\163\145\163\163\151\157\156\050\045\060\070\130\051\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\050\045\060\070\130\051\055\076\162\145\146\143\156\164\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)func2fixup, (U32)func2fixup->clonedCertInfo, func2fixup->clonedCertInfo->refcnt, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\103\141\143\150\145\137\144\145\163\164\162\165\143\164\157\162"));
            #if (!SHARKSSL_ENABLE_CLIENT_AUTH)
            
            baAssert(0 == (func2fixup->clonedCertInfo->refcnt));
            #endif
            baFree((void*)func2fixup->clonedCertInfo);
         }
         if (SharkSslSession_isProtocol(func2fixup, SHARKSSL_PROTOCOL_TLS_1_3) && (func2fixup->prot.tls13.ticket))
         {
            baFree((void*)func2fixup->prot.tls13.ticket);
         }
      }
      #endif
      memset(selectaudio(commoncontiguous->cache), 0, commoncontiguous->cacheSize * sizeof(SharkSslSession));
      baFree(commoncontiguous->cache);
   }
   ThreadMutex_destructor(&commoncontiguous->cacheMutex);
   memset(commoncontiguous, 0, sizeof(SharkSslSessionCache));
}


SharkSslSession *sa1111device(SharkSslSessionCache *commoncontiguous,
                                                 SharkSslCon *o, U8 *id, U16 setupinterface)
{
   SharkSslSession *func2fixup = 0;

   baAssert(o);
   if (commoncontiguous->cacheSize)
   {
      SharkSslSession *oldestSession = 0;
      U32 t, uart2hwmod, now;

      now = (U32)baGetUnixTime();
      t = 0xFFFFFFFF;
      func2fixup = (SharkSslSession*)selectaudio(commoncontiguous->cache);
      filtermatch(commoncontiguous);
      for (uart2hwmod = commoncontiguous->cacheSize; uart2hwmod > 0; uart2hwmod--, func2fixup++)
      {
         if (func2fixup->cipherSuite == 0)
         {
            baAssert(func2fixup->nUse == 0);
            break;
         }
         #if SHARKSSL_TLS_1_2
         #if SHARKSSL_TLS_1_3
         if (SharkSslSession_isProtocol(func2fixup, SHARKSSL_PROTOCOL_TLS_1_2))
         #endif
         {
            if ((func2fixup->prot.tls12.latestAccess < t) && (func2fixup->nUse == 0))
            {
               t = func2fixup->prot.tls12.latestAccess;
               oldestSession = func2fixup;
            }
         }
         #if SHARKSSL_TLS_1_3
         else
         #endif
         #endif
         #if SHARKSSL_TLS_1_3
         {
            if ((func2fixup->prot.tls13.expiration < t) && (func2fixup->nUse == 0))
            {
               t = func2fixup->prot.tls13.expiration;
               oldestSession = func2fixup;
            }
         }
         #endif
      }

      if (uart2hwmod == 0)
      {
         func2fixup = oldestSession;  
      }

      if (func2fixup) 
      {
         uart2hwmod = (U32)(func2fixup - (SharkSslSession*)selectaudio(commoncontiguous->cache));
         if (uart2hwmod < commoncontiguous->cacheSize)
         {
            #if SHARKSSL_SSL_CLIENT_CODE
            #if SHARKSSL_SSL_SERVER_CODE
            if (SharkSsl_isClient(o->sharkSsl))
            #endif
            {
               baAssert(id);
               baAssert(setupinterface);
               baAssert((SharkSslClonedCertInfo*)0 == func2fixup->clonedCertInfo);
               #if SHARKSSL_TLS_1_2
               #if SHARKSSL_TLS_1_3
               if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
               #endif
               {
                  if (setupinterface < SHARKSSL_MAX_SESSION_ID_LEN)
                  {
                     memset(func2fixup->prot.tls12.id, 0, SHARKSSL_MAX_SESSION_ID_LEN);
                  }
                  memcpy(func2fixup->prot.tls12.id, id, setupinterface);
               }
               #if SHARKSSL_TLS_1_3
               else
               #endif
               #endif
               #if SHARKSSL_TLS_1_3
               {
                  if (setupinterface > SHARKSSL_MAX_SESSION_TICKET_LEN)  
                  {
                     func2fixup = 0;  
                  }
                  else
                  {
                     baAssert((hardirqsenabled(func2fixup) != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) || (NULL == func2fixup->prot.tls13.ticket));
                     func2fixup->prot.tls13.ticket = baMalloc(setupinterface);
                     if (NULL == func2fixup->prot.tls13.ticket)
                     {
                        func2fixup = 0;
                     }
                     else
                     {
                        memcpy(func2fixup->prot.tls13.ticket, id, setupinterface);
                        func2fixup->prot.tls13.ticketLen = setupinterface;
                     }
                  }
               }
               #endif
            }
            #if SHARKSSL_SSL_SERVER_CODE
            else  
            #endif
            #endif
            #if SHARKSSL_SSL_SERVER_CODE
            {
               baAssert(0 == id);
               baAssert(0 == setupinterface);
               SHARKDBG_PRINTF(("\123\145\163\163\151\157\156\040\151\156\144\145\170\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", uart2hwmod, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\103\141\143\150\145\137\156\145\167\123\145\163\163\151\157\156"));
               uart2hwmod++;
               uart2hwmod = ~uart2hwmod;
               func2fixup->prot.tls12.id[0] = (U8)(uart2hwmod >> 24);
               func2fixup->prot.tls12.id[1] = (U8)(uart2hwmod >> 16);
               func2fixup->prot.tls12.id[2] = (U8)(uart2hwmod >> 8);
               func2fixup->prot.tls12.id[3] = (U8)(uart2hwmod & 0xFF);
               func2fixup->prot.tls12.id[4] = (U8)(now >> 24);
               func2fixup->prot.tls12.id[5] = (U8)(now >> 16);
               func2fixup->prot.tls12.id[6] = (U8)(now >> 8);
               func2fixup->prot.tls12.id[7] = (U8)(now & 0xFF);
               
               if (func2fixup->clonedCertInfo)
               {
                  func2fixup->clonedCertInfo->refcnt--;  
                  SHARKDBG_PRINTF(("\163\145\163\163\151\157\156\050\045\060\070\130\051\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\050\045\060\070\130\051\055\076\162\145\146\143\156\164\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)func2fixup, (U32)func2fixup->clonedCertInfo, func2fixup->clonedCertInfo->refcnt, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\103\141\143\150\145\137\156\145\167\123\145\163\163\151\157\156"));
                  if (0 == func2fixup->clonedCertInfo->refcnt)
                  {
                     SHARKDBG_PRINTF(("\163\145\163\163\151\157\156\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\040\162\145\154\145\141\163\145\144\054\040\045\163\072\040\045\144\012", __FILE__, __LINE__));
                     baFree((void*)func2fixup->clonedCertInfo);
                  }
                  func2fixup->clonedCertInfo = (SharkSslClonedCertInfo*)0;
               }
               if (sharkssl_rng(&func2fixup->prot.tls12.id[8], SHARKSSL_MAX_SESSION_ID_LEN - 8) < 0)
               {
                  func2fixup = 0;
               }
            }
            #endif

            if (func2fixup)
            {
               func2fixup->nUse = 1;
               func2fixup->flags = 0;
               func2fixup->firstAccess = now;
               sha224final(func2fixup, o->major, o->minor);

               #if SHARKSSL_TLS_1_2
               #if SHARKSSL_TLS_1_3
               if (SharkSslSession_isProtocol(func2fixup, SHARKSSL_PROTOCOL_TLS_1_2))
               #endif
               {
                  func2fixup->cipherSuite = hsParam(o)->cipherSuite;
                  func2fixup->prot.tls12.latestAccess = now;
               }
               #if SHARKSSL_TLS_1_3
               else
               #endif
               #endif
               #if SHARKSSL_TLS_1_3
               {
                  func2fixup->cipherSuite = o->rCipherSuite;  
                  func2fixup->prot.tls13.expiration = now;  
               }
               #endif
            }
         }
         else
         {
            func2fixup = 0;
         }
      }
      else
      {
         SHARKDBG_PRINTF(("\101\154\154\040\163\145\163\163\151\157\156\163\040\151\156\040\165\163\145\054\040\045\163\072\040\045\144\040\050\045\163\051\012", __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\103\141\143\150\145\137\156\145\167\123\145\163\163\151\157\156"));
      }
      helperglobal(commoncontiguous);
   }

   return func2fixup;
}


SharkSslSession *latchgpiochip(SharkSslSessionCache *commoncontiguous,
                                                  SharkSslCon *o, U8 *id, U16 setupinterface)
{
   SharkSslSession *func2fixup = 0;

   baAssert(id);
   baAssert(setupinterface);
   baAssert(commoncontiguous);
   if (commoncontiguous->cacheSize)
   {
      U32 now, uart2hwmod;

      now = (U32)baGetUnixTime();
      filtermatch(commoncontiguous);
      if (SharkSsl_isClient(o->sharkSsl))
      {
         func2fixup = (SharkSslSession*)selectaudio(commoncontiguous->cache);
         uart2hwmod = commoncontiguous->cacheSize - 1;
      }
      #if SHARKSSL_TLS_1_2
      else  
      {
         uart2hwmod = (~(((U32)id[0] << 24) | ((U32)id[1] << 16) | ((U16)id[2] << 8) | id[3])) - 1;
         SHARKDBG_PRINTF(("\123\145\163\163\151\157\156\040\151\156\144\145\170\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", uart2hwmod, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\103\141\143\150\145\137\146\151\156\144\123\145\163\163\151\157\156"));
         if (uart2hwmod < commoncontiguous->cacheSize)
         {
            func2fixup = (SharkSslSession*)((U8*)selectaudio(commoncontiguous->cache) + (uart2hwmod * sizeof(SharkSslSession)));
         }
      }
      #else
      uart2hwmod = 0;  
      #endif
      for (;;)  
      {
         #if SHARKSSL_TLS_1_2
         if ((func2fixup) &&
             (func2fixup->cipherSuite) &&
             (restarthandler(func2fixup, o->major, o->minor)) &&
             (SharkSslSession_isProtocol(func2fixup, SHARKSSL_PROTOCOL_TLS_1_2)) &&
             (0 == sharkssl_kmemcmp(func2fixup->prot.tls12.id, id, setupinterface)) &&
             ((U32)(now - func2fixup->firstAccess) < 21600L ) &&
             (func2fixup->nUse < 0xFFFF))
         {
            func2fixup->nUse++;
            func2fixup->prot.tls12.latestAccess = now;
            #if SHARKSSL_ENABLE_CA_LIST
            if (func2fixup->flags & ecoffaouthdr)
            {
               o->flags |= switcheractivation;
            }
            #endif
            break;
         }
         #if SHARKSSL_TLS_1_3
         else
         #endif
         #endif  
         #if SHARKSSL_TLS_1_3
         if ((func2fixup) &&
            (restarthandler(func2fixup, o->major, o->minor)) &&
            (SharkSslSession_isProtocol(func2fixup, SHARKSSL_PROTOCOL_TLS_1_3)) &&
            (func2fixup->prot.tls13.ticket) &&
            (0 == sharkssl_kmemcmp(func2fixup->prot.tls13.ticket, id, setupinterface)) &&
            (now < func2fixup->prot.tls13.expiration) &&
            (func2fixup->nUse < 0xFFFF))
         {
            func2fixup->nUse++;
            #if SHARKSSL_ENABLE_CA_LIST
            if (func2fixup->flags & ecoffaouthdr)
            {
               o->flags |= switcheractivation;
            }
            #endif
            break;
         }
         #endif  
         else
         {
            if ((SharkSsl_isServer(o->sharkSsl)) || (0 == uart2hwmod))
            {
               func2fixup = 0;
               break;
            }
            else
            {
               uart2hwmod--;
               func2fixup++;
            }
         }
      }
      helperglobal(commoncontiguous);
   }

   return func2fixup;
}
#endif



void atomiccmpxchg(SharkSslBuf *o, U16 icachealiases)
{
   U16 mcasp0device = icachealiases + gpio5config;
   baAssert(o);
   memset(o, 0, sizeof(SharkSslBuf));
   #if SHARKSSL_UNALIGNED_MALLOC
   o->mem = (U8*)baMalloc(pcmciapdata(mcasp0device));
   if (o->mem != NULL)
   {
      o->buf = (U8*)selectaudio(o->mem);
   #else
   baAssert(pcmciapdata(0) == 0);
   o->buf = (U8*)baMalloc(mcasp0device);
   if (o->buf != NULL)
   {
   #endif
      registerfixed(o);
      o->size = icachealiases;
   }
}


void guestconfig5(SharkSslBuf *o)
{
   baAssert(o);
   if (o->buf)
   {
      #if SHARKSSL_UNALIGNED_MALLOC
      memset(o->mem, 0, pcmciapdata(o->size) + gpio5config);
      baFree(o->mem);
      #else
      memset(o->buf, 0, o->size + gpio5config);
      baFree(o->buf);
      #endif
   }
   memset(o, 0, sizeof(SharkSslBuf));
}


void binaryheader(SharkSslBuf *o)
{
   U8 *doublefnmul = o->data;
   registerfixed(o);
   memmove(o->data, doublefnmul, o->dataLen);
}


#if (!SHARKSSL_DISABLE_INBUF_EXPANSION)
U8 *othersegments(SharkSslBuf *o, U16 kprobehandler)
{
   #if (SHARKSSL_UNALIGNED_MALLOC)
   U8 *percpuclockdev;
   #endif
   U8 *anatopenable;
   U16 mcasp0device;

   if (kprobehandler)
   {
      baAssert(o->size < kprobehandler);
      mcasp0device = ((kprobehandler + cachewback - 1) / cachewback) * cachewback;
      baAssert(mcasp0device >= kprobehandler);
   }
   else
   {
      mcasp0device = o->size + cachewback;
   }
   mcasp0device += gpio5config;

   #if (SHARKSSL_UNALIGNED_MALLOC)
   percpuclockdev = o->mem;
   anatopenable = (U8*)baMalloc(pcmciapdata(mcasp0device));
   if (anatopenable != NULL)
   {
      o->mem = anatopenable;
      anatopenable = (U8*)selectaudio(anatopenable);
      memcpy(anatopenable, o->buf, gpio5config + o->size);
   }
   baFree(percpuclockdev);
   #else
   anatopenable = (U8*)baRealloc(o->buf, mcasp0device);
   if (anatopenable == NULL)
   {
      anatopenable = (U8*)baMalloc(mcasp0device);
      if (anatopenable != NULL)
      {
         memcpy(anatopenable, o->buf, gpio5config + o->size);
      }
      baFree(o->buf);
   }
   #endif

   o->buf = anatopenable;
   if (anatopenable)
   {
      registerfixed(o);  
      o->size = (U16)mcasp0device - gpio5config;
   }

   return anatopenable;
}
#endif



void breakpointhandler(SharkSslHSParam *o)
{
   baAssert(o);
   memset(o, 0, sizeof(SharkSslHSParam));
   SharkSslSha256Ctx_constructor(&o->sha256Ctx);
   #if SHARKSSL_USE_SHA_384
   SharkSslSha384Ctx_constructor(&o->sha384Ctx);
   #endif
   #if (SHARKSSL_USE_SHA_512 && SHARKSSL_TLS_1_2)
   SharkSslSha512Ctx_constructor(&o->prot.tls12.sha512Ctx);
   #endif
}


void alignmentldmstm(SharkSslHSParam *o)
{
   baAssert(o);
   memset(o, 0, sizeof(SharkSslHSParam));
}


void ioremapresource(SharkSslHSParam *o, U8 *alloccontroller, U16 len)
{
   baAssert(o);
   baAssert(alloccontroller);
   baAssert(len);
   #if SHARKSSL_TLS_1_3
   #if SHARKSSL_TLS_1_2
   if ((o->cipherSuite) && (o->cipherSuite->flags & SHARKSSL_CS_TLS13))
   #else
   if (o->cipherSuite)
   #endif
   {
      switch (o->cipherSuite->hashID)
      {
         #if SHARKSSL_USE_SHA_256
         case domainnumber:
            SharkSslSha256Ctx_append(&o->sha256Ctx, alloccontroller, len);
            break;
         #endif

         #if SHARKSSL_USE_SHA_384
         case probewrite:
            SharkSslSha384Ctx_append(&o->sha384Ctx, alloccontroller, len);
            break;
         #endif

         default:
            baAssert(0);
            break;
      }
   }
   else  
   #endif
   {
      SharkSslSha256Ctx_append(&o->sha256Ctx, alloccontroller, len);
      #if SHARKSSL_USE_SHA_384
      SharkSslSha384Ctx_append(&o->sha384Ctx, alloccontroller, len);
      #endif
      #if (SHARKSSL_USE_SHA_512 && SHARKSSL_TLS_1_2)
      SharkSslSha512Ctx_append(&o->prot.tls12.sha512Ctx, alloccontroller, len);
      #endif
   }
}


int wakeupvector(SharkSslHSParam *o, U8 *chargerplatform, U8 configwrite)
{
   void *buf;
   baAssert(o);
   baAssert(chargerplatform);
   switch (configwrite)
   {
      #if (SHARKSSL_USE_SHA_512 && SHARKSSL_TLS_1_2)
      case batterythread:
         buf = baMalloc(sizeof(SharkSslSha512Ctx));
         if (!buf)
         {
            return -1;
         }
         memcpy(buf, &o->prot.tls12.sha512Ctx, sizeof(SharkSslSha512Ctx));
         SharkSslSha512Ctx_finish((SharkSslSha512Ctx*)buf, chargerplatform);
         break;
      #endif

      #if SHARKSSL_USE_SHA_384
      case probewrite:
         buf = baMalloc(sizeof(SharkSslSha384Ctx));
         if (!buf)
         {
            return -1;
         }
         memcpy(buf, &o->sha384Ctx, sizeof(SharkSslSha384Ctx));
         SharkSslSha384Ctx_finish((SharkSslSha384Ctx*)buf, chargerplatform);
         break;
      #endif

      #if SHARKSSL_USE_SHA_256
      case domainnumber:
         buf = baMalloc(sizeof(SharkSslSha256Ctx));
         if (!buf)
         {
            return -1;
         }
         memcpy(buf, &o->sha256Ctx, sizeof(SharkSslSha256Ctx));
         SharkSslSha256Ctx_finish((SharkSslSha256Ctx*)buf, chargerplatform);
         break;
      #endif

      default:
         return -1;
   }
   baFree(buf);
   return 0;
}



static void disablelevel(U8 *commonalloc)
{
   memset(commonalloc, 0, SHARKSSL_SEQ_NUM_LEN);
}


static void clusterpowerdown(U8 *commonalloc)
{
   #if 0
   U8 n = SHARKSSL_SEQ_NUM_LEN - 1;

   while ((0 == ++commonalloc[n]) && (n > 0))
   {
      n--;
   }
   #else  
   baAssert(8 == SHARKSSL_SEQ_NUM_LEN);
   U32 seq;

   read64uint32(seq, commonalloc, 4);
   seq++;
   inputlevel(seq, commonalloc, 4);
   if (0 == seq)
   {
      read64uint32(seq, commonalloc, 0);
      seq++;
      inputlevel(seq, commonalloc, 0);
   }
   #endif
}



void conditionvalid(SharkSslCon *o, SharkSsl *resetcounters)
{
   baAssert(o);
   memset(o, 0, sizeof(SharkSslCon));

   o->sharkSsl = resetcounters;
   if (SharkSsl_isClient(resetcounters))
   {
      
      o->flags |= probedaddress;
   }
   else
   {
      baAssert(SharkSsl_isServer(resetcounters));
      
      o->state = pciercxcfg070;
   }
}


static void singleftosi(SharkSslCon *o)
{
   
   if (o->clonedCertInfo)
   {
      #if SHARKSSL_ENABLE_SESSION_CACHE
      
      filtermatch(&o->sharkSsl->sessionCache);
      o->clonedCertInfo->refcnt--;
      SHARKDBG_PRINTF(("\157\050\045\060\070\130\051\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\050\045\060\070\130\051\055\076\162\145\146\143\156\164\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)o, (U32)o->clonedCertInfo, o->clonedCertInfo->refcnt, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\103\157\156\137\146\162\145\145\103\154\157\156\145\144\103\145\162\164\111\156\146\157"));
      if (0 == o->clonedCertInfo->refcnt)
      #endif
      {
         SHARKDBG_PRINTF(("\157\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\040\162\145\154\145\141\163\145\144\054\040\045\163\072\040\045\144\012", __FILE__, __LINE__)); 
         baFree((void*)o->clonedCertInfo);
      }
      #if SHARKSSL_ENABLE_SESSION_CACHE
      helperglobal(&o->sharkSsl->sessionCache);
      #endif
   }
}


void localenable(SharkSslCon *o)
{
   baAssert(o);
   guestconfig5(&o->inBuf);
   guestconfig5(&o->outBuf);
   #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
   guestconfig5(&o->tmpBuf);
   #endif

   if (o->rCipherSuite)
   {
      o->rCipherSuite->cipherFunc(o, chargerworker | populatebasepages, (U8*)0, 0);
   }
   if (o->wCipherSuite)
   {
      o->wCipherSuite->cipherFunc(o, chargerworker | ptraceregsets, (U8*)0, 0);
   }

   #if SHARKSSL_ENABLE_SESSION_CACHE
   if (o->session)
   {
      SharkSslSession *s = o->session;

      
      o->session = 0;
      if ((SharkSsl_isServer(o->sharkSsl)) || (o->flags & gpiolibmbank))
      {
         SharkSslSession_release(s, o->sharkSsl);
      }
   }
   #endif

   singleftosi(o);
   memset(o, 0, sizeof(SharkSslCon));
}


static int breakpointcontrol(U8 regsetcopyin)
{
   return ((regsetcopyin == rangealigned) ||
           (regsetcopyin == firstentry) ||
           (regsetcopyin == controllegacy) ||
           (regsetcopyin == polledbutton));
}

SharkSslCon_RetVal SharkSslCon_decrypt(SharkSslCon *o, U16 pmattrstore)
{
   U8 *registeredevent;
   SharkSslCon_RetVal ret;
   U16 backuppdata, recLenDec, atagsprocfs, consumedBytes;
   U8  regsetcopyin, tvp5146pdata, minor;

   baAssert(o);

   if (o->flags & firstcomponent)
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      resvdexits(o);
      return SharkSslCon_Error;
   }

   if (o->flags & SHARKSSL_FLAG_PARTIAL_HS_SEND)
   {
      o->flags &= ~SHARKSSL_FLAG_PARTIAL_HS_SEND;
      return SharkSslCon_Handshake;
   }

   #if SHARKSSL_SSL_CLIENT_CODE
   #if SHARKSSL_SSL_SERVER_CODE
   if (SharkSsl_isClient(o->sharkSsl))
   #endif
   {
      if (o->flags & probedaddress)
      {
         return configdword(o, 0, 0);
      }

      baAssert(!microresources(&o->inBuf));
   }
   #if SHARKSSL_SSL_SERVER_CODE
   else
   #endif
   #endif  
   #if SHARKSSL_SSL_SERVER_CODE
   {
      if (microresources(&o->inBuf))
      {
         #if (SHARKSSL_ENABLE_RSA || (SHARKSSL_ENABLE_ECDSA))
         SingleListEnumerator e;
         SingleLink *link;
         SingleListEnumerator_constructor(&e, (SingleList*)&o->sharkSsl->certList);
         recLenDec = 0;
         for (link = SingleListEnumerator_getElement(&e);
              link;
              link = SingleListEnumerator_nextElement(&e))
         {
            if (((SharkSslCertList*)link)->certP.msgLen > recLenDec)
            {
               recLenDec = ((SharkSslCertList*)link)->certP.msgLen;
            }
         }
         if (0 == recLenDec)
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return SharkSslCon_CertificateError;
         }
         #else
         recLenDec = 0;
         #endif
         baAssert(!(o->flags & clockgettime32));
         baAssert(!SharkSslCon_isHandshakeComplete(o));
         backuppdata     = o->sharkSsl->inBufStartSize;
         recLenDec += 128 + SHARKSSL_MAX_SESSION_ID_LEN + SHARKSSL_MAX_BLOCK_LEN +
                      SHARKSSL_MAX_DIGEST_LEN + prefetchwrite;
         #if SHARKSSL_ENABLE_DHE_RSA
         
         recLenDec += 1024 + 14;
         #elif SHARKSSL_ENABLE_ECDHE_RSA
         recLenDec += 256;  
         #endif
         recLenDec  = claimresource(recLenDec);
         if (backuppdata < recLenDec)
         {
            backuppdata = recLenDec;
         }

         atomiccmpxchg(&o->inBuf, backuppdata);
         if (microresources(&o->inBuf))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            return SharkSslCon_AllocationError;
         }

         if (microresources(&o->outBuf))
         {
            backuppdata = o->sharkSsl->outBufSize;
            baAssert(backuppdata >= (128 + sizeof(SharkSslHSParam)));
            atomiccmpxchg(&o->outBuf, backuppdata);
            if (microresources(&o->outBuf))
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return SharkSslCon_AllocationError;
            }
         }
      }
   }
   #endif

   

   registeredevent = o->inBuf.data;
   if (o->flags & SHARKSSL_FLAG_FRAGMENTED_HS_RECORD)
   {
      baAssert(o->inBuf.temp);
      registeredevent += o->inBuf.temp;
      
      backuppdata = ((U16)(*registeredevent++)) << 8;
      backuppdata += *registeredevent++;
      o->inBuf.dataLen = backuppdata;
      
      backuppdata = ((U16)(* registeredevent++)) << 8;
      backuppdata += *registeredevent++ - 4;  
      registeredevent += backuppdata;  
   }
   else if (o->flags & clockgettime32)
   {
      if (o->inBuf.temp)
      {
         return SharkSslCon_Decrypted;
      }
      else
      {
         o->flags &= ~clockgettime32;
      }
   }
   o->inBuf.dataLen += pmattrstore;
   atagsprocfs = o->inBuf.dataLen;
   backuppdata = 0;

   _sharkssl_process_another_record:
   if (atagsprocfs < clkctrlmanaged)
   {
      #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SECURE_RENEGOTIATION)
      if (o->flags & registerbuses
          #if SHARKSSL_SSL_CLIENT_CODE
          && (SharkSsl_isServer(o->sharkSsl))
          #endif
         )
      {
         o->flags &= ~registerbuses;
         o->flags |=  skciphersetkey;
         return SharkSslCon_Handshake;
      }
      #endif

      _sharkssl_need_more_data:
      baAssert(o->inBuf.size >= o->inBuf.dataLen);
      backuppdata += clkctrlmanaged; 
      if (!(o->flags & SHARKSSL_FLAG_FRAGMENTED_HS_RECORD))
      {
         
         if (!(serial2platform(&o->inBuf)))
         {
            
            binaryheader(&o->inBuf);
         }

         if (o->inBuf.size < backuppdata)   
         {
            #if (!SHARKSSL_DISABLE_INBUF_EXPANSION)
            if (!othersegments(&o->inBuf, backuppdata))
            #endif
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return SharkSslCon_AllocationError;
            }
         }
      }
      else
      {
         consumedBytes = (U16)(registeredevent - o->inBuf.data);
         
         if (backuppdata > (o->inBuf.size - consumedBytes))
         {
            #if (!SHARKSSL_DISABLE_INBUF_EXPANSION)
            if (!othersegments(&o->inBuf, o->inBuf.size + backuppdata))
            #endif
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               return SharkSslCon_AllocationError;
            }
         }

         
         registeredevent = o->inBuf.data + o->inBuf.temp;
         *registeredevent++ = (U8)(o->inBuf.dataLen >> 8);
         *registeredevent++ = (U8)(o->inBuf.dataLen & 0xFF);
         consumedBytes -= clkctrlmanaged;  
         o->inBuf.dataLen += consumedBytes;
         consumedBytes -= o->inBuf.temp;
         *registeredevent++ = (U8)(consumedBytes >> 8);
         *registeredevent++ = (U8)(consumedBytes & 0xFF);
      }

      return SharkSslCon_NeedMoreData;
   }

   if ((o->major) || (0 == (*registeredevent & 0x80)) || SharkSsl_isClient(o->sharkSsl))
   {
      regsetcopyin = *registeredevent++;
      tvp5146pdata   = *registeredevent++;
      minor   = *registeredevent++;
      backuppdata  = (U16)(*registeredevent++) << 8;
      backuppdata += *registeredevent++;
      atagsprocfs -= clkctrlmanaged;
   }
   else
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      goto _sharkssl_alert_unexpected_message;
   }

   if (!breakpointcontrol(regsetcopyin))
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      _sharkssl_alert_unexpected_message:
      return savedconfig(o, SHARKSSL_ALERT_UNEXPECTED_MESSAGE);
   }

   if ( (backuppdata == 0) || (backuppdata > gpio2enable) ||
        ((o->state != trampolinehandler) && 
         (o->state != pciercxcfg070) && 
         
         ((o->major != tvp5146pdata) || (minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)))
         ) )
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      _sharkssl_alert_illegal_parameter:
      return savedconfig(o, SHARKSSL_ALERT_ILLEGAL_PARAMETER);
   }

   if (atagsprocfs < backuppdata)
   {
      goto _sharkssl_need_more_data;
   }

   recLenDec = backuppdata;

   #if SHARKSSL_TLS_1_3
   if (o->state == SHARKSSL_HANDSHAKETYPE_ENCRYPTED_EXTENSIONS)
   {
      if ((regsetcopyin != rangealigned) && (!(o->rCipherSuite)))
      {
         SharkSslCon_calcHandshakeTrafficSecret(o);  
      }
   }
   #endif

   if (o->rCipherSuite)
   {
      if (backuppdata < o->rCipherSuite->digestLen)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         _sharkssl_alert_bad_record_mac:
         return savedconfig(o, SHARKSSL_ALERT_BAD_RECORD_MAC);
      }

      #if SHARKSSL_TLS_1_2
      #if SHARKSSL_TLS_1_3
      if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
      #endif
      {
         if (0
            #if SHARKSSL_ENABLE_AES_GCM
            || ((o->rCipherSuite->flags & framekernel) && (backuppdata < (SHARKSSL_AES_GCM_EXPLICIT_IV_LEN + o->rCipherSuite->digestLen )))
            #endif
            #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
            || ((o->rCipherSuite->flags & suspendenter) && (backuppdata < o->rCipherSuite->digestLen))
            #endif
            )
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_alert_bad_record_mac;
         }
      }
      #endif  

      
      if (o->rCipherSuite->cipherFunc(o, populatebasepages, registeredevent, backuppdata))
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         
         goto _sharkssl_alert_bad_record_mac;
         
         #if 0  
         resvdexits(o);
         return SharkSslCon_Error;
         #endif
      }

      #if SHARKSSL_TLS_1_3
      #if SHARKSSL_TLS_1_2
      if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
      #endif
      {
         regsetcopyin = registeredevent[0 - clkctrlmanaged];
         if (!breakpointcontrol(regsetcopyin))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_alert_unexpected_message;
         }
         recLenDec = (U16)(registeredevent[3 - clkctrlmanaged]) << 8;
         recLenDec += registeredevent[4 - clkctrlmanaged];
      }
      #if SHARKSSL_TLS_1_2
      else
      #endif
      #endif  
      #if SHARKSSL_TLS_1_2
      {
         #if SHARKSSL_ENABLE_AES_GCM
         if (o->rCipherSuite->flags & framekernel)
         {
            recLenDec -= (SHARKSSL_AES_GCM_EXPLICIT_IV_LEN + o->rCipherSuite->digestLen );
            registeredevent += SHARKSSL_AES_GCM_EXPLICIT_IV_LEN;
         }
         #endif
         #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
         #if SHARKSSL_ENABLE_AES_GCM
         if (o->rCipherSuite->flags & suspendenter)
         #endif
         {
            recLenDec -= o->rCipherSuite->digestLen; 
         }
         #endif
      }
      #endif  

      clusterpowerdown(o->rSeqNum);
      #if SHARKSSL_TLS_1_3
      #if SHARKSSL_TLS_1_2
      if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
      #endif
      {
         o->padLen = (backuppdata - recLenDec);  
      }
      #if SHARKSSL_TLS_1_2
      else
      #endif
      #endif
      #if SHARKSSL_TLS_1_2
      {
         o->padLen = 0; 
      }
      #endif
   }

   consumedBytes = 0;
   switch (regsetcopyin)
   {
      case controllegacy:
         if (o->flags & SHARKSSL_FLAG_FRAGMENTED_HS_RECORD)  
         {
            baAssert(o->inBuf.temp);
            
            memmove(o->inBuf.data + o->inBuf.temp, registeredevent, recLenDec);
            o->flags &= ~SHARKSSL_FLAG_FRAGMENTED_HS_RECORD;
            o->inBuf.temp += recLenDec;
            ret = configdword(o, o->inBuf.data, o->inBuf.temp);
         }
         else
         {
            ret = configdword(o, registeredevent, recLenDec);
            if (o->flags & SHARKSSL_FLAG_FRAGMENTED_HS_RECORD)  
            { 
               if (!(serial2platform(&o->inBuf)))
               {
                  binaryheader(&o->inBuf);
                  registeredevent = o->inBuf.data;
               }
               
               consumedBytes = (U16)(atagsprocfs - o->inBuf.dataLen);
               o->inBuf.temp = recLenDec - consumedBytes;
            }
         }
         _sharkssl_check_if_another_record:
         if (ret == SharkSslCon_Handshake)
         {
            atagsprocfs -= backuppdata;
            o->inBuf.dataLen = atagsprocfs;
            if (atagsprocfs)
            {
               registeredevent += backuppdata - consumedBytes;

               #if ((SHARKSSL_ENABLE_AES_GCM || (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)) && SHARKSSL_TLS_1_2)
               #if SHARKSSL_TLS_1_3
               if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
               #endif
               {
                  if ((o->flags & devicedriver) && (o->rCipherSuite->flags & framekernel))
                  {
                     registeredevent -= SHARKSSL_AES_GCM_EXPLICIT_IV_LEN;
                  }
               }
               #endif

               if (!(o->flags & SHARKSSL_FLAG_FRAGMENTED_HS_RECORD))
               {
                  o->inBuf.data = registeredevent;
               }
               if ((o->state != loongson3notifier) 
                    #if SHARKSSL_TLS_1_3
                    || ((o->flags & devicedriver)
                       #if SHARKSSL_TLS_1_2
                       && (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
                       #endif
                       )
                    #endif
                  )
               {
                  goto _sharkssl_process_another_record;
               }
            }
            else  
            {
               if (o->flags & SHARKSSL_FLAG_FRAGMENTED_HS_RECORD)
               {
                  SHARKDBG_PRINTF(("\111\116\124\105\122\116\101\114\040\105\122\122\117\122\040\055\040\045\163\072\040\045\144\012", __FILE__, __LINE__));
               }
               registerfixed(&o->inBuf);
            }

            #if SHARKSSL_TLS_1_3
            #if SHARKSSL_TLS_1_2
            if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
            #endif
            {
               o->flags &= ~devicedriver;  
            }
            #endif
         }
         break;

      case rangealigned:
         ret = kexecprotect(o, registeredevent, recLenDec);
         goto _sharkssl_check_if_another_record;
         

      case polledbutton:
         if (!SharkSslCon_isHandshakeComplete(o))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_alert_unexpected_message;
         }

         if (recLenDec == 0)
         {
            
            if (o->flags & stealenabled)
            {
               SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
               goto _sharkssl_alert_unexpected_message;
            }
            o->flags |= stealenabled;
         }
         else
         {
            o->flags &= ~stealenabled;
         }

         o->flags |= clockgettime32;
         atagsprocfs -= backuppdata;
         o->inBuf.dataLen = atagsprocfs;
         o->inBuf.data = registeredevent;
         o->inBuf.temp = recLenDec;
         ret = SharkSslCon_Decrypted;
         break;

      default: 
      case firstentry:
         if ((recLenDec < 2) ||
             ((*registeredevent != SHARKSSL_ALERT_LEVEL_WARNING) && (*registeredevent != SHARKSSL_ALERT_LEVEL_FATAL)))
         {
            SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
            goto _sharkssl_alert_illegal_parameter;
         }

         if (*registeredevent != SHARKSSL_ALERT_LEVEL_WARNING)
         {
            fpemureturn(o);
         }

         o->flags |= switcherregister;
         o->alertLevel = *registeredevent++;
         o->alertDescr = *registeredevent++;
         atagsprocfs -= backuppdata;
         o->inBuf.dataLen = atagsprocfs;
         o->inBuf.data = registeredevent;
         ret = SharkSslCon_AlertRecv;
         break;
   }

   return ret;
}


#if SHARKSSL_TLS_1_3

#if SHARKSSL_ENABLE_SESSION_CACHE

#define bgezllabel(s,b,c,o,l,h) brespdisable(s,b,c,o,l,0,h)
static int brespdisable(U8* spi4000check, char* clkdmoperations, U8* context, U8* out, U16 cachemumbojumbo, U8 ptrauthdisable, U8 configwrite)
#else

static int bgezllabel(U8 *spi4000check, char *clkdmoperations, U8 *context, U8 *out, U16 cachemumbojumbo, U8 configwrite)
#endif
{
   #define HKDF_LABEL_MAX_LENGTH 12
   U8 memblocksteal[SHARKSSL_MAX_HASH_LEN + 2 + 1 + 6 + HKDF_LABEL_MAX_LENGTH + 1 + SHARKSSL_MAX_HASH_LEN + 1];  
   U16 ftraceupdate = sharkssl_getHashLen(configwrite);
   U16 loops, HLen;

   HLen = (U16)strlen(clkdmoperations);
   baAssert(HLen <= HKDF_LABEL_MAX_LENGTH);  
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 0] = (U8)(cachemumbojumbo >> 8);
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 1] = (U8)(cachemumbojumbo & 0xFF);
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 2] = (U8)(HLen + 6);
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 3] = '\164';
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 4] = '\154';
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 5] = '\163';
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 6] = '\061';
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 7] = '\063';
   memblocksteal[SHARKSSL_MAX_HASH_LEN + 8] = '\040';
   memcpy(&memblocksteal[SHARKSSL_MAX_HASH_LEN + 9], clkdmoperations, HLen);
   baAssert(ftraceupdate <= 0xFF);
   if (NULL == context)
   {
      memblocksteal[SHARKSSL_MAX_HASH_LEN + 9 + HLen] = 0;
   }
   else
   {
      #if SHARKSSL_ENABLE_SESSION_CACHE
      U8 driverunregister = (ptrauthdisable > 0) ? ptrauthdisable : (U8)ftraceupdate;
      #else
      #define driverunregister ftraceupdate
      #endif
      memblocksteal[SHARKSSL_MAX_HASH_LEN + 9 + HLen] = (U8)driverunregister;
      memcpy(&memblocksteal[SHARKSSL_MAX_HASH_LEN + 10 + HLen], context, driverunregister);
      HLen += driverunregister;
      #ifdef driverunregister
      #undef driverunregister
      #endif
   }
   HLen += 11;
   

   loops = (cachemumbojumbo + ftraceupdate - 1)/ftraceupdate;
   
   memblocksteal[SHARKSSL_MAX_HASH_LEN + HLen - 1] = 0x01;
   sharkssl_HMAC(configwrite, &memblocksteal[SHARKSSL_MAX_HASH_LEN], HLen, spi4000check, ftraceupdate, &memblocksteal[SHARKSSL_MAX_HASH_LEN - ftraceupdate]);
   memcpy(out, &memblocksteal[SHARKSSL_MAX_HASH_LEN - ftraceupdate], cachemumbojumbo);
   #if 1  
   while (--loops)
   {
      out += ftraceupdate;
      cachemumbojumbo -= ftraceupdate;
      memblocksteal[SHARKSSL_MAX_HASH_LEN + HLen - 1]++;
      sharkssl_HMAC(configwrite, &memblocksteal[SHARKSSL_MAX_HASH_LEN - ftraceupdate], ftraceupdate + HLen, spi4000check, ftraceupdate, &memblocksteal[SHARKSSL_MAX_HASH_LEN - ftraceupdate]);
      memcpy(out, &memblocksteal[SHARKSSL_MAX_HASH_LEN - ftraceupdate], (loops == 1) ? cachemumbojumbo : ftraceupdate);
   }
   #endif
   
   return 0;
}


#if SHARKSSL_ENABLE_SESSION_CACHE
int SharkSslCon_calcResumptionSecret(SharkSslCon *o, U8 *chargerplatform)
{
   baAssert(SharkSsl_isClient(o->sharkSsl));
   bgezllabel(o->masterSecret, "\162\145\163\040\155\141\163\164\145\162", chargerplatform, o->resumptionMasterSecret, sharkssl_getHashLen(o->rCipherSuite->hashID), o->rCipherSuite->hashID);
   return 0;
}


int SharkSslCon_calcTicketPSK(SharkSslCon *o, U8 *PSK, U8 *broadcastenter, U8 unmapunlock)
{
   baAssert(SharkSsl_isClient(o->sharkSsl));
   if (0 == unmapunlock)
   {
      broadcastenter = NULL;  
   }
   brespdisable(o->resumptionMasterSecret, "\162\145\163\165\155\160\164\151\157\156", broadcastenter, PSK, sharkssl_getHashLen(o->rCipherSuite->hashID), unmapunlock, o->rCipherSuite->hashID);
   return 0;
}


int SharkSslCon_calcEarlySecret(SharkSslCon* o, U8* PSK, U8 configwrite)
{
   SharkSslHSParam* sharkSslHSParam = hsParam(o);
   U8 t1[SHARKSSL_MAX_HASH_LEN];
   U16 ftraceupdate;

   baAssert(SharkSsl_isClient(o->sharkSsl));
   ftraceupdate = sharkssl_getHashLen(configwrite);
   t1[0] = 0;
   sharkssl_HMAC(configwrite, PSK, ftraceupdate, t1, 1,  o->masterSecret);  
   sharkssl_hash(t1, t1, 0, configwrite);  
   bgezllabel(o->masterSecret, "\162\145\163\040\142\151\156\144\145\162", t1, t1, ftraceupdate, configwrite);  
   bgezllabel(t1, "\146\151\156\151\163\150\145\144", NULL, sharkSslHSParam->prot.tls13.HSSecret, ftraceupdate, configwrite);  
   return 0;
}
#endif  


int SharkSslCon_calcAppTrafficSecret(SharkSslCon *o, U8 *chargerplatform)
{
   SharkSslHSParam* sharkSslHSParam = hsParam(o);
   U8 t1[SHARKSSL_MAX_HASH_LEN], t2[SHARKSSL_MAX_HASH_LEN];
   U16 ftraceupdate;

   baAssert(SharkSsl_isClient(o->sharkSsl));
   o->rCipherSuite->cipherFunc(o, chargerworker | populatebasepages, (U8*)0, 0);
   o->wCipherSuite->cipherFunc(o, chargerworker | ptraceregsets, (U8*)0, 0);
   memset(t2, 0, ftraceupdate = sharkssl_getHashLen(o->rCipherSuite->hashID));
   sharkssl_hash(t1, t1, 0, o->rCipherSuite->hashID);  
   bgezllabel(sharkSslHSParam->prot.tls13.HSSecret, "\144\145\162\151\166\145\144", t1, t1, ftraceupdate, o->rCipherSuite->hashID);  
   sharkssl_HMAC(o->rCipherSuite->hashID, t2, ftraceupdate, t1, ftraceupdate, o->masterSecret);  
   bgezllabel(o->masterSecret, "\163\040\141\160\040\164\162\141\146\146\151\143", chargerplatform, t1, ftraceupdate, o->rCipherSuite->hashID);  
   bgezllabel(o->masterSecret, "\143\040\141\160\040\164\162\141\146\146\151\143", chargerplatform, t2, ftraceupdate, o->wCipherSuite->hashID);  
   bgezllabel(t1, "\153\145\171", NULL, o->rKey, o->rCipherSuite->keyLen, o->rCipherSuite->hashID);  
   bgezllabel(t2, "\153\145\171", NULL, o->wKey, o->wCipherSuite->keyLen, o->wCipherSuite->hashID);  
   
   bgezllabel(t1, "\151\166", NULL, o->rIV, 12, o->rCipherSuite->hashID);  
   bgezllabel(t2, "\151\166", NULL, o->wIV, 12, o->wCipherSuite->hashID);  
   o->rCipherSuite->cipherFunc(o, SHARKSSL_OP_CONSTRUCTOR | populatebasepages, (U8*)0, 0);
   o->wCipherSuite->cipherFunc(o, SHARKSSL_OP_CONSTRUCTOR | ptraceregsets, (U8*)0, 0);
   disablelevel(o->rSeqNum);
   disablelevel(o->wSeqNum);
   return 0;
}


int SharkSslCon_calcHandshakeTrafficSecret(SharkSslCon *o)
{
   SharkSslHSParam* sharkSslHSParam = hsParam(o);
   U8 chargerplatform[SHARKSSL_MAX_HASH_LEN];
   U8 t1[SHARKSSL_MAX_HASH_LEN], t2[SHARKSSL_MAX_HASH_LEN];
   U16 ftraceupdate;

   baAssert(SharkSsl_isClient(o->sharkSsl));
   
   o->rCipherSuite = o->wCipherSuite = sharkSslHSParam->cipherSuite;
   wakeupvector(sharkSslHSParam, &chargerplatform[0], o->rCipherSuite->hashID);
   memset(t1, 0, ftraceupdate = sharkssl_getHashLen(o->rCipherSuite->hashID));
   #if SHARKSSL_ENABLE_SESSION_CACHE
   if (o->flags & startqueue)
   {
      
      memcpy(t2, o->masterSecret, ftraceupdate);
   }
   else
   #endif
   {
      sharkssl_HMAC(o->rCipherSuite->hashID, t1, ftraceupdate, t1, 1, t2);  
   }
   sharkssl_hash(t1, t1, 0, o->rCipherSuite->hashID);  
   bgezllabel(t2, "\144\145\162\151\166\145\144", t1, t2, ftraceupdate, o->rCipherSuite->hashID);  
   sharkssl_HMAC(o->rCipherSuite->hashID, sharkSslHSParam->ecdhParam.k, sharkSslHSParam->ecdhParam.xLen, t2, ftraceupdate, sharkSslHSParam->prot.tls13.HSSecret);  
   bgezllabel(sharkSslHSParam->prot.tls13.HSSecret, "\163\040\150\163\040\164\162\141\146\146\151\143", chargerplatform, sharkSslHSParam->prot.tls13.srvHSTraffic, ftraceupdate, o->rCipherSuite->hashID);  
   bgezllabel(sharkSslHSParam->prot.tls13.HSSecret, "\143\040\150\163\040\164\162\141\146\146\151\143", chargerplatform, sharkSslHSParam->prot.tls13.cliHSTraffic, ftraceupdate, o->rCipherSuite->hashID);  
   bgezllabel(sharkSslHSParam->prot.tls13.srvHSTraffic, "\153\145\171", NULL, o->rKey, o->rCipherSuite->keyLen, o->rCipherSuite->hashID);  
   bgezllabel(sharkSslHSParam->prot.tls13.cliHSTraffic, "\153\145\171", NULL, o->wKey, o->wCipherSuite->keyLen, o->wCipherSuite->hashID);  
   
   bgezllabel(sharkSslHSParam->prot.tls13.srvHSTraffic, "\151\166", NULL, o->rIV, 12, o->rCipherSuite->hashID);  
   bgezllabel(sharkSslHSParam->prot.tls13.cliHSTraffic, "\151\166", NULL, o->wIV, 12, o->wCipherSuite->hashID);  
   o->rCipherSuite->cipherFunc(o, SHARKSSL_OP_CONSTRUCTOR | populatebasepages, (U8*)0, 0);
   o->wCipherSuite->cipherFunc(o, SHARKSSL_OP_CONSTRUCTOR | ptraceregsets, (U8*)0, 0);
   disablelevel(o->rSeqNum);
   disablelevel(o->wSeqNum);
   return 0;
}
#endif  


SharkSslCon_RetVal kexecprotect(SharkSslCon *o,
                                                       U8  *registeredevent,
                                                       U16  atagsprocfs)
{
   #if SHARKSSL_TLS_1_2
   SharkSslHSParam *sharkSslHSParam = hsParam(o);
   #endif

   if (
      #if SHARKSSL_TLS_1_3
         (
         #if SHARKSSL_TLS_1_2
         (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) && 
         #endif
         (o->state != SHARKSSL_HANDSHAKETYPE_ENCRYPTED_EXTENSIONS)
         )
      #if SHARKSSL_TLS_1_2
      ||
      #endif
      #endif
      #if SHARKSSL_TLS_1_2
         (
         #if SHARKSSL_TLS_1_3
         (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) && 
         #endif
         (o->state != switcherdevice)
         )
      #endif
      )
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      return savedconfig(o, SHARKSSL_ALERT_UNEXPECTED_MESSAGE);
   }

   if ((atagsprocfs != 1) || (*registeredevent != 1))
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      return savedconfig(o, SHARKSSL_ALERT_ILLEGAL_PARAMETER);
   }

   o->flags |= cachematch;

   #if SHARKSSL_TLS_1_2
   #if SHARKSSL_TLS_1_3
   if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
   #endif
   {
      #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
      if (o->rCipherSuite)  
      {
         baAssert(o->flags & platformdevice);
         o->rCipherSuite->cipherFunc(o, chargerworker | populatebasepages, (U8*)0, 0);
      }
      #endif
      o->rCipherSuite = sharkSslHSParam->cipherSuite;

      #if SHARKSSL_ENABLE_AES_GCM
      if (o->rCipherSuite->flags & framekernel)
      {
         baAssert(SHARKSSL_MAX_KEY_LEN);
         memcpy(o->rKey,
                sharkSslHSParam->prot.tls12.sharedSecret + (SharkSsl_isClient(o->sharkSsl) ? o->rCipherSuite->keyLen : 0),
                o->rCipherSuite->keyLen);
         memcpy(o->rIV,
                sharkSslHSParam->prot.tls12.sharedSecret + (2 * o->rCipherSuite->keyLen) + (SharkSsl_isClient(o->sharkSsl) ? 4 : 0),
                4);
         memset(&(o->rIV[4]), 0, 8);  
      }
      #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
      else
      #endif
      #endif
      #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
      #if SHARKSSL_ENABLE_AES_GCM
      if (o->rCipherSuite->flags & suspendenter)
      #endif
      {
         baAssert(SHARKSSL_MAX_KEY_LEN);
         memcpy(o->rKey,
                sharkSslHSParam->prot.tls12.sharedSecret + (SharkSsl_isClient(o->sharkSsl) ? o->rCipherSuite->keyLen : 0),
                o->rCipherSuite->keyLen);
         memcpy(o->rIV,
                  sharkSslHSParam->prot.tls12.sharedSecret + (2 * o->rCipherSuite->keyLen) + (SharkSsl_isClient(o->sharkSsl) ? 12 : 0),
                  12);
      }
      #if SHARKSSL_ENABLE_AES_GCM
      else
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
      }
      #endif
      #endif

      
      o->rCipherSuite->cipherFunc(o, SHARKSSL_OP_CONSTRUCTOR | populatebasepages, (U8*)0, 0);
      disablelevel(o->rSeqNum);
   }
   #endif  

   o->inBuf.temp = 0; 
   return SharkSslCon_Handshake;
}


#if SHARKSSL_TLS_1_2
int sanitisependbaser(SharkSslCon *o,
                              SharkSslCon_SendersRole fixupcy82c693,
                              U8 *pciercxcfg448)
{
   U8 *tp, i;
   SharkSslHSParam *sharkSslHSParam = hsParam(o);

   baAssert(serial2platform(&o->outBuf));
   #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
   if (o->wCipherSuite)
   {
      baAssert(o->flags & platformdevice);
      
      tp = templateentry(o, rangealigned, o->outBuf.data, 1);
      *tp++ = 1;
      if (SharkSslCon_calcMACAndEncrypt(o) < 0)
      {
         return -1;
      }
      if (pciercxcfg448 == NULL)
      {
         pciercxcfg448 = func3fixup(&o->inBuf);
         o->inBuf.temp = 0;
      }
      memcpy(pciercxcfg448, o->outBuf.data, o->outBuf.dataLen);
      registerfixed(&o->outBuf);
      o->inBuf.temp += o->outBuf.dataLen;
      pciercxcfg448 += o->outBuf.dataLen;

      o->wCipherSuite->cipherFunc(o, chargerworker | ptraceregsets, (U8*)0, 0);
   }
   #endif
   o->wCipherSuite = sharkSslHSParam->cipherSuite;

   #if SHARKSSL_ENABLE_AES_GCM
   if (o->wCipherSuite->flags & framekernel)
   {
      baAssert(o->minor >= 3);
      baAssert(SHARKSSL_MAX_KEY_LEN);
      memcpy(o->wKey,
             sharkSslHSParam->prot.tls12.sharedSecret + (SharkSsl_isServer(o->sharkSsl) ? o->wCipherSuite->keyLen : 0),
             o->wCipherSuite->keyLen);
      memcpy(o->wIV,
             sharkSslHSParam->prot.tls12.sharedSecret + (2 * o->wCipherSuite->keyLen) + (SharkSsl_isServer(o->sharkSsl) ? 4 : 0),
             4);
      memset(&o->wIV[4], 0, 8);
   }
   #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
   else
   #endif
   #endif
   #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
   #if SHARKSSL_ENABLE_AES_GCM
   if (o->wCipherSuite->flags & suspendenter)
   #endif
   {
      baAssert(SHARKSSL_MAX_KEY_LEN);
      memcpy(o->wKey,
             sharkSslHSParam->prot.tls12.sharedSecret + (SharkSsl_isServer(o->sharkSsl) ? o->wCipherSuite->keyLen : 0),
             o->wCipherSuite->keyLen);
      memcpy(o->wIV,
               sharkSslHSParam->prot.tls12.sharedSecret + (2 * o->wCipherSuite->keyLen) + (SharkSsl_isServer(o->sharkSsl) ? 12 : 0),
               12);
      disablelevel(o->wSeqNum);
   }
   #if SHARKSSL_ENABLE_AES_GCM
   else
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      return savedconfig(o, SHARKSSL_ALERT_INTERNAL_ERROR);
   }
   #endif
   #endif

   o->wCipherSuite->cipherFunc(o, SHARKSSL_OP_CONSTRUCTOR | ptraceregsets, (U8*)0, 0);
   tp = o->outBuf.data;
   i = SHARKSSL_FINISHED_MSG_LEN_TLS_1_2;

   tp = templateentry(o, controllegacy, tp, i + traceentry);
   *tp++ = switcherdevice;
   *tp++ = 0x00;
   *tp++ = 0x00;
   *tp++ = i;

   if (printsilicon(o, fixupcy82c693, tp) < 0)
   {
      return -1;
   }

   #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
   memcpy(SharkSsl_isServer(o->sharkSsl) ? o->serverVerifyData : o->clientVerifyData, tp, i);
   #endif

   
   if (((fixupcy82c693 == rodatastart) && (o->flags & startqueue))
       ||
       ((fixupcy82c693 == tvp5146routes) && (!(o->flags & startqueue))))
   {
      ioremapresource(sharkSslHSParam, tp - traceentry, i + traceentry);
   }

   if (SharkSslCon_calcMACAndEncrypt(o) < 0)
   {
      return -1;
   }

   if (pciercxcfg448 == NULL)  
   {
      baAssert(!(o->flags & createmappings));
      o->flags |= createmappings;
      pciercxcfg448 = o->outBuf.data;
   }

   o->inBuf.temp += o->outBuf.dataLen;
   #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
   if (o->flags & platformdevice)
   {
      
      memcpy(pciercxcfg448, o->outBuf.data, o->outBuf.dataLen);
   }
   else
   #endif
   {
      {
         
         memmove(pciercxcfg448 + clkctrlmanaged + 1, o->outBuf.data, o->outBuf.dataLen);

         
         tp = templateentry(o, rangealigned, pciercxcfg448, 1);
         *tp++ = 1;

         
         baAssert((clkctrlmanaged + 1) == (U16)(tp - pciercxcfg448));
         o->inBuf.temp += (clkctrlmanaged + 1);
      }
   }
   return 0;
}
#endif  


SharkSslCon_RetVal savedconfig(SharkSslCon *o, U8 local1irqdispatch)
{
   fpemureturn(o);
   return securememblock(o, SHARKSSL_ALERT_LEVEL_FATAL, local1irqdispatch);
}


SharkSslCon_RetVal securememblock(SharkSslCon *o,
                                                 U8 disableerrgen,
                                                 U8 local1irqdispatch)
   {
   U8 *tp;

   baAssert(o);

   baAssert((disableerrgen == SHARKSSL_ALERT_LEVEL_WARNING) || (disableerrgen == SHARKSSL_ALERT_LEVEL_FATAL));
   baAssert(
            (local1irqdispatch <= SHARKSSL_ALERT_UNRECOGNIZED_NAME));

   
   if (microresources(&o->outBuf))
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      resvdexits(o);
      return SharkSslCon_Error;
   }

   
   o->inBuf.dataLen = o->inBuf.temp = 0;
   registerfixed(&o->inBuf);

   registerfixed(&o->outBuf);
   tp = templateentry(o, firstentry, o->outBuf.data, 2);

   o->flags |= switcherregister;
   *tp++ = o->alertLevel = disableerrgen;
   *tp++ = o->alertDescr = local1irqdispatch;
   o->outBuf.dataLen = (U16)(tp - o->outBuf.data);
   if (o->wCipherSuite)
   {
      if (SharkSslCon_calcMACAndEncrypt(o) < 0)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         resvdexits(o);
         return SharkSslCon_Error;
      }
   }
   return SharkSslCon_AlertSend;
}


U8 *templateentry(SharkSslCon *o,
                               U8 defaultattrs,
                               U8 *ptr,
                               U16 backuppdata)
{
   *ptr++ = defaultattrs;
   *ptr++ = o->major;
   
   *ptr++ = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);  
   *ptr++ = (U8)(backuppdata >> 8);
   *ptr++ = (U8)(backuppdata & 0xFF);

   return ptr;
}


void fpemureturn(SharkSslCon* o)
{
   baAssert(o);
   baAssert(!(o->flags & firstcomponent));

   o->flags |= firstcomponent;
}


#if SHARKSSL_TLS_1_2
U16 disableclean(SharkSslCipherSuite* c)
{
   U16 hwcapfixup;

   hwcapfixup = c->keyLen;
   #if SHARKSSL_ENABLE_AES_GCM
   if (c->flags & framekernel)
   {
      hwcapfixup += 4;
   }
   else
   #endif
   {
      #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
      if (c->flags & suspendenter)
      {
         hwcapfixup += 12;  
      }
      #endif
   }
   baAssert(hwcapfixup < (U16)0x8000);
   return ((U16)(hwcapfixup << 1));
}


int allocalloc(SharkSslCon* o, U8 *pciercxcfg448, U16 len,
                                U8* s, U16 sLen, U8 r1[32], U8 r2[32])
{
   #if SHARKSSL_CRYPTO_USE_HEAP
   U8* buf;
   #else 
   U8  buf[claimresource(SHARKSSL_MAX_DIGEST_LEN + 13 + 32 + 32)];
   #endif
   U8* p;
   int offsetarray = -1;
   U16 ftraceupdate;
   U8  configwrite, n;

   baAssert(o && pciercxcfg448 && len && sLen && s && r1 && r2);
   baAssert(pcmciaplatform(pciercxcfg448));
   baAssert((len & 0x03) == 0);

   #if SHARKSSL_CRYPTO_USE_HEAP
   buf = (U8*)baMalloc(claimresource(SHARKSSL_MAX_DIGEST_LEN + 13 + 32 + 32));
   baAssert(buf);
   if (!buf)
   {
      return offsetarray;
   }
   #endif
   configwrite = hsParam(o)->cipherSuite->hashID;
   ftraceupdate = sharkssl_getHashLen(configwrite);
   n = (U8)((len + (ftraceupdate - 1)) / ftraceupdate);
   baAssert(n > 0);

   p = &buf[ftraceupdate];
   memcpy(p, (pciercxcfg448 == hsParam(o)->prot.tls12.masterSecret) ? "\155\141\163\164\145\162\040\163\145\143\162\145\164" : "\153\145\171\040\145\170\160\141\156\163\151\157\156", 13);
   memcpy(p + 13, r1, 32);
   memcpy(p + 13 + 32, r2, 32);

   if (sharkssl_HMAC(configwrite, p, 13 + 32 + 32, s, sLen, buf) < 0)
   {
      goto _SharkSslCon_calcCryptoParam_exit;
   }
             
   for (; ; pciercxcfg448 += ftraceupdate)
   {
      if (sharkssl_HMAC(configwrite, buf, ftraceupdate + 13 + 32 + 32, s, sLen, pciercxcfg448) < 0)
      {
         goto _SharkSslCon_calcCryptoParam_exit;
      }

      if (--n == 0)
      {
         break;
      }

      if (sharkssl_HMAC(configwrite, buf, ftraceupdate, s, sLen, buf) < 0)
      {
         goto _SharkSslCon_calcCryptoParam_exit;
      }
   }
   offsetarray = 0;
   _SharkSslCon_calcCryptoParam_exit:
   #if SHARKSSL_CRYPTO_USE_HEAP
   baFree(buf);
   #endif
   return offsetarray;
}
#endif  


int printsilicon(SharkSslCon *o, SharkSslCon_SendersRole fixupcy82c693, U8 *chargerplatform)
{
   #if SHARKSSL_TLS_1_2
   int offsetarray = -1;
   #endif
   U16 ftraceupdate;
   U8  configwrite;

   configwrite = hsParam(o)->cipherSuite->hashID;
   ftraceupdate = sharkssl_getHashLen(configwrite);
   
   #if SHARKSSL_TLS_1_3
   #if SHARKSSL_TLS_1_2
   if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
   #endif
   {
      U8 buf[SHARKSSL_MAX_HASH_LEN];
      bgezllabel((fixupcy82c693 == tvp5146routes) ? hsParam(o)->prot.tls13.cliHSTraffic : hsParam(o)->prot.tls13.srvHSTraffic, "\146\151\156\151\163\150\145\144", NULL, buf, ftraceupdate, configwrite);
      wakeupvector(hsParam(o), chargerplatform, configwrite);
      if (sharkssl_HMAC(configwrite, chargerplatform, ftraceupdate, buf, ftraceupdate, chargerplatform) < 0)
      {
         return -1;
      }
      return 0;
   }
   #if SHARKSSL_TLS_1_2
   else
   #endif
   #endif  
   #if SHARKSSL_TLS_1_2
   {
      U8  *buf;
      buf = (U8*)baMalloc((ftraceupdate << 1) + 16 );
      if (buf)
      {
         memcpy(&buf[ftraceupdate], (fixupcy82c693 == tvp5146routes) ? "\143\154\151\145\156\164\040\146\151\156\151\163\150\145\144" : "\163\145\162\166\145\162\040\146\151\156\151\163\150\145\144", 15);
         wakeupvector(hsParam(o), &buf[ftraceupdate + 15], configwrite);
         if (sharkssl_HMAC(configwrite, &buf[ftraceupdate], 15 + ftraceupdate, hsParam(o)->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN, buf) < 0)
         {
            goto _SharkSslCon_calcFinishedHash_exit;
         }
         if (sharkssl_HMAC(configwrite, buf, (U16)(ftraceupdate << 1) + 15 , hsParam(o)->prot.tls12.masterSecret, SHARKSSL_MASTER_SECRET_LEN, buf) < 0)
         {
            goto _SharkSslCon_calcFinishedHash_exit;
         }
         memcpy(chargerplatform, buf, 12);
         offsetarray = 0;
         _SharkSslCon_calcFinishedHash_exit:
         baFree(buf);
      }
   }
   return offsetarray;
   #endif
}


#if SHARKSSL_TLS_1_3

int SharkSslCon_calcMACAndEncryptHS(SharkSslCon *o)
{
   U8 *p;
   U16 fastforwardsingle;

   baAssert(o->rCipherSuite);
   baAssert(o->rCipherSuite->flags & (framekernel | suspendenter));
   
   p = o->inBuf.data;
   fastforwardsingle = (U16)(((U16)(*(p + 3)) << 8) + *(p + 4));
   p += clkctrlmanaged;
   if (o->wCipherSuite->cipherFunc(o, ptraceregsets, p, fastforwardsingle))
   {
      return -1;
   }
   
   fastforwardsingle = (U16)(((U16)(*(p - 2)) << 8) + *(p - 1));
   o->inBuf.temp = clkctrlmanaged + fastforwardsingle;
   baAssert(o->inBuf.size >= o->inBuf.temp);
   return 0;
}
#endif  



int SharkSslCon_calcMACAndEncrypt(SharkSslCon *o)
{
   U8 *p;
   U16 fastforwardsingle;
   #if (SHARKSSL_TLS_1_2 && SHARKSSL_ENABLE_AES_GCM)
   U8 guestconfig4 = *(o->outBuf.data);
   #endif

   baAssert(SHARKSSL_ENABLE_AES_GCM || (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305));
   baAssert(serial2platform(&o->outBuf));
   baAssert(o->wCipherSuite);
   baAssert(o->wCipherSuite->flags & (framekernel | suspendenter));

   p = o->outBuf.data;
   fastforwardsingle = (U16)(((U16)(*(p + 3)) << 8) + *(p + 4));

   #if (SHARKSSL_TLS_1_2 && SHARKSSL_ENABLE_AES_GCM)
   #if SHARKSSL_TLS_1_3
   if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
   #endif
   
   {
      if (o->wCipherSuite->flags & framekernel)
      {
         memcpy(p - SHARKSSL_AES_GCM_EXPLICIT_IV_LEN, &o->wIV[4], SHARKSSL_AES_GCM_EXPLICIT_IV_LEN);
      }
   }
   #endif

   p += clkctrlmanaged;
   if (o->wCipherSuite->cipherFunc(o, ptraceregsets, p, fastforwardsingle))
   {
      return -1;
   }

   #if SHARKSSL_TLS_1_3
   #if SHARKSSL_TLS_1_2
   if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3))
   #endif
   {
      clusterpowerdown(o->wSeqNum);
      fastforwardsingle = (U16)(((U16)(*(p - 2)) << 8) + *(p - 1));
   }
   #if SHARKSSL_TLS_1_2
   else
   #endif
   #endif
   #if SHARKSSL_TLS_1_2
   {
      #if (SHARKSSL_USE_CHACHA20 && SHARKSSL_USE_POLY1305)
      if (o->wCipherSuite->flags & suspendenter)
      {
         baAssert(16 == o->wCipherSuite->digestLen);
         clusterpowerdown(o->wSeqNum);
         fastforwardsingle += 16;  
         *(p + 3 - clkctrlmanaged) = (U8)(fastforwardsingle >> 8);
         *(p + 4 - clkctrlmanaged) = (U8)(fastforwardsingle & 0xFF);
      }
      #if SHARKSSL_ENABLE_AES_GCM
      else
      #endif
      #endif
      #if SHARKSSL_ENABLE_AES_GCM
      if (o->wCipherSuite->flags & framekernel)
      {
         memcpy(p - SHARKSSL_AES_GCM_EXPLICIT_IV_LEN, &o->wIV[4], SHARKSSL_AES_GCM_EXPLICIT_IV_LEN);
         clusterpowerdown(&o->wIV[4]);
         fastforwardsingle += o->wCipherSuite->digestLen + SHARKSSL_AES_GCM_EXPLICIT_IV_LEN;  
         o->outBuf.data = (p - clkctrlmanaged - SHARKSSL_AES_GCM_EXPLICIT_IV_LEN);
         templateentry(o, guestconfig4, o->outBuf.data, fastforwardsingle);
      }
      #endif
   }
   #endif  

   o->outBuf.dataLen = clkctrlmanaged + fastforwardsingle;

   baAssert(o->outBuf.size >= o->outBuf.dataLen);
   return 0;
}


SHARKSSL_API U16 SharkSslCon_getDecData(SharkSslCon *o, U8 **ptregdefines)
{
   U16 guestdebug;
   baAssert(o);
   baAssert(ptregdefines);
   baAssert(!(o->flags & firstcomponent));

   *ptregdefines = o->inBuf.data;
   guestdebug = o->inBuf.temp;
   o->inBuf.data += guestdebug;
   o->inBuf.temp = 0;

   if (o->inBuf.dataLen) 
   {
      o->inBuf.data += o->padLen;
      #if SHARKSSL_TLS_1_2
      #if SHARKSSL_TLS_1_3
      if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
      #endif
      {
         o->inBuf.data += o->rCipherSuite->digestLen;
      }
      #endif
      o->padLen = 0;
   }
   else
   {
      o->flags &= ~clockgettime32;
      registerfixed(&o->inBuf);
   }

   return guestdebug;
}


U16 SharkSslCon_copyDecData(SharkSslCon *o, U8 *buf, U16 masterclock)
{
   baAssert(o);
   baAssert(buf);
   baAssert(!(o->flags & firstcomponent));

   if (o->inBuf.temp < masterclock)
   {
      masterclock = o->inBuf.temp;
   }
   memcpy(buf, o->inBuf.data, masterclock);
   o->inBuf.data += masterclock;
   o->inBuf.temp -= masterclock;

   if (0 == o->inBuf.temp)
   {
      if (o->inBuf.dataLen) 
      {
         o->inBuf.data += o->padLen;
         #if SHARKSSL_TLS_1_2
         #if SHARKSSL_TLS_1_3
         if (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
         #endif
         {
            o->inBuf.data += o->rCipherSuite->digestLen;
         }
         #endif
         o->padLen = 0;
      }
      else
      {
         o->flags &= ~clockgettime32;
         registerfixed(&o->inBuf);
      }
   }

   return masterclock;
}


U8 *SharkSslCon_getBuf(SharkSslCon *o)
{
   baAssert(o);
   baAssert(o->inBuf.data);
   return (o->inBuf.data + o->inBuf.dataLen);
}


U16 SharkSslCon_getBufLen(SharkSslCon *o)
{
   baAssert(o);
   return (o->inBuf.size - o->inBuf.dataLen);
}


U8 SharkSslCon_decryptMore(SharkSslCon *o)
{
   baAssert(o);
   return ((o->flags & clockgettime32) ? 1 : 0);
}


U8 SharkSslCon_encryptMore(SharkSslCon *o)
{
   baAssert(o);
   return ((o->flags & audiosuspend) ? 1 : 0);
}


U16 SharkSslCon_getHandshakeDataLen(SharkSslCon *o)
{
   baAssert(o);
   return (o->inBuf.temp);
}


U16 SharkSslCon_setHandshakeDataSent(SharkSslCon *o, U16 traceleave)
{
   U16 res = 0;
   baAssert(o);
   if (traceleave <= (o->inBuf.temp))
   {
      res = o->inBuf.temp;
      if (traceleave > 0)
      {
         res -= traceleave;
         if (res > 0)
         {
            memmove(func3fixup(&o->inBuf), func3fixup(&o->inBuf) + traceleave, res);
            o->flags |= SHARKSSL_FLAG_PARTIAL_HS_SEND;
         }
         o->inBuf.temp = res;
      }
   }
   return res;
}


U8 *SharkSslCon_getHandshakeData(SharkSslCon *o)
{
   if (SharkSslCon_getHandshakeDataLen(o))
   {
      #if SHARKSSL_TLS_1_2
      if (o->flags & createmappings)
      {
         baAssert(o->outBuf.data);
         o->flags &= ~createmappings;
         return (o->outBuf.data);
      }
      #endif  
      baAssert(o->inBuf.buf);
      return (func3fixup(&o->inBuf));
   }

   return NULL;
}


U8 SharkSslCon_isHandshakeComplete(SharkSslCon *o)
{
   baAssert(o);
   if (!(o->flags & SHARKSSL_FLAG_PARTIAL_HS_SEND))
   {
      if ((o->state == loongson3notifier)
          #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
          && (!(o->flags & skciphersetkey))
          #endif
         )
      {
         #if SHARKSSL_TLS_1_3
         if (SharkSsl_isClient(o->sharkSsl) && (o->inBuf.dataLen) 
            #if SHARKSSL_TLS_1_2
            && (o->minor == SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)) 
            #endif
            )
         {
            return 2;
         }
         #endif
         return 1;
      }
   }

   return 0;
}


U8 SharkSslCon_getAlertLevel(SharkSslCon *o)
{
   baAssert(o);
   return (o->alertLevel);
}


U8 SharkSslCon_getAlertDescription(SharkSslCon *o)
{
   baAssert(o);
   return (o->alertDescr);
}


SharkSslCon_RetVal SharkSslCon_encrypt(SharkSslCon *o, U8 *buf, U16 masterclock)
{
   U8 *tp, iotimingdebugfs;
   U16 brightnesslimit;
   SharkSslBuf *oBuf;

   baAssert(o);
   if (o->flags & firstcomponent)
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      resvdexits(o);
      return SharkSslCon_Error;
   }

   #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
   if (o->flags & (registerbuses | skciphersetkey))
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      resvdexits(o);
      return SharkSslCon_Error;
   }
   #endif

   if (!SharkSslCon_isHandshakeComplete(o))
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      return SharkSslCon_HandshakeNotComplete;
   }

   baAssert(!microresources(&o->outBuf));

   oBuf = &o->outBuf;
   registerfixed(oBuf);  

   brightnesslimit = oBuf->temp;
   masterclock -= brightnesslimit;
   if ((!buf) && (brightnesslimit))
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      resvdexits(o);
      return SharkSslCon_Error;
   }

   iotimingdebugfs = r3000tlbchange(o);
   baAssert(oBuf->size > iotimingdebugfs);
   if (masterclock <= (oBuf->size - iotimingdebugfs))
   {
      o->flags &= ~audiosuspend;
      oBuf->temp = 0;
   }
   else
   {
      if (!buf)
      {
         SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
         return SharkSslCon_AllocationError;  
      }
      o->flags |= audiosuspend;
      masterclock = (oBuf->size - iotimingdebugfs);
      oBuf->temp += masterclock;
   }
   tp = templateentry(o, polledbutton, oBuf->data, masterclock);
   if (buf)
   {
      memcpy(tp, buf + brightnesslimit, (oBuf->dataLen = masterclock));
   }
   if (SharkSslCon_calcMACAndEncrypt(o) < 0)
   {
      SHARKDBG_PRINTF(("\045\163\072\040\045\144\012", __FILE__, __LINE__));
      resvdexits(o);
      return SharkSslCon_Error;
   }
   return SharkSslCon_Encrypted;
}


U8 *SharkSslCon_getEncBufPtr(SharkSslCon *o)
{
   baAssert(o);
   if (o->outBuf.data)
   {
      return (func3fixup(&(o->outBuf)) + clkctrlmanaged);
   }
   return (U8*)0;
}


U16 SharkSslCon_getEncBufSize(SharkSslCon *o)
{
   baAssert(o);
   if (o->outBuf.data)
   {
      return (o->outBuf.size - r3000tlbchange(o));
   }
   return 0;
}


U8 *SharkSslCon_getEncData(SharkSslCon *o)
{
   baAssert(o);
   baAssert(o->outBuf.data);
   return (o->outBuf.data);
}


U16 SharkSslCon_getEncDataLen(SharkSslCon *o)
{
   baAssert(o);
   return (o->outBuf.dataLen);
}


#if SHARKSSL_ENABLE_INFO_API
SHARKSSL_API U16 SharkSslCon_getCiphersuite(SharkSslCon *o)
{
   baAssert(o);
   if (SharkSslCon_isHandshakeComplete(o) && (o->rCipherSuite))
   {
      baAssert(o->rCipherSuite == o->wCipherSuite);
      return o->rCipherSuite->id;
   }

   return 0;
}

#if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
SHARKSSL_API U8 SharkSslCon_getProtocol(SharkSslCon *o)
{
   baAssert(o);
   baAssert(SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_2) == SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_3));
   if ((o->major == SHARKSSL_PROTOCOL_MAJOR(SHARKSSL_PROTOCOL_TLS_1_3)) && 
       (o->minor >= SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2)) &&
       (o->minor <= SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3)))
   {
      return ((o->major << 4) | (o->minor));
   }

   return SHARKSSL_PROTOCOL_UNKNOWN;
}
#endif
#endif  


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
SHARKSSL_API SharkSslCertInfo *SharkSslCon_getCertInfo(SharkSslCon *o)
{
   if (o)
   {
      #if SHARKSSL_ENABLE_SESSION_CACHE
      if ((o->session) && (o->session->clonedCertInfo))
      {
         return &(o->session->clonedCertInfo->ci);
      }
      #endif  
      if (o->clonedCertInfo)
      {
         return &(o->clonedCertInfo->ci);
      }
   }

   return (SharkSslCertInfo*)0;
}


U8 realnummemory(SharkSslCon *o, SharkSslClonedCertInfo **outCertInfoPtr)
{
   baAssert(outCertInfoPtr);
   #if SHARKSSL_SSL_SERVER_CODE
   if (!(o->flags & serialreset))  
   #endif
   {
      U32 stringlookup;
      SharkSslCertInfo *ci;
      SharkSslClonedCertInfo *cci;

      ci = &(hsParam(o)->certParam.certInfo);
      baAssert(ci);

      
      stringlookup = 0;
      while (ci)
      {
         
         #if SHARKSSL_ENABLE_SESSION_CACHE
         if (stringlookup == 0)
         {
            stringlookup += sizeof(SharkSslClonedCertInfo);
         }
         else
         #endif
         {
            stringlookup += sizeof(SharkSslCertInfo);
         }
         stringlookup += SHARKSSL_ALIGNMENT;

         stringlookup += ci->snLen +
                    ci->timeFromLen +
                    ci->timeToLen +
                    ci->issuer.commonNameLen +
                    ci->issuer.countryNameLen +
                    ci->issuer.localityLen +
                    ci->issuer.organizationLen +
                    ci->issuer.provinceLen +
                    ci->issuer.unitLen +
                    ci->subject.commonNameLen +
                    ci->subject.countryNameLen +
                    ci->subject.localityLen +
                    ci->subject.organizationLen +
                    ci->subject.provinceLen +
                    ci->subject.unitLen +
                    ci->subjectAltNamesLen;

         ci = ci->parent;
      }

      
      cci = (SharkSslClonedCertInfo*)baMalloc(claimresource(stringlookup));
      if (cci != NULL)
      {
         U8  *p = (U8*)0;
         SharkSslCertInfo *di = &cci->ci;

         ci = &(hsParam(o)->certParam.certInfo);
         *outCertInfoPtr = cci;
         #if SHARKSSL_ENABLE_SESSION_CACHE
         cci->refcnt = 1;  
         #endif

         
         for (;;)
         {
            
            if (p)
            {
               p = (U8*)((SharkSslCertInfo*)(di + 1));
            }
            else
            {
               p = (U8*)((SharkSslClonedCertInfo*)(cci + 1));
            }

            memcpy(di, ci, sizeof(SharkSslCertInfo));

            memcpy(p, ci->sn, ci->snLen);
            di->sn = p;
            p += ci->snLen;

            memcpy(p, ci->timeFrom, ci->timeFromLen);
            di->timeFrom = p;
            p += ci->timeFromLen;

            memcpy(p, ci->timeTo, ci->timeToLen);
            di->timeTo = p;
            p += ci->timeToLen;

            if (ci->subjectAltNamesPtr) 
            {
               baAssert(ci->subjectAltNamesLen > 0);
               memcpy(p, ci->subjectAltNamesPtr, ci->subjectAltNamesLen);
               di->subjectAltNamesPtr = p;
               di->subjectAltNamesLen = ci->subjectAltNamesLen;
               p += ci->subjectAltNamesLen;
            }

            if (ci->issuer.commonName)
            {
               memcpy(p, ci->issuer.commonName, ci->issuer.commonNameLen);
               di->issuer.commonName = p;
               p += ci->issuer.commonNameLen;
            }
            if (ci->issuer.countryName)
            {
               memcpy(p, ci->issuer.countryName, ci->issuer.countryNameLen);
               di->issuer.countryName = p;
               p += ci->issuer.countryNameLen;
            }
            if (ci->issuer.locality)
            {
               memcpy(p, ci->issuer.locality, ci->issuer.localityLen);
               di->issuer.locality = p;
               p += ci->issuer.localityLen;
            }
            if (ci->issuer.organization)
            {
               memcpy(p, ci->issuer.organization, ci->issuer.organizationLen);
               di->issuer.organization = p;
               p += ci->issuer.organizationLen;
            }
            if (ci->issuer.province)
            {
               memcpy(p, ci->issuer.province, ci->issuer.provinceLen);
               di->issuer.province = p;
               p += ci->issuer.provinceLen;
            }
            if (ci->issuer.unit)
            {
               memcpy(p, ci->issuer.unit, ci->issuer.unitLen);
               di->issuer.unit = p;
               p += ci->issuer.unitLen;
            }

            if (ci->subject.commonName)
            {
               memcpy(p, ci->subject.commonName, ci->subject.commonNameLen);
               di->subject.commonName = p;
               p += ci->subject.commonNameLen;
            }
            if (ci->subject.countryName)
            {
               memcpy(p, ci->subject.countryName, ci->subject.countryNameLen);
               di->subject.countryName = p;
               p += ci->subject.countryNameLen;
            }
            if (ci->subject.locality)
            {
               memcpy(p, ci->subject.locality, ci->subject.localityLen);
               di->subject.locality = p;
               p += ci->subject.localityLen;
            }
            if (ci->subject.organization)
            {
               memcpy(p, ci->subject.organization, ci->subject.organizationLen);
               di->subject.organization = p;
               p += ci->subject.organizationLen;
            }
            if (ci->subject.province)
            {
               memcpy(p, ci->subject.province, ci->subject.provinceLen);
               di->subject.province = p;
               p += ci->subject.provinceLen;
            }
            if (ci->subject.unit)
            {
               memcpy(p, ci->subject.unit, ci->subject.unitLen);
               di->subject.unit = p;
               p += ci->subject.unitLen;
            }

            
            p = (U8*)regulatorconsumer(p);

            ci = ci->parent;
            if (ci)
            {
               di->parent = (SharkSslCertInfo*)p;
               di = (SharkSslCertInfo*)p;
            }
            else
            {
               di->parent = (SharkSslCertInfo*)0;
               break;
            }
         }

         return 1;
      }
   }

   return 0;
}


#if (SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CLIENT_AUTH)
U8 SharkSslCon_certificateRequested(SharkSslCon *o)
{
   baAssert(o);
   return (o->flags & nresetconsumers) ? 1 : 0;
}
#endif


#if SHARKSSL_ENABLE_CA_LIST
SHARKSSL_API U8 SharkSslCon_trustedCA(SharkSslCon *o)
{
   baAssert(o);
   return (o->flags & switcheractivation) ? 1 : 0;
}


U8 SharkSslCon_isCAListEmpty(SharkSslCon *o)
{
   baAssert(o);
   baAssert(o->sharkSsl);
   baAssert(NULL == (void*)0);
   return (NULL == o->sharkSsl->caList);
}
#endif


#if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_RSA)
U8  SharkSslCon_favorRSA(SharkSslCon *o, U8 sha256export)
{
   if (o &&
       ((!(SharkSslCon_isHandshakeComplete(o)))
        #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
        || (o->flags & registerbuses)
        #endif
       )
       #if SHARKSSL_SSL_CLIENT_CODE
       && (SharkSsl_isServer(o->sharkSsl))
       #endif
      )
   {
      if (sha256export)
      {
         o->flags |= uprobeabort;
      }
      else
      {
         o->flags &= ~uprobeabort;
      }
      return 1;  
   }

   return 0;
}
#endif
#endif  


#if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_CLIENT_AUTH && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
U8 SharkSslCon_requestClientCert(SharkSslCon *o, const void *displaysetup)
{
   if (o &&
       ((!(SharkSslCon_isHandshakeComplete(o)))
        #if SHARKSSL_ENABLE_SECURE_RENEGOTIATION
        || (o->flags & registerbuses)
        #endif
       )
       #if SHARKSSL_SSL_CLIENT_CODE
       && (SharkSsl_isServer(o->sharkSsl))
       #endif
      )
   {
      o->flags |= unregistershash;
      #if SHARKSSL_ENABLE_CA_LIST
      o->caListCertReq = (SharkSslCAList)displaysetup;
      #else
      (void)displaysetup;
      #endif
      return 1;  
   }

   return 0;
}
#endif


#if (SHARKSSL_TLS_1_3 && SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CA_EXTENSION && (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
U8 SharkSslCon_setCertificateAuthorities(SharkSslCon *o, const void *displaysetup)
{
   if ((o) && (SharkSsl_isClient(o->sharkSsl)) && (o->state <= pciercxcfg070) 
       #if SHARKSSL_TLS_1_2
       && (o->minor != SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2))
       #endif
      )
   {
      #if SHARKSSL_ENABLE_CA_LIST
      o->flags |= SHARKSSL_FLAG_CA_EXTENSION_REQUEST;
      o->caListCertReq = (SharkSslCAList)displaysetup;
      return 1;
      #else
      (void)displaysetup;
      #endif
   }

   return 0;
}
#endif


#if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SECURE_RENEGOTIATION)
U8 SharkSslCon_renegotiate(SharkSslCon *o)
{
   if (o && (SharkSslCon_isHandshakeComplete(o)
       && (!(o->flags & (registerbuses | skciphersetkey))))
       #if SHARKSSL_SSL_CLIENT_CODE
       && (SharkSsl_isServer(o->sharkSsl))
       #endif
      )
   {
      U8 *tp;
      #if SHARKSSL_ENABLE_ALPN_EXTENSION
      
      o->rALPN = NULL;
      #endif
      
      registerfixed(&o->outBuf);
      tp = templateentry(o, controllegacy, o->outBuf.data, 4);
      *tp++ = switchessetup;
      *tp++ = 0;
      *tp++ = 0;
      *tp++ = 0;
      if (SharkSslCon_calcMACAndEncrypt(o) >= 0)
      {
         o->inBuf.temp = o->outBuf.dataLen;
         o->flags |= registerbuses;
         o->flags |= createmappings;
         singleftosi(o);
         o->clonedCertInfo = (SharkSslClonedCertInfo*)0;
         return 1;  
      }
   }

   return 0;
}
#endif


#if SHARKSSL_SSL_CLIENT_CODE 
U8 SharkSslCon_selectProtocol(SharkSslCon *o, U8 ejtagsetup)
{
   baAssert((ejtagsetup == SHARKSSL_PROTOCOL_TLS_1_2) || (ejtagsetup == SHARKSSL_PROTOCOL_TLS_1_3));

   if ((!o) || (o->state >= pciercxcfg070)
       #if SHARKSSL_ENABLE_SESSION_CACHE
       
       || (o->session)
       #endif
       #if SHARKSSL_SSL_SERVER_CODE
       || (!(SharkSsl_isClient(o->sharkSsl)))
       #endif
      )
   {
      return 0;
   }

   switch (ejtagsetup)
   {
      case SHARKSSL_PROTOCOL_TLS_1_2:
         #if SHARKSSL_TLS_1_2
         o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_2);
         #endif
         break;

      case SHARKSSL_PROTOCOL_TLS_1_3:
         #if SHARKSSL_TLS_1_3
         o->minor = SHARKSSL_PROTOCOL_MINOR(SHARKSSL_PROTOCOL_TLS_1_3);
         #endif
         break;

      default:
         break;
   }

   if (o->minor)  
   {
      #if SHARKSSL_ENABLE_SELECT_CIPHERSUITE
      
      if (o->cipherSelCtr)
      {
         U8 i = 0;
         while (i < o->cipherSelCtr)
         {
            if (sharkssl_protocol_ciphersuite(ejtagsetup, o->cipherSelection[i]))
            {
               i++;
            }
            else
            {
               
               U8 j = i + 1;
               while (j < o->cipherSelCtr)
               {
                  
                  o->cipherSelection[j - 1] = o->cipherSelection[j];
                  j++;
               }
               o->cipherSelCtr--;
               o->cipherSelection[o->cipherSelCtr] = 0;
            }
         }
      }
      #endif
      return 1;  
   }
   return 0;  
}


#if SHARKSSL_ENABLE_SNI
U8 SharkSslCon_setSNI(SharkSslCon *o, const char *gpio1config, U16 traceleave)
{
   baAssert(o);
   baAssert(gpio1config || !traceleave);

   #if SHARKSSL_SSL_SERVER_CODE
   if (SharkSsl_isClient(o->sharkSsl))
   #endif
   {
      if ((o->state == 0) && (traceleave <= 64))
      {
         
         baAssert(traceleave < 0x100);
         o->padLen = traceleave;
         o->rCtx = (void*)gpio1config;
         return 1;  
      }
   }

   return 0;
}
#endif
#endif  


#if SHARKSSL_ENABLE_SESSION_CACHE
#if SHARKSSL_ENABLE_INFO_API
U8 SharkSslCon_isResumed(SharkSslCon *o)
{
   baAssert(startqueue == 0x200);
   return (U8)((U32)(o->flags & startqueue) >> 9);
}
#endif


U8 SharkSslSession_release(SharkSslSession *o, SharkSsl *s)
{
   baAssert(s);
   if (o)
   {
      filtermatch(&s->sessionCache);
      baAssert(o->nUse);
      if (o->nUse)  
      {
         o->nUse--;
         SHARKDBG_PRINTF(("\157\050\045\060\070\130\051\055\076\156\125\163\145\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)o, (U32)o->nUse, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\137\162\145\154\145\141\163\145"));         
         #if SHARKSSL_SSL_CLIENT_CODE
         if ((SharkSsl_isClient(s)) && (0 == o->nUse))
         {
            #if SHARKSSL_ENABLE_CA_LIST
            o->flags &= ~ecoffaouthdr;
            #endif
            if (o->clonedCertInfo)
            {
               o->clonedCertInfo->refcnt--;
               SHARKDBG_PRINTF(("\157\050\045\060\070\130\051\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\050\045\060\070\130\051\055\076\162\145\146\143\156\164\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)o, (U32)o->clonedCertInfo, o->clonedCertInfo->refcnt, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\137\162\145\154\145\141\163\145"));
               
               if (0 == o->clonedCertInfo->refcnt)
               {
                  SHARKDBG_PRINTF(("\157\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\040\162\145\154\145\141\163\145\144\054\040\045\163\072\040\045\144\012", __FILE__, __LINE__)); 
                  baFree((void*)o->clonedCertInfo);
               }
               o->clonedCertInfo = (SharkSslClonedCertInfo*)0;
            }
            if (SharkSslSession_isProtocol(o, SHARKSSL_PROTOCOL_TLS_1_3) && (o->prot.tls13.ticket))
            {
               baFree((void*)o->prot.tls13.ticket);
               o->prot.tls13.ticket = (U8*)0;
            }
         }
         #endif  
      }
      helperglobal(&s->sessionCache);
      return 1;  
   }

   return 0;
}


void SharkSslSession_copyClonedCertInfo(SharkSslSession *func2fixup, SharkSslCon *o)
{
   
   baAssert((SharkSslClonedCertInfo*)0 == func2fixup->clonedCertInfo);
   func2fixup->clonedCertInfo = o->clonedCertInfo;
   o->clonedCertInfo->refcnt++;
   SHARKDBG_PRINTF(("\157\050\045\060\070\130\051\055\076\143\154\157\156\145\144\103\145\162\164\111\156\146\157\050\045\060\070\130\051\055\076\162\145\146\143\156\164\072\040\045\144\054\040\045\163\072\040\045\144\040\050\045\163\051\012", (U32)o, (U32)o->clonedCertInfo, o->clonedCertInfo->refcnt, __FILE__, __LINE__, "\123\150\141\162\153\123\163\154\123\145\163\163\151\157\156\137\143\157\160\171\103\154\157\156\145\144\103\145\162\164\111\156\146\157"));
   #if SHARKSSL_ENABLE_CA_LIST
   if (o->flags & switcheractivation)
   {
      func2fixup->flags |= ecoffaouthdr;
   }
   #endif
}


#if SHARKSSL_SSL_SERVER_CODE

U8 SharkSslCon_releaseSession(SharkSslCon *o)
{
   baAssert(o);
   if ((SharkSsl_isServer(o->sharkSsl)) &&  (SharkSslCon_isHandshakeComplete(o)) &&
       (o->session))
   {
      SharkSslSession *s = o->session;
      o->session = NULL;
      return SharkSslSession_release(s, o->sharkSsl);
   }
   return 0;
}
#endif


#if SHARKSSL_SSL_CLIENT_CODE
SharkSslSession *SharkSslCon_acquireSession(SharkSslCon *o)
{
   baAssert(o);
   if ((SharkSsl_isClient(o->sharkSsl)) && (SharkSslCon_isHandshakeComplete(o)) &&
       (o->sharkSsl->sessionCache.cache) && (o->session))
   {
      
      baAssert(o->minor == hardirqsenabled(o->session));
      #if SHARKSSL_TLS_1_2
      #if SHARKSSL_TLS_1_3
      if (SharkSslSession_isProtocol(o->session, SHARKSSL_PROTOCOL_TLS_1_2))
      #endif 
      {
         return latchgpiochip(&(o->sharkSsl->sessionCache), o,
                                                 o->session->prot.tls12.id, SHARKSSL_MAX_SESSION_ID_LEN);
      }
      #if SHARKSSL_TLS_1_3
      else
      #endif
      #endif
      #if SHARKSSL_TLS_1_3
      {
         return latchgpiochip(&(o->sharkSsl->sessionCache), o,
                                                 o->session->prot.tls13.ticket, o->session->prot.tls13.ticketLen);
      }
      #endif 
   }

   return 0;
}


U8 SharkSslCon_resumeSession(SharkSslCon *o, SharkSslSession *s)
{
   baAssert(o);

   
   if ((SharkSsl_isClient(o->sharkSsl)) && (o->session == 0) && (s) && (o->state <= pciercxcfg070))
   {
      U32 uart2hwmod = o->sharkSsl->sessionCache.cacheSize;

      if (uart2hwmod)
      {
         SharkSslSession *sv = o->sharkSsl->sessionCache.cache;

         do
         {
            if (s == sv)
            {
               baAssert(s->cipherSuite);
               o->session = s;

               
               #if SHARKSSL_ENABLE_SELECT_CIPHERSUITE
               
               o->cipherSelCtr = 0;
               #endif

               #if SHARKSSL_TLS_1_2 && SHARKSSL_TLS_1_3
               
               o->minor = hardirqsenabled(s);
               #endif
               return 1;  
            }

            uart2hwmod--;
            sv++;
         } while (uart2hwmod > 0);

         baAssert(0);  
      }
   }

   return 0;
}


U32 SharkSslSession_getLatestAccessTime(SharkSslSession *o)
{
   if (o)
   {
      #if SHARKSSL_TLS_1_2
      #if SHARKSSL_TLS_1_3
      if (SharkSslSession_isProtocol(o, SHARKSSL_PROTOCOL_TLS_1_2))
      #endif
      {
         return (o->prot.tls12.latestAccess);  
      }
      #endif
      #if SHARKSSL_TLS_1_3
      #if SHARKSSL_TLS_1_2
      else
      #endif
      {
         U32 now = (U32)baGetUnixTime();
         baAssert(SharkSslSession_isProtocol(o, SHARKSSL_PROTOCOL_TLS_1_3));
         if (now < o->prot.tls13.expiration)
         {
            return now;
         }
      }
      #endif
   }

   return 0;
}
#endif
#endif



#ifndef BA_LIB
#define BA_LIB
#endif



#if (!SHARKSSL_SSL_CLIENT_CODE)
#error Designed for the SharkSSL client lib
#endif
#if (!SHARKSSL_ENABLE_SESSION_CACHE)
#error Requires SHARKSSL_ENABLE_SESSION_CACHE
#endif

#include <SharkSslSCMgr.h>

#include <stddef.h>
#include <string.h>




#define SharkSslSCMgrNode_dlink2Obj(l) \
   (SharkSslSCMgrNode*)((U8*)l-offsetof(SharkSslSCMgrNode,dlink))


static void
hwdebugstate(SharkSslSCMgr* o, SharkSslSCMgrNode* n)
{
   if( ! n )
   {
      DoubleLink* l = DoubleList_lastNode(&o->dlist);
      if( ! l )
         return;
      n=SharkSslSCMgrNode_dlink2Obj(l);
   }
   SharkSslSession_release(n->ss, o->ssl);
   DoubleLink_unlink(&n->dlink);
   SplayTree_remove(&o->stree,(SplayTreeNode*)n);
   baFree(n);
   baAssert(o->noOfSessions > 0);
   o->noOfSessions--;
}


static int
memcachezalloc(SplayTreeNode* n, SplayTreeKey k)
{
   if( ((SharkSslSCMgrNode*)n)->port == ((SharkSslSCMgrNode*)k)->port )
      return sharkStrCaseCmp(((SharkSslSCMgrNode*)n)->host,
                             ((SharkSslSCMgrNode*)n)->hostLen,
                          ((SharkSslSCMgrNode*)k)->host,
                          ((SharkSslSCMgrNode*)n)->hostLen);
   return ((SharkSslSCMgrNode*)n)->port - ((SharkSslSCMgrNode*)k)->port;
}


SHARKSSL_API SharkSslSCMgrNode*
SharkSslSCMgr_get(SharkSslSCMgr* o,SharkSslCon* mmcsd0resources,const char* writereg16,U16 hwmoddeassert)
{
   SharkSslSCMgrNode k;
   SharkSslSCMgrNode* n;
   k.host=writereg16;
   k.port=hwmoddeassert;
   n = (SharkSslSCMgrNode*)SplayTree_find(&o->stree,(SplayTreeKey)&k);
   if(n)
   {
      if( ! mmcsd0resources->session && ! SharkSslCon_resumeSession(mmcsd0resources,n->ss) )
      {
         hwdebugstate(o, n);
         n=0;
      }
   }
   return n;
}


SHARKSSL_API int
SharkSslSCMgr_save(SharkSslSCMgr* o, SharkSslCon* mmcsd0resources, const char* writereg16, U16 hwmoddeassert)
{
   DoubleLink* l;
   SharkSslSCMgrNode* n;
   int handlersetup=-1;
   int iommucreate = o->noOfSessions > 0;
   SharkSslSession* ss = SharkSslCon_acquireSession(mmcsd0resources);
   if(!ss && o->noOfSessions >= mmcsd0resources->sharkSsl->sessionCache.cacheSize)
   {
      l=DoubleList_lastNode(&o->dlist);
      hwdebugstate(o, SharkSslSCMgrNode_dlink2Obj(l));
      ss = SharkSslCon_acquireSession(mmcsd0resources);
   }
   if(ss)
   {
      n=(SharkSslSCMgrNode*)baMalloc(
         sizeof(SharkSslSCMgrNode)+strlen(writereg16)+1);
      if(n)
      {
         SplayTreeNode_constructor((SplayTreeNode*)n,n);
         DoubleLink_constructor(&n->dlink);
         n->ss=ss;
         n->port=hwmoddeassert;
         n->hostLen=(U16)strlen(writereg16);
         strcpy((char*)(n+1),writereg16);
         n->host=(char*)(n+1);
         SplayTree_insert(&o->stree, (SplayTreeNode*)n);
         DoubleList_insertFirst(&o->dlist,&n->dlink);
         o->noOfSessions++;
         handlersetup=0;
      }
      else
         SharkSslSession_release(ss, o->ssl);
   }

   
   if(iommucreate)
   {
      l=DoubleList_lastNode(&o->dlist);
      n=SharkSslSCMgrNode_dlink2Obj(l);
      if((baGetUnixTime() - SharkSslSession_getLatestAccessTime(n->ss)) >
         o->maxTime)
      {
         hwdebugstate(o, n); 
      }
   }
   return handlersetup;
}



static void
hwrandomresource(SharkSslIntf* fdc37m81xconfig, SharkSsl* ssl)
{
   SharkSslSCMgr* o = (SharkSslSCMgr*)fdc37m81xconfig;
   (void)ssl;
   while( ! DoubleList_isEmpty(&o->dlist) )
      hwdebugstate(o,0);
   baFree(o);
}


SHARKSSL_API void
SharkSslSCMgr_constructor(SharkSslSCMgr* o, SharkSsl* ssl, U32 coherencytable)
{
   SharkSslIntf_constructor((SharkSslIntf*)o, hwrandomresource);
   SplayTree_constructor(
      &o->stree,memcachezalloc);
   DoubleList_constructor(&o->dlist);
   o->noOfSessions=0;
   o->maxTime=coherencytable;
   o->ssl = ssl;
}


#ifndef BA_LIB
#define BA_LIB
#endif



#include <string.h>


#if SHARKSSL_USE_ECC
#define fpscroffset(o, vect) \
        traceaddress(o, sizeof(vect)/sizeof(vect[0]), (void*)vect)


#if (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)
#define SharkSslECCurve_constructor1_(c, i, gpio1config) do {     \
   c->bits = i;                                            \
   fpscroffset(&c->prime, gpio1config##_prime);   \
   fpscroffset(&c->order, gpio1config##_order);   \
   fpscroffset(&c->G.x,   gpio1config##_Gx);      \
   fpscroffset(&c->G.y,   gpio1config##_Gy);      \
   fpscroffset(&c->a,     gpio1config##_a);       \
} while (0)

#else
#define SharkSslECCurve_constructor1_(c, i, gpio1config) do {     \
   c->bits = i;                                            \
   fpscroffset(&c->prime, gpio1config##_prime);   \
   fpscroffset(&c->order, gpio1config##_order);   \
   fpscroffset(&c->G.x,   gpio1config##_Gx);      \
   fpscroffset(&c->G.y,   gpio1config##_Gy);      \
} while (0)

#endif


#if SHARKSSL_ECC_VERIFY_POINT
#define SharkSslECCurve_constructor_(c, i, gpio1config) do {      \
   SharkSslECCurve_constructor1_(c, i, gpio1config);              \
   fpscroffset(&c->b, gpio1config##_b);           \
} while (0)

#else
#define SharkSslECCurve_constructor_(c, i, gpio1config)           \
   SharkSslECCurve_constructor1_(c, i, gpio1config);

#endif


#if SHARKSSL_ECC_USE_NIST
static void availableasids(shtype_t *o, shtype_t *mod)
{
   
   #if SHARKSSL_ECC_USE_SECP521R1
   shtype_t checkcontext;
   #endif
   #if (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1)
   shtype_tDoubleWordS d;
   #endif

   #if   (SHARKSSL_BIGINT_WORDSIZE == 32)
   baAssert(o->len == (mod->len * 2));
   switch (mod->len)
   {
      #if SHARKSSL_ECC_USE_SECP256R1
      case 8:  
         d  = (shtype_tDoubleWordS)o->beg[15] + o->beg[7] + o->beg[6] - o->beg[4] - o->beg[3] - o->beg[2] - o->beg[1];
         o->beg[15] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[14] + o->beg[6] + o->beg[5] - o->beg[3] - o->beg[2] - o->beg[1] - o->beg[0];
         o->beg[14] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[13] + o->beg[5] + o->beg[4] - o->beg[2] - o->beg[1] - o->beg[0];
         o->beg[13] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[12] + o->beg[4] + o->beg[4] + o->beg[3] + o->beg[3] + o->beg[2] - o->beg[0] - o->beg[7] - o->beg[6];
         o->beg[12] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[11] + o->beg[3] + o->beg[3] + o->beg[2] + o->beg[2] + o->beg[1] - o->beg[6] - o->beg[5];
         o->beg[11] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[10] + o->beg[2] + o->beg[2] + o->beg[1] + o->beg[1] + o->beg[0] - o->beg[5] - o->beg[4];
         o->beg[10] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[9] + o->beg[1] + o->beg[1] + o->beg[1] + o->beg[0] + o->beg[0] + o->beg[2] - o->beg[7] - o->beg[6];
         o->beg[9] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[8] + o->beg[0] + o->beg[0] + o->beg[0] + o->beg[7] - o->beg[5] - o->beg[4] - o->beg[3] - o->beg[2];
         o->beg[8] = (shtype_tWord)d; anatopdisconnect(d);
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP384R1
      case 12:  
         d  = (shtype_tDoubleWordS)o->beg[23] + o->beg[11] + o->beg[3] + o->beg[2] - o->beg[0];
         o->beg[23] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[22] + o->beg[10] + o->beg[1] + o->beg[0] - o->beg[11] - o->beg[3];
         o->beg[22] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[21] + o->beg[9] + o->beg[0] - o->beg[10] - o->beg[2];
         o->beg[21] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[20] + o->beg[11] + o->beg[8] + o->beg[3] + o->beg[2] - o->beg[9] - o->beg[1] - o->beg[0];
         o->beg[20] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[19] + o->beg[2] + o->beg[2] + o->beg[7] + o->beg[10] + o->beg[11] + o->beg[3] + o->beg[1] - o->beg[8] - o->beg[0] - o->beg[0];
         o->beg[19] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[18] + o->beg[1] + o->beg[1] + o->beg[6] + o->beg[9] + o->beg[10] + o->beg[2] + o->beg[0] - o->beg[7];
         o->beg[18] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[17] + o->beg[0] + o->beg[0] + o->beg[5] + o->beg[8] + o->beg[9] + o->beg[1] - o->beg[6];
         o->beg[17] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[16] + o->beg[4] + o->beg[7] + o->beg[8] + o->beg[0] - o->beg[5];
         o->beg[16] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[15] + o->beg[3] + o->beg[6] + o->beg[7] - o->beg[4];
         o->beg[15] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[14] + o->beg[2] + o->beg[5] + o->beg[6] - o->beg[3];
         o->beg[14] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[13] + o->beg[1] + o->beg[4] + o->beg[5] - o->beg[2];
         o->beg[13] = (shtype_tWord)d; anatopdisconnect(d);

         d += (shtype_tDoubleWordS)o->beg[12] + o->beg[0] + o->beg[3] + o->beg[4] - o->beg[1];
         o->beg[12] = (shtype_tWord)d; anatopdisconnect(d);
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP521R1
      case 17:  
         o->len = 17;
         traceaddress(&checkcontext, 17, &o->beg[17]);
         memmove(&o->beg[0], &o->beg[1], 17 * SHARKSSL__M);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         checkcontext.beg[0] &= 0x1FF;
         setupsdhci1(o, &checkcontext, mod);
         return;
      #endif

      default:
         return;
   }

   #elif (SHARKSSL_BIGINT_WORDSIZE == 16)
   #if (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1)
   shtype_tWord *r, *s1, *s2, *s3;
   shtype_tWord *s4;
   shtype_tWord *s5, *s6;
   #endif
   #if SHARKSSL_ECC_USE_SECP521R1
   shtype_tWord d0;
   #endif
   U16 i = mod->len;

   #if (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1)
   d = 0;
   r = &o->beg[i * 2 - 1];
   #endif
   baAssert(o->len == (i * 2));
   switch (i)
   {
      #if SHARKSSL_ECC_USE_SECP256R1
      case 16:  
         s1 = &o->beg[13];
         s2 = NULL;
         s3 = NULL;
         s4 = &o->beg[9];
         s5 = &o->beg[5];
         s6 = &o->beg[3];
         while (i--)
         {
            d += (shtype_tDoubleWordS)*r;
            d += *(r - 16);
            d += *s1--;
            d -= *s4--;
            d -= *(s4 - 1);
            if (s2)
            {
               d += *s2;
               d += *s2--;
            }
            if (s3)
            {
               d += *s3;
               d += *s3--;
            }
            if (s5)
            {
               d -= *s5--;
            }
            if (s6)
            {
               d -= *s6--;
            }

            *r-- = (shtype_tWord)d; anatopdisconnect(d);

            if (i & 1)
            {
               continue;
            }
            if ((i == 12) || (i == 8))
            {
               s6 = NULL;
            }
            else if (i == 10)
            {
               s1 = &o->beg[9];
               s2 = &o->beg[7];
               s3 = s5 = &o->beg[5];
               s4 = &o->beg[15];
               s6 = &o->beg[1];
            }
            else if (i == 4)
            {
               s1 = &o->beg[5];
               s2 = &o->beg[3];
               s3 = &o->beg[1];
               s4 = &o->beg[15];
               s5 = NULL;
            }
            else if (i == 2)
            {
               s1 = &o->beg[15];
               s3 = NULL;
               s4 = &o->beg[11];
               s5 = &o->beg[7];
               s6 = &o->beg[5];
            }
         }
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP384R1
      case 24:  
         s1 = &o->beg[7];
         s2 = &o->beg[1];
         s3 = NULL;
         s4 = NULL;
         s5 = NULL;
         s6 = &o->beg[25];
         while (i--)
         {
            d += (shtype_tDoubleWordS)*r;
            d += *(r - 24);
            d -= *(r - 22);
            d += *s1--;
            d += *(s1 - 1);
            if (s2)
            {
               d -= *s2--;
            }
            if (s3)
            {
               d -= *s3--;
            }
            if (s4)
            {
               d += *s4--;
            }
            if (s5)
            {
               d += *s5;
               d += *s5--;
            }
            if (s6)
            {
               d += *s6--;
            }

            *r-- = (shtype_tWord)d; anatopdisconnect(d);

            if ((i & 1) || (i <= 6))
            {
               continue;
            }
            if (i == 22)
            {
               s1 = &o->beg[3];
               s2 = &o->beg[7];
               s6 = NULL;
            }
            else if (i == 20)
            {
               s1 = s3 = &o->beg[3];
            }
            else if (i == 18)
            {
               s1 = &o->beg[7];
               s6 = &o->beg[23];
            }
            else if (i == 16)
            {
               s1 = &o->beg[23];
               s3 = &o->beg[1];
               s4 = &o->beg[7];
               s5 = &o->beg[5];
               s6 = &o->beg[3];
            }
            else if (i == 14)
            {
               s2 = s3 = NULL;
            }
            else if (i == 12)
            {
               s6 = NULL;
            }
            else if (i == 10)
            {
               s5 = NULL;
            }
            else if (i == 8)
            {
               s4 = NULL;
            }
         }
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP521R1
      case 33:  
         o->len = 33;
         traceaddress(&checkcontext, 33, &o->beg[33]);
         d0 = (o->beg[0] & 0x3) << 7;
         memmove(&o->beg[0], &o->beg[1], 33 * SHARKSSL__M);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         backlightpdata(o);
         o->beg[0] |= d0;
         checkcontext.beg[0] &= 0x1FF;
         setupsdhci1(o, &checkcontext, mod);
         return;
      #endif

      default:
         return;
   }

   #elif (SHARKSSL_BIGINT_WORDSIZE == 8)
   #if (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1)
   shtype_tWord *r, *s1, *s2, *s3;
   shtype_tWord *s4;
   shtype_tWord *s5, *s6;
   #endif
   U16 i = mod->len;

   #if (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1)
   d = 0;
   r = &o->beg[i * 2 - 1];
   #endif
   baAssert(o->len == (i * 2));
   switch (i)
   {
      #if SHARKSSL_ECC_USE_SECP256R1
      case 32:  
         s1 = &o->beg[27];
         s2 = NULL;
         s3 = NULL;
         s4 = &o->beg[19];
         s5 = &o->beg[11];
         s6 = &o->beg[7];
         while (i--)
         {
            d += (shtype_tDoubleWordS)*r;
            d += *(r - 32);
            d += *s1--;
            d -= *s4--;
            d -= *(s4 - 3);
            if (s2)
            {
               d += *s2;
               d += *s2--;
            }
            if (s3)
            {
               d += *s3;
               d += *s3--;
            }
            if (s5)
            {
               d -= *s5--;
            }
            if (s6)
            {
               d -= *s6--;
            }

            *r-- = (shtype_tWord)d; anatopdisconnect(d);

            if (i & 1)
            {
               continue;
            }
            if ((i == 24) || (i == 16))
            {
               s6 = NULL;
            }
            else if (i == 20)
            {
               s1 = &o->beg[19];
               s2 = &o->beg[15];
               s3 = s5 = &o->beg[11];
               s4 = &o->beg[31];
               s6 = &o->beg[3];
            }
            else if (i == 8)
            {
               s1 = &o->beg[11];
               s2 = &o->beg[7];
               s3 = &o->beg[3];
               s4 = &o->beg[31];
               s5 = NULL;
            }
            else if (i == 4)
            {
               s1 = &o->beg[31];
               s3 = NULL;
               s4 = &o->beg[23];
               s5 = &o->beg[15];
               s6 = &o->beg[11];
            }
         }
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP384R1
      case 48:  
         s1 = &o->beg[15];
         s2 = &o->beg[3];
         s3 = NULL;
         s4 = NULL;
         s5 = NULL;
         s6 = &o->beg[51];
         while (i--)
         {
            d += (shtype_tDoubleWordS)*r;
            d += *(r - 48);
            d -= *(r - 44);
            d += *s1--;
            d += *(s1 - 3);
            if (s2)
            {
               d -= *s2--;
            }
            if (s3)
            {
               d -= *s3--;
            }
            if (s4)
            {
               d += *s4--;
            }
            if (s5)
            {
               d += *s5;
               d += *s5--;
            }
            if (s6)
            {
               d += *s6--;
            }

            *r-- = (shtype_tWord)d; anatopdisconnect(d);

            if ((i & 1) || (i <= 14))
            {
               continue;
            }
            if (i == 44)
            {
               s1 = &o->beg[7];
               s2 = &o->beg[15];
               s6 = NULL;
            }
            else if (i == 40)
            {
               s1 = s3 = &o->beg[7];
            }
            else if (i == 36)
            {
               s1 = &o->beg[15];
               s6 = &o->beg[47];
            }
            else if (i == 32)
            {
               s1 = &o->beg[47];
               s3 = &o->beg[3];
               s4 = &o->beg[15];
               s5 = &o->beg[11];
               s6 = &o->beg[7];
            }
            else if (i == 28)
            {
               s2 = s3 = NULL;
            }
            else if (i == 24)
            {
               s6 = NULL;
            }
            else if (i == 20)
            {
               s5 = NULL;
            }
            else if (i == 16)
            {
               s4 = NULL;
            }
         }
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP521R1
      case 66:  
         o->len = 66;
         traceaddress(&checkcontext, 66, &o->beg[66]);
         memmove(&o->beg[0], &o->beg[1], 66 * SHARKSSL__M);
         backlightpdata(o);
         checkcontext.beg[0] &= 0x1;
         setupsdhci1(o, &checkcontext, mod);
         return;
      #endif

      default:
         return;
   }

   #else
   #error unsupported SHARKSSL_BIGINT_WORDSIZE

   #endif  

   #if (SHARKSSL_ECC_USE_SECP256R1 || SHARKSSL_ECC_USE_SECP384R1)
   o->len >>= 1;
   o->beg += o->len;

   while (d != 0)
   {
      if (d < 0)
      {
         d += (shtype_tWordS)resolverelocs(o, mod);
      }
      else
      {
         d += (shtype_tWordS)updatepmull(o, mod);
      }
   }

   if (timerwrite(o, mod))
   {
      updatepmull(o, mod);
   }
   #endif
}
#endif


void clearerrors(SharkSslECCurve *o, U16 rightsvalid)
{
   
   #if SHARKSSL_ECC_USE_SECP256R1
   static const shtype_tWord SECP256R1_prime[]   = {HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(00,00,00,01),
                                                          HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                          HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                          HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF)};
   static const shtype_tWord SECP256R1_order[]   = {HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(00,00,00,00),
                                                          HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                          HEX4_TO_WORDSIZE(BC,E6,FA,AD), HEX4_TO_WORDSIZE(A7,17,9E,84),
                                                          HEX4_TO_WORDSIZE(F3,B9,CA,C2), HEX4_TO_WORDSIZE(FC,63,25,51)};
   static const shtype_tWord SECP256R1_Gx[]      = {HEX4_TO_WORDSIZE(6B,17,D1,F2), HEX4_TO_WORDSIZE(E1,2C,42,47),
                                                          HEX4_TO_WORDSIZE(F8,BC,E6,E5), HEX4_TO_WORDSIZE(63,A4,40,F2),
                                                          HEX4_TO_WORDSIZE(77,03,7D,81), HEX4_TO_WORDSIZE(2D,EB,33,A0),
                                                          HEX4_TO_WORDSIZE(F4,A1,39,45), HEX4_TO_WORDSIZE(D8,98,C2,96)};
   static const shtype_tWord SECP256R1_Gy[]      = {HEX4_TO_WORDSIZE(4F,E3,42,E2), HEX4_TO_WORDSIZE(FE,1A,7F,9B),
                                                          HEX4_TO_WORDSIZE(8E,E7,EB,4A), HEX4_TO_WORDSIZE(7C,0F,9E,16),
                                                          HEX4_TO_WORDSIZE(2B,CE,33,57), HEX4_TO_WORDSIZE(6B,31,5E,CE),
                                                          HEX4_TO_WORDSIZE(CB,B6,40,68), HEX4_TO_WORDSIZE(37,BF,51,F5)};
   #if (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)
   static const shtype_tWord SECP256R1_a[]       = {(shtype_tWord)-3};
   #endif
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord SECP256R1_b[]       = {HEX4_TO_WORDSIZE(5A,C6,35,D8), HEX4_TO_WORDSIZE(AA,3A,93,E7),
                                                          HEX4_TO_WORDSIZE(B3,EB,BD,55), HEX4_TO_WORDSIZE(76,98,86,BC),
                                                          HEX4_TO_WORDSIZE(65,1D,06,B0), HEX4_TO_WORDSIZE(CC,53,B0,F6),
                                                          HEX4_TO_WORDSIZE(3B,CE,3C,3E), HEX4_TO_WORDSIZE(27,D2,60,4B)};
   #endif
   #endif  

   #if SHARKSSL_ECC_USE_SECP384R1
   static const shtype_tWord SECP384R1_prime[]  = {HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FE),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(00,00,00,00),
                                                         HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(FF,FF,FF,FF)};
   static const shtype_tWord SECP384R1_order[]  = {HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(C7,63,4D,81), HEX4_TO_WORDSIZE(F4,37,2D,DF),
                                                         HEX4_TO_WORDSIZE(58,1A,0D,B2), HEX4_TO_WORDSIZE(48,B0,A7,7A),
                                                         HEX4_TO_WORDSIZE(EC,EC,19,6A), HEX4_TO_WORDSIZE(CC,C5,29,73)};
   static const shtype_tWord SECP384R1_Gx[]     = {HEX4_TO_WORDSIZE(AA,87,CA,22), HEX4_TO_WORDSIZE(BE,8B,05,37),
                                                         HEX4_TO_WORDSIZE(8E,B1,C7,1E), HEX4_TO_WORDSIZE(F3,20,AD,74),
                                                         HEX4_TO_WORDSIZE(6E,1D,3B,62), HEX4_TO_WORDSIZE(8B,A7,9B,98),
                                                         HEX4_TO_WORDSIZE(59,F7,41,E0), HEX4_TO_WORDSIZE(82,54,2A,38),
                                                         HEX4_TO_WORDSIZE(55,02,F2,5D), HEX4_TO_WORDSIZE(BF,55,29,6C),
                                                         HEX4_TO_WORDSIZE(3A,54,5E,38), HEX4_TO_WORDSIZE(72,76,0A,B7)};
   static const shtype_tWord SECP384R1_Gy[]     = {HEX4_TO_WORDSIZE(36,17,DE,4A), HEX4_TO_WORDSIZE(96,26,2C,6F),
                                                         HEX4_TO_WORDSIZE(5D,9E,98,BF), HEX4_TO_WORDSIZE(92,92,DC,29),
                                                         HEX4_TO_WORDSIZE(F8,F4,1D,BD), HEX4_TO_WORDSIZE(28,9A,14,7C),
                                                         HEX4_TO_WORDSIZE(E9,DA,31,13), HEX4_TO_WORDSIZE(B5,F0,B8,C0),
                                                         HEX4_TO_WORDSIZE(0A,60,B1,CE), HEX4_TO_WORDSIZE(1D,7E,81,9D),
                                                         HEX4_TO_WORDSIZE(7A,43,1D,7C), HEX4_TO_WORDSIZE(90,EA,0E,5F)};
   #if (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)
   static const shtype_tWord SECP384R1_a[]      = {(shtype_tWord)-3};
   #endif
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord SECP384R1_b[]      = {HEX4_TO_WORDSIZE(B3,31,2F,A7), HEX4_TO_WORDSIZE(E2,3E,E7,E4),
                                                         HEX4_TO_WORDSIZE(98,8E,05,6B), HEX4_TO_WORDSIZE(E3,F8,2D,19),
                                                         HEX4_TO_WORDSIZE(18,1D,9C,6E), HEX4_TO_WORDSIZE(FE,81,41,12),
                                                         HEX4_TO_WORDSIZE(03,14,08,8F), HEX4_TO_WORDSIZE(50,13,87,5A),
                                                         HEX4_TO_WORDSIZE(C6,56,39,8D), HEX4_TO_WORDSIZE(8A,2E,D1,9D),
                                                         HEX4_TO_WORDSIZE(2A,85,C8,ED), HEX4_TO_WORDSIZE(D3,EC,2A,EF)};
   #endif
   #endif  

   #if SHARKSSL_ECC_USE_SECP521R1
   static const shtype_tWord SECP521R1_prime[]  = {HEX2_TO_WORDSIZE(01,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF)};
   static const shtype_tWord SECP521R1_order[]  = {HEX2_TO_WORDSIZE(01,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                         HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FA),
                                                         HEX4_TO_WORDSIZE(51,86,87,83), HEX4_TO_WORDSIZE(BF,2F,96,6B),
                                                         HEX4_TO_WORDSIZE(7F,CC,01,48), HEX4_TO_WORDSIZE(F7,09,A5,D0),
                                                         HEX4_TO_WORDSIZE(3B,B5,C9,B8), HEX4_TO_WORDSIZE(89,9C,47,AE),
                                                         HEX4_TO_WORDSIZE(BB,6F,B7,1E), HEX4_TO_WORDSIZE(91,38,64,09)};
   static const shtype_tWord SECP521R1_Gx[]     = {HEX2_TO_WORDSIZE(00,C6),
                                                         HEX4_TO_WORDSIZE(85,8E,06,B7), HEX4_TO_WORDSIZE(04,04,E9,CD),
                                                         HEX4_TO_WORDSIZE(9E,3E,CB,66), HEX4_TO_WORDSIZE(23,95,B4,42),
                                                         HEX4_TO_WORDSIZE(9C,64,81,39), HEX4_TO_WORDSIZE(05,3F,B5,21),
                                                         HEX4_TO_WORDSIZE(F8,28,AF,60), HEX4_TO_WORDSIZE(6B,4D,3D,BA),
                                                         HEX4_TO_WORDSIZE(A1,4B,5E,77), HEX4_TO_WORDSIZE(EF,E7,59,28),
                                                         HEX4_TO_WORDSIZE(FE,1D,C1,27), HEX4_TO_WORDSIZE(A2,FF,A8,DE),
                                                         HEX4_TO_WORDSIZE(33,48,B3,C1), HEX4_TO_WORDSIZE(85,6A,42,9B),
                                                         HEX4_TO_WORDSIZE(F9,7E,7E,31), HEX4_TO_WORDSIZE(C2,E5,BD,66)};
   static const shtype_tWord SECP521R1_Gy[]     = {HEX2_TO_WORDSIZE(01,18),
                                                         HEX4_TO_WORDSIZE(39,29,6A,78), HEX4_TO_WORDSIZE(9A,3B,C0,04),
                                                         HEX4_TO_WORDSIZE(5C,8A,5F,B4), HEX4_TO_WORDSIZE(2C,7D,1B,D9),
                                                         HEX4_TO_WORDSIZE(98,F5,44,49), HEX4_TO_WORDSIZE(57,9B,44,68),
                                                         HEX4_TO_WORDSIZE(17,AF,BD,17), HEX4_TO_WORDSIZE(27,3E,66,2C),
                                                         HEX4_TO_WORDSIZE(97,EE,72,99), HEX4_TO_WORDSIZE(5E,F4,26,40),
                                                         HEX4_TO_WORDSIZE(C5,50,B9,01), HEX4_TO_WORDSIZE(3F,AD,07,61),
                                                         HEX4_TO_WORDSIZE(35,3C,70,86), HEX4_TO_WORDSIZE(A2,72,C2,40),
                                                         HEX4_TO_WORDSIZE(88,BE,94,76), HEX4_TO_WORDSIZE(9F,D1,66,50)};
   #if (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)
   static const shtype_tWord SECP521R1_a[]       = {(shtype_tWord)-3};
   #endif
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord SECP521R1_b[]      = {HEX2_TO_WORDSIZE(00,51),
                                                         HEX4_TO_WORDSIZE(95,3E,B9,61), HEX4_TO_WORDSIZE(8E,1C,9A,1F),
                                                         HEX4_TO_WORDSIZE(92,9A,21,A0), HEX4_TO_WORDSIZE(B6,85,40,EE),
                                                         HEX4_TO_WORDSIZE(A2,DA,72,5B), HEX4_TO_WORDSIZE(99,B3,15,F3),
                                                         HEX4_TO_WORDSIZE(B8,B4,89,91), HEX4_TO_WORDSIZE(8E,F1,09,E1),
                                                         HEX4_TO_WORDSIZE(56,19,39,51), HEX4_TO_WORDSIZE(EC,7E,93,7B),
                                                         HEX4_TO_WORDSIZE(16,52,C0,BD), HEX4_TO_WORDSIZE(3B,B1,BF,07),
                                                         HEX4_TO_WORDSIZE(35,73,DF,88), HEX4_TO_WORDSIZE(3D,2C,34,F1),
                                                         HEX4_TO_WORDSIZE(EF,45,1F,D4), HEX4_TO_WORDSIZE(6B,50,3F,00)};
   #endif
   #endif  

   #if SHARKSSL_ECC_USE_BRAINPOOLP256R1
   
   static const shtype_tWord brainpoolP256R1_prime[]   = {HEX4_TO_WORDSIZE(A9,FB,57,DB), HEX4_TO_WORDSIZE(A1,EE,A9,BC),
                                                                HEX4_TO_WORDSIZE(3E,66,0A,90), HEX4_TO_WORDSIZE(9D,83,8D,72),
                                                                HEX4_TO_WORDSIZE(6E,3B,F6,23), HEX4_TO_WORDSIZE(D5,26,20,28),
                                                                HEX4_TO_WORDSIZE(20,13,48,1D), HEX4_TO_WORDSIZE(1F,6E,53,77)};
   static const shtype_tWord brainpoolP256R1_order[]   = {HEX4_TO_WORDSIZE(A9,FB,57,DB), HEX4_TO_WORDSIZE(A1,EE,A9,BC),
                                                                HEX4_TO_WORDSIZE(3E,66,0A,90), HEX4_TO_WORDSIZE(9D,83,8D,71),
                                                                HEX4_TO_WORDSIZE(8C,39,7A,A3), HEX4_TO_WORDSIZE(B5,61,A6,F7),
                                                                HEX4_TO_WORDSIZE(90,1E,0E,82), HEX4_TO_WORDSIZE(97,48,56,A7)};
   
   static const shtype_tWord brainpoolP256R1_Gx[]      = {HEX4_TO_WORDSIZE(8E,1F,76,7A), HEX4_TO_WORDSIZE(9E,11,9B,DF),
                                                                HEX4_TO_WORDSIZE(70,4C,31,1D), HEX4_TO_WORDSIZE(6B,89,2A,D3),
                                                                HEX4_TO_WORDSIZE(80,DE,4D,9A), HEX4_TO_WORDSIZE(B9,7C,F3,0A),
                                                                HEX4_TO_WORDSIZE(27,C0,D9,2D), HEX4_TO_WORDSIZE(35,1F,D1,0C)};
   static const shtype_tWord brainpoolP256R1_Gy[]      = {HEX4_TO_WORDSIZE(14,EB,78,C6), HEX4_TO_WORDSIZE(02,6E,B0,A2),
                                                                HEX4_TO_WORDSIZE(16,FD,F6,E8), HEX4_TO_WORDSIZE(DF,BD,8B,03),
                                                                HEX4_TO_WORDSIZE(A6,18,F2,59), HEX4_TO_WORDSIZE(CD,95,01,62),
                                                                HEX4_TO_WORDSIZE(9A,4F,E9,48), HEX4_TO_WORDSIZE(A0,91,7A,17)};
   static const shtype_tWord brainpoolP256R1_a[]       = {HEX4_TO_WORDSIZE(1E,46,76,AB), HEX4_TO_WORDSIZE(D6,66,BC,17),
                                                                HEX4_TO_WORDSIZE(95,EC,1E,5E), HEX4_TO_WORDSIZE(63,98,55,6E),
                                                                HEX4_TO_WORDSIZE(A6,81,23,F1), HEX4_TO_WORDSIZE(C1,D2,0C,64),
                                                                HEX4_TO_WORDSIZE(D5,D1,8E,DF), HEX4_TO_WORDSIZE(69,69,62,61)};
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord brainpoolP256R1_b[]       = {HEX4_TO_WORDSIZE(26,DC,5C,6C), HEX4_TO_WORDSIZE(E9,4A,4B,44),
                                                                HEX4_TO_WORDSIZE(F3,30,B5,D9), HEX4_TO_WORDSIZE(BB,D7,7C,BF),
                                                                HEX4_TO_WORDSIZE(95,84,16,29), HEX4_TO_WORDSIZE(5C,F7,E1,CE),
                                                                HEX4_TO_WORDSIZE(6B,CC,DC,18), HEX4_TO_WORDSIZE(FF,8C,07,B6)};
   #endif
   #endif  

   #if SHARKSSL_ECC_USE_BRAINPOOLP384R1
   
   static const shtype_tWord brainpoolP384R1_prime[]  = {HEX4_TO_WORDSIZE(8C,B9,1E,82), HEX4_TO_WORDSIZE(A3,38,6D,28),
                                                               HEX4_TO_WORDSIZE(0F,5D,6F,7E), HEX4_TO_WORDSIZE(50,E6,41,DF),
                                                               HEX4_TO_WORDSIZE(15,2F,71,09), HEX4_TO_WORDSIZE(ED,54,56,B4),
                                                               HEX4_TO_WORDSIZE(12,B1,DA,19), HEX4_TO_WORDSIZE(7F,B7,11,23),
                                                               HEX4_TO_WORDSIZE(AC,D3,A7,29), HEX4_TO_WORDSIZE(90,1D,1A,71),
                                                               HEX4_TO_WORDSIZE(87,47,00,13), HEX4_TO_WORDSIZE(31,07,EC,53)};
   static const shtype_tWord brainpoolP384R1_order[]  = {HEX4_TO_WORDSIZE(8C,B9,1E,82), HEX4_TO_WORDSIZE(A3,38,6D,28),
                                                               HEX4_TO_WORDSIZE(0F,5D,6F,7E), HEX4_TO_WORDSIZE(50,E6,41,DF),
                                                               HEX4_TO_WORDSIZE(15,2F,71,09), HEX4_TO_WORDSIZE(ED,54,56,B3),
                                                               HEX4_TO_WORDSIZE(1F,16,6E,6C), HEX4_TO_WORDSIZE(AC,04,25,A7),
                                                               HEX4_TO_WORDSIZE(CF,3A,B6,AF), HEX4_TO_WORDSIZE(6B,7F,C3,10),
                                                               HEX4_TO_WORDSIZE(3B,88,32,02), HEX4_TO_WORDSIZE(E9,04,65,65)};
   
   static const shtype_tWord brainpoolP384R1_Gx[]     = {HEX4_TO_WORDSIZE(85,00,75,33), HEX4_TO_WORDSIZE(88,F5,3F,C1),
                                                               HEX4_TO_WORDSIZE(9C,DD,0D,CF), HEX4_TO_WORDSIZE(BA,CD,00,99),
                                                               HEX4_TO_WORDSIZE(06,8B,26,4E), HEX4_TO_WORDSIZE(F9,5C,21,64),
                                                               HEX4_TO_WORDSIZE(94,C3,78,E9), HEX4_TO_WORDSIZE(9D,20,2F,23),
                                                               HEX4_TO_WORDSIZE(66,FC,80,E8), HEX4_TO_WORDSIZE(D5,A8,86,BF),
                                                               HEX4_TO_WORDSIZE(A1,89,DE,EB), HEX4_TO_WORDSIZE(D4,38,FB,C1)};
   static const shtype_tWord brainpoolP384R1_Gy[]     = {HEX4_TO_WORDSIZE(2C,F4,A0,62), HEX4_TO_WORDSIZE(45,89,68,B5),
                                                               HEX4_TO_WORDSIZE(C6,16,25,66), HEX4_TO_WORDSIZE(4F,21,DD,B6),
                                                               HEX4_TO_WORDSIZE(A1,80,AC,D4), HEX4_TO_WORDSIZE(D5,71,92,17),
                                                               HEX4_TO_WORDSIZE(F8,83,09,A3), HEX4_TO_WORDSIZE(8F,07,37,FC),
                                                               HEX4_TO_WORDSIZE(F5,E0,D2,46), HEX4_TO_WORDSIZE(C7,99,6F,55),
                                                               HEX4_TO_WORDSIZE(E7,38,B3,31), HEX4_TO_WORDSIZE(0D,E1,40,A5)};
   static const shtype_tWord brainpoolP384R1_a[]      = {HEX4_TO_WORDSIZE(7C,33,80,21), HEX4_TO_WORDSIZE(A2,E8,C0,D1),
                                                               HEX4_TO_WORDSIZE(40,0A,8F,DF), HEX4_TO_WORDSIZE(42,B0,0C,60),
                                                               HEX4_TO_WORDSIZE(E7,FF,E9,E5), HEX4_TO_WORDSIZE(35,52,93,74),
                                                               HEX4_TO_WORDSIZE(93,67,71,B9), HEX4_TO_WORDSIZE(D7,F1,0D,B4),
                                                               HEX4_TO_WORDSIZE(75,D7,F3,FE), HEX4_TO_WORDSIZE(F1,57,B0,7B),
                                                               HEX4_TO_WORDSIZE(DB,26,B8,95), HEX4_TO_WORDSIZE(46,6C,3C,99)};
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord brainpoolP384R1_b[]      = {HEX4_TO_WORDSIZE(04,A8,C7,DD), HEX4_TO_WORDSIZE(22,CE,28,26),
                                                               HEX4_TO_WORDSIZE(8B,39,B5,54), HEX4_TO_WORDSIZE(16,F0,44,7C),
                                                               HEX4_TO_WORDSIZE(2F,B7,7D,E1), HEX4_TO_WORDSIZE(07,DC,D2,A6),
                                                               HEX4_TO_WORDSIZE(2E,88,0E,A5), HEX4_TO_WORDSIZE(3E,EB,62,D5),
                                                               HEX4_TO_WORDSIZE(7C,B4,39,02), HEX4_TO_WORDSIZE(95,DB,C9,94),
                                                               HEX4_TO_WORDSIZE(3A,B7,86,96), HEX4_TO_WORDSIZE(FA,50,4C,11)};
   #endif
   #endif  

   #if SHARKSSL_ECC_USE_BRAINPOOLP512R1
   
   static const shtype_tWord brainpoolP512R1_prime[]  = {HEX4_TO_WORDSIZE(AA,DD,9D,B8), HEX4_TO_WORDSIZE(DB,E9,C4,8B),
                                                               HEX4_TO_WORDSIZE(3F,D4,E6,AE), HEX4_TO_WORDSIZE(33,C9,FC,07),
                                                               HEX4_TO_WORDSIZE(CB,30,8D,B3), HEX4_TO_WORDSIZE(B3,C9,D2,0E),
                                                               HEX4_TO_WORDSIZE(D6,63,9C,CA), HEX4_TO_WORDSIZE(70,33,08,71),
                                                               HEX4_TO_WORDSIZE(7D,4D,9B,00), HEX4_TO_WORDSIZE(9B,C6,68,42),
                                                               HEX4_TO_WORDSIZE(AE,CD,A1,2A), HEX4_TO_WORDSIZE(E6,A3,80,E6),
                                                               HEX4_TO_WORDSIZE(28,81,FF,2F), HEX4_TO_WORDSIZE(2D,82,C6,85),
                                                               HEX4_TO_WORDSIZE(28,AA,60,56), HEX4_TO_WORDSIZE(58,3A,48,F3)};
   static const shtype_tWord brainpoolP512R1_order[]  = {HEX4_TO_WORDSIZE(AA,DD,9D,B8), HEX4_TO_WORDSIZE(DB,E9,C4,8B),
                                                               HEX4_TO_WORDSIZE(3F,D4,E6,AE), HEX4_TO_WORDSIZE(33,C9,FC,07),
                                                               HEX4_TO_WORDSIZE(CB,30,8D,B3), HEX4_TO_WORDSIZE(B3,C9,D2,0E),
                                                               HEX4_TO_WORDSIZE(D6,63,9C,CA), HEX4_TO_WORDSIZE(70,33,08,70),
                                                               HEX4_TO_WORDSIZE(55,3E,5C,41), HEX4_TO_WORDSIZE(4C,A9,26,19),
                                                               HEX4_TO_WORDSIZE(41,86,61,19), HEX4_TO_WORDSIZE(7F,AC,10,47),
                                                               HEX4_TO_WORDSIZE(1D,B1,D3,81), HEX4_TO_WORDSIZE(08,5D,DA,DD),
                                                               HEX4_TO_WORDSIZE(B5,87,96,82), HEX4_TO_WORDSIZE(9C,A9,00,69)};
   
   static const shtype_tWord brainpoolP512R1_Gx[]     = {HEX4_TO_WORDSIZE(5A,2B,A1,4C), HEX4_TO_WORDSIZE(09,94,E9,81),
                                                               HEX4_TO_WORDSIZE(87,1C,B5,CA), HEX4_TO_WORDSIZE(00,6D,45,73),
                                                               HEX4_TO_WORDSIZE(B2,B6,EA,37), HEX4_TO_WORDSIZE(F3,6D,3C,F7),
                                                               HEX4_TO_WORDSIZE(24,33,D7,6F), HEX4_TO_WORDSIZE(90,5C,87,37),
                                                               HEX4_TO_WORDSIZE(85,50,53,95), HEX4_TO_WORDSIZE(14,C0,1F,C8),
                                                               HEX4_TO_WORDSIZE(34,AB,04,14), HEX4_TO_WORDSIZE(6D,F5,5E,8F),
                                                               HEX4_TO_WORDSIZE(68,3E,4D,64), HEX4_TO_WORDSIZE(27,2C,02,A4),
                                                               HEX4_TO_WORDSIZE(C4,CE,96,09), HEX4_TO_WORDSIZE(51,61,D9,D3)};
   static const shtype_tWord brainpoolP512R1_Gy[]     = {HEX4_TO_WORDSIZE(8C,50,C9,D1), HEX4_TO_WORDSIZE(2A,CB,72,81),
                                                               HEX4_TO_WORDSIZE(9A,5E,D7,DA), HEX4_TO_WORDSIZE(87,0F,3F,9B),
                                                               HEX4_TO_WORDSIZE(58,5D,2B,77), HEX4_TO_WORDSIZE(CD,9D,3F,8C),
                                                               HEX4_TO_WORDSIZE(7C,17,0B,88), HEX4_TO_WORDSIZE(8F,E6,2F,DC),
                                                               HEX4_TO_WORDSIZE(36,0E,C7,75), HEX4_TO_WORDSIZE(59,8E,CC,3E),
                                                               HEX4_TO_WORDSIZE(BF,84,55,53), HEX4_TO_WORDSIZE(4C,85,94,90),
                                                               HEX4_TO_WORDSIZE(75,18,DF,6F), HEX4_TO_WORDSIZE(47,42,F3,25),
                                                               HEX4_TO_WORDSIZE(2F,90,66,29), HEX4_TO_WORDSIZE(25,04,2A,6D)};
   static const shtype_tWord brainpoolP512R1_a[]      = {HEX4_TO_WORDSIZE(5E,C4,F1,87), HEX4_TO_WORDSIZE(22,7D,2A,83),
                                                               HEX4_TO_WORDSIZE(B8,3B,84,FA), HEX4_TO_WORDSIZE(E2,D0,85,0C),
                                                               HEX4_TO_WORDSIZE(18,2D,0F,59), HEX4_TO_WORDSIZE(F4,1E,87,78),
                                                               HEX4_TO_WORDSIZE(A5,EC,30,C8), HEX4_TO_WORDSIZE(3F,80,D1,C7),
                                                               HEX4_TO_WORDSIZE(CF,8F,01,11), HEX4_TO_WORDSIZE(9E,6E,87,FF),
                                                               HEX4_TO_WORDSIZE(40,B0,4B,72), HEX4_TO_WORDSIZE(46,75,BB,AB),
                                                               HEX4_TO_WORDSIZE(14,E4,95,7D), HEX4_TO_WORDSIZE(AF,A7,D2,83),
                                                               HEX4_TO_WORDSIZE(DA,1F,8A,34), HEX4_TO_WORDSIZE(EA,10,C4,46)};
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord brainpoolP512R1_b[]      = {HEX4_TO_WORDSIZE(3D,F9,16,10), HEX4_TO_WORDSIZE(A8,34,41,CA),
                                                               HEX4_TO_WORDSIZE(EA,98,63,BC), HEX4_TO_WORDSIZE(2D,ED,5D,5A),
                                                               HEX4_TO_WORDSIZE(A8,25,3A,A1), HEX4_TO_WORDSIZE(0A,2E,F1,C9),
                                                               HEX4_TO_WORDSIZE(8B,9A,C8,B5), HEX4_TO_WORDSIZE(7F,11,17,A7),
                                                               HEX4_TO_WORDSIZE(2B,F2,C7,B9), HEX4_TO_WORDSIZE(E7,C1,AC,4D),
                                                               HEX4_TO_WORDSIZE(77,FC,94,CA), HEX4_TO_WORDSIZE(DC,08,3E,67),
                                                               HEX4_TO_WORDSIZE(98,40,50,B7), HEX4_TO_WORDSIZE(5E,BA,E5,DD),
                                                               HEX4_TO_WORDSIZE(28,09,BD,63), HEX4_TO_WORDSIZE(80,16,F7,23)};
   #endif
   #endif  

   #if SHARKSSL_ECC_USE_CURVE25519
   
   static const shtype_tWord curve25519_prime[]  = {HEX4_TO_WORDSIZE(7F,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                          HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                          HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                          HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,ED)};
   static const shtype_tWord curve25519_order[]  = {HEX4_TO_WORDSIZE(10,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                          HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                          HEX4_TO_WORDSIZE(14,DE,F9,DE), HEX4_TO_WORDSIZE(A2,F7,9C,D6),
                                                          HEX4_TO_WORDSIZE(58,12,63,1A), HEX4_TO_WORDSIZE(5C,F5,D3,ED)};
   static const shtype_tWord curve25519_Gx[]     = {HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                          HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                          HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                          HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,09)};
   static const shtype_tWord curve25519_Gy[]     = {HEX4_TO_WORDSIZE(20,AE,19,A1), HEX4_TO_WORDSIZE(B8,A0,86,B4),
                                                          HEX4_TO_WORDSIZE(E0,1E,DD,2C), HEX4_TO_WORDSIZE(77,48,D1,4C),
                                                          HEX4_TO_WORDSIZE(92,3D,4D,7E), HEX4_TO_WORDSIZE(6D,7C,61,B2),
                                                          HEX4_TO_WORDSIZE(29,E9,C5,A2), HEX4_TO_WORDSIZE(7E,CE,D3,D9)};
   
   static const shtype_tWord curve25519_a[]      = {HEX4_TO_WORDSIZE(00,46,8B,A6)};
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord curve25519_b[]      = {(shtype_tWord)0};
   #endif
   #endif  

   #if SHARKSSL_ECC_USE_CURVE448
   
   static const shtype_tWord curve448_prime[] = {HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                       HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                       HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                       HEX4_TO_WORDSIZE(FF,FF,FF,FE), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                       HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                       HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                       HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF)};
   static const shtype_tWord curve448_order[] = {HEX4_TO_WORDSIZE(3F,FF,FF,FF), HEX4_TO_WORDSIZE(FF,FF,FF,FF),
                                                       HEX4_TO_WORDSIZE(FF,FF,FF,FF), HEX4_TO_WORDSIZE(7C,CA,23,E9),
                                                       HEX4_TO_WORDSIZE(C4,4E,DB,49), HEX4_TO_WORDSIZE(AE,D6,36,90),
                                                       HEX4_TO_WORDSIZE(21,6C,C2,72), HEX4_TO_WORDSIZE(8D,C5,8F,55),
                                                       HEX4_TO_WORDSIZE(23,78,C2,92), HEX4_TO_WORDSIZE(AB,58,44,F3)};
   static const shtype_tWord curve448_Gx[] =    {HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,05)};
   static const shtype_tWord curve448_Gy[] =    {HEX4_TO_WORDSIZE(7D,23,5D,12), HEX4_TO_WORDSIZE(95,F5,B1,F6),
                                                       HEX4_TO_WORDSIZE(6C,98,AB,6E), HEX4_TO_WORDSIZE(58,32,6F,CE),
                                                       HEX4_TO_WORDSIZE(CB,AE,5D,34), HEX4_TO_WORDSIZE(F5,55,45,D0),
                                                       HEX4_TO_WORDSIZE(60,F7,5D,C2), HEX4_TO_WORDSIZE(8D,F3,F6,ED),
                                                       HEX4_TO_WORDSIZE(B8,02,7E,23), HEX4_TO_WORDSIZE(46,43,0D,21),
                                                       HEX4_TO_WORDSIZE(13,12,C4,B1), HEX4_TO_WORDSIZE(50,67,7A,F7),
                                                       HEX4_TO_WORDSIZE(6F,D7,22,3D), HEX4_TO_WORDSIZE(45,7B,5B,1A)};
   
   static const shtype_tWord curve448_a[] =     {HEX4_TO_WORDSIZE(00,00,98,A9), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,00,00),
                                                       HEX4_TO_WORDSIZE(00,00,00,00), HEX4_TO_WORDSIZE(00,00,98,A9)};
   #if SHARKSSL_ECC_VERIFY_POINT
   static const shtype_tWord curve448_b[] =     {(shtype_tWord)0};
   #endif
   #endif  

   baAssert(o);
   baAssert((rightsvalid >= SHARKSSL_EC_CURVE_ID_SECP256R1) || (rightsvalid <= SHARKSSL_EC_CURVE_ID_CURVE448));
   #if SHARKSSL_ECC_USE_EDWARDS
   if (rightsvalid < SHARKSSL_EC_CURVE_ID_CURVE25519)
   {
      o->setPoint = SharkSslECCurve_setPoint_NB;
      o->multiply = SharkSslECCurve_multiply_NB;
   }
   else
   {
      o->setPoint = SharkSslECCurve_setPoint_ED;
      o->multiply = SharkSslECCurve_multiply_ED;
   }
   #endif

   switch (rightsvalid)
   {
      #if SHARKSSL_ECC_USE_SECP256R1
      case SHARKSSL_EC_CURVE_ID_SECP256R1:
         SharkSslECCurve_constructor_(o, 256, SECP256R1);
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP384R1
      case SHARKSSL_EC_CURVE_ID_SECP384R1:
         SharkSslECCurve_constructor_(o, 384, SECP384R1);
         break;
      #endif

      #if SHARKSSL_ECC_USE_SECP521R1
      case SHARKSSL_EC_CURVE_ID_SECP521R1:
         SharkSslECCurve_constructor_(o, 521, SECP521R1);
         break;
      #endif

      #if SHARKSSL_ECC_USE_BRAINPOOLP256R1
      case SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1:
         SharkSslECCurve_constructor_(o, 256, brainpoolP256R1);
         break;
      #endif

      #if SHARKSSL_ECC_USE_BRAINPOOLP384R1
      case SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1:
         SharkSslECCurve_constructor_(o, 384, brainpoolP384R1);
         break;
      #endif

      #if SHARKSSL_ECC_USE_BRAINPOOLP512R1
      case SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1:
         SharkSslECCurve_constructor_(o, 512, brainpoolP512R1);
         break;
      #endif

      #if SHARKSSL_ECC_USE_CURVE25519
      case SHARKSSL_EC_CURVE_ID_CURVE25519:
         SharkSslECCurve_constructor_(o, 256, curve25519);
         break;
      #endif

      #if SHARKSSL_ECC_USE_CURVE448
      case SHARKSSL_EC_CURVE_ID_CURVE448:
         SharkSslECCurve_constructor_(o, 448, curve448);
         break;
      #endif

      default:
         memset(o, 0, sizeof(SharkSslECCurve));
   }

   return;
}


typedef void (*func_mulmod)(const shtype_t*, const shtype_t*, shtype_t*, shtype_t*, shtype_tWord*);
typedef void (*func_fmulmod)(const shtype_t*, const shtype_t*, shtype_t*, shtype_t*, shtype_tWord);

typedef struct
{
   shtype_t A, B, C, D, E, F;
   #if SHARKSSL_ECC_USE_EDWARDS
   shtype_t G;
   #endif
   #if (SHARKSSL_ECC_USE_NIST && (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS))
   func_mulmod mulmod;
   func_fmulmod fmulmod;
   #endif
   #if (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)
   shtype_t *factor_a;
   shtype_tWord mu;
   #endif
} SharkSslEC_temp;


#if (SHARKSSL_ECC_USE_NIST && (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS))
#define probehandler(x,y,z) brightnesslimit->fmulmod(x, y, z, mod, brightnesslimit->mu);
#define traceguest(x,y,z)  brightnesslimit->mulmod(x, y, z, mod, &brightnesslimit->D.mem[0]);
#define temp_fmulmod brightnesslimit.fmulmod
#define temp_mulmod  brightnesslimit.mulmod
static void registernotifier(const shtype_t *o1, const shtype_t *o2, shtype_t *deltadevices, shtype_t *cpuidfeature, shtype_tWord *afterhandler)
{
   hotplugpgtable(o1, o2, deltadevices);
   envdatamcheck(deltadevices, cpuidfeature, afterhandler);
}

static void branchlikely(const shtype_t *o1, const shtype_t *o2, shtype_t *deltadevices, shtype_t *cpuidfeature, shtype_tWord mu)
{
   writebytes(o1, o2, deltadevices, cpuidfeature, mu);
}

static void helpersetup(const shtype_t *o1, const shtype_t *o2, shtype_t *deltadevices, shtype_t *cpuidfeature, shtype_tWord *afterhandler)
{
   (void)afterhandler;
   hotplugpgtable(o1, o2, deltadevices);
   availableasids(deltadevices, cpuidfeature);
}

static void softlockupwatchdog(const shtype_t *o1, const shtype_t *o2, shtype_t *deltadevices, shtype_t *cpuidfeature, shtype_tWord mu)
{
   helpersetup(o1, o2, deltadevices, cpuidfeature, &mu);
}

#elif SHARKSSL_ECC_USE_NIST  
#define probehandler(x,y,z) hotplugpgtable(x, y, z); availableasids(z, mod)
#define traceguest(x,y,z)  hotplugpgtable(x, y, z); availableasids(z, mod)

#elif (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)  
#define probehandler(x,y,z) writebytes(x, y, z, mod, brightnesslimit->mu)
#define traceguest(x,y,z)  hotplugpgtable(x, y, z); envdatamcheck(z, mod, &brightnesslimit->D.mem[0])
#define temp_fmulmod(x,y,z,mod,mu)    writebytes(x, y, z, mod, mu)
#define temp_mulmod(x,y,z,mod,afterhandler) hotplugpgtable(x, y, z); envdatamcheck(z, mod, afterhandler)

#else
   

#endif


#if (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS)
void SharkSslEC_temp_setmulmod(SharkSslEC_temp *brightnesslimit, SharkSslECCurve *o)
{
   if (((shtype_tWord)-3) == o->a.beg[0])
   {
      #if (SHARKSSL_ECC_USE_NIST && (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS))
      brightnesslimit->mulmod = helpersetup;
      brightnesslimit->fmulmod = softlockupwatchdog;
      #endif
      brightnesslimit->factor_a = NULL;
      brightnesslimit->mu = 0;
   }
   else
   {
      #if (SHARKSSL_ECC_USE_NIST && (SHARKSSL_ECC_USE_BRAINPOOL || SHARKSSL_ECC_USE_EDWARDS))
      brightnesslimit->mulmod = registernotifier;
      brightnesslimit->fmulmod = branchlikely;
      #endif
      brightnesslimit->factor_a = &(o->a);
      brightnesslimit->mu = remapcfgspace(&o->prime);
   }
   return;
}

#else
#define SharkSslEC_temp_setmulmod(t,o)

#endif



int SharkSslECCurve_setPoint_NB(SharkSslECCurve *o, SharkSslECPoint *p)
{
   if ((void*)p != (void*)NULL)
   {
      if ((p->x.len <= o->G.x.len) && (p->y.len <= o->G.y.len))
      {
         #if SHARKSSL_ECC_VERIFY_POINT
         
         SharkSslEC_temp doublefnmul, *brightnesslimit;
         shtype_t *mod;
         shtype_tWord *tmp_b, *tmp_buf;
         U16 i;

         mod = &o->prime;
         brightnesslimit = &doublefnmul;  
         if ((timerwrite(&p->x, mod)) || (timerwrite(&p->y, mod)))
         {
            return 2;  
         }

         i = (o->prime.len << 1) + 1;  
         tmp_b = (shtype_tWord*)baMalloc(pcmciapdata(i * SHARKSSL__M * 6));
         if (tmp_b == NULL)
         {
            return 3;  
         }

         tmp_buf = (shtype_tWord*)selectaudio(tmp_b);

         traceaddress(&doublefnmul.A, i, tmp_buf); tmp_buf += i;
         traceaddress(&doublefnmul.B, i, tmp_buf); tmp_buf += i;
         traceaddress(&doublefnmul.C, i, tmp_buf); tmp_buf += i;
         traceaddress(&doublefnmul.D, i, tmp_buf); tmp_buf += i;
         traceaddress(&doublefnmul.E, i, tmp_buf); tmp_buf += i;
         traceaddress(&doublefnmul.F, i, tmp_buf);

         SharkSslEC_temp_setmulmod(&doublefnmul, o);

         traceguest(&p->x, &p->x, &doublefnmul.A);    
         traceguest(&p->x, &doublefnmul.A, &doublefnmul.B);   
         setupsdhci1(&doublefnmul.B, &o->b, mod);      
         #if (SHARKSSL_ECC_USE_NIST && SHARKSSL_ECC_USE_BRAINPOOL)
         if (NULL == doublefnmul.factor_a)  
         #endif
         #if SHARKSSL_ECC_USE_NIST
         {
            keypaddevice(&doublefnmul.B, &p->x, mod);
            keypaddevice(&doublefnmul.B, &p->x, mod);
            keypaddevice(&doublefnmul.B, &p->x, mod);  
         }
         #if SHARKSSL_ECC_USE_BRAINPOOL
         else
         #endif
         #endif
         #if SHARKSSL_ECC_USE_BRAINPOOL
         {
            
            doublefnmul.D.len = 1;
            doublefnmul.D.beg[0] = 1;
            writebytes(&doublefnmul.D, &o->a, &doublefnmul.C, &o->prime, doublefnmul.mu);
            traceguest(&doublefnmul.C, &p->x, &doublefnmul.A);  
            setupsdhci1(&doublefnmul.B, &doublefnmul.A, mod);    
            
            o->bits |= SharkSslECCurve_bits_Montgomery_flag;
         }
         #endif
         traceguest(&p->y, &p->y, &doublefnmul.A);  
         keypaddevice(&doublefnmul.A, &doublefnmul.B, mod);   
         blastscache(&doublefnmul.A);
         i = (U16)(doublefnmul.A.len - 1) | (U16)(doublefnmul.A.beg[0] & 0xFFFF);
         #if (SHARKSSL_BIGINT_WORDSIZE == 32)
         i |= (doublefnmul.A.beg[0] >> 16);
         #endif
         baFree((void*)tmp_b);
         if (i)
         {
            return 1;  
         }
         #elif SHARKSSL_ECC_USE_BRAINPOOL
         #if SHARKSSL_ECC_USE_NIST
         if (((shtype_tWord)-3) != o->a.beg[0])
         #endif
         {
            
            o->bits |= SharkSslECCurve_bits_Montgomery_flag;
         }
         #endif
         o->G.x = p->x;
         o->G.y = p->y;
      }
      else
      {
         memset(o, 0, sizeof(SharkSslECCurve));
         return 4;  
      }
   }

   return 0;
}


#if SHARKSSL_ECC_USE_EDWARDS

int SharkSslECCurve_setPoint_ED(SharkSslECCurve *o, SharkSslECPoint *p)
{
   if ((void*)p != (void*)NULL)
   {
      if (p->x.len <= o->G.x.len)
      {
         
         o->G.x = p->x;
         o->G.y = p->y;
      }
      else
      {
         memset(o, 0, sizeof(SharkSslECCurve));
         return 4;  
      }
   }

   return 0;
}
#endif


typedef struct  
{
   shtype_t x, y, z;
} SharkSslECPointJ;

#define SharkSslECPointJ_copy(s,d) \
        unassignedvector(&((s)->x), &((d)->x)); unassignedvector(&((s)->y), &((d)->y)); unassignedvector(&((s)->z), &((d)->z))


static void timerconfig(SharkSslECPointJ *p,
                                    shtype_t   *mod,
                                    SharkSslEC_temp  *brightnesslimit)
{
   probehandler(&p->y, &p->z, &brightnesslimit->A);
   setupsdhci1(&brightnesslimit->A, &brightnesslimit->A, mod);
   probehandler(&p->y, &p->y, &brightnesslimit->B);
   probehandler(&p->z, &p->z, &brightnesslimit->C);
   unassignedvector(&brightnesslimit->A, &p->z);
   probehandler(&p->x, &brightnesslimit->B, &brightnesslimit->A);
   setupsdhci1(&brightnesslimit->A, &brightnesslimit->A, mod);
   setupsdhci1(&brightnesslimit->A, &brightnesslimit->A, mod);
   probehandler(&brightnesslimit->B, &brightnesslimit->B, &brightnesslimit->D);
   unassignedvector(&brightnesslimit->D, &brightnesslimit->B);
   setupsdhci1(&brightnesslimit->B, &brightnesslimit->B, mod);
   setupsdhci1(&brightnesslimit->B, &brightnesslimit->B, mod);
   setupsdhci1(&brightnesslimit->B, &brightnesslimit->B, mod);
   #if SHARKSSL_ECC_USE_BRAINPOOL
   if (brightnesslimit->factor_a != NULL)  
   {
      probehandler(&p->x, &p->x, &brightnesslimit->D);
      unassignedvector(&brightnesslimit->D, &brightnesslimit->F);
      setupsdhci1(&brightnesslimit->D, &brightnesslimit->D, mod);
      setupsdhci1(&brightnesslimit->D, &brightnesslimit->F, mod);
      probehandler(&brightnesslimit->C, &brightnesslimit->C, &brightnesslimit->F);
      probehandler(brightnesslimit->factor_a, &brightnesslimit->F, &brightnesslimit->E);
      setupsdhci1(&brightnesslimit->D, &brightnesslimit->E, mod);
   }
   #if SHARKSSL_ECC_USE_NIST
   else
   #endif
   #endif
   #if SHARKSSL_ECC_USE_NIST
   {
      unassignedvector(&p->x, &brightnesslimit->E);
      keypaddevice(&brightnesslimit->E, &brightnesslimit->C, mod);
      setupsdhci1(&brightnesslimit->C, &p->x, mod);
      probehandler(&brightnesslimit->E, &brightnesslimit->C, &brightnesslimit->D);
      unassignedvector(&brightnesslimit->D, &brightnesslimit->E);
      setupsdhci1(&brightnesslimit->E, &brightnesslimit->E, mod);
      setupsdhci1(&brightnesslimit->D, &brightnesslimit->E, mod);
   }
   #endif
   probehandler(&brightnesslimit->D, &brightnesslimit->D, &brightnesslimit->F);
   keypaddevice(&brightnesslimit->F, &brightnesslimit->A, mod);
   keypaddevice(&brightnesslimit->F, &brightnesslimit->A, mod);
   unassignedvector(&brightnesslimit->F, &p->x);
   keypaddevice(&brightnesslimit->A, &brightnesslimit->F, mod);
   probehandler(&brightnesslimit->D, &brightnesslimit->A, &brightnesslimit->F);
   keypaddevice(&brightnesslimit->F, &brightnesslimit->B, mod);
   unassignedvector(&brightnesslimit->F, &p->y);
}


#if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
static void threadflush(SharkSslECPointJ *p,
                                     SharkSslECPointJ *g,
                                     shtype_t   *mod,
                                     SharkSslEC_temp  *brightnesslimit)
{
   
   probehandler(&p->z, &p->z, &brightnesslimit->A);                
   probehandler(&brightnesslimit->A, &g->x, &brightnesslimit->C);             
   probehandler(&g->z, &g->z, &brightnesslimit->B);                
   probehandler(&brightnesslimit->B, &p->x, &brightnesslimit->D);             
   probehandler(&brightnesslimit->B, &g->z, &brightnesslimit->E);             
   probehandler(&brightnesslimit->E, &p->y, &brightnesslimit->B);             
   probehandler(&brightnesslimit->A, &p->z, &brightnesslimit->E);             
   probehandler(&brightnesslimit->E, &g->y, &brightnesslimit->A);             
   keypaddevice(&brightnesslimit->C, &brightnesslimit->D, mod);                
   keypaddevice(&brightnesslimit->A, &brightnesslimit->B, mod);                
   if (eventtimeout(&brightnesslimit->C))
   {
      if (eventtimeout(&brightnesslimit->A))
      {
         timerconfig(p, mod, brightnesslimit);
      }
      else
      {
         baAssert(0);  
      }
   }
   else
   {
      probehandler(&brightnesslimit->C, &p->z, &brightnesslimit->E);             
      probehandler(&brightnesslimit->E, &g->z, &brightnesslimit->F);             
      unassignedvector(&brightnesslimit->F, &p->z);
      probehandler(&brightnesslimit->C, &brightnesslimit->C, &brightnesslimit->E);          
      probehandler(&brightnesslimit->D, &brightnesslimit->E, &brightnesslimit->F);          
      probehandler(&brightnesslimit->C, &brightnesslimit->E, &brightnesslimit->D);          
      probehandler(&brightnesslimit->A, &brightnesslimit->A, &brightnesslimit->C);          
      keypaddevice(&brightnesslimit->C, &brightnesslimit->D, mod);                
      keypaddevice(&brightnesslimit->C, &brightnesslimit->F, mod);                
      keypaddevice(&brightnesslimit->C, &brightnesslimit->F, mod);                
      unassignedvector(&brightnesslimit->C, &p->x);
      keypaddevice(&brightnesslimit->F, &brightnesslimit->C, mod);                
      probehandler(&brightnesslimit->B, &brightnesslimit->D, &brightnesslimit->E);          
      probehandler(&brightnesslimit->A, &brightnesslimit->F, &brightnesslimit->B);          
      keypaddevice(&brightnesslimit->B, &brightnesslimit->E, mod);                
      unassignedvector(&brightnesslimit->B, &p->y);
   }
}
#endif


static void deviceu2ootg(SharkSslECPointJ *p,
                                 SharkSslECPoint  *g,
                                 shtype_t   *mod,
                                 SharkSslEC_temp  *brightnesslimit)
{
   
   probehandler(&p->z, &p->z, &brightnesslimit->A);
   probehandler(&brightnesslimit->A, &g->x, &brightnesslimit->C);
   keypaddevice(&brightnesslimit->C, &p->x, mod);
   probehandler(&brightnesslimit->A, &p->z, &brightnesslimit->D);
   probehandler(&brightnesslimit->D, &g->y, &brightnesslimit->A);
   keypaddevice(&brightnesslimit->A, &p->y, mod);
   probehandler(&brightnesslimit->C, &p->z, &brightnesslimit->B);
   unassignedvector(&brightnesslimit->B, &p->z);
   probehandler(&brightnesslimit->C, &brightnesslimit->C, &brightnesslimit->B);
   probehandler(&brightnesslimit->B, &brightnesslimit->C, &brightnesslimit->F);
   unassignedvector(&p->x, &brightnesslimit->C);
   setupsdhci1(&brightnesslimit->C, &p->x, mod);
   probehandler(&brightnesslimit->C, &brightnesslimit->B, &brightnesslimit->D);
   setupsdhci1(&brightnesslimit->D, &brightnesslimit->F, mod);
   probehandler(&brightnesslimit->A, &brightnesslimit->A, &brightnesslimit->E);
   keypaddevice(&brightnesslimit->E, &brightnesslimit->D, mod);
   probehandler(&brightnesslimit->F, &p->y, &brightnesslimit->D);
   probehandler(&brightnesslimit->B, &p->x, &brightnesslimit->F);
   unassignedvector(&brightnesslimit->E, &p->x);
   keypaddevice(&brightnesslimit->F, &p->x, mod);
   probehandler(&brightnesslimit->F, &brightnesslimit->A, &brightnesslimit->E);
   keypaddevice(&brightnesslimit->E, &brightnesslimit->D, mod);
   unassignedvector(&brightnesslimit->E, &p->y);
}


static void panicblink(SharkSslECPointJ *j,
                                      SharkSslECPoint  *p,
                                      shtype_t   *mod,
                                      SharkSslEC_temp  *brightnesslimit)
{
   ioswabwdefault(&j->z, mod, &brightnesslimit->A.mem[0]);
   traceguest(&j->z, &j->z, &brightnesslimit->A);     
   traceguest(&j->z, &brightnesslimit->A, &brightnesslimit->B);  
   traceguest(&j->x, &brightnesslimit->A, &brightnesslimit->C);
   unassignedvector(&brightnesslimit->C, &p->x);
   traceguest(&j->y, &brightnesslimit->B, &brightnesslimit->C);
   unassignedvector(&brightnesslimit->C, &p->y);
}


#undef probehandler
#undef traceguest


#if (!SHARKSSL_ECDSA_ONLY_VERIFY)
int SharkSslECCurve_multiply_NB(SharkSslECCurve *o,
                                shtype_t *k,
                                SharkSslECPoint *deltadevices)
{
   SharkSslEC_temp brightnesslimit;
   shtype_tWord *tmp_b, *tmp_buf, bitmask;
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 4)
   #error SHARKSSL_ECC_MULT_SLIDING_WINDOW_K must be between 1 and 4
   #elif ((SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1) && (SHARKSSL_ECC_TIMING_RESISTANT))
   #error SHARKSSL_ECC_MULT_SLIDING_WINDOW_K must be 0 when SHARKSSL_ECC_TIMING_RESISTANT is enabled
   #endif
   #if (SHARKSSL_ECC_TIMING_RESISTANT)
   shtype_tWord m0;
   SharkSslECPointJ point[2];
   #else
   SharkSslECPointJ point[1];
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
   SharkSslECPointJ countshift[1 << (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K - 1)];
   #endif
   #endif
   U16 i, flash1resources;
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
   shtype_tWord sha256export;
   U8 bitcounter, accvalue;
   #endif

   i = o->prime.len;
   baAssert((deltadevices->x.len == i) && (deltadevices->y.len == i));
   #if SHARKSSL_ECC_TIMING_RESISTANT
   flash1resources  = (i * SHARKSSL__M) * (3 + 3 + 12);
   #else
   flash1resources  = (i * SHARKSSL__M) * (3 + 12);
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
   flash1resources += (i * SHARKSSL__M) * (3 * (1 << (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K - 1)));
   #endif
   #endif

   SharkSslEC_temp_setmulmod(&brightnesslimit, o);
   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      flash1resources += (6 * SHARKSSL__M);
   }
   #endif

   tmp_b = (shtype_tWord*)baMalloc(pcmciapdata(flash1resources));
   if (tmp_b == NULL)
   {
      return 1;
   }

   tmp_buf = (shtype_tWord*)selectaudio(tmp_b);

   #if SHARKSSL_ECC_TIMING_RESISTANT
   m0 = 0;
   #endif

   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      if (o->bits & SharkSslECCurve_bits_Montgomery_flag)
      {
         o->bits &= ~SharkSslECCurve_bits_Montgomery_flag;
         brightnesslimit.A.beg = brightnesslimit.A.mem = tmp_buf;
         brightnesslimit.A.len = o->prime.len + 1;
         deviceparse(&brightnesslimit.A);
         brightnesslimit.B.beg = brightnesslimit.B.mem = tmp_buf + brightnesslimit.A.len;
         brightnesslimit.A.beg[0] = 1;
         temp_mulmod(&brightnesslimit.A, &o->G.x, &brightnesslimit.B, &o->prime, tmp_buf + (i << 2));
         unassignedvector(&brightnesslimit.B, &o->G.x);
         temp_mulmod(&brightnesslimit.A, &o->G.y, &brightnesslimit.B, &o->prime, tmp_buf + (i << 2));
         unassignedvector(&brightnesslimit.B, &o->G.y);
      }
   }
   #endif
   traceaddress(&point[0].x, i, tmp_buf); tmp_buf += i;
   traceaddress(&point[0].y, i, tmp_buf); tmp_buf += i;
   traceaddress(&point[0].z, i, tmp_buf); tmp_buf += i;
   mipidplatform(&(o->G), &point[0]);
   deviceparse(&point[0].z);
   point[0].z.beg[i - 1] = 1;  

   #if SHARKSSL_ECC_TIMING_RESISTANT
   traceaddress(&point[1].x, i, tmp_buf); tmp_buf += i;
   traceaddress(&point[1].y, i, tmp_buf); tmp_buf += i;
   traceaddress(&point[1].z, i, tmp_buf); tmp_buf += i;
   SharkSslECPointJ_copy(&point[0], &point[1]);
   #endif

   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
   
   for (flash1resources = 0; flash1resources < (1 << (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K - 1)); flash1resources++)
   {
      traceaddress(&countshift[flash1resources].x, i, tmp_buf); tmp_buf += i;
      traceaddress(&countshift[flash1resources].y, i, tmp_buf); tmp_buf += i;
      traceaddress(&countshift[flash1resources].z, i, tmp_buf); tmp_buf += i;
   }
   #endif

   
   i <<= 1;
   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      i++;  
      brightnesslimit.A.beg = brightnesslimit.A.mem = tmp_buf;
      brightnesslimit.A.len = o->prime.len + 1;
      deviceparse(&brightnesslimit.A);
      brightnesslimit.A.beg[0] = 1;
      updatepmull(&brightnesslimit.A, &o->prime);
      blastscache(&brightnesslimit.A);
      unassignedvector(&brightnesslimit.A, &point[0].z);
   }
   #endif
   traceaddress(&brightnesslimit.A, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.B, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.C, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.D, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.E, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.F, i, tmp_buf);
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
   SharkSslECPointJ_copy(&point[0], &countshift[0]);
   timerconfig(&countshift[0], &o->prime, &brightnesslimit);
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 2)
   timerconfig(&countshift[0], &o->prime, &brightnesslimit);  
   #endif
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 3)
   timerconfig(&countshift[0], &o->prime, &brightnesslimit);  
   #endif
   
   for (i = 1; i < (1 << (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K - 1)); i++)
   {
      
      SharkSslECPointJ_copy(&countshift[i-1], &countshift[i]);
      deviceu2ootg(&countshift[i], &o->G, &o->prime, &brightnesslimit);
   }
   #endif

   blastscache(k);  
   bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
   #if SHARKSSL_ECC_TIMING_RESISTANT
   m0  = (SHARKSSL_BIGINT_WORDSIZE - 1);
   for (; bitmask > 0; bitmask >>= 1, m0--)
   #else
   for (; bitmask > 0; bitmask >>= 1)
   #endif
   {
      if (k->beg[0] & bitmask)
      {
         bitmask >>= 1;
         #if SHARKSSL_ECC_TIMING_RESISTANT
         m0--;
         #endif
         break;
      }
   }
   #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
   sha256export = 0;
   bitcounter = accvalue = 0;
   #endif
   for (i = 0; i < k->len; i++)
   {
      #if SHARKSSL_ECC_TIMING_RESISTANT
      for (; bitmask > 0; bitmask >>= 1, m0--)
      #else
      for (; bitmask > 0; bitmask >>= 1)
      #endif
      {
         timerconfig(&point[0], &o->prime, &brightnesslimit);

         #if SHARKSSL_ECC_TIMING_RESISTANT
         deviceu2ootg(&point[((~(k->beg[i] & bitmask)) >> m0) & 0x1], &o->G, &o->prime, &brightnesslimit);

         #else
         #if (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K > 1)
         if (0 == sha256export)
         {
            sha256export = (k->beg[i] & bitmask);
            
            if (sha256export && (i == (k->len - 1)) && (bitmask < (1 << (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K - 1))))
            {
               deviceu2ootg(&point[0], &o->G, &o->prime, &brightnesslimit);
               sha256export = 0;
            }
         }
         else
         {
            bitcounter++;
            accvalue <<= 1;
            if (k->beg[i] & bitmask)
            {
               accvalue |= 1;
            }
            if (bitcounter == (SHARKSSL_ECC_MULT_SLIDING_WINDOW_K - 1))
            {
               threadflush(&point[0], &countshift[accvalue], &o->prime, &brightnesslimit);
               bitcounter = 0;
               accvalue = 0;
               sha256export = 0;
            }
         }

         #else
         if (k->beg[i] & bitmask)
         {
            deviceu2ootg(&point[0], &o->G, &o->prime, &brightnesslimit);
         }
         #endif

         #endif  
      }

      bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
      #if SHARKSSL_ECC_TIMING_RESISTANT
      m0  = (SHARKSSL_BIGINT_WORDSIZE - 1);
      #endif
   }

   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      brightnesslimit.A.len = 1;
      brightnesslimit.A.beg[0] = 1;
      writebytes(&brightnesslimit.A, &point[0].x, &brightnesslimit.C, &o->prime, brightnesslimit.mu);
      writebytes(&brightnesslimit.A, &point[0].y, &brightnesslimit.D, &o->prime, brightnesslimit.mu);
      writebytes(&brightnesslimit.A, &point[0].z, &brightnesslimit.E, &o->prime, brightnesslimit.mu);
      unassignedvector(&brightnesslimit.C, &point[0].x);
      unassignedvector(&brightnesslimit.D, &point[0].y);
      unassignedvector(&brightnesslimit.E, &point[0].z);
   }
   #endif

   panicblink(&point[0], deltadevices, &o->prime, &brightnesslimit);

   baFree((void*)tmp_b);
   return 0;
}


#if SHARKSSL_ECC_USE_EDWARDS
int SharkSslECCurve_multiply_ED(SharkSslECCurve *o,
                                shtype_t *k,
                                SharkSslECPoint *deltadevices)
{
   

   SharkSslEC_temp brightnesslimit;
   shtype_t x;
   shtype_tWord *tmp_b, *tmp_buf, bitmask, bit;
   U16 i, flash1resources, bIndex;

   baAssert(o);
   baAssert(k);
   baAssert(deltadevices);
   i = o->prime.len;
   baAssert(deltadevices->x.len == i);
   i <<= 1;
   i++;  
   SharkSslEC_temp_setmulmod(&brightnesslimit, o);
   flash1resources = (i * SHARKSSL__M) * 7 + (o->prime.len * SHARKSSL__M);

   tmp_b = (shtype_tWord*)baMalloc(pcmciapdata(flash1resources));
   if (tmp_b == NULL)
   {
      return 1;
   }
   tmp_buf = (shtype_tWord*)selectaudio(tmp_b);

   traceaddress(&brightnesslimit.A, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.B, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.C, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.D, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.E, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.F, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.G, i, tmp_buf); tmp_buf += i;
   traceaddress(&x, o->prime.len, tmp_buf);

   brightnesslimit.A.len = o->prime.len + 1;
   deviceparse(&brightnesslimit.A);
   brightnesslimit.A.beg[0] = 1;
   
   unassignedvector(&o->G.x, &brightnesslimit.D);
   blastscache(&brightnesslimit.D);

   #if SHARKSSL_ECC_USE_CURVE25519
   if ((brightnesslimit.D.len == 1) && (brightnesslimit.D.beg[0] == 9))
   {
      
      #if (SHARKSSL_BIGINT_WORDSIZE == 8)
      brightnesslimit.D.len++;
      *(brightnesslimit.D.beg--) = 0x56;
      *(brightnesslimit.D.beg)   = 0x01;
      #else
      brightnesslimit.D.beg[0] = 0x0156;
      #endif
      shtype_t_copyfull(&brightnesslimit.D, &brightnesslimit.B);
   }
   else
   #endif
   #if SHARKSSL_ECC_USE_CURVE448
   if ((brightnesslimit.D.len == 1) && (brightnesslimit.D.beg[0] == 5))
   {
      
      brightnesslimit.D.len = (8 * 32 / SHARKSSL_BIGINT_WORDSIZE) + 1 - (32 / SHARKSSL_BIGINT_WORDSIZE);
      brightnesslimit.D.beg -= brightnesslimit.D.len - 1;
      brightnesslimit.D.beg[0] = 0x05;
      shtype_t_copyfull(&brightnesslimit.D, &brightnesslimit.B);
   }
   else
   #endif
   {
      
      temp_mulmod(&brightnesslimit.A, &brightnesslimit.D, &brightnesslimit.B, &o->prime, &brightnesslimit.E.mem[0]);
   }
   unassignedvector(&brightnesslimit.B, &x);
   
   deviceparse(&brightnesslimit.C);
   blastscache(&brightnesslimit.C);
   updatepmull(&brightnesslimit.A, &o->prime);
   #if SHARKSSL_ECC_USE_CURVE25519
   #if SHARKSSL_ECC_USE_CURVE448
   if (o->bits == 256)  
   #endif
   {
      updatepmull(&brightnesslimit.A, &o->prime);
   }
   #endif
   
   unassignedvector(&brightnesslimit.A, &brightnesslimit.D);
   blastscache(&brightnesslimit.A);
   blastscache(&brightnesslimit.D);

   blastscache(k);  
   bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
   for (bIndex = (SHARKSSL_BIGINT_WORDSIZE - 1); bitmask > 0; bitmask >>= 1, bIndex--)
   {
      if (k->beg[0] & bitmask)
      {
         break;
      }
   }
   bit = 0;
   for (i = 0; i < k->len; i++)
   {
      for (; bitmask > 0; bitmask >>= 1, bIndex--)
      {
         shtype_tWord kt = (k->beg[i] & bitmask) >> bIndex;
         bit ^= kt;
         shtype_t_swapConditional(&brightnesslimit.A, &brightnesslimit.B, (U32)bit);
         shtype_t_swapConditional(&brightnesslimit.C, &brightnesslimit.D, (U32)bit);
         bit = kt;
         shtype_t_copyfull(&brightnesslimit.A, &brightnesslimit.E);
         setupsdhci1(&brightnesslimit.E, &brightnesslimit.C, &o->prime);
         keypaddevice(&brightnesslimit.A, &brightnesslimit.C, &o->prime);
         shtype_t_copyfull(&brightnesslimit.B, &brightnesslimit.C);
         setupsdhci1(&brightnesslimit.C, &brightnesslimit.D, &o->prime);
         keypaddevice(&brightnesslimit.B, &brightnesslimit.D, &o->prime);
         temp_fmulmod(&brightnesslimit.E, &brightnesslimit.E, &brightnesslimit.D, &o->prime, brightnesslimit.mu);
         temp_fmulmod(&brightnesslimit.A, &brightnesslimit.A, &brightnesslimit.F, &o->prime, brightnesslimit.mu);
         temp_fmulmod(&brightnesslimit.C, &brightnesslimit.A, &brightnesslimit.G, &o->prime, brightnesslimit.mu);
         temp_fmulmod(&brightnesslimit.E, &brightnesslimit.B, &brightnesslimit.C, &o->prime, brightnesslimit.mu);
         shtype_t_copyfull(&brightnesslimit.G, &brightnesslimit.A);
         setupsdhci1(&brightnesslimit.G, &brightnesslimit.C, &o->prime);
         keypaddevice(&brightnesslimit.A, &brightnesslimit.C, &o->prime);
         temp_fmulmod(&brightnesslimit.A, &brightnesslimit.A, &brightnesslimit.B, &o->prime, brightnesslimit.mu);
         shtype_t_copyfull(&brightnesslimit.D, &brightnesslimit.C);
         keypaddevice(&brightnesslimit.C, &brightnesslimit.F, &o->prime);
         temp_fmulmod(&brightnesslimit.C, brightnesslimit.factor_a, &brightnesslimit.A, &o->prime, brightnesslimit.mu);
         setupsdhci1(&brightnesslimit.A, &brightnesslimit.D, &o->prime);
         temp_fmulmod(&brightnesslimit.A, &brightnesslimit.C, &brightnesslimit.E, &o->prime, brightnesslimit.mu);
         temp_fmulmod(&brightnesslimit.D, &brightnesslimit.F, &brightnesslimit.A, &o->prime, brightnesslimit.mu);
         temp_fmulmod(&x, &brightnesslimit.B, &brightnesslimit.D, &o->prime, brightnesslimit.mu);
         temp_fmulmod(&brightnesslimit.G, &brightnesslimit.G, &brightnesslimit.B, &o->prime, brightnesslimit.mu);
         shtype_t_copyfull(&brightnesslimit.E, &brightnesslimit.C);
      }

      bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
      bIndex = (SHARKSSL_BIGINT_WORDSIZE - 1);
   }

   #if 0  
   #if (SHARKSSL_ECC_USE_CURVE25519 && SHARKSSL_ECC_USE_CURVE448)
   if (o->bits == 256)  
   {
      i = 253;
      flash1resources = 4;
      bIndex = 2;
   }
   else  
   {
      i = 446;
      flash1resources = 224;
      bIndex = 1;
   }
   #endif
   
   unassignedvector(&brightnesslimit.C, &brightnesslimit.D);
   #if (SHARKSSL_ECC_USE_CURVE25519 && SHARKSSL_ECC_USE_CURVE448)
   for (; i > 0; i--)
   #elif SHARKSSL_ECC_USE_CURVE25519
   for (i = 253; i > 0; i--)
   #elif SHARKSSL_ECC_USE_CURVE448
   for (i = 446; i > 0; i--)
   #else
   #error internal error in SharkSslECCurve_multiply_ED
   #endif
   {
      temp_fmulmod(&brightnesslimit.C, &brightnesslimit.C, &brightnesslimit.E, &o->prime, brightnesslimit.mu);
      #if (SHARKSSL_ECC_USE_CURVE25519 && SHARKSSL_ECC_USE_CURVE448)
      if ((i == flash1resources) || (i == bIndex))
      #elif SHARKSSL_ECC_USE_CURVE25519
      if ((i == 4) || (i == 2))
      #else
      if ((i == 224) || (i == 1))
      #endif
      {
         #if 0
         unassignedvector(&brightnesslimit.E, &brightnesslimit.C);
         #else
         shtype_t_swapConditional(&brightnesslimit.C, &brightnesslimit.E, 1);
         #endif
      }
      else
      {
         temp_fmulmod(&brightnesslimit.E, &brightnesslimit.D, &brightnesslimit.C, &o->prime, brightnesslimit.mu);
      }
   }
   
   temp_fmulmod(&brightnesslimit.A, &brightnesslimit.C, &brightnesslimit.D, &o->prime, brightnesslimit.mu);
   
   brightnesslimit.A.len = 1;
   brightnesslimit.A.beg[0] = 1;
   temp_fmulmod(&brightnesslimit.A, &brightnesslimit.D, &brightnesslimit.E, &o->prime, brightnesslimit.mu);
   unassignedvector(&brightnesslimit.E, &deltadevices->x);

   #else  
   
   brightnesslimit.B.len = 1;
   brightnesslimit.B.beg[0] = 1;
   temp_fmulmod(&brightnesslimit.B, &brightnesslimit.C, &brightnesslimit.D, &o->prime, brightnesslimit.mu);
   temp_fmulmod(&brightnesslimit.B, &brightnesslimit.A, &brightnesslimit.C, &o->prime, brightnesslimit.mu);
   
   iommumapping(&brightnesslimit.D, &o->prime);
   temp_mulmod(&brightnesslimit.C, &brightnesslimit.D, &brightnesslimit.B, &o->prime, &brightnesslimit.E.mem[0]);
   unassignedvector(&brightnesslimit.B, &deltadevices->x);

   #endif

   deltadevices->y.mem = NULL;
   deltadevices->y.beg = NULL;
   deltadevices->y.len = 0;

   baFree((void*)tmp_b);
   return 0;
}
#endif
#endif  


#if SHARKSSL_ENABLE_EDDSA
#if SHARKSSL_ECC_USE_CURVE25519

#endif
#endif


#if SHARKSSL_ENABLE_ECDSA
int directalloc(SharkSslECCurve *S,
                              shtype_t *d,
                              SharkSslECCurve *T,
                              shtype_t *e,
                              SharkSslECPoint *deltadevices)
{
   SharkSslEC_temp brightnesslimit;
   shtype_tWord *tmp_b, *tmp_buf, bitmask;
   SharkSslECPointJ point[1];
   SharkSslECPoint sum;
   #if SHARKSSL_ECC_USE_BRAINPOOL
   SharkSslECPoint TG, *TGP;
   #endif
   U16 i, flash1resources;

   i = S->prime.len;
   #if SHARKSSL_ECC_USE_BRAINPOOL
   T->bits &= ~SharkSslECCurve_bits_Montgomery_flag;
   #endif
   if ((i != T->prime.len) || (S->bits != T->bits) || (d->len != e->len))
   {
      return 1;
   }

   baAssert(T->prime.beg == S->prime.beg);
   baAssert((deltadevices->x.len == i) && (deltadevices->y.len == i));

   flash1resources  = (i * SHARKSSL__M) * (3 + 2 + 12);

   SharkSslEC_temp_setmulmod(&brightnesslimit, S);
   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      flash1resources += (6 * SHARKSSL__M);
      
      flash1resources += (i * SHARKSSL__M) * 2;
   }
   #endif

   tmp_b = (shtype_tWord*)baMalloc(pcmciapdata(flash1resources));
   if (tmp_b == NULL)
   {
      return 1;
   }

   tmp_buf = (shtype_tWord*)selectaudio(tmp_b);

   traceaddress(&point[0].x, i, tmp_buf); tmp_buf += i;
   traceaddress(&point[0].y, i, tmp_buf); tmp_buf += i;
   traceaddress(&point[0].z, i, tmp_buf); tmp_buf += i;
   deviceparse(&point[0].z);
   point[0].z.beg[i - 1] = 1;  

   mipidplatform(&(S->G), &point[0]);

   receivebroadcast(&sum, i, tmp_buf, tmp_buf + i); tmp_buf += (i << 1);

   i <<= 1;
   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      receivebroadcast(&TG, T->prime.len, tmp_buf, tmp_buf + T->prime.len);
      tmp_buf += i;

      i++;  
      brightnesslimit.A.beg = brightnesslimit.A.mem = tmp_buf;
      brightnesslimit.A.len = T->prime.len + 1;
      deviceparse(&brightnesslimit.A);
      brightnesslimit.A.beg[0] = 1;
      updatepmull(&brightnesslimit.A, &T->prime);
      blastscache(&brightnesslimit.A);
      unassignedvector(&brightnesslimit.A, &point[0].z);  

      
      hotplugpgtable(&T->G.x, &point[0].z, &brightnesslimit.A);
      envdatamcheck(&brightnesslimit.A, &T->prime, tmp_buf + i);
      unassignedvector(&brightnesslimit.A, &TG.x);
      hotplugpgtable(&T->G.y, &point[0].z, &brightnesslimit.A);
      envdatamcheck(&brightnesslimit.A, &T->prime, tmp_buf + i);
      unassignedvector(&brightnesslimit.A, &TG.y);
   }
   #endif
   traceaddress(&brightnesslimit.A, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.B, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.C, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.D, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.E, i, tmp_buf); tmp_buf += i;
   traceaddress(&brightnesslimit.F, i, tmp_buf);


   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      deviceu2ootg(&point[0], &TG, &S->prime, &brightnesslimit);
      
      brightnesslimit.A.len = 1;
      brightnesslimit.A.beg[0] = 1;
      writebytes(&brightnesslimit.A, &point[0].x, &brightnesslimit.C, &T->prime, brightnesslimit.mu);
      writebytes(&brightnesslimit.A, &point[0].y, &brightnesslimit.D, &T->prime, brightnesslimit.mu);
      writebytes(&brightnesslimit.A, &point[0].z, &brightnesslimit.E, &T->prime, brightnesslimit.mu);
      unassignedvector(&brightnesslimit.C, &point[0].x);
      unassignedvector(&brightnesslimit.D, &point[0].y);
      unassignedvector(&brightnesslimit.E, &point[0].z);
   }
   #if SHARKSSL_ECC_USE_NIST
   else
   #endif
   #endif
   #if SHARKSSL_ECC_USE_NIST
   {
      
      deviceu2ootg(&point[0], &T->G, &S->prime, &brightnesslimit);
   }
   #endif

   panicblink(&point[0], &sum, &S->prime, &brightnesslimit);

   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      brightnesslimit.A.len = T->prime.len + 1;
      deviceparse(&brightnesslimit.A);
      brightnesslimit.A.beg[0] = 1;
      updatepmull(&brightnesslimit.A, &T->prime);
      blastscache(&brightnesslimit.A);
      unassignedvector(&brightnesslimit.A, &point[0].z);

      hotplugpgtable(&sum.x, &point[0].z, &brightnesslimit.A);
      envdatamcheck(&brightnesslimit.A, &T->prime, &brightnesslimit.B.beg[0]);
      unassignedvector(&brightnesslimit.A, &sum.x);
      hotplugpgtable(&sum.y, &point[0].z, &brightnesslimit.A);
      envdatamcheck(&brightnesslimit.A, &T->prime, &brightnesslimit.B.beg[0]);
      unassignedvector(&brightnesslimit.A, &sum.y);
      TGP = &TG;
   }
   #if SHARKSSL_ECC_USE_NIST
   else
   #endif
   #endif
   #if SHARKSSL_ECC_USE_NIST
   {
      
      point[0].z.len = S->prime.len;
      deviceparse(&point[0].z);
      point[0].z.beg[S->prime.len - 1] = 1;  
      #if SHARKSSL_ECC_USE_BRAINPOOL
      TGP = &T->G;
      #endif
   }
   #endif

   while ((e->beg[0] == 0) && (d->beg[0] == 0) && (e->len > 1) && (d->len > 1))
   {
      e->beg++;
      e->len--;
      d->beg++;
      d->len--;
   }
   bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
   for (; bitmask > 0; bitmask >>= 1)
   {
      if (e->beg[0] & bitmask)
      {
         if (d->beg[0] & bitmask)
         {
            mipidplatform(&sum, &point[0]);
         }
         else
         #if SHARKSSL_ECC_USE_BRAINPOOL
         {
            mipidplatform(TGP, &point[0]);
         }
         #else
         {
            mipidplatform(&(T->G), &point[0]);
         }
         #endif
      }
      else if (d->beg[0] & bitmask)
      {
         mipidplatform(&(S->G), &point[0]);
      }
      else
      {
         continue;
      }

      bitmask >>= 1;
      break;
   }

   for (i = 0; i < e->len; i++)
   {
      for (; bitmask > 0; bitmask >>= 1)
      {
         timerconfig(&point[0], &S->prime, &brightnesslimit);

         if (e->beg[i] & bitmask)
         {
            if (d->beg[i] & bitmask)
            {
               deviceu2ootg(&point[0], &sum, &S->prime, &brightnesslimit);
            }
            else
            #if SHARKSSL_ECC_USE_BRAINPOOL
            {
               deviceu2ootg(&point[0], TGP, &S->prime, &brightnesslimit);
            }
            #else
            {
               deviceu2ootg(&point[0], &T->G, &S->prime, &brightnesslimit);
            }
            #endif
         }
         else if (d->beg[i] & bitmask)
         {
            deviceu2ootg(&point[0], &S->G, &S->prime, &brightnesslimit);
         }
      }

      bitmask = (shtype_tWord)((shtype_tWord)1 << (SHARKSSL_BIGINT_WORDSIZE - 1));
   }

   #if SHARKSSL_ECC_USE_BRAINPOOL
   #if SHARKSSL_ECC_USE_NIST
   if (brightnesslimit.factor_a != NULL)
   #endif
   {
      
      brightnesslimit.A.len = 1;
      brightnesslimit.A.beg[0] = 1;
      writebytes(&brightnesslimit.A, &point[0].x, &brightnesslimit.C, &T->prime, brightnesslimit.mu);
      writebytes(&brightnesslimit.A, &point[0].y, &brightnesslimit.D, &T->prime, brightnesslimit.mu);
      writebytes(&brightnesslimit.A, &point[0].z, &brightnesslimit.E, &T->prime, brightnesslimit.mu);
      unassignedvector(&brightnesslimit.C, &point[0].x);
      unassignedvector(&brightnesslimit.D, &point[0].y);
      unassignedvector(&brightnesslimit.E, &point[0].z);
   }
   #endif

   panicblink(&point[0], deltadevices, &S->prime, &brightnesslimit);

   baFree((void*)tmp_b);
   return 0;
}
#endif  


#if SHARKSSL_ENABLE_ECCKEY_CREATE
extern U8 controllerregister(U16 defaultsdhci1);

SHARKSSL_API int SharkSslECCKey_createEx(SharkSslECCKey *mcbspplatform, U16 defaultsdhci1, void* iospacestart, sharkssl_rngfunc smartflush)
{
   static const shtype_tWord w_one = 0x1;
   SharkSslECCurve nandflashpartition;
   SharkSslECPoint Q;
   shtype_t one, d, order;
   U8 *buf;
   int buttonsbuffalo = 0;
   U8  allockuser, plen;

   *mcbspplatform = NULL;
   plen = controllerregister(defaultsdhci1);
   if (0 == plen)
   {
      return -1;  
   }
   allockuser = (U8)((plen + 3) & ~3);  
   buttonsbuffalo = (int)(((unsigned int)allockuser << 1) + allockuser + 8);
   *mcbspplatform = buf = (U8*)baMalloc(buttonsbuffalo);
   if (NULL == buf)
   {
      return -1;  
   }
   if (smartflush ? smartflush(iospacestart, buf, allockuser + 8) : sharkssl_rng(buf, allockuser + 8))
   {
      baFree(buf);
      return -2;  
   }

   onenandpartitions(&one, sizeof(shtype_tWord) * 8, &w_one);
   onenandpartitions(&d, ((allockuser + 8) * 8), buf);
   clearerrors(&nandflashpartition, defaultsdhci1);
   #if SHARKSSL_ECC_USE_SECP521R1
   if (allockuser > plen)
   {
	   d.beg[0] &= nandflashpartition.prime.beg[0];
   }
   #endif

   
   buf += allockuser + 8;
   onenandpartitions(&order, (nandflashpartition.prime.len * SHARKSSL_BIGINT_WORDSIZE), buf);  
   unassignedvector(&(nandflashpartition.order), &order);
   updatepmull(&order, &one);
   suspendfinish(&d, &order);
   resolverelocs(&d, &one);

   updatefrequency(&Q, (nandflashpartition.prime.len * SHARKSSL_BIGINT_WORDSIZE), buf , buf + allockuser);  
   unregisterskciphers(&nandflashpartition, &d, &Q);

   buf = *mcbspplatform;
   buf[0] = 0x30;
   buf[1] = 0x82;
   buf[2] = buf[3] = 0x00;
   buf[4] = 0x02;  
   buf[5] = buf[7] = plen;
   buf[6] = (U8)defaultsdhci1;
   memmove_endianess(&buf[8], &buf[8], (allockuser << 1) + allockuser);
   #if SHARKSSL_ECC_USE_SECP521R1
   if (allockuser > plen)
   {
	   allockuser -= plen;
	   memmove(&buf[8], &buf[8 + allockuser], plen);
	   memmove(&buf[8 + plen], &buf[8 + plen + (allockuser * 2)], plen);
	   memmove(&buf[8 + (plen * 2)], &buf[8 + (plen * 2) + (allockuser * 2) + allockuser], plen);
   }
   #endif

   return buttonsbuffalo;
}

#endif

#endif  
#endif


#ifndef BA_LIB
#define BA_LIB 1
#endif

#include "WebSocketServer.h"

static int
simulateldrstr(WSS* o, int flushoffset)
{
   SoDispCon_closeCon((SoDispCon*)o);
   o->cb->closeFp(o->cb, o, flushoffset);
   return 1;
}


static int
ictlrmatch(WSS* o, int flushoffset, int sectionsearly)
{
   U8* buf;
   DynBuffer_expand(&o->db, o->db.expandSize);
   buf = (U8*)DynBuffer_getBuf(&o->db);
   if(!buf)
      return -1;
   buf[0] = 0x88; 
   if(flushoffset)
   {
      buf[1] = 2; 
      buf[2] = (U8)((unsigned)flushoffset >> 8);
      buf[3]= (U8)flushoffset;
   }
   else
      buf[1] = 0; 
   SoDispCon_sendDataNT((SoDispCon*)o, buf, flushoffset ? 4 : 2);
   if(sectionsearly)
      return simulateldrstr(o, flushoffset);
   return -1;
}


static int
ahashqueued(WSS* o)
{
   U32 pl; 
   BufPrint* bp = (BufPrint*)&o->db;
  L_more:
   if( ! o->endOfPacketIx )
   {
      
      if(bp->cursor < 6)
         return 0;
      if( !(0x80 & bp->buf[0]) ) 
      {
         
         return ictlrmatch(o, 1002, TRUE);
      }
      pl = bp->buf[1];
      if( !(0x80 & pl) )
      {
         
         return ictlrmatch(o, 1002, TRUE);
      }
      pl &= 0x7F;
      if( pl >= 126 ) 
      {
         
         if(bp->cursor < 8)
            return 0;
         if( pl > 126 )
         {
            
            return ictlrmatch(o, 1003, TRUE);
         }
         
         pl = (U8)bp->buf[2];
         pl <<= 8;
         pl |= (U8)bp->buf[3];
         o->endOfPacketIx = 8 + (int)pl;
      }
      else
         o->endOfPacketIx = 6 + (int)pl;
   }
   if(bp->cursor >= o->endOfPacketIx)
   {
      U32 i;
      U8 ntosd2devices;
      U8* prussresources;
      U8* sdramstandby;
      int idmapstart, sffsdrnandflash;
      o->endOfPacketIx=0;
      pl = bp->buf[1] & 0x7F;
      if( pl == 126 )
      {
         pl = (U8)bp->buf[2];
         pl <<= 8;
         pl |= (U8)bp->buf[3];
         prussresources = (U8*)bp->buf+4;
         idmapstart=8;
      }
      else
      {
         prussresources = (U8*)bp->buf+2;
         idmapstart=6;
      }
      sdramstandby = prussresources+4;
      
      for(i=0 ; i < pl ; i++,sdramstandby++)
      {
          
         *sdramstandby ^= prussresources[i&3];
      }
      i=FALSE;
      switch(bp->buf[0] & 0x0F) 
      {
         case 0x1: 
            i=TRUE;
            
         case 0x2: 
            ntosd2devices=*sdramstandby;
            *sdramstandby=0;  
            o->cb->frameFp(o->cb, o, bp->buf+idmapstart, pl, i);
            *sdramstandby=ntosd2devices;
            break;

         case 0x8: 
            if(pl >= 2 && pl < 126)
            {
               pl = (U8)bp->buf[idmapstart];
               pl <<= 8;
               pl |= (U8)bp->buf[idmapstart+1];
            }
            else
               pl=0;
            return simulateldrstr(o, (int)pl);

         case 0x9: 
            if(pl > 125)
               return ictlrmatch(o, 1009, TRUE);
            bp->buf[0] = (U8)0x8A; 
            bp->buf[1]= 0x7F & (U8)pl; 
            if( (sffsdrnandflash=SoDispCon_sendDataNT((SoDispCon*)o,bp->buf,pl+2)) < 0)
               return simulateldrstr(o, sffsdrnandflash);
            if(o->cb->pingFp)
               o->cb->pingFp(o->cb, o, pl ? bp->buf+idmapstart : 0, pl);
            break;

         case 0xA: 
            break;

         default:
            return ictlrmatch(o, 1002, TRUE);
      }
      
      i = (int)(((U8*)bp->buf+bp->cursor)-sdramstandby);
      if(i > 0)
      {
         memmove(bp->buf, sdramstandby, i);
         bp->cursor=i;
         goto L_more;
      }
      else
      {
         DynBuffer_release((DynBuffer*)bp);
      }
   }
   return 0;
}



static void
multientry(SoDispCon* fdc37m81xconfig)
{
   int len;
   WSS* o = (WSS*)fdc37m81xconfig;
   BufPrint* bp = (BufPrint*)&o->db;
   do
   {
      if( (len=DynBuffer_expand(&o->db, o->db.expandSize)) != 0)
      {
         simulateldrstr(o, E_MALLOC);
         return;
      }
      len = SoDispCon_readData((SoDispCon*)o, bp->buf+bp->cursor, bp->bufSize-bp->cursor, FALSE);
      if(len)
      {
         if(len < 0)
         {
            simulateldrstr(o, len);
            return;
         }
         bp->cursor += len;
         len = ahashqueued(o); 
      }
   } while(len == 0 && SoDispCon_hasMoreData((SoDispCon*)o));
   if(len && len != 1) 
      SoDispCon_closeCon((SoDispCon*)o);
}


BA_API int
WSS_connect(WSS* o, HttpConnection* con)
{
   if( ! SoDispCon_isValid((SoDispCon*)con) )
      return -1;
   if(SoDispCon_isValid((SoDispCon*)o))
      SoDispCon_closeCon((SoDispCon*)o);
   SoDispCon_moveCon((SoDispCon*)con, (SoDispCon*)o);
   SoDisp_addConnection(((SoDispCon*)o)->dispatcher, (SoDispCon*)o);
   SoDisp_activateRec(((SoDispCon*)o)->dispatcher, (SoDispCon*)o);
   BufPrint_erase((BufPrint*)&o->db);
   o->endOfPacketIx=0;
   return 0;
}


BA_API int
WSS_upgrade(WSS* o, HttpRequest* req)
{
   if(HttpRequest_wsUpgrade(req))
   {
      HttpResponse_sendError2(
         HttpRequest_getResponse(req), 400, "\116\157\164\040\141\040\127\145\142\123\157\143\153\145\164\040\122\145\161\165\145\163\164");
      return -1;
   }
   return WSS_connect(o, HttpRequest_getConnection(req));
}


BA_API int
WSS_rawWrite(WSS* o, const void* alloccontroller, int len, int buddyavail)
{
   U8 buf[4];
   int sffsdrnandflash;
   buf[0] = 0x80 | (U8)buddyavail;
   if(len >= 126)
   {
      buf[1] = 126;
      buf[2] = (U16)len >> 8;
      buf[3] = (U8)len;
   }
   else
      buf[1] = (U8)len;
   sffsdrnandflash = SoDispCon_sendDataNT((SoDispCon*)o, buf, len >= 126 ? 4 : 2);
   if(sffsdrnandflash >= 0)
      sffsdrnandflash = SoDispCon_sendDataNT((SoDispCon*)o, alloccontroller, len);
   return sffsdrnandflash < 0 ? sffsdrnandflash : 0;
}



BA_API int
WSS_close(WSS* o, int suspendstate)
{
   if( ! SoDispCon_isValid((SoDispCon*)o) )
      return -1;
   ictlrmatch(o, suspendstate <= 0 ? 1000 : suspendstate, FALSE);
   SoDispCon_closeCon((SoDispCon*)o);
   return 0;
}


BA_API void
WSS_constructor(
   WSS* o, WSSCB* cb, SoDisp* sha256start, int allocpages, int heartclocksource)
{
   memset(o, 0, sizeof(WSS));
   if(heartclocksource < allocpages)
      heartclocksource = allocpages;
   SoDispCon_constructor((SoDispCon*)o, sha256start, multientry);
   DynBuffer_constructor(&o->db, allocpages, heartclocksource, 0, 0);
   o->cb=cb;
}


BA_API void
WSS_destructor(WSS* o)
{
   SoDispCon_destructor((SoDispCon*)o);
   DynBuffer_destructor(&o->db);
}

