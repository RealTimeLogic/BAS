/*
 *     ____             _________                __                _     
 *    / __ \___  ____ _/ /_  __(_)___ ___  ___  / /   ____  ____ _(_)____
 *   / /_/ / _ \/ __ `/ / / / / / __ `__ \/ _ \/ /   / __ \/ __ `/ / ___/
 *  / _, _/  __/ /_/ / / / / / / / / / / /  __/ /___/ /_/ / /_/ / / /__  
 * /_/ |_|\___/\__,_/_/ /_/ /_/_/ /_/ /_/\___/_____/\____/\__, /_/\___/  
 *                                                       /____/          
 *
 *                  Barracuda Embedded Web-Server
 *
 ****************************************************************************
 *			      HEADER
 *
 *   $Id: CspRunTm.h 5670 2025-10-06 21:06:24Z wini $
 *
 *   COPYRIGHT:  Real Time Logic, 2006 - 2023
 *
 *   This software is copyrighted by and is the sole property of Real
 *   Time Logic LLC.  All rights, title, ownership, or other interests in
 *   the software remain the property of Real Time Logic LLC.  This
 *   software may only be used in accordance with the terms and
 *   conditions stipulated in the corresponding license agreement under
 *   which the software has been supplied.  Any unauthorized use,
 *   duplication, transmission, distribution, or disclosure of this
 *   software is expressly forbidden.
 *                                                                        
 *   This Copyright notice may not be removed or modified without prior
 *   written consent of Real Time Logic LLC.
 *                                                                         
 *   Real Time Logic LLC. reserves the right to modify this software
 *   without notice.
 *
 *               http://www.realtimelogic.com
 ****************************************************************************
 *
 *
 */
#ifndef __CspRunTm_h
#define __CspRunTm_h

#include "HttpServer.h"
#ifndef SharkSslStandalone
#include "CspCompileCommon.h"
#endif

/* Struct for building a minimum GZIP header. See RFC 1952 for GZIP format.
 * We do not need FLG.FEXTRA, FLG.FNAME, FLG.FCOMMENT & FLG.FHCRC 
 *
 *  <--------------- GZIP header ---------->
 *  +---+---+---+---+---+---+---+---+---+---+=============+--4--+---4--+
 *  |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | compr block | crc | size |
 *  +---+---+---+---+---+---+---+---+---+---+=============+--4--+------+
 */
#ifndef __DOXYGEN__
struct GzipHeader
{
      U8 id1;
      U8 id2;
      U8 compressionMethod;
      U8 flags;
      U8 unixTime[4];
      U8 extraflag; /* Compression type */
      U8 operatingSystem;
}
#ifdef __GNUC__
__attribute__((__packed__))
#endif
;

typedef struct GzipHeader GzipHeader;
#endif

#define FLG_FTEXT    ( 1 << 0 )
#define FLG_FHCRC    ( 1 << 1 )
#define FLG_FEXTRA   ( 1 << 2 )
#define FLG_FNAME    ( 1 << 3 )
#define FLG_FCOMMENT ( 1 << 4 )

#ifndef __DOXYGEN__
struct GzipTrailer
{
      U8 crc[4];
      U8 uncompressedSize[4];
}
#ifdef __GNUC__
__attribute__((__packed__))
#endif
;

typedef struct GzipTrailer GzipTrailer;
#endif

struct CspReader;


/** Prototype for the CspReader callback function.
    @ingroup CSP
\param o CspReader
\param data a pointer to the data area where the data read should be
copied.
\param offset the offset position into the "dat" file.
\param size number of bytes to read.
\param blockStart TRUE if this is the beginning of a block. All blocks
are protected by a magic number. The httpDiskRead function can use
this for integrity check.
 */
typedef  int (*CspReader_Read)(
   struct CspReader* o, void* data, U32 offset, U32 size, int blockStart);

#define CspReader_validFlag 0xA503

/** Abstract interface class for reading the "dat" file generated by
 <a href="../../CspTools.html#CspLink">HttpLink</a>.
    \sa FileCspReader
    \sa CspReader_Read
*/
typedef struct CspReader
{
#ifdef __cplusplus
      void *operator new(size_t s) { return ::baMalloc(s); }
      void operator delete(void* d) { if(d) ::baFree(d); }
      void *operator new(size_t, void *place) { return place; }
      void operator delete(void*, void *) { }

      /** Returns true if the reader object is valid */
      bool isValid();
      int read(void* data, U32 offset, U32 size, bool blockStart);
      void setIsValid() { validFlag=CspReader_validFlag; }
   private:
#endif
      CspReader_Read readCB;
      U16 validFlag;
} CspReader;

#ifdef __cplusplus
extern "C" {
#endif
#define CspReader_constructor(o, httpDiskRead) do {\
        (o)->readCB = httpDiskRead; \
        (o)->validFlag = (U16)~CspReader_validFlag; \
}while(0)

#define CspReader_isValid(o) (((CspReader*)o)->readCB != 0 && \
                             ((CspReader*)o)->validFlag == CspReader_validFlag)
#define CspReader_setIsValid(o) ((CspReader*)o)->validFlag=CspReader_validFlag
#define CspReader_read(httpData, data, offset, size, blockStart) \
  (*((CspReader*)httpData)->readCB)((CspReader*)httpData, data, \
                                 offset, size, blockStart)
#ifdef __cplusplus
}
inline bool CspReader::isValid() {
   return CspReader_isValid(this) ? true : false;
}
inline int CspReader::read(void* data, U32 offset, U32 size, bool blockStart) {
   return CspReader_read(this, data, offset, size, blockStart);
}
#endif

#ifndef SharkSslStandalone

#ifndef __DOXYGEN__
typedef struct HttpStaticMemPage
{
      HttpPage page;
      CspReader* data;
      U32 time;
      HttpDiskBlock mimeBlock;
      HttpDiskBlock payloadBlock;
      char isCompressed;
} HttpStaticMemPage;
#endif

#ifdef __cplusplus
extern "C" {
#endif
BA_API int httpWriteSection(
   CspReader* data, HttpResponse* reply,U32 offset,U32 size);
BA_API int httpUnzipAndWrite(CspReader* data,
                      HttpResponse* response,
                      U32 offset,
                      U32 size,
                      GzipHeader* gzipH);
BA_API void httpRawWrite(CspReader* data,
                  HttpRequest* request,
                  HttpResponse* response,
                  U32 time,
                  U32 offset,
                  U32 size,
                  GzipHeader* gzipH,
                  GzipTrailer* gzipT);

BA_API int cspCheckCondition(HttpRequest* request, HttpResponse* response);

BA_API void HttpStaticMemPage_loadAndInit(HttpStaticMemPage* o,
                                   CspReader* data, U32 time,
                                   U32 nameOffset, U32 nameSize,
                                   U32 mimeOffset, U32 mimeSize,
                                   U32 payloadOffset, U32 payloadSize,
                                   char isCompressed, HttpDir* parent);
   
BA_API void HttpDynamicMemPage_loadAndInit(
   HttpPage* o, CspReader* data, U32 size,
   HttpPage_Service fptr,
   U32 nameOffset, U32 nameSize);
#ifdef __cplusplus
}
#endif

#endif

#endif /* __CspRunTm_h */





