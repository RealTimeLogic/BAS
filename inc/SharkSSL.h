/*
 *     ____             _________                __                _
 *    / __ \___  ____ _/ /_  __(_)___ ___  ___  / /   ____  ____ _(_)____
 *   / /_/ / _ \/ __ `/ / / / / / __ `__ \/ _ \/ /   / __ \/ __ `/ / ___/
 *  / _, _/  __/ /_/ / / / / / / / / / / /  __/ /___/ /_/ / /_/ / / /__
 * /_/ |_|\___/\__,_/_/ /_/ /_/_/ /_/ /_/\___/_____/\____/\__, /_/\___/
 *                                                       /____/
 *
 *                 SharkSSL Embedded SSL/TLS Stack
 ****************************************************************************
 *   PROGRAM MODULE
 *
 *   $Id: SharkSSL.h 5637 2025-03-02 21:51:18Z gianluca $
 *
 *   COPYRIGHT:  Real Time Logic LLC, 2010 - 2025
 *
 *   This software is copyrighted by and is the sole property of Real
 *   Time Logic LLC.  All rights, title, ownership, or other interests in
 *   the software remain the property of Real Time Logic LLC.  This
 *   software may only be used in accordance with the terms and
 *   conditions stipulated in the corresponding license agreement under
 *   which the software has been supplied.  Any unauthorized use,
 *   duplication, transmission, distribution, or disclosure of this
 *   software is expressly forbidden.
 *
 *   This Copyright notice may not be removed or modified without prior
 *   written consent of Real Time Logic LLC.
 *
 *   Real Time Logic LLC. reserves the right to modify this software
 *   without notice.
 *
 *               http://www.realtimelogic.com
 *               http://www.sharkssl.com
 ****************************************************************************
 *
 */
#ifndef _SharkSsl_h
#define _SharkSsl_h

#include "TargConfig.h"      /* platform dependencies  */

#if SHARKDBG_PRINTF
#undef SHARKDBG_PRINTF
#define SHARKDBG_PRINTF(x) printf x
#else
#undef SHARKDBG_PRINTF
#define SHARKDBG_PRINTF(x)
#endif

#ifndef SHARKSSL_API
#define SHARKSSL_API
#else  /* Barracuda */
#define SHARKSSL_BA 1
#include <ThreadLib.h>
#include <BaServerLib.h>
#endif

#include "SharkSSL_cfg.h"    /* SharkSSL configuration */
#ifdef __cplusplus
#include <stddef.h>          /* size_t for new, delete */
#endif

#include "SharkSslCrypto.h"  /* Crypto API */

#ifndef sharkCertSerialNumber2NetworkEndian
/** 
    @ingroup SharkSslCertApi
    Default serial number type
*/
typedef U64 SharkCertSerialNumber;
#ifdef B_BIG_ENDIAN
#define sharkCertSerialNumber2NetworkEndian(n)
#else
#define sharkCertSerialNumber2NetworkEndian(n)  \
   do {                                         \
      U64 nn=0;                                 \
      register U8* t=(U8*)&nn;                  \
      register U8* f=(U8*)&n;                   \
      t[7]=f[0];                                \
      t[6]=f[1];                                \
      t[5]=f[2];                                \
      t[4]=f[3];                                \
      t[3]=f[4];                                \
      t[2]=f[5];                                \
      t[1]=f[6];                                \
      t[0]=f[7];                                \
      n=nn;                                     \
   } while(0)
#endif
#endif

/* Forward decl. */
struct SharkSslCertDN;
struct SharkSslASN1Create;
struct SharkSslBitExtReq;

/** \defgroup ECDSA ECDSA sign/verify functions
\ingroup RayCryptoApi

See [Signing and Verifying Binaries](@ref signing) for an example
of how to use the ECDSA ECDSA sign/verify functions.

*/




/** \addtogroup SharkSslAlert
@{

Alert messages are generated by SharkSSL or the peer side on errors.

Alert messages are one of: fatal or warning. A fatal error means that
the connection must be closed.
*/

/** SSL/TLS warning message */
#define SHARKSSL_ALERT_LEVEL_WARNING               1

/** Fatal error message. Connection must be closed. */
#define SHARKSSL_ALERT_LEVEL_FATAL                 2

/** \defgroup SharkSslAlertMsg SSL/TLS Alert Messages
\ingroup SharkSslAlert
@{

\brief Alert messages returned by function #SharkSslCon_getAlertDescription

Alert messages are generated by SharkSSL when processing the incoming
data fails. Alert messages can also be received from the peer side,
when the peer fails to process the data.
*/

/** SHARKSSL_ALERT_CLOSE_NOTIFY */
#define SHARKSSL_ALERT_CLOSE_NOTIFY                0
/** SHARKSSL_ALERT_UNEXPECTED_MESSAGE */
#define SHARKSSL_ALERT_UNEXPECTED_MESSAGE          10
/** SHARKSSL_ALERT_BAD_RECORD_MAC */
#define SHARKSSL_ALERT_BAD_RECORD_MAC              20
/** SHARKSSL_ALERT_DECRYPTION_FAILED */
#define SHARKSSL_ALERT_DECRYPTION_FAILED           21
/** SHARKSSL_ALERT_RECORD_OVERFLOW */
#define SHARKSSL_ALERT_RECORD_OVERFLOW             22
/** SHARKSSL_ALERT_DECOMPRESSION_FAILURE */
#define SHARKSSL_ALERT_DECOMPRESSION_FAILURE       30
/** SHARKSSL_ALERT_HANDSHAKE_FAILURE */
#define SHARKSSL_ALERT_HANDSHAKE_FAILURE           40
/** SHARKSSL_ALERT_BAD_CERTIFICATE */
#define SHARKSSL_ALERT_BAD_CERTIFICATE             42
/** SHARKSSL_ALERT_UNSUPPORTED_CERTIFICATE */
#define SHARKSSL_ALERT_UNSUPPORTED_CERTIFICATE     43
/** SHARKSSL_ALERT_CERTIFICATE_REVOKED */
#define SHARKSSL_ALERT_CERTIFICATE_REVOKED         44
/** SHARKSSL_ALERT_CERTIFICATE_EXPIRED */
#define SHARKSSL_ALERT_CERTIFICATE_EXPIRED         45
/** SHARKSSL_ALERT_CERTIFICATE_UNKNOWN */
#define SHARKSSL_ALERT_CERTIFICATE_UNKNOWN         46
/** SHARKSSL_ALERT_ILLEGAL_PARAMETER */
#define SHARKSSL_ALERT_ILLEGAL_PARAMETER           47
/** SHARKSSL_ALERT_UNKNOWN_CA */
#define SHARKSSL_ALERT_UNKNOWN_CA                  48
/** SHARKSSL_ALERT_ACCESS_DENIED */
#define SHARKSSL_ALERT_ACCESS_DENIED               49
/** SHARKSSL_ALERT_DECODE_ERROR */
#define SHARKSSL_ALERT_DECODE_ERROR                50
/** SHARKSSL_ALERT_DECRYPT_ERROR */
#define SHARKSSL_ALERT_DECRYPT_ERROR               51
/** SHARKSSL_ALERT_EXPORT_RESTRICTION */
#define SHARKSSL_ALERT_EXPORT_RESTRICTION          60
/** SHARKSSL_ALERT_PROTOCOL_VERSION */
#define SHARKSSL_ALERT_PROTOCOL_VERSION            70
/** SHARKSSL_ALERT_INSUFFICIENT_SECURITY */
#define SHARKSSL_ALERT_INSUFFICIENT_SECURITY       71
/** SHARKSSL_ALERT_INTERNAL_ERROR */
#define SHARKSSL_ALERT_INTERNAL_ERROR              80
/** SHARKSSL_ALERT_USER_CANCELED */
#define SHARKSSL_ALERT_USER_CANCELED               90
/** SHARKSSL_ALERT_NO_RENEGOTIATION */
#define SHARKSSL_ALERT_NO_RENEGOTIATION            100
/** SHARKSSL_ALERT_UNRECOGNIZED_NAME */
#define SHARKSSL_ALERT_UNRECOGNIZED_NAME           112
/** SHARKSSL_ALERT_NO_APPLICATION_PROTOCOL */
#define SHARKSSL_ALERT_NO_APPLICATION_PROTOCOL     120  /* RFC 7301 */

/** @} */ /* end group SharkSslAlertMsg */ 
/** @} */ /* end group SharkSslAlert */ 


/** \defgroup SharkSslCiphers Supported Ciphersuites
\ingroup SharkSslInfoAndCodes
@{

 \brief Supported Ciphersuites and values returned by
SharkSslCon_getCiphersuite.
*/

#if SHARKSSL_TLS_1_3
/** TLS_AES_128_GCM_SHA256 */
#define TLS_AES_128_GCM_SHA256                              0x1301
/** TLS_AES_256_GCM_SHA384 */
#define TLS_AES_256_GCM_SHA384                              0x1302
/** TLS_CHACHA20_POLY1305_SHA256 */
#define TLS_CHACHA20_POLY1305_SHA256                        0x1303
#endif
#if SHARKSSL_TLS_1_2
/** TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 */
#define TLS_DHE_RSA_WITH_AES_128_GCM_SHA256                 0x009E
/** TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 */
#define TLS_DHE_RSA_WITH_AES_256_GCM_SHA384                 0x009F
/** TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 */
#define TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256             0xC02B
/** TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 */
#define TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384             0xC02C
/** TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 */
#define TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256               0xC02F
/** TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 */
#define TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384               0xC030
/** TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 */
#define TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256         0xCCA8
/** TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 */
#define TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256       0xCCA9
/** TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 */
#define TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256           0xCCAA
#endif

/** @} */ /* end group SharkSslCiphers */ 


/** \defgroup SharkSslProtocol SSL and TLS protocol version
\ingroup SharkSslInfoAndCodes
@{
 \brief Return values from function #SharkSslCon_getProtocol.
*/

/** SHARKSSL_PROTOCOL_UNKNOWN */
#define SHARKSSL_PROTOCOL_UNKNOWN                  0x00
/** SHARKSSL_PROTOCOL_TLS_1_2 */
#define SHARKSSL_PROTOCOL_TLS_1_2                  0x33
/** SHARKSSL_PROTOCOL_TLS_1_3 */
#define SHARKSSL_PROTOCOL_TLS_1_3                  0x34

/* internal use, with SHARKSSL_PROTOCOL_TLS_1_x as parameter */
#define SHARKSSL_PROTOCOL_MAJOR(p)                 (p >> 4)
#define SHARKSSL_PROTOCOL_MINOR(p)                 (p & 0xF)

/** @} */ /* end group SharkSslProtocol */ 


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
#ifndef BA_API  /* standalone SharkSSL */
#define BA_API SHARKSSL_API
#ifdef _SHARKSSL_C_
#define SingleListCode 1
#endif
#endif
#include "SingleList.h"
#endif


#if SHARKSSL_ENABLE_SESSION_CACHE || SHARKSSL_NOPACK

/** @addtogroup SharkSslSessionApi
@{
*/

/** SharkSslSession is an opaque handle returned by function
    #SharkSslCon_acquireSession.
 */
typedef struct SharkSslSession SharkSslSession;

/** @} */ /* end group SharkSslSessionApi */ 

#ifndef _DOXYGEN
typedef struct SharkSslSessionCache
{
   SharkSslSession *cache;
   ThreadMutexBase  cacheMutex;
   U16 cacheSize;
} SharkSslSessionCache;
#endif
#endif


/** \addtogroup SharkSslInfoAndCodes
@{
*/

/** Select one of client or server mode when creating a #SharkSsl
    object.

    __Note:__ A SharkSsl instance in server mode requires that you
    install at a minimum one certificate by calling function
    #SharkSsl_addCertificate.
*/
typedef enum
{
   SharkSsl_Unspecified,  /*!< Invalid value */
   SharkSsl_Server,       /*!< Select SSL server mode */
   SharkSsl_Client        /*!< Select SSL client mode */
} SharkSsl_Role;

/** @} */ /* end group SharkSslInfoAndCodes */


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
/** \addtogroup SharkSslInfoAndCodes
@{
*/


/** The SharkSslKey type.
 */
typedef U8* SharkSslKey;


/** The SharkSSL Certificate is in a binary format optimized for speed
    and size. The certificate can be created by calling #sharkssl_PEM
    or by using the command line tool
    [SharkSslParseCert](\ref SharkSslParseCert)
 */
typedef const U8 *SharkSslCert;

#ifdef __cplusplus
extern "C" {
#endif

/** 
    @ingroup SharkSslCertApi
    Get certificate length
    \param cert a valid SharkSSL certificate
 */
SHARKSSL_API U16 SharkSslCert_len(SharkSslCert cert);

/** Platform dependent function returning seconds since Jan 1 1970.
 */
#ifdef __DOXYGEN__
U32 baGetUnixTime(void);
#endif

#if SHARKSSL_ENABLE_CSR_CREATION
/** 
    @ingroup SharkSslCertApi
    CSR creation (all parameters are input parameters)

   Note: after successful execution, the function
   SharkSslASN1Create_getDataLen must be called.

   Example:
   \code
   U8 *asnData;
   int asnDataLen;
   SharkSslASN1Create asn;
   
   SharkSslASN1Create_CSR(&asn, <additional parameters>)
   asnDataLen = SharkSslASN1Create_getDataLen(&asn, &asnData);
   \endcode

   The blob 'asnData' is the CSR in binary format.

   \param o pointer to an initialized #SharkSslASN1Create instance.

   \param privKey a private key (ECC or RSA) in SharkSSL format. The
   key can be created with #SharkSslECCKey_create and
   #SharkSslRSAKey_create.

   \param hashID an identifier for the digest function used in the CSR signature
   Allowed values are:
         SHARKSSL_HASHID_SHA512
         SHARKSSL_HASHID_SHA384
         SHARKSSL_HASHID_SHA256

   \param certDN pointer to an initialized #SharkSslCertDN instance.

   \param SAN pointer to a string where Subject Alternative Names are
   listed.  Multiple names and/or IP addresses can be specified
   separating them by semicolons. Note: SAN must include the common
   name set in SharkSslCertDN. The subject alternative name may
   include an IP address in the form "IP:IPv4"; example:
   "localhost;IP:127.0.0.1"

   \param keyUsage flags used to specify the key usage. You may use
   the following flags and combine them by a bitwise OR:
         SHARKSSL_X509_KU_DIGITAL_SIGNATURE
         SHARKSSL_X509_KU_NON_REPUDIATION
         SHARKSSL_X509_KU_KEY_ENCIPHERMENT
         SHARKSSL_X509_KU_DATA_ENCIPHERMENT
         SHARKSSL_X509_KU_KEY_AGREEMENT
         SHARKSSL_X509_KU_KEY_CERT_SIGN
         SHARKSSL_X509_KU_CRL_SIGN

   \param nsCertType flags used to specify the "Netscape" certificate
      type. You may use the following flags and combine them by a
      bitwise OR:
         SHARKSSL_X509_NS_CERT_TYPE_SSL_CLIENT
         SHARKSSL_X509_NS_CERT_TYPE_SSL_SERVER
         SHARKSSL_X509_NS_CERT_TYPE_OBJECT_SIGNING
         SHARKSSL_X509_NS_CERT_TYPE_SSL_CA
         SHARKSSL_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA

   \return 0 on success, otherwise a negative value is returned on
   error, where the typical reason would be that the buffer is full.
 */
SHARKSSL_API int
SharkSslASN1Create_CSR(struct SharkSslASN1Create* o,
                       SharkSslKey privKey,
                       U8 hashID,
                       struct SharkSslCertDN* certDN,
                       const char *SAN,
                       struct SharkSslBitExtReq* keyUsage,
                       struct SharkSslBitExtReq* nsCertType);
#endif

#if SHARKSSL_ENABLE_CSR_SIGNING
/** 
    @ingroup SharkSslCertApi
    CSR signing (if not specified, parameters are input parameters)

   \param signedCSR [output variable] is a certificate in SharkSSL
      format. Variable signedCSR will on successfull execution point
      to allocated memory that can be freed by calling
      baFree(signedCSR); Please notice that the SharkSSL
      certificate format includes both the certificate and the private
      key. See the privKey parameter for more information.
   
   \param csrData pointer to a CSR, see #SharkSslASN1Create_CSR and
      #SharkSslASN1Create_getDataLen. CSR is in binary DER format.

   \param csrDataLen CSR length, see #SharkSslASN1Create_getDataLen

   \param caCert: a CA certificate in SharkSSL format or NULL if the
      CSR is to be self-signed -- that is, when issuer is the same as
      subject. This certificate may be obtained by using the
      [SharkSslParseCert](\ref SharkSslParseCert) tool. Note that the
      SharkSSL certificate format includes both the CA certificate and
      the CA private key, where the latter will be used to sign the
      certificate obtained from the CSR.

   \param privKey the private key (ECC or RSA) matching the CSR's
      public key, in SharkSSL format. The key may for example be
      obtained by using the [SharkSslParseKey](\ref SharkSslParseKey)
      tool. if the parameter caCert is NULL (self-signing), this key
      will be used to sign the certificate. This function is primarily
      designed for creating SharkSSL certificates, which include both
      the key and the certificate. The key should therefore normally
      be provided for both self signed certificates and certificates
      that is to be signed by the caCert (arg 4). However, the key may
      be set to NULL when the caCert is provided. The produced
      SharkSSL certificate will then include a combined
      key/certificate, where the key is set to a dummy variable. This
      mode is designed when one must save the certificate as a X.509
      certificate. The produced certificate , with the dummy key,
      cannot be used as argument to SharkSsl_addCertificate.

   \param validFrom string in format YYYYMMDDHHMMSS. The certificate is
   valid starting from this date.

   \param validTo string in format YYYYMMDDHHMMSS. The certificate is
   valid until this date.

   \param serialNumber serial number for the generated certificate.

   \param hashID an identifier for the digest function used in the
      certificate signature. Allowed values are:
         SHARKSSL_HASHID_SHA256
         SHARKSSL_HASHID_SHA384
         SHARKSSL_HASHID_SHA512

   \return the number of allocated bytes for the signed certificate or
      a negative value on error, where the typical reason would be
      that allocation fails. This is a binary format that can be saved
      to RAM or Flash by saving the returned allocated number of bytes
      starting at the address pointed to by 'signedCSR'
 */
SHARKSSL_API int
SharkSslCert_signCSR(SharkSslCert *signedCSR,
                     const U8 *csrData,
                     int csrDataLen,
                     const SharkSslCert caCert,
                     const SharkSslKey privKey,
                     const char *validFrom,
                     const char *validTo,
                     SharkCertSerialNumber serialNumber,
                     U8 hashID);
#endif					 

#if SHARKSSL_ENABLE_ASN1_KEY_CREATION
/** Convert a SharkSslKey to ASN.1 representation. See the example
    file CSR.c for how to use this function.
    \param o the ASN.1 instance
    \param key a valid SharkSslKey
    \return zero on success, otherwise a negative value is returned.
 */
SHARKSSL_API int
SharkSslASN1Create_key(struct SharkSslASN1Create *o, const SharkSslKey key);
#endif


#ifdef __cplusplus
}
#endif


#if SHARKSSL_ENABLE_CA_LIST
/** The SharkSSL Certificate Authority (CA) List is in a binary format
    optimized for speed and size. The list can be created by calling
    #SharkSslCertStore_assemble or by using the command line tool
    [SharkSSLParseCAList](\ref SharkSSLParseCAList).
 */
typedef const U8 *SharkSslCAList;
#endif

/** @} */ /* end group SharkSslInfoAndCodes */
#endif

#ifndef _DOXYGEN
struct SharkSsl;
#endif


/* Non documented API used by SharkSslSCMgr when used indirectly by
   Lua code in the Barracuda Application Server. The code manages
   automatic destruction of SharkSslSCMgr.
 */
#ifndef _DOXYGEN
struct SharkSslIntf;
typedef void (*SharkSslIntf_Terminate)(struct SharkSslIntf* o,
                                       struct SharkSsl* ssl); 
typedef struct SharkSslIntf
{
   SharkSslIntf_Terminate terminate;
} SharkSslIntf;
#define SharkSslIntf_constructor(o,terminateFunc) (o)->terminate=terminateFunc
#endif


/** \addtogroup SharkSslInfoAndCodes
@{
*/

/**  SharkSslCon is an opaque handle returned by function
     #SharkSsl_createCon. 

     The lifetime of a SharkSslCon object is as follows:

     - Create a network connection and create a SharkSslCon object by
       calling #SharkSsl_createCon

     - Use the SharkSslCon functions to encode and decode data sent
       and received over the network. See #SharkSslCon_encrypt and
       #SharkSslCon_decrypt for more information.

     - When you are ready to close the connection: close the network
       connection and call function #SharkSsl_terminateCon

   \sa  SharkSsl
*/
typedef struct SharkSslCon SharkSslCon;


/** A SharkSsl object is the coordinator for managing #SharkSslCon
    objects (See #SharkSsl_constructor for details).
*/
typedef struct
SharkSsl
{
#ifdef __cplusplus
   void *operator new(size_t s) { return ::baMalloc(s); }
   void operator delete(void* d) { if(d) ::baFree(d); }
   void *operator new(size_t, void *place) { return place; }
   void operator delete(void*, void *) { }

   SharkSsl() {};

   SharkSsl(SharkSsl_Role role,
            U16 cacheSize         = 0,
            U16 inBufStartSize    = 4096,
            U16 outBufSize        = 4096
            );

   ~SharkSsl();
   SharkSslCon *createCon(void);
   U8 setCAList(SharkSslCAList caList);
   U8 addCertificate(SharkSslCert cert);
   void terminateCon(SharkSslCon *sslCon);
#endif
   #if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_SSL_CLIENT_CODE) || SHARKSSL_NOPACK
   SharkSsl_Role role;
   #endif
   U16 outBufSize;
   U16 inBufStartSize;
   U16 nCon;
   #if (SHARKSSL_ENABLE_RSA || (SHARKSSL_ENABLE_ECDSA))  || SHARKSSL_NOPACK
   SingleList certList;
   #if SHARKSSL_ENABLE_CA_LIST || SHARKSSL_NOPACK
   SharkSslCAList caList;
   #endif
   #endif
   #if SHARKSSL_ENABLE_SESSION_CACHE  || SHARKSSL_NOPACK
   SharkSslSessionCache sessionCache;
   /* Reserved for use with one SharkSslSCMgr object  */
   SharkSslIntf* intf;
   #endif
} SharkSsl;

/** @} */ /* end group SharkSslInfoAndCodes */

/** @addtogroup SharkSslCoreApi
@{
*/

/** The #SharkSslCon_decrypt and #SharkSslCon_encrypt return values.
 */
typedef enum
{
   /** Indicates general errors, including configuration errors.
    */
   SharkSslCon_Error = 1, 

   /** The memory pool is too small.
    */
   SharkSslCon_AllocationError,

   /** Returned when a block of received data has been successfully decrypted.

       __selib.c code snippet:__
       \dontinclude selib.c
       \skipline case SharkSslCon_Decrypted:
       \until return

       \sa SharkSslCon_getDecData
    */
   SharkSslCon_Decrypted,

   /** Returned when an SSL/TLS handshake message has been received or
       is to be sent. During this phase, one must call
       #SharkSslCon_getHandshakeData and
       #SharkSslCon_getHandshakeDataLen, and send the handshake data to
       the peer side. 

       __selib.c code snippet:__
       \dontinclude selib.c
       \skipline case SharkSslCon_Handshake:
       \until xprintf(("handshake complete"));
    */
   SharkSslCon_Handshake,

   /** Returned when SharkSSL holds an incomplete SSL/TLS record or
       when the connection is initially established and the readLen
       parameter is zero. 

       __selib.c code snippet:__
       \dontinclude selib.c
       \skipline case SharkSslCon_NeedMoreData:
       \until decrypt next record

       \sa #SharkSslCon_getBuf and #SharkSslCon_getBufLen
    */
   SharkSslCon_NeedMoreData,

   /** Returned when an [SSL/TLS alert message](@ref SharkSslAlertMsg)
       must be sent to the peer side. The error code, which must be
       sent to the peer, indicates that SharkSSL was unable to decode
       the data sent from the peer.
       
       __selib.c code snippet:__
       \dontinclude selib.c
       \skipline case SharkSslCon_AlertSend:
       \until return

       \sa #SharkSslCon_getAlertData and #SharkSslCon_getAlertDataLen
   */
   SharkSslCon_AlertSend,

   /** SharkSSL received an [SSL/TLS alert message](@ref SharkSslAlertMsg)
       from the peer, which means that the peer either failed to
       decode the message from SharkSSL or the peer entered an
       exception state.

       \sa SharkSslCon_getAlertLevel and SharkSslCon_getAlertDescription
    */
   SharkSslCon_AlertRecv,

   /** SharkSSL has successfully decrypted a chunk of data. The data
       is available in the SharkSSL receive buffer, which is returned
       by function #SharkSslCon_getEncData. The length is returned by
       function #SharkSslCon_getEncDataLen.

       __selib.c code snippet:__
       \dontinclude selib.c
       \skipline case SharkSslCon_Encrypted:
       \until return maxLen
   */
   SharkSslCon_Encrypted,

   /** An error condition returned by function #SharkSslCon_encrypt if
       the SSL handshake is not completed. You cannot send encrypted
       data before completing the handshake phase.
    */
   SharkSslCon_HandshakeNotComplete,

   /** Unrecognized format of a provided certificate.
    */
   SharkSslCon_CertificateError

} SharkSslCon_RetVal;

/** @} */ /* end group SharkSslCoreApi */

#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)

/** \defgroup SharkSslCertInfo Peer's certificate information
\ingroup SharkSslInfoAndCodes

\brief Certificate information returned by #SharkSslCon_getCertInfo

@{
*/

/** Certificate KeyUsage and ExtendedKeyUsage flags and relative
    pseudofunctions
 */
#if SHARKSSL_ENABLE_CERT_KEYUSAGE
#define SHARKSSL_CERT_KEYUSAGE_DIGITALSIGNATURE     0x00000001
#define SHARKSSL_CERT_KEYUSAGE_NONREPUDIATION       0x00000002
#define SHARKSSL_CERT_KEYUSAGE_KEYENCIPHERMENT      0x00000004
#define SHARKSSL_CERT_KEYUSAGE_DATAENCIPHERMENT     0x00000008
#define SHARKSSL_CERT_KEYUSAGE_KEYAGREEMENT         0x00000010
#define SHARKSSL_CERT_KEYUSAGE_KEYCERTSIGN          0x00000020
#define SHARKSSL_CERT_KEYUSAGE_CRLSIGN              0x00000040
#define SHARKSSL_CERT_KEYUSAGE_ENCIPHERONLY         0x00000080 
#define SHARKSSL_CERT_KEYUSAGE_DECIPHERONLY         0x00000100
#define SHARKSSL_CERT_KEYUSAGE_PRESENT              0x00000200
#define SHARKSSL_CERT_KEYUSAGE_CRITICAL             0x00000400

#define SHARKSSL_CERT_KEYPURPOSE_SERVERAUTH         0x00010000
#define SHARKSSL_CERT_KEYPURPOSE_CLIENTAUTH         0x00020000
#define SHARKSSL_CERT_KEYPURPOSE_CODESIGNING        0x00040000
#define SHARKSSL_CERT_KEYPURPOSE_EMAILPROTECTION    0x00080000
#define SHARKSSL_CERT_KEYPURPOSE_TIMESTAMPING       0x00100000
#define SHARKSSL_CERT_KEYPURPOSE_OCSPSIGNING        0x00200000

#define SharkSslCertInfo_KeyFlagSet(o,f)            ((o)->keyUsagePurposes & f)

/** The following pseudo-functions return a non-zero value
    if the corresponding flag is set 
 */
#define SharkSslCertInfo_isKeyUsagePresent(o)       SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_PRESENT)
#define SharkSslCertInfo_isKeyUsageCritical(o)      SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_CRITICAL)
#define SharkSslCertInfo_KU_digitalSignature(o)     SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_DIGITALSIGNATURE)
#define SharkSslCertInfo_KU_nonRepudiation(o)       SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_NONREPUDIATION)
#define SharkSslCertInfo_KU_keyEncipherment(o)      SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_KEYENCIPHERMENT)
#define SharkSslCertInfo_KU_dataEncipherment(o)     SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_DATAENCIPHERMENT)
#define SharkSslCertInfo_KU_keyAgreement(o)         SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_KEYAGREEMENT)
#define SharkSslCertInfo_KU_keyCertSign(o)          SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_KEYCERTSIGN)
#define SharkSslCertInfo_KU_cRLSign(o)              SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_CRLSIGN)
#define SharkSslCertInfo_KU_encipherOnly(o)         SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_ENCIPHERONLY)
#define SharkSslCertInfo_KU_decipherOnly(o)         SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYUSAGE_DECIPHERONLY)

#define SharkSslCertInfo_kp_serverAuth(o)           SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYPURPOSE_SERVERAUTH)
#define SharkSslCertInfo_kp_clientAuth(o)           SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYPURPOSE_CLIENTAUTH)
#define SharkSslCertInfo_kp_codeSigning(o)          SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYPURPOSE_CODESIGNING)
#define SharkSslCertInfo_kp_emailProtection(o)      SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYPURPOSE_EMAILPROTECTION)
#define SharkSslCertInfo_kp_timeStamping(o)         SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYPURPOSE_TIMESTAMPING)
#define SharkSslCertInfo_kp_OCSPSigning(o)          SharkSslCertInfo_KeyFlagSet(o, SHARKSSL_CERT_KEYPURPOSE_OCSPSIGNING)
#endif


/** Certificate Distinguished Name

    Example from certcheck.c:

    \dontinclude certcheck.c
    \skip  Begin Cert Info
    \until End Cert Info

    \sa SharkSslCertInfo

 */
typedef struct SharkSslCertDN
{
   const U8 *countryName; /**< ISO3166 country code */
   const U8 *province;  /**< State or Province */
   const U8 *locality; /**< The city or town name */ 
   const U8 *organization; /**< Organization Name (company or department) */
   const U8 *unit; /**< Organizational Unit (OU: department or organization unit) */
   /** Common Name is the Host + Domain Name (example:
       www.mycompany.com, where www is host and mycompany.com is Domain
       Name) */
   const U8 *commonName;
   const U8 *emailAddress;

   U8 countryNameLen;   /** length in bytes of the field "country" */
   U8 provinceLen;      /** length in bytes of the field "province" */
   U8 localityLen;      /** length in bytes of the field "locality" */
   U8 organizationLen;  /** length in bytes of the field "organization" */
   U8 unitLen;          /** length in bytes of the field "unit" */
   U8 commonNameLen;    /** length in bytes of the field "common name" */
   U8 emailAddressLen;  /** length in bytes of the field "emailAddress" */
} SharkSslCertDN;

/** SharkSslCertDN constructor
 */
#define SharkSslCertDN_constructor(o) memset(o,0,sizeof(SharkSslCertDN))
/** setCountryName
 */
#define SharkSslCertDN_setCountryName(o, countryNameMA) \
   (o)->countryName=(const U8*)countryNameMA,(o)->countryNameLen=(U8)strlen(countryNameMA)
/** setProvince
 */
#define SharkSslCertDN_setProvince(o, provinceMA) \
   (o)->province=(const U8*)provinceMA,(o)->provinceLen=(U8)strlen(provinceMA)
/** setLocality
 */
#define SharkSslCertDN_setLocality(o, localityMA) \
   (o)->locality=(const U8*)localityMA,(o)->localityLen=(U8)strlen(localityMA)
/** setOrganization
 */
#define SharkSslCertDN_setOrganization(o, organizationMA) \
   (o)->organization=(const U8*)organizationMA,(o)->organizationLen=(U8)strlen(organizationMA)
/** setUnit
 */
#define SharkSslCertDN_setUnit(o, unitMA) \
   (o)->unit=(const U8*)unitMA,(o)->unitLen=(U8)strlen(unitMA)
/** setCommonName
 */
#define SharkSslCertDN_setCommonName(o, commonNameMA) \
   (o)->commonName=(const U8*)commonNameMA,(o)->commonNameLen=(U8)strlen(commonNameMA)
/** setEmailAddress
 */
#define SharkSslCertDN_setEmailAddress(o, emailAddressMA) \
   (o)->emailAddress=(const U8*)emailAddressMA,(o)->emailAddressLen=(U8)strlen(emailAddressMA)


/** The peer's certificate information returned by #SharkSslCon_getCertInfo.
    \sa SharkSslCertDN
 */
typedef struct SharkSslCertInfo
{
   /** Length of 'sn' (serial number) */
   U16 snLen;

   /**  Certificate version is offset at 0 so add +1 for actual
        version number.
   */
   U8  version; 

   /** The Certificate Authority flag (CA) is set to one if the
       certificate is a CA i.e. a root certificate.
    */
   U8 CAflag;

   /** Binary serial number. The length is provided in 'snLen'
    */
   U8 *sn;

   /** Certificate is valid from date (in Time format: [YY]YYMMDDHHMMSSZ)
    *  UTCTime: 2-digit year; GeneralizedTime: 4-digit year (years > 2050)
    */
   U8 *timeFrom;  /* declaration of U8 timeFromLen below */

   /** Certificate expiration date (in Time format: [YY]YYMMDDHHMMSSZ)
    *  UTCTime: 2-digit year; GeneralizedTime: 4-digit year (years > 2050)
    *  GeneralizedTime: 4-digit year for years > 2050
    */
   U8 *timeTo;    /* declaration of U8 timeToLen below */

   /** The entity who has signed and issued the certificate (<a 
       href="http://tools.ietf.org/html/rfc2459#section-4.1.2.4"
       >RFC 2459 4.1.2.4</a>)
    */
   SharkSslCertDN issuer;

   /** The entity associated with the public key (<a 
       href="http://tools.ietf.org/html/rfc2459#section-4.1.2.6"
       >RFC 2459 4.1.2.6</a>).
    */
   SharkSslCertDN subject;

   /** Subject Alternative Names 
       subjectAltNamesPtr is a pointer to an ASN1 sequence, 
       whose length is subjectAltNamesLen. 
       Use the SubjectAltNameEnumerator/SubjectAltName struct
       as in the SharkSslCon_trusted function in SharkSslEx.c
       The following example is from certcheck.c:

       \dontinclude certcheck.c
       \skipline U8 *tp
       \until xprintf(("\n"))
    */
   U8 *subjectAltNamesPtr;
   U16 subjectAltNamesLen;

   /** Length of 'timeFrom' */
   U8  timeFromLen;

   /** Length of 'timeTo' */
   U8  timeToLen;

   #if SHARKSSL_ENABLE_CERT_KEYUSAGE
   /** KeyUsage & ExtendedKeyUsage (key purposes) flags. 
       Verify that the KeyUsage extension is present through the 
         SharkSslCertInfo_isKeyUsagePresent(o) pseudo-function, 
       then verify all the flags through the pseudo-functions:
         SharkSslCertInfo_KU_digitalSignature(o)
         SharkSslCertInfo_KU_nonRepudiation(o)
         SharkSslCertInfo_KU_keyEncipherment(o)
         SharkSslCertInfo_KU_dataEncipherment(o)
         SharkSslCertInfo_KU_keyAgreement(o)
         SharkSslCertInfo_KU_keyCertSign(o)
         SharkSslCertInfo_KU_cRLSign(o)
         SharkSslCertInfo_KU_encipherOnly(o)
         SharkSslCertInfo_KU_decipherOnly(o)

       Verify the ExtendedKeyUsage purposes through the following:
         SharkSslCertInfo_kp_serverAuth(o)
         SharkSslCertInfo_kp_clientAuth(o)
         SharkSslCertInfo_kp_codeSigning(o)
         SharkSslCertInfo_kp_emailProtection(o)
         SharkSslCertInfo_kp_timeStamping(o)
         SharkSslCertInfo_kp_OCSPSigning(o)
    */ 
   U32 keyUsagePurposes; 
   #endif

   /** Pointer to parent node when the SharkSslCertInfo object is part of
       a certificate chain. You walk up the chain until you reach the root.
   */
   struct SharkSslCertInfo *parent;
} SharkSslCertInfo;

/** @} */ /* end group SharkSslCertInfo */ 
#endif

/** @addtogroup SharkSslApi
@{
*/


#ifdef __cplusplus
extern "C" {
#endif

/** A SharkSsl object is the coordinator for managing SharkSslCon
    objects.

    You must at a minimum create one SharkSsl object. A more advanced
    configuration may include several SharkSsl objects. For example, a
    system that includes both a client and server SSL stack must
    create and initialize two SharkSsl objects.

    \param o Uninitialized data of size sizeof(SharkSsl).

    \param role Select client or server SSL mode. See #SharkSsl_Role
    for details.

    \param cacheSize The session resumption cache size. Setting this
    to zero disables the cache management code. See
    [SSL Session Management](@ref SharkSslSessionApi) for details.

    \param inBufStartSize
    \param outBufSize

    parameter must be provided if you plan on using function
    #SharkSslCon_trustedCA or #SharkSslCon_trusted. See
    #SharkSslCAList for details.

    \sa #SharkSsl_addCertificate, #SharkSsl_setCAList,
    SharkSsl_createCon, and SharkSsl_terminateCon.
 */
SHARKSSL_API void  SharkSsl_constructor(
                      SharkSsl *o,
                      SharkSsl_Role role,
                      U16 cacheSize,
                      U16 inBufStartSize,
                      U16 outBufSize
                      );

/** Close the SharkSsl object. Closing a SharkSsl object is not
    common in embedded devices. You would normally keep the SharkSsl
    object for the lifetime of the application. You must make sure
    all #SharkSslCon objects are terminated by calling
    #SharkSslCon_terminate for each active connection prior to calling
    the SharkSsl_destructor.
 */
SHARKSSL_API void  SharkSsl_destructor(SharkSsl *o);


/** Create a #SharkSslCon object. You must create one SharkSslCon
    object for each active network connection that requires encryption.

    The following code snippet is from the
    [example programs](\ref SharkExamples).
    \code
int rc;
SharkSslCon* scon;
if( (rc=se_connect(&sock, "realtimelogic.com", 443)) == 0) // open socket
{
   if( (scon = SharkSsl_createCon(&sharkSsl)) != NULL)
   {
      // success
   \endcode

    \return a SharkSslCon object or NULL if memory is exhausted.

    \sa SharkSsl_terminateCon and SharkSslCon_terminate
 */
SharkSslCon *SharkSsl_createCon(SharkSsl *o);


/** Terminate a SharkSslCon object created by function SharkSsl_createCon.

    \param o the SharkSsl object. Setting this parameter to NULL is
    the same as calling macro #SharkSslCon_terminate.

    \param con the SharkSslCon object to reclaim.

    Code snippet from the example code: sessioncache.c 

       \dontinclude sessioncache.c
       \skipline Release resources
       \until se_close

 */
void SharkSsl_terminateCon(const SharkSsl *o, SharkSslCon* con);


#if SHARKSSL_ENABLE_SESSION_CACHE

/** Returns the SharkSsl session cache size.
    \sa SharkSsl_constructor (parameter cacheSize) and
    #SHARKSSL_ENABLE_SESSION_CACHE
*/
SHARKSSL_API U16   SharkSsl_getCacheSize(SharkSsl *o);

#define SharkSsl_setIntf(o, sharkSslIntf) (o)->intf=sharkSslIntf
#define SharkSsl_getIntf(o) (o)->intf

#endif


/** The SharkSslCon object must be reclaimed when you close the
 * network connection.

    \sa #SharkSsl_createCon
    \sa SharkSsl_terminateCon
 */ 
#define SharkSslCon_terminate(o) SharkSsl_terminateCon(0, o)

/** @addtogroup SharkSslCoreApi
@{
*/

/** Decrypt the received data copied into the SharkSslCon receive
    buffer (the buffer returned by #SharkSslCon_getBuf). See
    #SharkSslCon_RetVal for example code.

    The SharkSslCon_decrypt function keeps decrypt state information
    in the SharkSslCon object and the function can therefore be used
    in event driven systems.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.

    \param readLen the length of the received network data copied into
    the buffer returned by #SharkSslCon_getBuf.

    \return the decrypt state information #SharkSslCon_RetVal.

    \sa SharkSslCon_getBuf, SharkSslCon_getBufLen, SharkSslCon_encrypt
 */
SharkSslCon_RetVal SharkSslCon_decrypt(SharkSslCon *o, U16 readLen);


/** Encrypt the data provided by parameter 'buf' or encrypt data in
    the SharkSslCon send buffer. SharkSSL provides a zero copy API and
    you can optionally copy data directly to the SharkSslCon send
    buffer. The send buffer is returned by calling function
    #SharkSslCon_getEncBufPtr.

    The SharkSslCon_encrypt function keeps decrypt state information
    in the SharkSslCon object and the function can therefore be used
    in event driven systems.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.

    \param buf the data to be encrypted or NULL when encrypting data
    copied directly to the SharkSslCon send buffer i.e. when copying
    the data to the pointer returned by function
    #SharkSslCon_getEncBufPtr.

    \param maxLen is the length of 'buf' or the length of the data
    data copied directly to the SharkSslCon send buffer.

    \return the decrypt state information #SharkSslCon_RetVal.

    \sa SharkSslCon_getEncBufPtr, SharkSslCon_getEncBufSize, SharkSslCon_decrypt
 */
SharkSslCon_RetVal SharkSslCon_encrypt(SharkSslCon *o, U8 *buf, U16 maxLen);


/** Returns the following values:
    \li 0: The TLS handshake has not completed.
    \li 1: The TLS handshake has completed.
    \li 2: The TLS handshake has completed; however, the SharkSSL
    connection includes additional data that must be processed by calling
    SharkSslCon_decrypt.
    See state #SharkSslCon_Handshake for example code.
*/
U8 SharkSslCon_isHandshakeComplete(SharkSslCon *o);


/** This function is used in conjunction with state
    SharkSslCon_Encrypted returned by function
    #SharkSslCon_encrypt. 

    The function returns TRUE if the SharkSslCon send buffer is full
    and must be flushed out.

    The maximum size of the output buffer is set with parameter
    'outBufSize' when calling the #SharkSsl_constructor. When the
    unencrypted buffer is larger than what fits into the internal
    output buffer, SharkSSL breaks the unencrypted data into multiple
    chunks and SharkSslCon_encryptMore lets the application know when
    the buffer must be flushed.

    See #SharkSslCon_Encrypted for example code.
 */
U8  SharkSslCon_encryptMore(SharkSslCon *o);


/** This function is used in conjunction with state
    SharkSslCon_Decrypted returned by function
    #SharkSslCon_decrypt.

    The function returns TRUE if a complete SSL frame has been
    decrypted and is ready for consumption. See #SharkSslCon_Decrypted
    for example code.

 */
U8  SharkSslCon_decryptMore(SharkSslCon *o);

/** Returns a pointer to the SharkSslCon input/receive buffer. The
    pointer returned by SharkSslCon_getBuf is where you copy the
    encrypted data you receive from the network.

    Example code:
    \code
   readLen = recv(mysocket, SharkSslCon_getBuf(s),SharkSslCon_getBufLen(s), 0);
   \endcode
    \sa SharkSslCon_getBufLen and SharkSslCon_getDecData
 */
U8 *SharkSslCon_getBuf(SharkSslCon *o);


/** Returns the length of the SharkSslCon input buffer. The buffer is
    internally managed by SharkSSL and may dynamically grow as large
    as 16Kbytes. The SharkSslCon input buffer start size is set with
    parameter inBufStartSize when calling the #SharkSsl_constructor.

    Many ciphers are block based and the receiving end must read the
    complete block before it can be decrypted. The SSL/TLS
    specification enables blocks up to 16K in size. Note, the block
    will not be larger than the size of the packet sent by the peer
    side.

    \sa SharkSslCon_getBuf
 */
U16 SharkSslCon_getBufLen(SharkSslCon *o);

/** Copy decoded data to 'buf'. Provides an alternative to using the
    zero copy API and the buffer returned by #SharkSslCon_getDecData.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.
    \param buf a buffer provided by the caller
    \param maxLen the size of parameter 'buf'. SharkSSL will copy at
    most maxLen bytes to 'buf'.

    Example:
    \code
for(;;)
{
   switch (SharkSslCon_decrypt(s, (U16)readLen))
   {
      case SharkSslCon_Decrypted:
         readLen = SharkSslCon_copyDecData(s, buf, maxLen);
         // decrypted readLen bytes
         if (SharkSslCon_decryptMore(s))
         {
            if ((readLen == 0) && (maxLen > 0))
            {
               break; // zero-length record, decrypt next one
            }
         }
         return readLen;

      // other cases not shown here
    \endcode
    \sa SharkSslCon_getDecData
 */
U16 SharkSslCon_copyDecData(SharkSslCon *o, U8 *buf, U16 maxLen);


/** Get a pointer to the decoded data.

    See #SharkSslCon_Decrypted for example code.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.
    \param bufPtr is set to the beginning of the decoded data.
    \returns Number of bytes decoded.
    \sa SharkSslCon_copyDecData
 */
SHARKSSL_API U16 SharkSslCon_getDecData(SharkSslCon *o, U8 **bufPtr);


/** This function is used in conjunction with state
    SharkSslCon_Handshake returned by function
    #SharkSslCon_encrypt. 

    The function returns the handshake data that must be sent to the
    peer side, if any.

    See #SharkSslCon_Handshake for example code.

    \sa SharkSslCon_getHandshakeDataLen
 */
U8 *SharkSslCon_getHandshakeData(SharkSslCon *o);


/** This function is used in conjunction with state
    SharkSslCon_Handshake returned by function
    #SharkSslCon_decrypt.

    The function returns the length of the handshake data that must be
    sent to the peer side, if any. The function returns zero if no
    handshake data should be sent.
    
    See #SharkSslCon_Handshake for example code.

    \sa SharkSslCon_getHandshakeData
 */
U16 SharkSslCon_getHandshakeDataLen(SharkSslCon *o);


/** This function is used in conjunction with
    SharkSslCon_getHandshakeData.
    See #SharkSslCon_Handshake for example code.

    The function returns the residual length of the handshake data 
    that must be sent to the peer side, if any. The function returns 
    zero if no handshake data should be sent.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.
    \param length is number of handshake bytes sent to the peer 
    (usually via TCP/IP).

    \sa SharkSslCon_getHandshakeData
 */
U16 SharkSslCon_setHandshakeDataSent(SharkSslCon *o, U16 length);


/** This function is used in conjunction with state
    SharkSslCon_Encrypted returned by function
    #SharkSslCon_encrypt.

    The function returns a pointer to the encoded data that must be
    sent to the peer side.

    \sa SharkSslCon_getEncDataLen and SharkSslCon_encryptMore
 */
U8 *SharkSslCon_getEncData(SharkSslCon *o);


/** This function is used in conjunction with state
    SharkSslCon_Encrypted returned by function
    #SharkSslCon_encrypt.

    The function returns the length of the encoded data that must be
    sent to the peer side.
   
    See #SharkSslCon_Encrypted for example code.

    \sa SharkSslCon_getEncData and SharkSslCon_encryptMore
 */
U16 SharkSslCon_getEncDataLen(SharkSslCon *o);


/** This function is used in conjunction with #SharkSslCon_encrypt
    when using the zero copy send API.

    \return a pointer to the internal SharkSslCon send buffer. 
    \sa SharkSslCon_getEncBufSize.
 */
U8 *SharkSslCon_getEncBufPtr(SharkSslCon *o);


/** Returns the length of the buffer returned by #SharkSslCon_getEncBufPtr
 */
U16 SharkSslCon_getEncBufSize(SharkSslCon *o);


/** This function is used in conjunction with state
    #SharkSslCon_AlertSend returned by function #SharkSslCon_encrypt or
    in conjunction with state #SharkSslCon_AlertRecv returned by
    function #SharkSslCon_decrypt.

    \returns #SHARKSSL_ALERT_LEVEL_WARNING or #SHARKSSL_ALERT_LEVEL_FATAL

    \sa #SharkSslCon_getAlertDescription and #SharkSslCon_getAlertData
 */
U8  SharkSslCon_getAlertLevel(SharkSslCon *o);


/** This function is used in conjunction with state
    #SharkSslCon_AlertSend returned by function #SharkSslCon_encrypt or
    in conjunction with state #SharkSslCon_AlertRecv returned by
    function #SharkSslCon_decrypt.

    returns the [SSL/TLS alert message](@ref SharkSslAlertMsg)

    \sa #SharkSslCon_getAlertLevel and #SharkSslCon_getAlertData
 */
U8  SharkSslCon_getAlertDescription(SharkSslCon *o);


/** This function is used in conjunction with state
    #SharkSslCon_AlertSend returned by function
    #SharkSslCon_encrypt.

    The function returns a pointer to the alert data that must be sent
    to the peer side.

    \sa #SharkSslCon_getAlertDataLen
 */
#define SharkSslCon_getAlertData(o)    SharkSslCon_getEncData(o)


/** This function is used in conjunction with state
    #SharkSslCon_AlertSend returned by function
    #SharkSslCon_encrypt. 

    The function returns the length of the alert data that must be
    sent to the peer side.

    \sa #SharkSslCon_getAlertData
 */
#define SharkSslCon_getAlertDataLen(o) SharkSslCon_getEncDataLen(o)

/** @} */ /* end group SharkSslCoreApi */ 


#if SHARKSSL_ENABLE_INFO_API

/** Returns the active session's [chiper suite](@ref Ciphersuites)
 */
SHARKSSL_API U16 SharkSslCon_getCiphersuite(SharkSslCon *o);

/** Returns the active session's [protocol version](@ref SharkSslProtocol)
 */
#if (SHARKSSL_TLS_1_3 && SHARKSSL_TLS_1_2)
SHARKSSL_API U8  SharkSslCon_getProtocol(SharkSslCon *o);
#elif SHARKSSL_TLS_1_3
#define SharkSslCon_getProtocol(o) (SHARKSSL_PROTOCOL_TLS_1_3)
#elif SHARKSSL_TLS_1_2
#define SharkSslCon_getProtocol(o) (SHARKSSL_PROTOCOL_TLS_1_2)
#else
#error please enable at least one of SHARKSSL_TLS_1_3, SHARKSSL_TLS_1_2
#endif

#endif


#if SHARKSSL_ENABLE_SNI

#if SHARKSSL_SSL_CLIENT_CODE
/** set Server Name Indication for TLS client connections
 */
SHARKSSL_API U8  SharkSslCon_setSNI(SharkSslCon *o, const char *name, U16 length); 
#endif

#endif


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
#if (SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CLIENT_AUTH)
/** Returns TRUE if the server requested a certificate from the client
    to verify that the client's identity (authentication)
 */
U8  SharkSslCon_certificateRequested(SharkSslCon *o);
#endif

/** Returns the peer's certificate if the handshaking has
    completed. The certificate is available at any time.
 */
SHARKSSL_API SharkSslCertInfo  *SharkSslCon_getCertInfo(SharkSslCon *o);

/** Add a certificate to the SharkSsl object. A SharkSsl object in
    [server mode](\ref #SharkSsl_Server) is required to have at least
    one certificate.

    __Note:__ You must install the certificate(s) before using the
    SharkSsl object -- i.e. before calling #SharkSsl_createCon.

    \returns TRUE on success or FALSE on error. The function
    fails if you have existing connections in the SharkSsl object.
 */
SHARKSSL_API U8 SharkSsl_addCertificate(SharkSsl *o, SharkSslCert cert);

#if SHARKSSL_ENABLE_CA_LIST

/** Set a Certificate Authority (CA) list so the SharkSSL object can
    permform certificate validation on the peer's certificate.
    
    \param o the SharkSsl object.

    \param caList list created by calling #SharkSslCertStore_assemble
    or by using the command line tool
    [SharkSSLParseCAList](\ref SharkSSLParseCAList)

    __Note:__ You can only set one CA list, thus the CA list must
    include all root certificates required for your system.

    The example program certcheck.c includes code that shows how to
    perform complete certificate validation of the connected servers.

    \return TRUE if the CA list was successfully installed or FALSE if
    another CA list has previously been installed.

    \sa #SharkSslCAList and SharkSslCon_trusted.
 */
SHARKSSL_API U8  SharkSsl_setCAList(SharkSsl *o, SharkSslCAList caList);

/** Returns TRUE if the certificate is valid and is signed with a root
    certificate trusted by SharkSSL. Root certificates can optionally
    be installed with parameter #SharkSslCAList when calling
    #SharkSsl_constructor.

    Note, the function only validates the certificate and its
    chain. You must typically also validate the domain name and the
    certificate's date. Function #SharkSslCon_trusted extends the
    certificate validation and also includes domain name validation
    and date check.

    \sa SharkSslCon_trusted
 */
SHARKSSL_API U8  SharkSslCon_trustedCA(SharkSslCon *o);

U8  SharkSslCon_isCAListEmpty(SharkSslCon *o);
#else

#define  SharkSslCon_trustedCA(o)   0
#endif  /* SHARKSSL_ENABLE_CA_LIST */

#if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_RSA)
/** Description to be added.
 */

/* to be used as 'flag' param */
#define SHARKSSL_SET_FAVOR_RSA      1  
#define SHARKSSL_CLEAR_FAVOR_RSA    0

/** A SharkSSL server can have multiple certificates, such as RSA
    certificates with various strengths, and Elliptic Curve
    Certificates (ECC). A SharkSSL server connection will select the
    strongest cipher combination supported by the server and the
    client. In general, the ECC certificate will be preferred by the
    server connection, if supported by the client. Most browsers today
    support ECC, however, Certificate Authorities do not typically
    support ECC.

    The purpose with function SharkSslCon_favorRSA is to favor RSA
    certificates over ECC when a client such as browser supports both
    ECC and RSA. An M2M device can then force the use of ECC by
    calling function SharkSslCon_selectCiphersuite, or at compile time
    by removing RSA support. This enables devices to use ECC, with
    self signed Certificate Authority certificates and browsers to use
    RSA certificates signed by well known Certificate Authorities.
 */
U8  SharkSslCon_favorRSA(SharkSslCon *o, U8 flag);
#endif  /* SHARKSSL_SSL_SERVER_CODE */
#endif  /* SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA */

#if SHARKSSL_SSL_CLIENT_CODE 
U8  SharkSslCon_selectProtocol(SharkSslCon *o, U8 protocol);
#endif

/** @addtogroup SharkSslSessionApi
@{
*/

#if SHARKSSL_ENABLE_SESSION_CACHE

#if SHARKSSL_ENABLE_INFO_API
/** Returns 1 if the current session is a resumed one.
 */
SHARKSSL_API U8    SharkSslCon_isResumed(SharkSslCon *o);
#endif

/** Release a session created by function #SharkSslCon_acquireSession.
 */
SHARKSSL_API U8    SharkSslSession_release(SharkSslSession *o, SharkSsl *s);

#if SHARKSSL_SSL_SERVER_CODE
/** experimental 
 */
SHARKSSL_API U8    SharkSslCon_releaseSession(SharkSslCon *o);
#endif

#if SHARKSSL_SSL_CLIENT_CODE 

/** Request a SharkSslSession object from the client's session pool.

    \returns a SharkSslSession object on success or NULL if the
    session cache pool is exhausted. See parameter 'cacheSize' in
    function SharkSsl_constructor for more information on the cache
    size.
  */
SHARKSSL_API SharkSslSession *SharkSslCon_acquireSession(SharkSslCon *o);


/** Resume an existing session.
    \param o the SharkSslCon object.
    \param s a session object created by function #SharkSslCon_acquireSession.

    \returns TRUE on success or FALSE if the session cannot be resumed.
 */
SHARKSSL_API U8 SharkSslCon_resumeSession(SharkSslCon *o, SharkSslSession *s); 

/** Returns the last time the session was accessed. Delta time can be
    calculated as follows: baGetUnixTime() -
    SharkSslSession_getLatestAccessTime(ss);
 */
SHARKSSL_API U32   SharkSslSession_getLatestAccessTime(SharkSslSession *o);
#endif
#endif

/** @} */ /* end group SharkSslSessionApi */

#if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_CLIENT_AUTH && \
    (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
/** This function is used by server solutions that require client SSL
    certificate authentication. For example, it can be used by an
    HTTPS server that requires the client to authenticate using a
    certificate signed with a Certificate Authority (CA) known to the
    server. The second parameter, caList specifies one or several CA
    certificates the server uses when validating the client
    certificate.

    The function must be called before the initial handshake has
    started or just after calling SharkSslCon_renegotiate. Calling
    SharkSslCon_requestClientCert after #SharkSslCon_renegotiate
    enables an existing session to request client authentication at a
    later stage. For example, a server may require that the client
    authenticates when the user navigates to a protected web page.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.

    \param caList the SharkSSL CA list is in a binary format optimized
    for speed and size. The list can be created by calling
    #SharkSslCertStore_assemble or by using the command line tool
    [SharkSSLParseCAList](\ref SharkSSLParseCAList). The client is
    then requested to provide an SSL certificate and this certificate
    must be signed using one of the CA certificates provided in the
    caList. The SSL handshake or rehandshake fails if the client's
    certificate is not trusted or not signed with a known CA
    certificate.

    \return TRUE (1) if the request is accepted. Returns FALSE (0) if
    the SharkSSL connection is already going through or done with a
    handshaking phase.
 */
SHARKSSL_API U8 SharkSslCon_requestClientCert(
   SharkSslCon *o, const void *caList);
#endif

#if (SHARKSSL_TLS_1_3 && SHARKSSL_SSL_CLIENT_CODE && SHARKSSL_ENABLE_CA_EXTENSION && \
    (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA))
/** This function is used by client solutions that require server SSL
    certificate authentication. It implements the "Certificate Authorities"
    extension as per RFC 8446, section 4.2.4.

    The function must be called before the initial handshake has
    started. 

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.

    \param caList the SharkSSL CA list is in a binary format optimized
    for speed and size. The list can be created by calling
    #SharkSslCertStore_assemble or by using the command line tool
    [SharkSSLParseCAList](\ref SharkSSLParseCAList). 
    
    Whenever the server is requested to provide an SSL certificate, 
    this certificate must be signed using one of the CA certificates 
    provided in the caList. The SSL handshake fails if the server's
    certificate is not trusted or not signed with a known CA
    certificate. In practice, for the specific connection, caList 
    will take over the list associated with the SharkSSL object 
    via #SharkSsl_setCAList.

    \return TRUE (1) if the request is accepted. Returns FALSE (0) if
    the SharkSSL connection is already going through or done with a
    handshaking phase.
 */
SHARKSSL_API U8 SharkSslCon_setCertificateAuthorities(
   SharkSslCon *o, const void *caList);
#endif

#if SHARKSSL_ENABLE_ALPN_EXTENSION
#if SHARKSSL_SSL_CLIENT_CODE
/** This function is used by client solutions to specify a list of
    application layer protocols according to RFC 7301 (ALPN).
    It must be called before the initial handshake has started.
    
    \param o the SharkSslCon object returned by function #SharkSsl_createCon.

    \param protList a string of comma separated protocols. Do not specify
    a final comma at the end of the string. This string
    must be a constant string stored in ROM for the function
    #SharkSslCon_getALPNProtocol to work properly.
        
    \return TRUE (1) if the request is accepted. Returns FALSE (0) if
    the SharkSSL connection is already going through or done with a
    handshaking phase.
*/
SHARKSSL_API U8 SharkSslCon_setALPNProtocols(
   SharkSslCon* o, const char* protList);

/** This function is used by client solutions to return the application
    layer protocol selected by the server among the ones specified through
    #SharkSslCon_setALPNProtocols. This function has to be called after the
    handshake has been initiated.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.

    \return NULL if none of the application layer protocols specified by the
    client have been selected by the server, or a pointer to the protocol name
    selected by the server - this pointer is to the string passed via the
    function #SharkSslCon_setALPNProtocols; please be aware that the protocol
    name can be terminated by a NULL or a comma, according to the passed string.
*/
SHARKSSL_API const char *SharkSslCon_getALPNProtocol(SharkSslCon* o);
#endif
#if SHARKSSL_SSL_SERVER_CODE
typedef int(*ALPNFunction)(SharkSslCon*, const char*, void *);
SHARKSSL_API U8 SharkSslCon_setALPNFunction(
   SharkSslCon *o, ALPNFunction func, void *pvoid);
#endif
#endif  /* SHARKSSL_ENABLE_ALPN_EXTENSION */

#if ((SHARKSSL_SSL_SERVER_CODE || SHARKSSL_SSL_CLIENT_CODE) && \
     SHARKSSL_ENABLE_SELECT_CIPHERSUITE)
/**
This function enables you to limit the number of ciphers at
runtime. Cipher suites can be enabled/disabled at compile time, but
your application may require that you also allow only specific ciphers
at runtime. By default, all ciphers enabled at compile time can be
used by SharkSSL. Calling this function disables the use of all
ciphers except the selected cipher. You can call this function up to N
times and re-enable N ciphers. N is by default set to 8 at compile
time. You can change the N value by setting macro
#SHARKSSL_SELECT_CIPHERSUITE_LIST_DEPTH.

The function must be called before the initial handshake has completed
or just after calling SharkSslCon_renegotiate. Calling
SharkSslCon_selectCiphersuite and then #SharkSslCon_renegotiate
enables an existing session to change cipher.

<b>Example:</b><br>
SharkSslCon_selectCiphersuite(myCon, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)

\param o the SharkSslCon object returned by function #SharkSsl_createCon.

\param cipherSuite is one of the [supported ciphers](\ref SharkSslCiphers)
enabled at compile time.

\return TRUE (1) if the request is accepted. Returns FALSE (0) if the
SharkSSL connection is currently in the handshaking phase, if the
selected cipher was not enabled at compile time, or if called more
than N times.
*/
SHARKSSL_API U8 SharkSslCon_selectCiphersuite(SharkSslCon *o, U16 cipherSuite);

/** Clears the selection, thus enabling all ciphers.
 */
SHARKSSL_API U8 SharkSslCon_clearCiphersuiteSelection(SharkSslCon *o); 
#endif

#if (SHARKSSL_SSL_SERVER_CODE && SHARKSSL_ENABLE_SECURE_RENEGOTIATION)
/** This function enables you to renegotiate an already established
    SSL/TLS connection. Renegotiation is also known as
    rehandshake. The function informs the SharkSSL state machine for
    the active connection that you wish to renegotiate the
    connection. The actual renegotiation is initiated and performed
    the next time you call #SharkSslCon_decrypt.

    The function is typically used in combination with
    #SharkSslCon_requestClientCert, when requesting client SSL
    certificate authentication on an existing connection. The function
    can also be used in combination with
    #SharkSslCon_selectCiphersuite, to force a change in the cipher
    being used.

    \param o the SharkSslCon object returned by function #SharkSsl_createCon.

    \return TRUE (1) if the request is accepted. Returns FALSE (0) if
    the SharkSSL connection is currently in the handshaking phase.
*/
SHARKSSL_API U8 SharkSslCon_renegotiate(SharkSslCon *o);
#endif

/** @} */ /* end group SharkSslApi */ 


#if SHARKSSL_ENABLE_PEM_API
/** @addtogroup RayCryptoApi
@{
*/


/** Return values from function #sharkssl_PEM
 */
typedef enum
{
   /** OK */
   SHARKSSL_PEM_OK = 0,

   /** OK_PUBLIC */
   SHARKSSL_PEM_OK_PUBLIC = 1,

   /** ALLOCATION_ERROR */
   SHARKSSL_PEM_ALLOCATION_ERROR = - 3000,

   /** KEY_PARSE_ERROR */
   SHARKSSL_PEM_KEY_PARSE_ERROR,

   /** KEY_WRONG_IV */
   SHARKSSL_PEM_KEY_WRONG_IV,

   /** KEY_WRONG_LENGTH */
   SHARKSSL_PEM_KEY_WRONG_LENGTH,

   /** KEY_PASSPHRASE_REQUIRED */
   SHARKSSL_PEM_KEY_PASSPHRASE_REQUIRED,

   /** KEY_UNRECOGNIZED_FORMAT */
   SHARKSSL_PEM_KEY_UNRECOGNIZED_FORMAT,

   /** KEY_UNSUPPORTED_FORMAT */
   SHARKSSL_PEM_KEY_UNSUPPORTED_FORMAT,

   /** KEY_UNSUPPORTED_MODULUS_LENGTH */
   SHARKSSL_PEM_KEY_UNSUPPORTED_MODULUS_LENGTH,

   /** KEY_UNSUPPORTED_EXPONENT_LENGTH */
   SHARKSSL_PEM_KEY_UNSUPPORTED_EXPONENT_LENGTH,

   /** KEY_UNSUPPORTED_ENCRYPTION_TYPE */
   SHARKSSL_PEM_KEY_UNSUPPORTED_ENCRYPTION_TYPE,

   /** KEY_CERT_MISMATCH */
   SHARKSSL_PEM_KEY_CERT_MISMATCH,

   /** CERT_UNRECOGNIZED_FORMAT */
   SHARKSSL_PEM_CERT_UNRECOGNIZED_FORMAT,

   /** CERT_UNSUPPORTED_TYPE */
   SHARKSSL_PEM_CERT_UNSUPPORTED_TYPE,

   /** KEY_UNSUPPORTED_VERSION */
   SHARKSSL_PEM_KEY_UNSUPPORTED_VERSION,

   /** KEY_REQUIRED */
   SHARKSSL_PEM_KEY_REQUIRED,

   /** A PRIVATE KEY IS REQUIRED */
   SHARKSSL_PEM_KEY_PRIVATE_KEY_REQUIRED,

   /** INTERNAL ERROR */
   SHARKSSL_PEM_INTERNAL_ERROR
} sharkssl_PEM_RetVal;


/** Create a SharkSslCert certificate by using a certificate and key
 * in PEM format.

    example:

    \code
int addMyCert(SharkSsl* shark)
{
   SharkSslCert *sharkCert;
   // The two following functions illustrate how a certificate and
   // key can be read from a file system and inserted into an
   // allocated buffer.
   char* cert=readMyCertFromFileSystem();
   char* key=readMyKeyFromFileSystem();
   if(sharkssl_PEM(cert,key,NULL,&sharkCert))
      return -1;
   free(cert);
   free(key);
   // You may redesign the code and keep a reference to the
   // SharkSslCert object if you design a system using dynamic objects
   // i.e. if you later plan on releasing the SharkSSL object and
   // the SharkSslCert object. You cannot release the SharkSslCert
   // object before releasing the SharkSSL object.
   SharkSsl_addCertificate(shark,sharkCert);
   return 0;
}
    \endcode
 */
SHARKSSL_API sharkssl_PEM_RetVal sharkssl_PEM(
   const char *certPEM, const char *keyPEM, 
   const char *passphrase, SharkSslCert *sharkSslCert);

#if SHARKSSL_ENABLE_ENCRYPTED_PKCS8_SUPPORT
/** sharkssl_PEM_PBKDF2 (output, passphrase, salt, salt_len, iterations, dkLen, hashID)
    Derives a key from a passphrase using the PBKDF2 algorithm as specified in RFC 8018 section 5.2.
  
   This function performs the Password-Based Key Derivation Function 2 (PBKDF2) to derive a key from a given passphrase.
   The derived key is computed by iterating the specified hash function over the passphrase and salt.
  
   \param dk          pointer to the buffer where the derived key will be stored
   \param passphrase  pointer to the passphrase (null-terminated string) used to derive the key
   \param salt        pointer to the salt string used in the key derivation process
   \param saltLen     length of the salt in bytes
   \param iterations  number of iterations to perform in the key derivation process
   \param dkLen       desired length of the derived key in bytes.
   \param hashID      identifier for the digest function to use; allowed values are: 
                      SHARKSSL_HASHID_SHA512,  SHARKSSL_HASHID_SHA384, SHARKSSL_HASHID_SHA256
                        
   \return 0 on success, or a non-zero error code on failure
 */
SHARKSSL_API int sharkssl_PEM_PBKDF2(
   U8 *dk, const char *passphrase, 
   const char *salt, U32 saltLen, 
   U32 iterations, U16 dkLen, U8 hashID);
#endif

/** @} */ /* end group RayCryptoApi */
#endif

#if SHARKSSL_ENABLE_RSA

/** \addtogroup SharkSslInfoAndCodes
@{
*/

/** SHARKSSL_RSA_NO_PADDING for raw RSA encryption (insecure).
 */
#define SHARKSSL_RSA_NO_PADDING      0


/** SHARKSSL_RSA_PKCS1_PADDING for
    [PKCS #1 v1.5](http://tools.ietf.org/html/rfc2313).
*/
#define SHARKSSL_RSA_PKCS1_PADDING   1


/** Return values from functions #sharkssl_RSA_public_encrypt,
    #sharkssl_RSA_private_decrypt, #sharkssl_RSA_public_decrypt,
    #sharkssl_RSA_private_encrypt, #sharkssl_RSA_PKCS1V1_5_sign_hash,
    #sharkssl_RSA_PKCS1V1_5_verify_hash
 */
typedef enum
{
   /** OK */
   SHARKSSL_RSA_OK = 0,

   /** ALLOCATION_ERROR */
   SHARKSSL_RSA_ALLOCATION_ERROR = -3000,

   /** INTERNAL_ERROR */
   SHARKSSL_RSA_INTERNAL_ERROR = -3100,

   /** WRONG_PARAMETERS */
   SHARKSSL_RSA_WRONG_PARAMETERS,

   /** WRONG_KEY_FORMAT */
   SHARKSSL_RSA_WRONG_KEY_FORMAT,

   /** WRONG_KEY_LENGTH */
   SHARKSSL_RSA_WRONG_KEY_LENGTH,

   /** INPUT_DATA_LENGTH_TOO_BIG */
   SHARKSSL_RSA_INPUT_DATA_LENGTH_TOO_BIG,

   /** INPUT_DATA_LENGTH_AND_KEY_LENGTH_MISMATCH */
   SHARKSSL_RSA_INPUT_DATA_LENGTH_AND_KEY_LENGTH_MISMATCH,

   /** PKCS1_PADDING_ERROR */
   SHARKSSL_RSA_PKCS1_PADDING_ERROR,

   /** KEY_IS_NOT_PRIVATE */
   SHARKSSL_RSA_KEY_NOT_PRIVATE,

   /** VERIFICATION FAIL */
   SHARKSSL_RSA_VERIFICATION_FAIL,

   /** WRONG SIGNATURE */
   SHARKSSL_RSA_WRONG_SIGNATURE,

   /** WRONG_LABEL_LENGTH */
   SHARKSSL_RSA_WRONG_LABEL_LENGTH
} sharkssl_RSA_RetVal;
#endif

/** @} */ /* end group SharkSslInfoAndCodes */ 

#if SHARKSSL_ENABLE_RSA_API

/** \defgroup RSA RSA encrypt/decrypt functions
\ingroup RayCryptoApi

@{
*/

/** SharkSslRSAKey is an alias for the #SharkSslCert type and is a
    private/public key converted by sharkssl_PEM_to_RSAKey or the
    command line tool [SharkSslParseKey](\ref SharkSslParseKey).
 */
typedef U8* SharkSslRSAKey;

#if SHARKSSL_ENABLE_PEM_API
/** Convert an RSA private or public key in PEM format to the
    #SharkSslRSAKey format.
 
    Note: the converted value must be released by calling
    SharkSslRSAKey_free, when no longer needed.

    example:
    \code
   {
      SharkSslRSAKey RSAKey;   
      ...
      RSAKey = sharksslPEM_to_RSAKey(key, pass);
      if (RSAKey)
      {
         ...
         void SharkSslRSAKey_free(RSAKey);
      }
   }
   \endcode

   \return the private/public key in #SharkSslRSAKey format or NULL if
   the conversion fails.
  */
SHARKSSL_API SharkSslRSAKey sharkssl_PEM_to_RSAKey(
   const char *PEMKey, const char *passphrase);

/** Extract the public key form a certificate in PEM format

    Note: the converted value must be released by calling
    SharkSslKey_free, when no longer needed.

    example:
    \code
   {
      SharkSslKey SslKey;   
      ...
      SslKey = sharkssl_PEM_extractPublicKey(cert);
      if (SslKey)
      {
         ...
         void SharkSslKey_free(SslKey);
      }
   }
   \endcode

   \return the certificate's public key in #SharkSslKey (RSA or ECC) format
   or NULL if the conversion fails.

 */
SHARKSSL_API SharkSslKey
sharkssl_PEM_extractPublicKey(const char *certPEM);

SHARKSSL_API SharkSslKey
sharkssl_PEM_extractPublicKey_ext(const char *certPEM, U8 *keyType);
#endif  /* SHARKSSL_ENABLE_PEM_API */

#if (SHARKSSL_ENABLE_PEM_API || (SHARKSSL_ENABLE_RSA && SHARKSSL_ENABLE_RSAKEY_CREATE))
/** Release a SharkSslRSAKey allocated by functions #sharkssl_PEM_to_RSAKey
    and sharkssl_PEM_extractPublicKey.
 */
SHARKSSL_API void SharkSslRSAKey_free(SharkSslRSAKey key);
#define _SHARKSSLRSAKEY_FREE 1
#endif

#if SHARKSSL_ENABLE_RSA
#if SHARKSSL_ENABLE_RSAKEY_CREATE
/** 
    @ingroup SharkSslCertApi
    RSA key creation.

  \param privKey [output parameter] points to a buffer allocated by
     SharkSslRSAKey_create and which contains the generated private
     RSA key; the key is represented in the SharkSSL format.

  \param keyLength key length in bits, valid values: 1024,
     2048, 4096; other key length are not currently supported for
     certificate creation. 
     
  \return the number of allocated bytes if the key creation was
   successful. A negative value is returned on error --
   e.g. allocation error.  They key is in a binary format that can be
   saved to RAM or Flash by saving the returned allocated number of
   bytes starting at the address pointed to by 'privKey'

   Note: the key must be saved after creating it if the key must
   be persistent. See the #SharkSslECCKey_create example for more information.
 */
SHARKSSL_API int SharkSslRSAKey_create(SharkSslRSAKey *privKey, U16 keyLength);

/** 
    @ingroup SharkSslCertApi
    RSA public key extraction from a private key.

  \param privKey [input parameter] RSA key represented in the
     internal SharkSSL format. See the privKey parameter in
     #SharkSslRSAKey_create function.

  \return a pointer to the RSA public key as sequence of bytes.
     The RSA public key is a modulo and its length can be
     determined by calling the function #SharkSslRSAKey_size and
     passing to it the RSA key privKey.
 */
SHARKSSL_API U8 *SharkSslRSAKey_getPublic(SharkSslRSAKey privKey);
#endif 

/** 
    @ingroup SharkSslCertApi
    Returns the private or public key's modulus size in bytes.
 */
SHARKSSL_API U16 SharkSslRSAKey_size(SharkSslRSAKey key);

/** Encrypt data using the public key or private key. The private key
    includes the public key an can for this reason be used for
    encrypting the data.

    \param pubkey is the public key in SharkSslRSAKey format.

    \param in the plaintext

    \param len is the length/size of parameter 'in'. This length must be
    exactly #SharkSslRSAKey_size (key) when selecting
    #SHARKSSL_RSA_NO_PADDING or a value between 1 and
    (#SharkSslRSAKey_size (key) - 11) when selecting
    SHARKSSL_RSA_PKCS1_PADDING.

    \param out the encrypted ciphertext is copied to this buffer. The
    size of this buffer must be no less than #SharkSslRSAKey_size (key)

   \param padding is one of #SHARKSSL_RSA_PKCS1_PADDING or
   #SHARKSSL_RSA_NO_PADDING

   \return the size of the encrypted ciphertext, or -1 if any error occurs
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_public_encrypt(
    SharkSslRSAKey pubkey, const U8 *in, int len, U8 *out, int padding);


/** Decrypt ciphertext using the private key.

    \param privkey is the private key in SharkSslRSAKey format.

    \param in the ciphertext

    \param len is the length/size of parameter 'in'. This length must be
    exactly #SharkSslRSAKey_size (key).

    \param out the decrypted ciphertext is copied to this buffer. The
    size of this buffer must be no less than #SharkSslRSAKey_size (key)

   \param padding is one of #SHARKSSL_RSA_PKCS1_PADDING or
   #SHARKSSL_RSA_NO_PADDING

   \return the size of the decrypted ciphertext, or -1 if any error occurs
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_private_decrypt(
   SharkSslRSAKey privkey, const U8 *in, int len, U8 *out, int padding);


/**
 * Sign a hash using a private RSA key.
 * Padding follows PKCS#1 V1.5 per RFC 8017 section 8.2.1.
 *
 * \param privkey is the private key in SharkSslRSAKey format.
 * \param sig     Pointer to the buffer where the signature will be stored.
 *                The buffer size must be at least #SharkSslRSAKey_size.
 * \param siglen  Pointer to store the length of the generated signature (output parameter).
 * \param hash    Pointer to the hash to sign.
 * \param hashID  Identifier for the digest function used.
 *                Valid values:
 *                - SHARKSSL_HASHID_SHA256
 *                - SHARKSSL_HASHID_SHA384
 *                - SHARKSSL_HASHID_SHA512
 * \return 0 upon successful completion, or an error value to be checked
 *         against #sharkssl_RSA_RetVal.
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_PKCS1V1_5_sign_hash(
   SharkSslRSAKey privkey, U8 *sig, U16 *siglen, const U8 *hash, U8 hashID);


/**
 * Verify a signature hash using a public RSA key.
 * Padding follows PKCS#1 V1.5 per RFC 8017 section 8.2.2.
 *
 * \param pubkey The public key in SharkSslRSAKey format.
 *               A corresponding private key may also be used.
 * \param sig     Pointer to the signature to verify.
 * \param siglen  The length of the signature in bytes (input parameter).
 * \param hash    Pointer to the hash to verify against the signature.
 * \param hashID Identifier for the digest function used.
 *              Valid values:
 *                - SHARKSSL_HASHID_SHA256
 *                - SHARKSSL_HASHID_SHA384
 *                - SHARKSSL_HASHID_SHA512
 * \return 0 upon successful verification, or an error value to be checked
 *         against #sharkssl_RSA_RetVal.
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_PKCS1V1_5_verify_hash(
   SharkSslRSAKey pubkey, U8 *sig, U16 siglen, const U8 *hash, U8 hashID);


#if SHARKSSL_ENABLE_RSA_OAEP
/** Decrypt ciphertext using the private key, padding is OAEP per RFC 8017.

   \param privkey is the private key in SharkSslRSAKey format.

   \param in the ciphertext (must be in RAM since ITS CONTENT WILL BE MODIFIED)

   \param len is the length/size of parameter 'in'. This length must be
   exactly #SharkSslRSAKey_size(privkey).

   \param hashID an identifier for the digest function used 
    Allowed values are:
        SHARKSSL_HASHID_SHA1

   \param out the decrypted ciphertext is copied to this buffer. The
   size of this buffer must be no less than the expected decrypted text

   \param label is an optional label per RFC 8017 sec. 7.1.1. Use
    null string when empty.

   \param labelLen is the length of the label. Specify 0 when label
    is empty

   \return the size of the decrypted ciphertext, or <0 if any error occurs
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_private_decrypt_OAEP(
   SharkSslRSAKey privkey, U8 *in, int len, U8 hashID, U8 *out, const char *label, U16 labelLen);


/** Encrypt cleartext using the public key, padding is OAEP per RFC 8017.

   \param pubkey is the public key in SharkSslRSAKey format. The matching
   private key can be provided, too.

   \param in the cleartext (not required to be in RAM)

   \param len is the length/size of parameter 'in'. This length must be
   not greater than #SharkSslRSAKey_size(pubkey) - (2 * labelLen) - 2.

   \param hashID an identifier for the digest function used 
    Allowed values are:
        SHARKSSL_HASHID_SHA1

   \param out the encrypted cleartext is copied to this buffer. The
   size of this buffer must be #SharkSslRSAKey_size(pubkey)

   \param label is an optional label per RFC 8017 sec. 7.1.1. Use
    null string when empty.

   \param labelLen is the length of the label. Specify 0 when label
    is empty

   \return the size of the encrypted ciphertext, or <0 if any error occurs
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_public_encrypt_OAEP(
   SharkSslRSAKey pubkey, const U8 *in, int len, U8 hashID, U8 *out, const char *label, U16 labelLen);
#endif


/** Sign a message digest using the private key. See RFC 8017 sec. 7.1.2

    \param privkey is the private key in SharkSslRSAKey format.

    \param in commonly, an algorithm identifier followed by a message digest

    \param len is the length/size of parameter 'in'. This length must be
    exactly #SharkSslRSAKey_size (key) when selecting
    #SHARKSSL_RSA_NO_PADDING or a value between 1 and
    (#SharkSslRSAKey_size (key) - 11) when selecting
    SHARKSSL_RSA_PKCS1_PADDING.

    \param out the signature is copied to this buffer. The size
    of this buffer must be no less than #SharkSslRSAKey_size (key)

   \param padding is one of #SHARKSSL_RSA_PKCS1_PADDING or
   #SHARKSSL_RSA_NO_PADDING

   \return the size of the signature, or -1 if any error occurs
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_private_encrypt(
   SharkSslRSAKey privkey, const U8 *in, int len, U8 *out, int padding);


/** Bring back a message digest using the public key or private key. 
    The private key includes the public key an can for this reason be used for
    this operation.

    \param pubkey is the public key in SharkSslRSAKey format.

    \param in the RSA signature.  Please notice that the RSA signature is
    modified by this function and must for this reason be in RAM.

    \param len is the length/size of parameter 'in'. This length must be
    exactly #SharkSslRSAKey_size (key).

    \param out the message digest is copied to this buffer. The size
    of this buffer must be no less than #SharkSslRSAKey_size (key)

   \param padding is one of #SHARKSSL_RSA_PKCS1_PADDING or
   #SHARKSSL_RSA_NO_PADDING

   \return the size of the obtained message digest, or -1 if any error occurs
 */
SHARKSSL_API sharkssl_RSA_RetVal sharkssl_RSA_public_decrypt(
   SharkSslRSAKey pubkey, const U8 *in, int len, U8 *out, int padding);

#endif

/** @} */ /* end group RSA */
#endif


/** To be used as hashlen parameter in sharkssl_ECDSA_ functions
    These are the hash lengths for the functions implemented in SharkSSL/RayCrypto

    SHARKSSL_MD5_HASH_LEN
    SHARKSSL_SHA1_HASH_LEN
    SHARKSSL_SHA256_HASH_LEN
    16SHARKSSL_SHA384_HASH_LEN
    SHARKSSL_SHA512_HASH_LEN
    SHARKSSL_POLY1305_HASH_LEN
 */


#if SHARKSSL_USE_ECC

/*
 * NamedCurve, use as curveID parameter
 * SECPxxxR1       - RFC 4492 section 5.1.1
 * BRAINPOOLPxxxR1 - RFC 7027 section 2
 * CURVE25519,448  - RFC 8446 section 4.2.7
 */
#define SHARKSSL_EC_CURVE_ID_SECP256R1        23
#define SHARKSSL_EC_CURVE_ID_SECP384R1        24
#define SHARKSSL_EC_CURVE_ID_SECP521R1        25
#define SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1  26
#define SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1  27
#define SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1  28
#define SHARKSSL_EC_CURVE_ID_CURVE25519       29
#define SHARKSSL_EC_CURVE_ID_CURVE448         30


/** 
    @ingroup ECDSA
    SharkSslECCKey is an alias for the #SharkSslCert type and is a
    private/public key converted by #sharkssl_PEM_to_ECCKey or the
    command line tool [SharkSslParseKey](\ref SharkSslParseKey).
 */
typedef U8* SharkSslECCKey;

#if SHARKSSL_ENABLE_PEM_API
/** 
    @ingroup ECDSA
    Convert an ECC private or public key in PEM format to the
    #SharkSslECCKey format.
 
    Note: the converted value must be released by calling
    SharkSslECCKey_free, when no longer needed.

    example:
    \code
   {
      SharkSslECCKey ECCKey;   
      ...
      ECCKey = sharksslPEM_to_ECCKey(key, pass);
      if (ECCKey)
      {
         ...
         void SharkSslECCKey_free(ECCKey);
      }
   }
   \endcode

   \return the private/public key in #SharkSslECCKey format or NULL if
   the conversion fails.
  */
SHARKSSL_API SharkSslECCKey sharkssl_PEM_to_ECCKey(
   const char *PEMKey, const char *passphrase);


#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
/** 
   @ingroup SharkSslCertApi
   Returns the private or public key's "vector size" in bytes.
   The "vector size" is the size of the key as represented as
   an array of bytes in the SharkSSL internal proprietary format.
   This function is useful for key comparison or saving.
  */

SHARKSSL_API U16 SharkSslKey_vectSize(const SharkSslKey key);
#define SharkSslCert_vectSize(c) SharkSslKey_vectSize((const SharkSslCert)c)
#define SharkSslCert_vectSize_keyInfo(c, t, p, a, b, x, y) SharkSslKey_vectSize_keyInfo((const SharkSslKey)c, t, p, a, b, x, y)
#if SHARKSSL_ENABLE_RSA
#define SharkSslRSAKey_vectSize(k) SharkSslKey_vectSize(k)
#define SharkSslRSAKey_vectSize_keyInfo(k, t, p, a, b, x, y) SharkSslKey_vectSize_keyInfo((const SharkSslKey)k, t, p, a, b, x, y)
#endif
#if SHARKSSL_ENABLE_ECDSA
#define SharkSslECCKey_vectSize(k) SharkSslKey_vectSize(k)
#define SharkSslECCKey_vectSize_keyInfo(k, t, p, a, b, x, y) SharkSslKey_vectSize_keyInfo((const SharkSslKey)k, t, p, a, b, x, y)
#endif

/* return values of function SharkSslKey_vectSize_keyInfo for the parameter keyType */
#define SHARKSSL_KEYTYPE_RSA     0x00 
#define SHARKSSL_KEYTYPE_EC      0x02

/** 
   @ingroup SharkSslCertApi
   Returns the private or public key's "vector size" in bytes.
   The "vector size" is the size of the key as represented as
   an array of bytes in the SharkSSL internal proprietary format.
   Returns 0 if the key is not valid.
   keyType: return value, either SHARKSSL_KEYTYPE_RSA or SHARKSSL_KEYTYPE_EC
   isKeyPrivate: 0 if public key, 1 if private key
   if the keyType is SHARKSSL_KEYTYPE_RSA:
     d1: pointer to the modulus, a sequence of bytes in big endian format of length d1Len
     d2: pointer to the exponent, a sequence of bytes in big endian format of length d2Len
   if the keyType is SHARKSSL_KEYTYPE_EC:
     d1: pointer to the X coordinate, a sequence of bytes in big endian format of length d1Len
     d2: pointer to the Y coordinate, a sequence of bytes in big endian format of length d2Len
   This function is useful to extract info from a key.
  */
SHARKSSL_API U16 SharkSslKey_vectSize_keyInfo(const SharkSslKey key, U8 *keyType, U8 *isKeyPrivate, U8 **d1, U16 *d1Len, U8 **d2, U16 *d2Len);
#endif
#endif

#if SHARKSSL_ENABLE_ECCKEY_CREATE

typedef int (*sharkssl_rngfunc)(void* handle, U8 *ptr, U16 len);


/** A macro for creating an ECC key using the SharkSSL library.
  @ingroup SharkSslCertApi
  @def SharkSslECCKey_create(privKey, curveID)
 
  This macro simplifies the creation of an ECC key by calling the 
  `SharkSslECCKey_createEx` function with default values for the random 
  number generator (RNG) handle and function.
 
  @param privKey Pointer to a `SharkSslECCKey` structure that will hold the 
           generated private key.
  @param curveID The curve identifier (`curveID`) specifying which elliptic 
           curve to use.
 
  @note This macro automatically sets `rngHandle` and `rngFunc` to `0`, 
        which means the default RNG mechanism will be used.
 
  @see SharkSslECCKey_createEx
 */
#define SharkSslECCKey_create(privKey, curveID) SharkSslECCKey_createEx((privKey), (curveID), 0, 0)


/** Creates an ECC key using the SharkSSL library.
    @ingroup SharkSslCertApi

    \param privKey [output parameter] points to a buffer allocated by
     SharkSslECCKey_create and which contains the generated private
     ECC key; the key is represented in a the SharkSSL format.

  \param curveID is one of:
    - SHARKSSL_EC_CURVE_ID_SECP256R1
    - SHARKSSL_EC_CURVE_ID_SECP384R1
    - SHARKSSL_EC_CURVE_ID_SECP521R1
    - SHARKSSL_EC_CURVE_ID_BRAINPOOLP256R1
    - SHARKSSL_EC_CURVE_ID_BRAINPOOLP384R1
    - SHARKSSL_EC_CURVE_ID_BRAINPOOLP512R1
    - SHARKSSL_EC_CURVE_ID_CURVE25519
    - SHARKSSL_EC_CURVE_ID_CURVE448

    \param rngHandle optional object handle/instance for rngFunc
    \param rngFunc You can use your own random generator function for creating the key


  \return the number of allocated bytes if the key creation was
     successful. A negative value is returned on error --
     e.g. allocation error.  They key is in a binary format that can
     be saved to RAM or Flash by saving the returned allocated number
     of bytes starting at the address pointed to by 'privKey'

   Note: the key must be saved after creating it if the key must
   be persistent. 
   The following example shows how to create and save a key.
   \code
   SharkSslECCKey createAndSaveKey(const char* filename)
   {
      SharkSslECCKey privKey;
      int len = SharkSslECCKey_create(&privKey, SHARKSSL_EC_CURVE_ID_SECP256R1,0,0);
      if(len > 0)
      {
         FILE* fp = fopen(filename, "w");
         if(fp)
         {
            fwrite(privKey, sizeof(U8), len, fp);
            fclose(fp);
            return privKey;
         }
      }
      return 0;
   }
   \endcode
 */
SHARKSSL_API int SharkSslECCKey_createEx(SharkSslECCKey* privKey, U16 curveID, void* rngHandle, sharkssl_rngfunc rngFunc);
#endif


#if (SHARKSSL_ENABLE_PEM_API || SHARKSSL_ENABLE_ECCKEY_CREATE)
/** 
    @ingroup SharkSslCertApi
    Release a SharkSslECCKey allocated by functions #sharkssl_PEM_to_ECCKey
    or #SharkSslECCKey_create
 */
SHARKSSL_API void SharkSslECCKey_free(SharkSslECCKey key);
#define _SHARKSSLECCKEY_FREE 1
#endif


/*
 *-----------------------------------------------------------------------------
 * To free up the memory allocated by SharkSslECCKey_create and 
 * SharkSslRSAKey_create, the following macro is provided
 * For instance, this function could be called after saving the key to a file
 *-----------------------------------------------------------------------------
 * key: input parameter, points to a buffer allocated by either 
 *    SharkSslECCKey_create or SharkSslRSAKey_create
 */
#if defined(_SHARKSSLRSAKEY_FREE)
#define SharkSslKey_free SharkSslRSAKey_free
#elif defined (_SHARKSSLECCKEY_FREE)
#define SharkSslKey_free SharkSslECCKey_free
#else
#define SharkSslKey_free
#endif
#undef _SHARKSSLRSAKEY_FREE
#undef _SHARKSSLECCKEY_FREE


/** \addtogroup SharkSslInfoAndCodes
@{
*/


#if SHARKSSL_ENABLE_ECDSA 
/** Return values from functions #sharkssl_ECDSA_sign_hash,
    #sharkssl_ECDSA_verify_hash
 */
/* ECDSA API and also internal sharkssl_ECDSA_signASN1 */
typedef enum
{
   /** OK */
   SHARKSSL_ECDSA_OK = 0,

   /** ALLOCATION_ERROR */
   SHARKSSL_ECDSA_ALLOCATION_ERROR = -3200,

   /** INTERNAL_ERROR */
   SHARKSSL_ECDSA_INTERNAL_ERROR = -3300,

   /** WRONG_PARAMETERS */
   SHARKSSL_ECDSA_WRONG_PARAMETERS,

   /** WRONG_KEY_FORMAT */
   SHARKSSL_ECDSA_WRONG_KEY_FORMAT,

   /** KEY_IS_NOT_PRIVATE */
   SHARKSSL_ECDSA_KEY_NOT_PRIVATE,

   /** KEY_IS_NOT_PUBLIC */
   SHARKSSL_ECDSA_KEY_NOT_PUBLIC,

   /** SIGLEN_TOO_SMALL */
   SHARKSSL_ECDSA_SIGLEN_TOO_SMALL,

   /** VERIFICATION_FAIL */
   SHARKSSL_ECDSA_VERIFICATION_FAIL,

   /** WRONG SIGNATURE */
   SHARKSSL_ECDSA_WRONG_SIGNATURE
} sharkssl_ECDSA_RetVal;

/** @} */ /* end group SharkSslInfoAndCodes */ 

/** @addtogroup ECDSA
@{
*/


#if SHARKSSL_ENABLE_ECDSA_API
#if (!SHARKSSL_ECDSA_ONLY_VERIFY)
/** Returns the maximum length (in bytes) of a DER-encoded ECDSA 
    signature generated with the private key 'privkey'. This function 
    is typically used in combination with #sharkssl_ECDSA_sign_hash to
    compute the maximum length of the signature and to allocate a 
    buffer large enough to hold the signature 'sig'.

    \param privkey is the private key in SharkSslECCKey format.
 */
SHARKSSL_API U16 sharkssl_ECDSA_siglen(SharkSslECCKey privkey);

/** Generate the signature using the ECC private key and a hash. 

    \param privkey is the private key in #SharkSslECCKey format.

    \param sig is a pointer to the buffer where the DER-encoded ECDSA
     signature will be generated. The size of this buffer must not be
     smaller than the value returned by #sharkssl_ECDSA_siglen for
     param 'privkey'. The length of this buffer, which may be larger
     than required, is provided in the next parameter (siglen).

    \param siglen is parameter "sig"'s length and is provided as an
     input parameter. The signature length will be returned as output
     parameter.

    \param hash the message digest obtained from a hash function
     e.g. SHA256. 

    \param hashID  Identifier for the digest function used.
                   Valid values:
                   - SHARKSSL_HASHID_SHA256
                   - SHARKSSL_HASHID_SHA384
                   - SHARKSSL_HASHID_SHA512

    \return SHARKSSL_ECDSA_OK if the signature generation is successful, 
     or one of the #sharkssl_ECDSA_RetVal error codes.
 */
SHARKSSL_API sharkssl_ECDSA_RetVal sharkssl_ECDSA_sign_hash(
   SharkSslECCKey privkey, U8 *sig, U16 *siglen, const U8 *hash, U8 hashID);
#endif

/** Verify a message using the ECC public key and a hash algorithm. 

    \param pubkey is the public key in SharkSslECCKey format.

    \param sig is a pointer to the DER-encoded ECDSA signature 
     that is to be verified.

    \param siglen is parameter "sig"'s length.

    \param hash the message digest obtained from a hash function
     e.g. SHA256. 

    \param hashID  Identifier for the digest function used.
                   Valid values:
                   - SHARKSSL_HASHID_SHA256
                   - SHARKSSL_HASHID_SHA384
                   - SHARKSSL_HASHID_SHA512

    \return SHARKSSL_ECDSA_OK if the signature verification is successful, 
     or one of the #sharkssl_ECDSA_RetVal error codes.
 */
SHARKSSL_API sharkssl_ECDSA_RetVal sharkssl_ECDSA_verify_hash(
   SharkSslECCKey pubkey, U8 *sig, U16 siglen, const U8 *hash, U8 hashID);

#endif  /* SHARKSSL_ENABLE_ECDSA_API */
#endif  /* SHARKSSL_ENABLE_ECDSA */

/** @} */ /* end group ECC */
#endif


#if (SHARKSSL_ENABLE_CA_LIST && SHARKSSL_ENABLE_CERTSTORE_API)

/** @addtogroup SharkSslCertApi
@{
*/


#ifndef BA_API  /* standalone SharkSSL */
#define BA_API SHARKSSL_API
typedef U8 BaBool;
#endif
#include "DoubleList.h"

/** SharkSslCertStore is a container object used when assembling a
 #SharkSslCAList. Without a certificate store, function
 #SharkSslCon_trustedCA() will only return FALSE (not trusted).

 A certificate store is required when a TLS client must
 validate the server's certificate and the complete chain. See the
 tutorial [Certificate Management](
 https://realtimelogic.com/articles/Certificate-Management-for-Embedded-Systems)
 for an introduction to Public Key Infrastructure or PKI for short.

 ### Example:
 \code
   SharkSslCertStore certStore;
   SharkSslCertStore_constructor(&certStore);
   SharkSslCertStore_add(&certStore, cert, certLen);
   SharkSslCertStore_assemble(&certStore, &caList);
 \endcode

 */
typedef struct SharkSslCertStore
{
   DoubleList certList;
   SharkSslCAList caList;
   U16 elements;  /* number of elements in list */
} SharkSslCertStore;

/** Initialize a SharkSslCertStore object. See #SharkSslCertStore for
    details.  The object must reside in memory as long as the produced
    SharkSslCAList is used by a SharkSSL object.

    \param o Uninitialized data of size sizeof(SharkSsl).

    \sa #SharkSslCertStore_assemble.
*/
SHARKSSL_API void  SharkSslCertStore_constructor(SharkSslCertStore *o);

/** Cleanup all memory used by the SharkSslCAList object. 
 */
SHARKSSL_API void  SharkSslCertStore_destructor(SharkSslCertStore* o);

/** Alias for SharkSslCertStore_destructor */
#define            SharkSslCertStore_release(o) SharkSslCertStore_destructor(o)

/** add a certificate in PEM or p7b format to the CA store. A
    convenient way to get CA's is to export the certificates from a
    browser in PEM or p7b format. The p7b format is a container format
    that can contain many CA's.

    \param o the SharkSslCertStore object.
    \param cert is a one PEM cert or multiple certs in p7b format.
    \param certlen is the length of parameter 'cert'
    \sa SharkSslCertStore_assemble.
    \return the number of certificates successfully parsed and added to
    the certificate store or a negative value if memory could not be allocated.
 */
SHARKSSL_API U16   SharkSslCertStore_add(
   SharkSslCertStore *o, const char *cert, U32 certlen);

/** Assemble all certificates added by calling #SharkSslCertStore_add.
    The assembled #SharkSslCAList object contains pointers to the
    #SharkSslCertStore object, thus the SharkSslCertStore object
    cannot be released/terminated as long as the SharkSslCAList object
    is in use.
    \param o the SharkSslCertStore object
    \param outList is the SharkSslCAList out value
    \return TRUE on success or FALSE if memory could not be allocated
    \sa #SharkSslCertStore_destructor and #SharkSsl_setCAList
 */
SHARKSSL_API U8  SharkSslCertStore_assemble(
   SharkSslCertStore *o, SharkSslCAList *outList);

/** @} */ /* end group SharkSslCertApi */ 
#endif  /* SHARKSSL_ENABLE_CA_LIST && SHARKSSL_ENABLE_CERTSTORE_API */

#if ((SHARKSSL_ENABLE_PEM_API) || (SHARKSSL_ENABLE_CERTSTORE_API))
SHARKSSL_API U32 sharkssl_B64Decode(
   U8 *outStr, U32 outStrSize, const char *b64beg, const char *b64end);
#endif



#ifdef __cplusplus
}

inline SharkSsl::SharkSsl(
   SharkSsl_Role role, U16 cacheSize, U16 inBufStartSize, U16 outBufSize) {
   SharkSsl_constructor(this, role, cacheSize, inBufStartSize, outBufSize);
}
inline SharkSsl::~SharkSsl() {
   SharkSsl_destructor(this);
}
inline SharkSslCon *SharkSsl::createCon(void) {
   return SharkSsl_createCon(this);
}
inline void SharkSsl::terminateCon(SharkSslCon *sslCon) {
   SharkSsl_terminateCon(this, sslCon);
}

#if (SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA)
inline U8 SharkSsl::addCertificate(SharkSslCert cert) {
   return SharkSsl_addCertificate(this, cert);
}
#if SHARKSSL_ENABLE_CA_LIST
inline U8 SharkSsl::setCAList(SharkSslCAList caList) {
   return SharkSsl_setCAList(this, caList);
}
#endif  /* SHARKSSL_ENABLE_CA_LIST */
#endif  /* SHARKSSL_ENABLE_RSA || SHARKSSL_ENABLE_ECDSA */

#endif  /* __cplusplus */


#endif
